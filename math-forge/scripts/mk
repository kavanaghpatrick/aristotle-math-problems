#!/usr/bin/env bash
# mk — Math-forge Knowledge Base CLI
# Usage: mk <command> [args...]

set -uo pipefail

# 3-level DB path resolution
if [ -n "${MATH_FORGE_DB:-}" ]; then
    DB="$MATH_FORGE_DB"
elif [ -n "${CLAUDE_PLUGIN_ROOT:-}" ]; then
    DB="${CLAUDE_PLUGIN_ROOT}/data/knowledge.db"
else
    DB="$(dirname "$0")/../data/knowledge.db"
fi

# Also need tracking.db for cross-queries
if [ -n "${CLAUDE_PROJECT_DIR:-}" ]; then
    TRACKING_DB="${CLAUDE_PROJECT_DIR}/submissions/tracking.db"
else
    TRACKING_DB="$(dirname "$0")/../../submissions/tracking.db"
fi

# Color support (TTY-aware)
if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
    GREEN='\033[0;32m'; RED='\033[0;31m'; YELLOW='\033[0;33m'
    CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'
else
    GREEN=''; RED=''; YELLOW=''; CYAN=''; BOLD=''; RESET=''
fi

escape_sql() {
    printf '%s' "$1" | sed "s/'/''/g"
}

run_sql() {
    local db="$1"; shift
    local output
    output=$(sqlite3 "$db" "$@" 2>&1)
    local rc=$?
    if [ $rc -ne 0 ]; then
        echo "[math-forge] ERROR: sqlite3 failed: $output" >&2
        return $rc
    fi
    [ -n "$output" ] && printf '%s\n' "$output"
    return 0
}

# Normalize problem ID: strip spaces, underscores, lowercase
normalize_problem() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[ _-]//g'
}

# Check DB exists
check_db() {
    if [ ! -f "$DB" ]; then
        echo "[math-forge] ERROR: knowledge.db not found at $DB" >&2
        echo "Run: math-forge/scripts/bootstrap.sh or mk init" >&2
        return 1
    fi
}

SCHEMA_PATH="$(dirname "$0")/../data/schema.sql"

case "${1:-help}" in
    search)
        shift
        check_db || exit 1
        if [ $# -eq 0 ]; then
            echo "Usage: mk search <query> [--limit N] [--domain D]"
            exit 1
        fi
        # Parse args
        QUERY=""
        LIMIT=5
        DOMAIN=""
        while [ $# -gt 0 ]; do
            case "$1" in
                --limit) LIMIT="$2"; shift 2 ;;
                --domain) DOMAIN="$2"; shift 2 ;;
                *) QUERY="$QUERY $1"; shift ;;
            esac
        done
        QUERY=$(echo "$QUERY" | sed 's/^ //')
        ESCAPED_Q=$(escape_sql "$QUERY")

        DOMAIN_FILTER=""
        if [ -n "$DOMAIN" ]; then
            ESCAPED_D=$(escape_sql "$DOMAIN")
            DOMAIN_FILTER="AND f.domain_id = '${ESCAPED_D}'"
        fi

        RESULT=$(run_sql "$DB" -header -separator '|' "
            SELECT f.id,
                   CASE f.finding_type
                       WHEN 'theorem' THEN '[PROVEN]'
                       WHEN 'technique' THEN '[TECHNIQUE]'
                       WHEN 'failure' THEN '[FAILED]'
                       WHEN 'false_lemma' THEN '[FALSE]'
                       WHEN 'computation' THEN '[COMPUTED]'
                       WHEN 'insight' THEN '[INSIGHT]'
                       ELSE '[' || UPPER(f.finding_type) || ']'
                   END as badge,
                   f.title,
                   COALESCE(f.proof_technique, SUBSTR(f.description, 1, 120)) as detail,
                   'Domain: ' || COALESCE(f.domain_id, '?') || ' | Slot: ' || COALESCE(f.source_slot, '?') as meta
            FROM findings_fts fts
            JOIN findings f ON f.id = fts.rowid
            WHERE findings_fts MATCH '{title description theorem_statement proof_technique tags why_failed}:${ESCAPED_Q}'
            ${DOMAIN_FILTER}
            ORDER BY bm25(findings_fts, 10.0, 5.0, 1.0, 5.0, 3.0, 2.0, 3.0)
            LIMIT ${LIMIT};
        ")

        if [ -z "$RESULT" ] || [ "$RESULT" = "id|badge|title|detail|meta" ]; then
            echo "[math-forge] No findings matching '${QUERY}'"
            echo "  Try broader terms or run: mk stats"
        else
            echo "[math-forge] Search: '${QUERY}' (top ${LIMIT})"
            echo "---"
            # Skip header, format each row
            echo "$RESULT" | tail -n +2 | while IFS='|' read -r id badge title detail meta; do
                printf "  #%-3s %-12s %s\n" "$id" "$badge" "$title"
                printf "       %s\n" "$detail"
                printf "       %s\n" "$meta"
            done
            TOTAL=$(run_sql "$DB" "SELECT COUNT(*) FROM findings_fts WHERE findings_fts MATCH '{title description theorem_statement proof_technique tags why_failed}:${ESCAPED_Q}';")
            if [ "${TOTAL:-0}" -gt "$LIMIT" ]; then
                echo "---"
                echo "  Showing ${LIMIT} of ${TOTAL} results. Use --limit N for more."
            fi
        fi
        ;;

    find)
        shift
        check_db || exit 1
        if [ $# -eq 0 ]; then
            echo "Usage: mk find <problem-id>"
            exit 1
        fi
        PROBLEM=$(escape_sql "$1")

        echo "[math-forge] Problem: ${1}"
        echo "==="

        # Problem summary
        SUMMARY=$(run_sql "$DB" -header -column "SELECT id, name, domain_id, status, submission_count, proven_count, failed_count FROM problems WHERE id LIKE '%${PROBLEM}%' LIMIT 1;")
        if [ -n "$SUMMARY" ]; then
            echo "$SUMMARY"
        else
            echo "  (No problem record found — showing findings only)"
        fi
        echo ""

        # Findings grouped by type
        echo "--- Findings ---"
        run_sql "$DB" -header -column "
            SELECT finding_type as type, title, COALESCE(CAST(source_slot AS TEXT), '') as slot, confidence
            FROM findings WHERE problem_id LIKE '%${PROBLEM}%'
            ORDER BY finding_type, created_at DESC;
        "

        echo ""
        echo "--- Strategies ---"
        run_sql "$DB" -header -column "
            SELECT approach_name, outcome, attempts, COALESCE(CAST(submission_slot AS TEXT), '') as slot, learned
            FROM strategies WHERE problem_id LIKE '%${PROBLEM}%'
            ORDER BY outcome, last_attempted DESC;
        "

        # Cross-DB: false_lemmas from tracking.db
        if [ -f "$TRACKING_DB" ]; then
            echo ""
            echo "--- False Lemmas (tracking.db) ---"
            run_sql "$TRACKING_DB" -header -column "
                SELECT lemma_name, why_false, counterexample
                FROM false_lemmas
                WHERE lemma_name LIKE '%${PROBLEM}%' OR impact LIKE '%${PROBLEM}%';
            "
        fi
        ;;

    strategies)
        shift
        check_db || exit 1
        DOMAIN_FILTER=""
        if [ $# -gt 0 ]; then
            ESCAPED_D=$(escape_sql "$1")
            DOMAIN_FILTER="AND domain_id = '${ESCAPED_D}'"
        fi
        echo "[math-forge] Proven techniques"
        echo "---"
        run_sql "$DB" -header -column "
            SELECT proof_technique, COUNT(*) as cnt,
                   GROUP_CONCAT(DISTINCT source_slot) as slots,
                   domain_id
            FROM findings
            WHERE finding_type = 'theorem' AND confidence = 'verified'
              AND proof_technique IS NOT NULL
              ${DOMAIN_FILTER}
            GROUP BY proof_technique, domain_id
            ORDER BY cnt DESC;
        "
        ;;

    failed)
        shift
        check_db || exit 1
        KEYWORD=""
        if [ $# -gt 0 ]; then
            KEYWORD=$(escape_sql "$1")
        fi

        echo "[math-forge] Failed approaches"
        echo "---"

        if [ -n "$KEYWORD" ]; then
            run_sql "$DB" -header -column "
                SELECT title, why_failed, avoid_pattern, COALESCE(CAST(source_slot AS TEXT), '') as slot, problem_id
                FROM findings
                WHERE finding_type IN ('failure', 'false_lemma')
                  AND (title LIKE '%${KEYWORD}%' OR why_failed LIKE '%${KEYWORD}%' OR problem_id LIKE '%${KEYWORD}%')
                ORDER BY created_at DESC;
            "
        else
            run_sql "$DB" -header -column "
                SELECT title, why_failed, avoid_pattern, COALESCE(CAST(source_slot AS TEXT), '') as slot, problem_id
                FROM findings
                WHERE finding_type IN ('failure', 'false_lemma')
                ORDER BY created_at DESC;
            "
        fi

        echo ""
        printf "${YELLOW}WARNING: Do NOT repeat approaches listed above without a fundamentally new angle.${RESET}\n"
        ;;

    stats)
        check_db || exit 1
        echo "[math-forge] Knowledge Base Dashboard"
        echo "==="

        # Finding counts by type
        echo "Findings by type:"
        run_sql "$DB" "SELECT '  ' || finding_type || ': ' || COUNT(*) FROM findings GROUP BY finding_type ORDER BY COUNT(*) DESC;"

        echo ""
        echo "Findings by domain:"
        run_sql "$DB" "SELECT '  ' || COALESCE(domain_id, 'unknown') || ': ' || COUNT(*) FROM findings GROUP BY domain_id ORDER BY COUNT(*) DESC;"

        TOTAL=$(run_sql "$DB" "SELECT COUNT(*) FROM findings;")
        NEWEST=$(run_sql "$DB" "SELECT MAX(created_at) FROM findings;")
        echo ""
        echo "Total findings: ${TOTAL:-0}"
        echo "Latest: ${NEWEST:-never}"

        # Strategy outcomes
        STRAT_COUNT=$(run_sql "$DB" "SELECT COUNT(*) FROM strategies;")
        if [ "${STRAT_COUNT:-0}" -gt 0 ]; then
            echo ""
            echo "Strategy outcomes:"
            run_sql "$DB" "SELECT '  ' || outcome || ': ' || COUNT(*) FROM strategies GROUP BY outcome ORDER BY COUNT(*) DESC;"
        fi

        # Problem count
        PROB_COUNT=$(run_sql "$DB" "SELECT COUNT(*) FROM problems;")
        echo ""
        echo "Problems tracked: ${PROB_COUNT:-0}"
        ;;

    init)
        if [ -f "$DB" ]; then
            echo "[math-forge] knowledge.db already exists at $DB"
        else
            if [ -f "$SCHEMA_PATH" ]; then
                sqlite3 "$DB" < "$SCHEMA_PATH"
                echo "[math-forge] Created knowledge.db"
            else
                echo "[math-forge] ERROR: schema.sql not found at $SCHEMA_PATH" >&2
                exit 1
            fi
        fi
        # Run migration if tracking.db exists
        MIGRATE_SCRIPT="$(dirname "$0")/migrate_tracking.py"
        if [ -f "$MIGRATE_SCRIPT" ] && [ -f "$TRACKING_DB" ]; then
            echo "[math-forge] Running migration from tracking.db..."
            python3 "$MIGRATE_SCRIPT" --tracking-db "$TRACKING_DB" --knowledge-db "$DB"
        fi
        ;;

    submit)
        shift
        if [ $# -eq 0 ]; then
            echo "Usage: mk submit <file> [args...]"
            echo "  Delegates to safe_aristotle_submit.py with all args passed through."
            exit 1
        fi
        SUBMIT_SCRIPT="$(dirname "$0")/../../scripts/safe_aristotle_submit.py"
        if [ ! -f "$SUBMIT_SCRIPT" ]; then
            echo "[math-forge] ERROR: safe_aristotle_submit.py not found at $SUBMIT_SCRIPT" >&2
            exit 1
        fi
        python3 "$SUBMIT_SCRIPT" "$@"
        ;;

    status)
        shift
        FETCH_SCRIPT="$(dirname "$0")/../../scripts/aristotle_fetch.py"
        if [ ! -f "$FETCH_SCRIPT" ]; then
            echo "[math-forge] ERROR: aristotle_fetch.py not found at $FETCH_SCRIPT" >&2
            exit 1
        fi
        python3 "$FETCH_SCRIPT" status "$@"
        ;;

    partials)
        shift
        if [ ! -f "$TRACKING_DB" ]; then
            echo "[math-forge] ERROR: tracking.db not found at $TRACKING_DB" >&2
            exit 1
        fi
        echo "[math-forge] Near-miss submissions (sorry=1)"
        echo "---"
        run_sql "$TRACKING_DB" -header -column "
            SELECT filename, sorry_count, proven_count, notes, completed_at
            FROM submissions
            WHERE sorry_count = 1 AND status IN ('near_miss', 'completed')
            ORDER BY completed_at DESC;
        "
        ;;

    resubmittable)
        shift
        if [ ! -f "$TRACKING_DB" ]; then
            echo "[math-forge] ERROR: tracking.db not found at $TRACKING_DB" >&2
            exit 1
        fi
        echo "[math-forge] Resubmittable submissions"
        echo "---"
        run_sql "$TRACKING_DB" -header -column "
            SELECT filename, status, sorry_count, proven_count,
                   COALESCE(output_file, '') as output,
                   COALESCE(SUBSTR(notes, 1, 80), '') as notes
            FROM submissions
            WHERE status IN ('near_miss', 'completed', 'failed')
              AND sorry_count >= 1
              AND sorry_count <= 3
              AND output_file IS NOT NULL
            ORDER BY sorry_count ASC, completed_at DESC;
        "
        ;;

    query)
        shift
        if [ ! -f "$TRACKING_DB" ]; then
            echo "[math-forge] ERROR: tracking.db not found at $TRACKING_DB" >&2
            exit 1
        fi
        if [ $# -eq 0 ]; then
            echo "Usage: mk query <sql>"
            echo "  Runs read-only SQL against tracking.db."
            echo "  Example: mk query \"SELECT COUNT(*) FROM submissions WHERE status='compiled_clean'\""
            exit 1
        fi
        SQL="$1"
        # Safety: reject non-SELECT statements
        UPPER_SQL=$(echo "$SQL" | tr '[:lower:]' '[:upper:]' | sed 's/^[[:space:]]*//')
        case "$UPPER_SQL" in
            SELECT*|WITH*|EXPLAIN*|PRAGMA*)
                run_sql "$TRACKING_DB" -header -column "$SQL"
                ;;
            *)
                echo "[math-forge] ERROR: mk query only allows SELECT/WITH/EXPLAIN/PRAGMA statements." >&2
                echo "  For writes, use sqlite3 directly." >&2
                exit 1
                ;;
        esac
        ;;

    context)
        shift
        if [ ! -f "$TRACKING_DB" ]; then
            echo "[math-forge] ERROR: tracking.db not found at $TRACKING_DB" >&2
            exit 1
        fi
        if [ $# -eq 0 ]; then
            echo "Usage: mk context <problem-id>"
            echo "  Lists prior Aristotle result files for passing as context."
            exit 1
        fi
        PROBLEM=$(escape_sql "$1")

        echo "[math-forge] Context files for '${1}':"
        echo "---"

        RESULTS=$(run_sql "$TRACKING_DB" "
            SELECT output_file, status, proven_count
            FROM submissions
            WHERE (problem_id LIKE '%${PROBLEM}%'
                   OR filename LIKE '%${PROBLEM}%')
              AND output_file IS NOT NULL
              AND status IN ('compiled_clean', 'near_miss', 'completed', 'disproven')
            ORDER BY submitted_at DESC;
        ")

        if [ -z "$RESULTS" ]; then
            echo "  (No prior results found)"
            echo ""
            echo "This is the first submission for this problem."
        else
            CONTEXT_ARGS=""
            while IFS='|' read -r filepath status proven; do
                if [ -f "$filepath" ]; then
                    LINES=$(wc -l < "$filepath" | tr -d ' ')
                    printf "  %s (%s, %s lines)\n" "$filepath" "$status" "$LINES"
                    CONTEXT_ARGS="${CONTEXT_ARGS} --context ${filepath}"
                else
                    printf "  %s (MISSING — file not found)\n" "$filepath"
                fi
            done <<< "$RESULTS"
            echo "---"
            echo "Submit with:${CONTEXT_ARGS}"
        fi
        ;;

    gaps)
        shift
        if [ ! -f "$TRACKING_DB" ]; then
            echo "[math-forge] ERROR: tracking.db not found at $TRACKING_DB" >&2
            exit 1
        fi

        echo "[math-forge] Open Gaps Being Targeted"
        echo "==="

        run_sql "$TRACKING_DB" -header -column "
            SELECT
                COALESCE(problem_id, filename) as problem,
                COALESCE(gap_statement, SUBSTR(notes, 1, 60)) as gap,
                COUNT(*) as subs,
                MAX(CASE WHEN status = 'compiled_clean' THEN 'compiled_clean'
                         WHEN status = 'near_miss' THEN 'near_miss'
                         WHEN status = 'completed' THEN 'completed'
                         ELSE status END) as best_status,
                MAX(CASE WHEN target_resolved = 1 THEN 'YES' ELSE '' END) as resolved
            FROM submissions
            WHERE submission_type = 'gap_targeting'
               OR submission_type IS NULL
            GROUP BY COALESCE(problem_id, filename)
            HAVING COUNT(*) > 0
            ORDER BY subs DESC
            LIMIT 30;
        "

        RESOLVED=$(run_sql "$TRACKING_DB" "
            SELECT COUNT(DISTINCT COALESCE(problem_id, filename))
            FROM submissions WHERE target_resolved = 1;
        ")
        echo ""
        echo "Gaps resolved: ${RESOLVED:-0}"
        ;;

    help|*)
        echo "mk — Math-forge Knowledge Base CLI"
        echo ""
        echo "Knowledge commands:"
        echo "  search <query> [--limit N] [--domain D]  Search findings (FTS5 + BM25)"
        echo "  find <problem-id>                         Problem-level knowledge report"
        echo "  strategies [domain]                       Proven techniques by frequency"
        echo "  failed [keyword]                          Failed approaches (don't repeat these!)"
        echo "  stats                                     KB dashboard"
        echo "  init                                      Initialize/bootstrap knowledge.db"
        echo ""
        echo "Pipeline commands:"
        echo "  submit <file> [args...]                   Submit sketch to Aristotle"
        echo "  status [uuid-or-slot]                     Aristotle queue status"
        echo "  context <problem-id>                      Prior Aristotle results for auto-context"
        echo "  gaps                                       Open gaps being targeted + status"
        echo "  partials                                   Near-miss submissions (sorry=1)"
        echo "  resubmittable                              Resubmission candidates"
        echo "  query <sql>                                Read-only SQL on tracking.db"
        echo ""
        echo "  help                                      Show this help"
        echo ""
        echo "Examples:"
        echo "  mk search \"cubic residue\"                 Find findings about cubic residues"
        echo "  mk find ft_p3                             Everything we know about FT p=3"
        echo "  mk failed tuza                            Failed approaches for Tuza"
        echo "  mk strategies nt                          NT proof techniques"
        echo "  mk submit sketch.txt --informal           Submit a sketch"
        echo "  mk status                                 Check Aristotle queue"
        echo "  mk partials                               List near-miss results"
        echo "  mk query \"SELECT * FROM submissions WHERE target_resolved=1\""
        ;;
esac
