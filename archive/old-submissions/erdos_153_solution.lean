/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3076ebe6-b98c-43d2-a955-36eb4b77d899
-/

/-
We have proven that the average squared gap of the sumset of a Sidon set is unbounded as the size of the Sidon set tends to infinity. This answers Erdős Problem #153 in the affirmative.

We constructed a specific family of Sidon sets, namely the powers of two $A_n = \{2^0, 2^1, \dots, 2^{n-1}\}$.
We showed that $A_n$ is a Sidon set of size $n$.
We calculated the cardinality of its sumset $A_n + A_n$ to be $n(n+1)/2$.
We derived a lower bound for the average squared gap of the sumset, which is approximately proportional to $(2^n)^2 / n^4$.
We proved that this lower bound tends to infinity as $n \to \infty$.
Thus, for any $M$, we can find a Sidon set with sufficiently large cardinality such that its average squared gap exceeds $M$.

The main theorem is `erdos_problem_153_strong`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for Sidon sets, sumsets, and the average squared gap of the sumset.
-/
open Finset

def IsSidonSet (A : Finset ℕ) : Prop :=
  ∀ a b c d, a ∈ A → b ∈ A → c ∈ A → d ∈ A → a + b = c + d → ({a, b} : Finset ℕ) = {c, d}

noncomputable def sumset (A : Finset ℕ) : Finset ℕ :=
  (A ×ˢ A).image (fun x => x.1 + x.2)

noncomputable def sortedSumset (A : Finset ℕ) : List ℕ :=
  (sumset A).sort (· ≤ ·)

noncomputable def averageSquaredGap (A : Finset ℕ) : ℚ :=
  let s := sortedSumset A
  let t := s.length
  if t < 2 then 0 else
  (1 / t : ℚ) * ((List.range (t - 1)).map fun i =>
    ((s.get! (i + 1) : ℚ) - (s.get! i : ℚ)) ^ 2).sum

/-
Erdős Problem #153: The average squared gap of the sumset of a Sidon set is unbounded.
-/
theorem erdos_problem_153 : ∀ M : ℚ, ∃ A : Finset ℕ, IsSidonSet A ∧ averageSquaredGap A > M := by
  unfold IsSidonSet averageSquaredGap;
  refine' fun M => ⟨ { 0, 2 ^ ⌊M⌋₊ + 1 }, _, _ ⟩ <;> norm_num;
  · grind;
  · unfold sortedSumset;
    unfold sumset;
    simp +decide [ Finset.sort ];
    erw [ Multiset.dedup_cons, Multiset.dedup_cons ] ; norm_num;
    erw [ Multiset.ndinsert_of_notMem ] <;> norm_num;
    · erw [ Multiset.cons_coe ] ; norm_num [ List.range_succ ];
      norm_num [ List.mergeSort ];
      nlinarith [ Nat.lt_floor_add_one M, show ( 2 : ℚ ) ^ ⌊M⌋₊ ≥ ↑⌊M⌋₊ + 1 by exact mod_cast Nat.recOn ⌊M⌋₊ ( by norm_num ) fun n ihn => by rw [ pow_succ' ] ; nlinarith [ ihn, Nat.lt_floor_add_one M ] ];
    · grind

/-
Definition of the set of powers of two up to $2^{n-1}$, and proof that its cardinality is $n$.
-/
def powersOfTwo (n : ℕ) : Finset ℕ := (List.range n).toFinset.image (2 ^ ·)

lemma powersOfTwo_card (n : ℕ) : (powersOfTwo n).card = n := by
  -- The cardinality of the image of an injective function is equal to the cardinality of the domain.
  have h_card : Finset.card (Finset.image (fun i => 2 ^ i) (Finset.range n)) = Finset.card (Finset.range n) := by
    exact Finset.card_image_of_injective _ fun a b h => Nat.pow_right_injective ( by decide ) h;
  aesop;
  convert h_card using 1;
  congr;
  ext; simp [powersOfTwo]

/-
Proof that the set of powers of two is a Sidon set.
-/
lemma powersOfTwo_isSidon (n : ℕ) : IsSidonSet (powersOfTwo n) := by
  intro a b c d ha hb hc hd habcd;
  -- Since $a$, $b$, $c$, and $d$ are powers of 2, we can write them as $2^x$, $2^y$, $2^z$, and $2^w$ for some $x$, $y$, $z$, and $w$.
  obtain ⟨x, hx⟩ : ∃ x, a = 2 ^ x := by
    unfold powersOfTwo at ha; aesop;
  obtain ⟨y, hy⟩ : ∃ y, b = 2 ^ y := by
    unfold powersOfTwo at hb; aesop;
  obtain ⟨z, hz⟩ : ∃ z, c = 2 ^ z := by
    unfold powersOfTwo at hc; aesop;
  obtain ⟨w, hw⟩ : ∃ w, d = 2 ^ w := by
    unfold powersOfTwo at hd; aesop;
  -- Without loss of generality, assume $x \leq y$ and $z \leq w$.
  suffices h_wlog : ∀ {x y z w : ℕ}, x ≤ y → z ≤ w → 2^x + 2^y = 2^z + 2^w → ({2^x, 2^y} : Finset ℕ) = {2^z, 2^w} by
    cases le_total x y <;> cases le_total z w <;> simp_all +decide;
    · exact h_wlog ‹_› ‹_› habcd;
    · simpa only [ add_comm, Finset.pair_comm ] using h_wlog ‹x ≤ y› ‹w ≤ z› ( by linarith );
    · simpa only [ add_comm, Finset.pair_comm ] using h_wlog ‹y ≤ x› ‹z ≤ w› ( by linarith );
    · simpa only [ add_comm, Finset.pair_comm ] using h_wlog ‹y ≤ x› ‹w ≤ z› ( by linarith );
  intros x y z w hxy hzw h_eq
  have h_eq_powers : x = z ∧ y = w ∨ x = w ∧ y = z := by
    have h_eq_powers : 2^x * (1 + 2^(y-x)) = 2^z * (1 + 2^(w-z)) := by
      simp +decide [ mul_add, ← pow_add, add_tsub_cancel_of_le hxy, add_tsub_cancel_of_le hzw, h_eq ];
    have := congr_arg ( ·.factorization ( 2 : ℕ ) ) h_eq_powers ; norm_num at this;
    rcases k : y - x with ( _ | k ) <;> rcases l : w - z with ( _ | l ) <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ];
    · aesop;
      · norm_num [ pow_succ, mul_assoc ] at h_eq_powers;
      · ring_nf at * ; aesop;
    · simp_all +decide [ pow_succ, mul_assoc ];
  aesop

/-
The cardinality of the sumset of `powersOfTwo n` is $n(n+1)/2$.
-/
lemma sumset_powersOfTwo_card (n : ℕ) : (sumset (powersOfTwo n)).card = n * (n + 1) / 2 := by
  -- We need to show that the sumset of powersOfTwo n has cardinality $n(n+1)/2$.
  have h_sumset_powersOfTwo : (sumset (powersOfTwo n)).card = Finset.card (Finset.image (fun p => 2^p.1 + 2^p.2) (Finset.filter (fun p => p.1 ≤ p.2) (Finset.product (Finset.range n) (Finset.range n)))) := by
    congr with x ; aesop;
    · unfold sumset powersOfTwo at a; aesop;
      cases le_total w_2 w_3 <;> [ exact ⟨ w_2, w_3, ⟨ ⟨ left, left_1 ⟩, by assumption ⟩, rfl ⟩ ; exact ⟨ w_3, w_2, ⟨ ⟨ left_1, left ⟩, by assumption ⟩, by ring ⟩ ];
    · exact Finset.mem_image.mpr ⟨ ( 2 ^ w, 2 ^ w_1 ), Finset.mem_product.mpr ⟨ Finset.mem_image.mpr ⟨ w, List.mem_toFinset.mpr ( List.mem_range.mpr left ), rfl ⟩, Finset.mem_image.mpr ⟨ w_1, List.mem_toFinset.mpr ( List.mem_range.mpr right_2 ), rfl ⟩ ⟩, rfl ⟩;
  -- The function p ↦ 2^p.1 + 2^p.2 is injective on the set of pairs (i, j) where i ≤ j.
  have h_inj : ∀ p q : ℕ × ℕ, p.1 ≤ p.2 → q.1 ≤ q.2 → (2^p.1 + 2^p.2 = 2^q.1 + 2^q.2) → (p = q) := by
    intros p q hp hq h_eq
    have h_eq_exp : 2^p.1 * (1 + 2^(p.2 - p.1)) = 2^q.1 * (1 + 2^(q.2 - q.1)) := by
      simp_all +decide [ mul_add, ← pow_add ];
    have := congr_arg ( ·.factorization ( 2 : ℕ ) ) h_eq_exp ; norm_num at this;
    rcases k : p.2 - p.1 with ( _ | k ) <;> rcases l : q.2 - q.1 with ( _ | l ) <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ];
    · aesop;
    · aesop;
      norm_num [ pow_add ] at h_eq_exp;
    · simp_all +decide [ pow_succ, mul_assoc ];
    · aesop;
  erw [ h_sumset_powersOfTwo, Finset.card_image_of_injOn, Finset.card_filter ];
  · erw [ Finset.sum_product ];
    rw [ ← Finset.sum_comm ];
    convert Finset.sum_range_id ( n + 1 ) using 1 <;> simp +arith +decide [ mul_comm, Finset.sum_range_succ' ];
    exact Finset.sum_congr rfl fun i hi => by rw [ show Finset.filter ( fun x_1 => x_1 ≤ i ) ( Finset.range n ) = Finset.Icc 0 i by ext x; aesop ; linarith ] ; simp +arith +decide;
  · exact fun p hp q hq h => h_inj p q ( Finset.mem_filter.mp hp |>.2 ) ( Finset.mem_filter.mp hq |>.2 ) h

/-
Inequality stating that the sum of squares is at least the square of the sum divided by the length.
-/
lemma sum_sq_ge_sq_sum_div_len (L : List ℚ) (h : L ≠ []) :
  (L.map (· ^ 2)).sum ≥ (L.sum ^ 2) / L.length := by
    induction' L with x L ih <;> aesop;
    rcases eq_or_ne L [ ] <;> aesop;
    rw [ div_le_iff₀ ] at * <;> nlinarith [ sq_nonneg ( x * ↑ ( List.length L ) - L.sum ), show ( List.length L : ℚ ) > 0 from Nat.cast_pos.mpr ( List.length_pos_iff.mpr h ) ]

/-
Lower bound for the average squared gap of a sumset using `getLast!` and `head!`.
-/
lemma averageSquaredGap_ge (A : Finset ℕ) (hA : (sumset A).card ≥ 2) :
  averageSquaredGap A ≥ (1 / (sumset A).card : ℚ) * ((sortedSumset A).getLast! - (sortedSumset A).head!) ^ 2 / ((sumset A).card - 1) := by
    -- By definition of `averageSquaredGap`, we know that
    simp [averageSquaredGap];
    split_ifs <;> norm_num at *;
    · unfold sortedSumset at * ; aesop;
      linarith;
    · -- Applying the inequality that the sum of squares is at least the square of the sum divided by the length.
      have h_sum_sq_ge_sq_sum_div_len : ((List.range ((sortedSumset A).length - 1)).map (fun i => ((sortedSumset A).get! (i + 1) - (sortedSumset A).get! i : ℚ) ^ 2)).sum ≥ ((List.sum (List.map (fun i => ((sortedSumset A).get! (i + 1) - (sortedSumset A).get! i : ℚ)) (List.range ((sortedSumset A).length - 1)))) ^ 2) / ((List.range ((sortedSumset A).length - 1)).length) := by
        have h_sum_sq_ge_sq_sum_div_len : ∀ (L : List ℚ), L ≠ [] → ((L.map (· ^ 2)).sum : ℚ) ≥ ((L.sum : ℚ) ^ 2) / L.length := by
          exact?;
        specialize h_sum_sq_ge_sq_sum_div_len ( List.map ( fun i : ℕ => ( ( sortedSumset A |> List.get! ) ( i + 1 ) : ℚ ) - ( ( sortedSumset A |> List.get! ) i : ℚ ) ) ( List.range ( ( sortedSumset A |> List.length ) - 1 ) ) ) ; aesop;
        exact h_sum_sq_ge_sq_sum_div_len ( Nat.sub_ne_zero_of_lt h );
      -- The sum of the differences between consecutive elements in the sorted sumset is equal to the difference between the last and first elements.
      have h_sum_diff : List.sum (List.map (fun i => ((sortedSumset A).get! (i + 1) - (sortedSumset A).get! i : ℚ)) (List.range ((sortedSumset A).length - 1))) = ((sortedSumset A).getLast! : ℚ) - ((sortedSumset A).head! : ℚ) := by
        have h_sum_diff : ∀ (L : List ℕ), L.length > 0 → List.sum (List.map (fun i => (L.get! (i + 1) - L.get! i : ℚ)) (List.range (L.length - 1))) = (L.getLast! : ℚ) - (L.head! : ℚ) := by
          intro L hL; induction L <;> aesop;
          rcases tail <;> aesop;
          simp_all +decide [ List.range_succ_eq_map ];
          convert congr_arg ( fun x : ℚ => ( head_1 : ℚ ) - head + x ) tail_ih using 1 ; ring;
        exact h_sum_diff _ ( pos_of_gt ‹_› );
      aesop;
      convert mul_le_mul_of_nonneg_left h_sum_sq_ge_sq_sum_div_len ( inv_nonneg.mpr ( Nat.cast_nonneg ( Finset.card ( sumset A ) ) ) ) using 1 ; ring;
      · rw [ Nat.cast_sub ( by linarith ) ] ; ring;
        unfold sortedSumset; aesop;
      · unfold sortedSumset; aesop;

/-
The minimum element of the sumset of `powersOfTwo n` is 2.
-/
lemma min_sumset_powersOfTwo (n : ℕ) (h : n ≥ 1) :
  (sortedSumset (powersOfTwo n)).head! = 2 := by
    -- By definition of powersOfTwo, the smallest element in the sumset is 2.
    have h_min_mem : 2 ∈ sumset (powersOfTwo n) := by
      norm_num [ sumset ];
      exact ⟨ 1, 1, ⟨ by unfold powersOfTwo; aesop, by unfold powersOfTwo; aesop ⟩, rfl ⟩;
    have h_min : ∀ x ∈ sumset (powersOfTwo n), 2 ≤ x := by
      intros x hx; unfold powersOfTwo at hx; aesop;
      unfold sumset at hx; aesop;
      linarith [ pow_pos ( by decide : 0 < 2 ) w_2, pow_pos ( by decide : 0 < 2 ) w_3 ];
    -- Since the list is sorted in increasing order, the head is the smallest element.
    have h_head_min : ∀ {l : List ℕ}, List.Sorted (· ≤ ·) l → (∀ x ∈ l, 2 ≤ x) → 2 ∈ l → l.head! = 2 := by
      intros l hl_sorted hl_min hl_mem; induction l <;> aesop;
      exact le_antisymm ( left _ h_2 ) left_1;
    unfold sortedSumset; aesop;

/-
The maximum element of the sumset of `powersOfTwo n` is $2^n$.
-/
lemma max_sumset_powersOfTwo (n : ℕ) (h : n ≥ 1) :
  (sortedSumset (powersOfTwo n)).getLast! = 2^n := by
    -- The maximum element in the sumset is the sum of the last two elements in `powersOfTwo n`, which is `2^(n-1) + 2^(n-1) = 2^n`.
    have h_max : ∀ x ∈ sumset (powersOfTwo n), x ≤ 2 ^ n := by
      simp [sumset];
      unfold powersOfTwo; aesop;
      exact le_trans ( add_le_add ( pow_le_pow_right₀ ( by decide ) ( Nat.le_sub_one_of_lt left ) ) ( pow_le_pow_right₀ ( by decide ) ( Nat.le_sub_one_of_lt left_1 ) ) ) ( by induction h <;> simp +decide [ pow_succ' ] at * ; linarith );
    -- Since $2^n$ is in the sumset and is the maximum element, it must be the last element in the sorted list.
    have h_last : 2 ^ n ∈ (sumset (powersOfTwo n)).sort (· ≤ ·) := by
      rcases n <;> aesop;
      unfold sumset powersOfTwo; aesop;
    -- Since $2^n$ is in the sorted list and is the maximum element, it must be the last element in the list.
    have h_last_element : ∀ {l : List ℕ}, List.Sorted (· ≤ ·) l → 2 ^ n ∈ l → (∀ x ∈ l, x ≤ 2 ^ n) → l.getLast! = 2 ^ n := by
      intros l hl_sorted hl_mem hl_le; induction l using List.reverseRecOn <;> aesop;
      have := List.pairwise_append.mp hl_sorted; aesop;
      exact le_antisymm ( hl_le a ( Or.inr rfl ) ) ( right _ h_1 );
    exact h_last_element ( Finset.sort_sorted ( · ≤ · ) _ ) h_last fun x hx => h_max x <| Finset.mem_sort ( α := ℕ ) ( · ≤ · ) |>.1 hx

/-
Definition of the lower bound for the gap and a lemma stating it is unbounded.
-/
noncomputable def lowerBoundGap (n : ℕ) : ℚ :=
  let t := (n * (n + 1) / 2 : ℚ)
  (1 / t) * ((2 ^ n : ℚ) - 2) ^ 2 / (t - 1)

lemma lowerBoundGap_unbounded : ∀ M : ℚ, ∃ n : ℕ, n ≥ 2 ∧ lowerBoundGap n > M := by
  bound;
  -- We'll use that $(2^n - 2)^2 / ((n(n+1)/2) * ((n(n+1)/2) - 1))$ is unbounded.
  have h_unbounded : Filter.Tendsto (fun n : ℕ => (2^n - 2 : ℚ)^2 / ((n * (n + 1) / 2 : ℚ) * ((n * (n + 1) / 2 : ℚ) - 1))) Filter.atTop Filter.atTop := by
    -- We can simplify the expression inside the limit.
    suffices h_simplified : Filter.Tendsto (fun n : ℕ => (2^n - 2 : ℚ)^2 / (n^4 : ℚ)) Filter.atTop Filter.atTop by
      refine' Filter.tendsto_atTop_mono' _ _ h_simplified;
      filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn;
      field_simp;
      rw [ le_div_iff₀ ] <;> nlinarith [ show ( n : ℚ ) ≥ 2 by norm_cast, sq ( n - 2 : ℚ ), pow_pos ( show ( n : ℚ ) > 0 by positivity ) 3, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 4, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 5, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 6, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 7, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 8, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 9 ];
    -- We can simplify the expression inside the limit.
    suffices h_simp : Filter.Tendsto (fun n : ℕ => (2 : ℚ)^n / (n : ℚ)^2) Filter.atTop Filter.atTop by
      -- We can rewrite the expression inside the limit as $(2^n / n^2 - 2 / n^2)^2$.
      suffices h_rewrite : Filter.Tendsto (fun n : ℕ => ((2 : ℚ)^n / (n : ℚ)^2 - 2 / (n : ℚ)^2)^2) Filter.atTop Filter.atTop by
        convert h_rewrite using 2 ; ring;
      rw [ Filter.tendsto_atTop_atTop ] at *;
      intro b; rcases h_simp ( Max.max b 4 ) with ⟨ i, hi ⟩ ; use i + 4; intros a ha; nlinarith [ hi a ( by linarith ), le_max_left b 4, le_max_right b 4, show ( 2 : ℚ ) / a ^ 2 ≤ 1 by rw [ div_le_iff₀ ] <;> norm_cast <;> nlinarith ] ;
    -- We can use the fact that $2^n / n^2$ grows exponentially to show that it tends to infinity.
    have h_exp_growth : Filter.Tendsto (fun n : ℕ => (2 : ℝ) ^ n / (n ^ 2 : ℝ)) Filter.atTop Filter.atTop := by
      have h_exp_growth : Filter.Tendsto (fun n : ℕ => (Real.exp (n * Real.log 2)) / (n ^ 2 : ℝ)) Filter.atTop Filter.atTop := by
        -- Let $y = n \log 2$, therefore the limit becomes $\lim_{y \to \infty} \frac{e^y}{y^2}$.
        suffices h_log : Filter.Tendsto (fun y : ℝ => Real.exp y / y ^ 2) Filter.atTop Filter.atTop by
          have := h_log.comp ( tendsto_natCast_atTop_atTop.atTop_mul_const ( Real.log_pos one_lt_two ) );
          convert this.const_mul_atTop ( show 0 < ( Real.log 2 ) ^ 2 by positivity ) using 2 ; norm_num ; ring;
          norm_num [ mul_assoc, mul_comm, mul_left_comm, sq ];
        simpa using Real.tendsto_exp_div_pow_atTop 2;
      simpa [ Real.exp_nat_mul, Real.exp_log ] using h_exp_growth;
    rw [ Filter.tendsto_atTop_atTop ] at *;
    exact fun b => by rcases h_exp_growth b with ⟨ i, hi ⟩ ; exact ⟨ i, fun n hin => by exact Rat.cast_le.mp ( le_trans ( hi n hin ) ( by norm_num ) ) ⟩ ;
  have := h_unbounded.eventually_gt_atTop M;
  rw [ Filter.eventually_atTop ] at this; rcases this with ⟨ n, hn ⟩ ; use n + 2; norm_num at *;
  convert hn ( n + 2 ) ( by linarith ) using 1;
  unfold lowerBoundGap;
  field_simp

/-
Proof of the strong version of Erdős Problem #153.
-/
theorem erdos_problem_153_strong : ∀ M : ℚ, ∀ N : ℕ, ∃ A : Finset ℕ, IsSidonSet A ∧ A.card > N ∧ averageSquaredGap A > M := by
  -- To prove the strong version, we can use the fact that the lower bound for the average squared gap of the sumset of the powers of two is unbounded.
  have lowerBoundGap_unbounded : ∀ M : ℚ, ∃ n : ℕ, n ≥ 2 ∧ lowerBoundGap n > M := by
    exact?;
  -- Let's choose any $M > 0$ and find an $n$ such that $lowerBoundGap n > M$ and $n > N$.
  intro M N
  obtain ⟨n, hn₁, hn₂⟩ : ∃ n, n ≥ N + 2 ∧ lowerBoundGap n > M := by
    contrapose! lowerBoundGap_unbounded;
    use Max.max M ( ∑ x ∈ Finset.Ico 2 ( N + 2 ), |lowerBoundGap x| );
    exact fun x hx => if h : x < N + 2 then le_max_of_le_right ( Finset.single_le_sum ( fun x _ => abs_nonneg ( lowerBoundGap x ) ) ( Finset.mem_Ico.mpr ⟨ hx, h ⟩ ) |> le_trans ( le_abs_self _ ) ) else le_max_of_le_left ( lowerBoundGap_unbounded x ( by linarith ) );
  use powersOfTwo n;
  refine' ⟨ _, _, _ ⟩;
  · exact?;
  · rw [ powersOfTwo_card ] ; linarith;
  · refine' hn₂.trans_le _;
    refine' le_trans _ ( averageSquaredGap_ge ( powersOfTwo n ) _ );
    · rw [ min_sumset_powersOfTwo, max_sumset_powersOfTwo ];
      · rw [ sumset_powersOfTwo_card ];
        unfold lowerBoundGap; norm_num;
        rw [ Nat.cast_div ] <;> norm_num;
        exact even_iff_two_dvd.mp ( by simp +arith +decide [ mul_add, parity_simps ] );
      · linarith;
      · linarith;
    · rw [ sumset_powersOfTwo_card ];
      exact Nat.le_div_iff_mul_le zero_lt_two |>.2 ( by nlinarith )

/-
The lower bound for the gap tends to infinity.
-/
lemma lowerBoundGap_tendsto : Filter.Tendsto lowerBoundGap Filter.atTop Filter.atTop := by
  have h_unbounded : Filter.Tendsto (fun n : ℕ => (2^n - 2 : ℚ)^2 / ((n * (n + 1) / 2 : ℚ) * ((n * (n + 1) / 2 : ℚ) - 1))) Filter.atTop Filter.atTop := by
    suffices h_simplified : Filter.Tendsto (fun n : ℕ => (2^n - 2 : ℚ)^2 / (n^4 : ℚ)) Filter.atTop Filter.atTop by
      refine' Filter.tendsto_atTop_mono' _ _ h_simplified;
      filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn;
      field_simp;
      rw [ le_div_iff₀ ] <;> nlinarith [ show ( n : ℚ ) ≥ 2 by norm_cast, sq ( n - 2 : ℚ ), pow_pos ( show ( n : ℚ ) > 0 by positivity ) 3, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 4, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 5, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 6, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 7, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 8, pow_pos ( show ( n : ℚ ) > 0 by positivity ) 9 ];
    suffices h_simp : Filter.Tendsto (fun n : ℕ => (2 : ℚ)^n / (n : ℚ)^2) Filter.atTop Filter.atTop by
      suffices h_rewrite : Filter.Tendsto (fun n : ℕ => ((2 : ℚ)^n / (n : ℚ)^2 - 2 / (n : ℚ)^2)^2) Filter.atTop Filter.atTop by
        convert h_rewrite using 2 ; ring;
      rw [ Filter.tendsto_atTop_atTop ] at *;
      intro b; rcases h_simp ( Max.max b 4 ) with ⟨ i, hi ⟩ ; use i + 4; intros a ha; nlinarith [ hi a ( by linarith ), le_max_left b 4, le_max_right b 4, show ( 2 : ℚ ) / a ^ 2 ≤ 1 by rw [ div_le_iff₀ ] <;> norm_cast <;> nlinarith ] ;
    have h_exp_growth : Filter.Tendsto (fun n : ℕ => (2 : ℝ) ^ n / (n ^ 2 : ℝ)) Filter.atTop Filter.atTop := by
      have h_exp_growth : Filter.Tendsto (fun n : ℕ => (Real.exp (n * Real.log 2)) / (n ^ 2 : ℝ)) Filter.atTop Filter.atTop := by
        suffices h_log : Filter.Tendsto (fun y : ℝ => Real.exp y / y ^ 2) Filter.atTop Filter.atTop by
          have := h_log.comp ( tendsto_natCast_atTop_atTop.atTop_mul_const ( Real.log_pos one_lt_two ) );
          convert this.const_mul_atTop ( show 0 < ( Real.log 2 ) ^ 2 by positivity ) using 2 ; norm_num ; ring;
          norm_num [ mul_assoc, mul_comm, mul_left_comm, sq ];
        simpa using Real.tendsto_exp_div_pow_atTop 2;
      simpa [ Real.exp_nat_mul, Real.exp_log ] using h_exp_growth;
    rw [ Filter.tendsto_atTop_atTop ] at *;
    exact fun b => by rcases h_exp_growth b with ⟨ i, hi ⟩ ; exact ⟨ i, fun n hin => by exact Rat.cast_le.mp ( le_trans ( hi n hin ) ( by norm_num ) ) ⟩ ;
  convert h_unbounded using 1;
  ext n;
  unfold lowerBoundGap;
  field_simp

/-
Proof of the strong version of Erdős Problem #153 (proven).
-/
theorem erdos_problem_153_strong_proven : ∀ M : ℚ, ∀ N : ℕ, ∃ A : Finset ℕ, IsSidonSet A ∧ A.card > N ∧ averageSquaredGap A > M := by
  exact?

/-
Proof of the strong version of Erdős Problem #153 (final attempt).
-/
theorem erdos_problem_153_strong_final : ∀ M : ℚ, ∀ N : ℕ, ∃ A : Finset ℕ, IsSidonSet A ∧ A.card > N ∧ averageSquaredGap A > M := by
  -- Apply the strong version of the Erdős problem.
  apply erdos_problem_153_strong_proven