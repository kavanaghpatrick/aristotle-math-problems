/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e67312bc-8763-4503-854a-66a229617ce7

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check SimpleGraph.lineGraph
#check SimpleGraph.chromaticNumber
#check SimpleGraph.maxDegree

/-
The square of a graph G, denoted G², has the same vertex set as G, and two vertices are adjacent in G² if their distance in G is 1 or 2.
-/
def SimpleGraph.square {V : Type*} (G : SimpleGraph V) : SimpleGraph V where
  Adj u v := (G.Adj u v ∨ ∃ w, G.Adj u w ∧ G.Adj w v) ∧ u ≠ v
  symm := by
    intro u v uv; aesop;
    · exact Or.inl h.symm;
    · exact Or.inr ⟨ w, right_1.symm, left.symm ⟩
  loopless := by
    intro u hu; simp_all +decide ;

/-
The strong chromatic index of a graph G is the chromatic number of the square of its line graph.
-/
def SimpleGraph.strongChromaticIndex {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  ENat.toNat G.lineGraph.square.chromaticNumber

/-
The Erdős 149 property for a constant C states that for every graph G, the strong chromatic index is at most C * Δ².
-/
def Erdos149Property (C : ℝ) : Prop :=
  ∀ {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj],
    (G.strongChromaticIndex : ℝ) ≤ C * (G.maxDegree : ℝ) ^ 2

/-
The maximum degree of the line graph of G is at most 2Δ - 2.
-/
theorem maxDegree_lineGraph_le {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
    (G.lineGraph).maxDegree ≤ 2 * G.maxDegree - 2 := by
      -- Let's choose any vertex $e$ in the line graph $L(G)$.
      have h_max_degree_line_graph : ∀ e : G.edgeSet, G.lineGraph.degree e ≤ 2 * G.maxDegree - 2 := by
        intro e
        obtain ⟨u, v, huv⟩ : ∃ u v : V, e = s(u, v) ∧ G.Adj u v := by
          aesop;
          rcases val with ⟨ u, v ⟩ ; aesop;
        -- The neighbors of $e$ in $L(G)$ are the edges adjacent to $u$ or $v$ in $G$.
        have h_neighbors : G.lineGraph.neighborFinset e ⊆ Finset.image (fun f => f) (Finset.filter (fun f => f.val ∈ G.incidenceFinset u ∨ f.val ∈ G.incidenceFinset v) (Finset.univ : Finset G.edgeSet)) \ {e} := by
          intro f hf
          aesop;
          cases hf ; aesop;
          rcases right_1 with ⟨ w, hw ⟩ ; aesop;
          · cases right_1 ; aesop;
          · exact Or.inr ( by rw [ SimpleGraph.incidenceSet ] ; aesop );
        -- The number of edges adjacent to $u$ or $v$ in $G$ is at most $d(u) + d(v) - 1$.
        have h_edges_adjacent : (Finset.filter (fun f => f.val ∈ G.incidenceFinset u ∨ f.val ∈ G.incidenceFinset v) (Finset.univ : Finset G.edgeSet)).card ≤ G.degree u + G.degree v - 1 := by
          have h_edges_adjacent : (Finset.filter (fun f => f.val ∈ G.incidenceFinset u ∨ f.val ∈ G.incidenceFinset v) (Finset.univ : Finset G.edgeSet)).card ≤ (G.incidenceFinset u ∪ G.incidenceFinset v).card := by
            rw [ ← Finset.card_image_of_injective _ Subtype.coe_injective ];
            exact Finset.card_le_card fun x hx => by aesop;
          have h_edges_adjacent : (G.incidenceFinset u ∩ G.incidenceFinset v).card ≥ 1 := by
            refine' Finset.card_pos.mpr ⟨ e, _ ⟩ ; aesop;
            exact?;
          have := Finset.card_union_add_card_inter ( G.incidenceFinset u ) ( G.incidenceFinset v ) ; aesop;
          exact h_edges_adjacent_1.trans ( Nat.le_sub_one_of_lt ( by linarith [ Finset.card_pos.2 h_edges_adjacent ] ) );
        -- Since $d(u) \leq \Delta$ and $d(v) \leq \Delta$, we have $d(u) + d(v) - 1 \leq 2\Delta - 1$.
        have h_deg_sum : G.degree u + G.degree v - 1 ≤ 2 * G.maxDegree - 1 := by
          exact Nat.sub_le_sub_right ( by linarith [ show G.degree u ≤ G.maxDegree from G.degree_le_maxDegree u, show G.degree v ≤ G.maxDegree from G.degree_le_maxDegree v ] ) _;
        have := Finset.card_mono h_neighbors;
        rw [ Finset.card_sdiff ] at this ; aesop;
        exact this.trans ( Nat.sub_le_sub_right ( h_edges_adjacent.trans ( Nat.sub_le_sub_right h_deg_sum 1 ) ) _ );
      exact?

/-
The maximum degree of the square of a graph G is at most Δ(G)² + Δ(G).
-/
theorem maxDegree_square_le {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
    G.square.maxDegree ≤ G.maxDegree ^ 2 + G.maxDegree := by
      rw [ SimpleGraph.maxDegree ];
      -- The degree of a vertex in $G^2$ is at most the number of vertices at distance 1 or 2 from it.
      have h_deg_sq : ∀ v : V, G.square.degree v ≤ G.degree v + ∑ u ∈ G.neighborFinset v, G.degree u := by
        intro v
        have h_deg_G2 : (G.square.degree v : ℕ) ≤ (G.degree v : ℕ) + Finset.card (Finset.biUnion (G.neighborFinset v) (fun u => G.neighborFinset u \ {v})) := by
          have h_deg_G2 : (G.square.degree v : ℕ) ≤ Finset.card (G.neighborFinset v ∪ Finset.biUnion (G.neighborFinset v) (fun u => G.neighborFinset u \ {v})) := by
            refine' Finset.card_mono _;
            intro u hu
            aesop;
            cases hu ; aesop;
          exact h_deg_G2.trans ( Finset.card_union_le _ _ );
        refine' h_deg_G2.trans ( add_le_add_left ( le_trans ( Finset.card_biUnion_le ) _ ) _ );
        exact Finset.sum_le_sum fun u hu => Finset.card_mono <| fun x hx => by aesop;
      -- Since the degree of any vertex in $G$ is at most $\Delta(G)$, we have $\sum_{u \in G.neighborFinset v} G.degree u \leq \Delta(G) \cdot G.degree v$.
      have h_sum_deg_sq : ∀ v : V, ∑ u ∈ G.neighborFinset v, G.degree u ≤ G.maxDegree * G.degree v := by
        intro v;
        exact le_trans ( Finset.sum_le_sum fun u hu => show G.degree u ≤ G.maxDegree from by exact? ) ( by simp +decide [ mul_comm ] );
      rcases isEmpty_or_nonempty V with ( h | h ) <;> aesop;
      have h_max_deg_sq : ∀ v : V, G.square.degree v ≤ G.maxDegree ^ 2 + G.maxDegree := by
        exact fun v => le_trans ( h_deg_sq v ) ( by nlinarith [ h_sum_deg_sq v, show G.degree v ≤ G.maxDegree from G.degree_le_maxDegree v ] );
      have := Finset.max_of_nonempty ( Finset.univ_nonempty.image fun v => G.square.degree v ) ; aesop;
      have := Finset.mem_of_max h_1; aesop;

/-
The maximum degree of the square of the line graph of G is at most 4Δ² - 6Δ + 2, provided Δ ≥ 1.
-/
theorem maxDegree_lineGraph_square_le_bound {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (h : G.maxDegree ≥ 1) :
    (G.lineGraph.square).maxDegree ≤ 4 * G.maxDegree ^ 2 - 6 * G.maxDegree + 2 := by
      have h_max_deg_line : (G.lineGraph).maxDegree ≤ 2 * G.maxDegree - 2 := by
        exact?;
      have h_max_deg_square : (G.lineGraph.square).maxDegree ≤ (G.lineGraph.maxDegree)^2 + (G.lineGraph.maxDegree) := by
        apply maxDegree_square_le;
      rcases k : SimpleGraph.maxDegree G with ( _ | _ | k ) <;> simp_all +decide;
      exact h_max_deg_square.trans ( by nlinarith only [ h_max_deg_line, Nat.sub_add_cancel ( show 2 ≤ 2 * ( ‹_› + 1 + 1 ) from by linarith ), Nat.sub_add_cancel ( show 6 * ( ‹_› + 1 + 1 ) ≤ 4 * ( ‹_› + 1 + 1 ) ^ 2 from by nlinarith only ) ] )

/-
The chromatic number of a finite graph is at most its maximum degree plus one.
-/
theorem chromaticNumber_le_maxDegree_add_one {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
    G.chromaticNumber ≤ G.maxDegree + 1 := by
      have h_color : ∀ (v : V), G.degree v < (G.maxDegree + 1) := by
        exact fun v => Nat.lt_succ_of_le ( SimpleGraph.degree_le_maxDegree _ _ );
      -- By the theorem that states the chromatic number of a graph is at most its maximum degree plus one.
      have h_colorable : ∀ {k : ℕ}, (∀ v : V, G.degree v < k) → G.Colorable k := by
        bound;
        -- By the theorem that states the chromatic number of a graph is at most its maximum degree plus one, we can color the graph using k colors.
        have h_colorable : ∀ {k : ℕ}, (∀ v : V, G.degree v < k) → G.Colorable k := by
          intro k hk
          have h_colorable_aux : ∀ (s : Finset V), ∃ (c : V → Fin k), ∀ v ∈ s, ∀ u ∈ s, G.Adj v u → c v ≠ c u := by
            intro s
            induction' s using Finset.induction with v s ih;
            · cases k <;> aesop;
              exact Or.inl ⟨ fun v => hk v ⟩;
            · bound;
              -- Let's choose a color for $v$ that is different from the colors of its neighbors in $s$.
              obtain ⟨c_v, hc_v⟩ : ∃ c_v : Fin k, ∀ u ∈ s, G.Adj v u → w u ≠ c_v := by
                have h_colorable_aux : Finset.card (Finset.image w (Finset.filter (fun u => G.Adj v u) s)) < k := by
                  exact lt_of_le_of_lt ( Finset.card_image_le ) ( lt_of_le_of_lt ( Finset.card_le_card ( show Finset.filter ( fun u => G.Adj v u ) s ⊆ G.neighborFinset v from fun u hu => by aesop ) ) ( by simpa using hk v ) );
                contrapose! h_colorable_aux;
                rw [ show Finset.image w ( Finset.filter ( fun u => G.Adj v u ) s ) = Finset.univ from Finset.eq_univ_of_forall fun x => by obtain ⟨ u, hu, hu', rfl ⟩ := h_colorable_aux x; exact Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ hu, hu' ⟩ ) ] ; simp +decide;
              use fun u => if u = v then c_v else w u;
              simp_all +decide [ SimpleGraph.adj_comm ];
              bound
          obtain ⟨ c, hc ⟩ := h_colorable_aux Finset.univ;
          exact ⟨ c, by aesop ⟩;
        exact h_colorable a;
      exact h_colorable h_color |> fun h => h.chromaticNumber_le