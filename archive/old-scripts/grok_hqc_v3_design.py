#!/usr/bin/env python3
"""
Design HQC v3 with Grok - exploit quasi-cyclic structure explicitly.
"""

import json
import subprocess
import sys
import os

# Get API key from environment
api_key = os.environ.get('GROK_API_KEY')
if not api_key:
    print("‚ùå GROK_API_KEY not set", file=sys.stderr)
    sys.exit(1)

# Read HQC v2 for reference
with open('/Users/patrickkavanagh/Downloads/ec2b9506-6f58-4a99-898a-9b8bad40b57b-output.lean', 'r') as f:
    hqc_v2 = f.read()

# Read HQC v2 input for reference
with open('hqc_improved_input.txt', 'r') as f:
    hqc_v2_input = f.read()

question = """HQC v3 PROBLEM DESIGN: Exploit Quasi-Cyclic Structure

You are designing HQC v3 to address the critical gap in v2: **lack of quasi-cyclic structure exploitation**.

---

## CONTEXT

**HQC v2 Assessment:**
- Novelty: 4/10 (formalizes known bounds)
- Rating: 5-6/10 (sophisticated formalization but not novel)
- **Critical Gap**: Uses generic linear code bounds (n, k, t) without exploiting circulant properties

**Your Recommendation:** Option A - Deeper QC Structure Analysis
- Exploit circulant matrix properties explicitly
- Analyze dual code structure
- Prove bounds specific to quasi-cyclic codes

---

## HQC QUASI-CYCLIC STRUCTURE

**Key Properties:**
1. **Circulant Matrices**: Generated by single row (h_0, h_1, ..., h_{n-1})
2. **Block Structure**: H = [H_1 | H_2] where each H_i is circulant
3. **Eigenvalue Decomposition**: Circulant matrix has FFT eigenvalues
4. **Dual Code**: QC code ‚Üí dual is also QC
5. **Automorphism Group**: Cyclic shifts preserve code structure

**Security Impact:**
- ISD might exploit circulant structure (faster than generic codes?)
- Statistical attacks may benefit from repeated patterns
- Algebraic attacks could use polynomial representation

**Research Question:** Does QC structure help or hurt attackers?

---

## HQC PARAMETERS

**HQC-128:**
- n = 17669 (code length)
- k = 13893 (dimension)
- t = 66 (error weight)
- r = 83 (block size for quasi-cyclic structure)
- Structure: n = 213 √ó 83 (213 blocks of size 83)

**Circulant Structure:**
- Parity check H is doubly-circulant: H = [H_1 | H_2]
- Each H_i is 213√ó213 matrix of 83√ó83 circulant blocks

---

## WHAT v2 DID WRONG

```lean
def CirculantMatrix (n : ‚Ñï) := Fin n ‚Üí ZMod 2  // DEFINED but NEVER USED

// Proofs used generic bounds:
ISD_Complexity = C(n,t) / C(n-k,t)  // Could apply to ANY linear code!
```

**Problem:** v2 mentioned "quasi-cyclic" but proofs are 100% generic.

---

## YOUR TASK: Design HQC v3

Create a comprehensive problem statement that FORCES exploitation of QC structure.

### Goal 1: Circulant ISD Complexity with Automorphisms

**Question:** Does the cyclic automorphism group reduce ISD search space?

**Formulation:**
"Prove that for HQC's circulant parity check matrix H, the ISD algorithm must search over at least X orbits under the cyclic group C_83, where each orbit contains at most 83 information sets. Account for the orbit structure in the complexity bound."

**Why This Forces QC Analysis:**
- Must analyze automorphism group action
- Must compute orbit sizes
- Can't just use generic C(n,k)

### Goal 2: Eigenvalue Analysis

**Question:** How do circulant eigenvalues affect syndrome decoding?

**Formulation:**
"For circulant matrix H_i with eigenvalues Œª_0, ..., Œª_{82} (via FFT over Z_2[x]/(x^83-1)), prove that syndrome decoding complexity depends on the number of non-zero eigenvalues. For HQC parameters, show this gives a lower bound of at least 2^Œª operations."

**Why This Forces QC Analysis:**
- Must compute/analyze FFT eigenvalues
- Must use polynomial ring representation
- Generic codes don't have this structure

### Goal 3: Polynomial Representation Bounds

**Question:** Using polynomial ring ideal representation?

**Formulation:**
"Represent HQC code as ideal I ‚äÇ Z_2[x]/(x^{17669}-1). Prove that solving QCSD in the polynomial representation requires computing a Gr√∂bner basis of degree at least d, implying complexity ‚â• 2^Œª."

**Why This Forces QC Analysis:**
- Polynomial ring is unique to quasi-cyclic codes
- Gr√∂bner basis complexity is specific to algebraic structure

### Goal 4: Independence Assumptions

**Question:** Do independence assumptions hold for circulant codes?

**Formulation:**
"Classical ISD analysis assumes independence of information set trials. For circulant codes, prove that the dependence coefficient œÅ satisfies œÅ ‚â§ 1 + Œµ for small Œµ, or show that dependence increases complexity."

**Reference:** "Independence assumptions in quasi-cyclic codes" (Jan 2025, arXiv:2501.02626)

### Goal 5: Dual Code Lower Bound

**Question:** Does dual code structure provide tighter bounds?

**Formulation:**
"For HQC's quasi-cyclic dual code C^‚ä•, prove that the dual distance d^‚ä• ‚â• d_min, which implies ISD complexity ‚â• f(d^‚ä•, n, k) via covering radius bounds. Show this is tighter than primal-only analysis."

---

## SUCCESS CRITERIA

**Aristotle's output MUST include:**
1. ‚úÖ Explicit use of circulant eigenvalues or polynomial representation
2. ‚úÖ Analysis of automorphism group (C_83 or C_{213})
3. ‚úÖ Comparison: "QC code requires 2^X vs generic code requires 2^Y"
4. ‚úÖ Reference to cyclotomic polynomials or FFT
5. ‚úÖ Dual code analysis specific to QC structure

**Red Flags (means we failed again):**
- ‚ùå Only uses C(n,t)/C(n-k,t) formulas
- ‚ùå CirculantMatrix defined but never used in proofs
- ‚ùå No mention of eigenvalues, automorphisms, or polynomial ring
- ‚ùå Could apply proof to any [n,k,t] linear code

---

## EXPECTED OUTPUT

**Lean 4 proof containing:**
1. Circulant matrix eigenvalue definitions (FFT-based)
2. Automorphism group action on information sets
3. Polynomial ring ideal representation
4. Theorems comparing QC vs generic codes
5. Concrete bounds accounting for r=83 block structure

**Target:** 250-400 lines (vs v2's 167)

**Novelty Target:** 7-8/10 (vs v2's 5-6/10)
- First formal proof exploiting QC structure in HQC
- Tighter bounds due to structural analysis
- Novel use of automorphism group in ISD complexity

---

## OUTPUT FORMAT

Provide a complete Aristotle input file with:

1. **Problem Title**
2. **Executive Summary** (what makes v3 different from v2)
3. **Background on Quasi-Cyclic Structure**
4. **Goal 1: [Specific formulation with QC exploitation]**
5. **Goal 2: [Specific formulation with QC exploitation]**
6. **Goal 3: [Specific formulation with QC exploitation]**
7. **Goal 4: [Specific formulation with QC exploitation]**
8. **Formalization Requirements** (what Lean definitions are needed)
9. **Success Criteria** (how to verify QC structure was used)
10. **Expected Proof Structure** (outline of what proof should contain)

Make it concrete, specific, and impossible to solve without exploiting quasi-cyclic properties!
"""

# Create request
request = {
    "messages": [{"role": "user", "content": question}],
    "model": "grok-2-1212",
    "temperature": 0.7  # Higher temperature for creative problem design
}

with open('/tmp/grok_hqc_v3_request.json', 'w') as f:
    json.dump(request, f)

print("üé® Asking Grok to design HQC v3 with QC structure exploitation...")
print("üå°Ô∏è  Temperature: 0.7 (creative mode)")
print()

# Call Grok API
result = subprocess.run(
    [
        'curl', '-X', 'POST',
        'https://api.x.ai/v1/chat/completions',
        '-H', 'Content-Type: application/json',
        '-H', f'Authorization: Bearer {api_key}',
        '-d', '@/tmp/grok_hqc_v3_request.json',
        '--max-time', '300'
    ],
    capture_output=True,
    text=True
)

if result.returncode != 0:
    print(f"‚ùå Error: {result.stderr}", file=sys.stderr)
    sys.exit(1)

try:
    response = json.loads(result.stdout)
    design = response['choices'][0]['message']['content']
    print(design)
    print()

    # Save to file
    with open('/tmp/grok_hqc_v3_design.txt', 'w') as f:
        f.write(design)

    print("üíæ Saved to: /tmp/grok_hqc_v3_design.txt")

except Exception as e:
    print(f"‚ùå Error: {e}", file=sys.stderr)
    print(f"Raw: {result.stdout}", file=sys.stderr)
    sys.exit(1)
