/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a1de5a51-f272-4233-8766-3a7928bed4c5
-/

/-
Formal verification of HOMFLY-PT polynomial non-triviality for 6 knots.
Implements sparse 2-variable Laurent polynomials, Hecke algebra representation of braids,
and the Ocneanu trace algorithm.
Proves that the Trefoil, Figure-eight, Cinquefoil, Three-twist, 6_1, and 7_1 knots
have HOMFLY-PT polynomials distinct from the unknot.
Includes validation that the unknot and trivial braids evaluate to the expected value.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define sparse 2-variable Laurent polynomials and their operations using fuel-based recursion for normalization.
Normalization sorts terms and merges duplicates.
Addition concatenates and normalizes.
Multiplication distributes terms and normalizes.
-/
abbrev SparsePoly2 := List (Int × Int × Int)

def SparsePoly2.merge (fuel : Nat) (p : SparsePoly2) : SparsePoly2 :=
  match fuel with
  | 0 => []
  | fuel + 1 =>
    match p with
    | [] => []
    | [x] => if x.2.2 == 0 then [] else [x]
    | x :: y :: rest =>
      if x.1 == y.1 && x.2.1 == y.2.1 then
        merge fuel ((x.1, x.2.1, x.2.2 + y.2.2) :: rest)
      else
        if x.2.2 == 0 then merge fuel (y :: rest) else x :: merge fuel (y :: rest)

def SparsePoly2.normalize (p : SparsePoly2) : SparsePoly2 :=
  let sorted := p.mergeSort (fun a b => if a.1 != b.1 then a.1 < b.1 else a.2.1 < b.2.1)
  SparsePoly2.merge (sorted.length + 1) sorted

def SparsePoly2.add (p1 p2 : SparsePoly2) : SparsePoly2 :=
  SparsePoly2.normalize (p1 ++ p2)

def SparsePoly2.mul (p1 p2 : SparsePoly2) : SparsePoly2 :=
  let raw := p1.foldl (fun acc t1 =>
    acc ++ p2.map (fun t2 => (t1.1 + t2.1, t1.2.1 + t2.2.1, t1.2.2 * t2.2.2))) []
  SparsePoly2.normalize raw

def SparsePoly2.mul_norm (p1 p2 : SparsePoly2) : SparsePoly2 :=
  (SparsePoly2.mul p1 p2).normalize

/-
Define Hecke algebra elements and operations.
Permutations are lists of numbers.
Hecke elements are linear combinations of permutations with polynomial coefficients.
Multiplication by generators T_i and T_i^{-1} follows the Hecke relations.
q = v^2.
Relation: T_i^2 = (q - q^{-1})T_i + 1.
Action on permutations depends on whether length increases or decreases (determined by relative order of swapped values).
-/
abbrev BraidWord := List Int
abbrev Permutation := List Nat
abbrev Hecke_elt := List (Permutation × SparsePoly2)

def Permutation.id (n : Nat) : Permutation :=
  List.range n

def Permutation.swap_values (p : Permutation) (v1 v2 : Nat) : Permutation :=
  p.map (fun x => if x == v1 then v2 else if x == v2 then v1 else x)

def Permutation.pos (p : Permutation) (v : Nat) : Option Nat :=
  let rec aux (l : List Nat) (i : Nat) : Option Nat :=
    match l with
    | [] => none
    | h :: t => if h == v then some i else aux t (i+1)
  aux p 0

def poly_q : SparsePoly2 := [(2, 0, 1)]
def poly_q_inv : SparsePoly2 := [(-2, 0, 1)]
def poly_diff : SparsePoly2 := [(2, 0, 1), (-2, 0, -1)] -- q - q⁻¹

def Hecke_elt.merge (fuel : Nat) (h : Hecke_elt) : Hecke_elt :=
  match fuel with
  | 0 => []
  | fuel + 1 =>
    match h with
    | [] => []
    | [x] => if x.2 == [] then [] else [x]
    | x :: y :: rest =>
      if x.1 == y.1 then
        merge fuel ((x.1, SparsePoly2.add x.2 y.2) :: rest)
      else
        if x.2 == [] then merge fuel (y :: rest) else x :: merge fuel (y :: rest)

def Hecke_elt.normalize (h : Hecke_elt) : Hecke_elt :=
  let sorted := h.mergeSort (fun a b => a.1 < b.1)
  Hecke_elt.merge (sorted.length + 1) sorted

def Hecke_elt.scale (h : Hecke_elt) (s : SparsePoly2) : Hecke_elt :=
  h.map (fun (p, c) => (p, SparsePoly2.mul_norm c s))

def Hecke_elt.add (h1 h2 : Hecke_elt) : Hecke_elt :=
  Hecke_elt.normalize (h1 ++ h2)

def Hecke_elt.mul_gen (h : Hecke_elt) (i : Nat) (inv : Bool) : Hecke_elt :=
  let v1 := i - 1
  let v2 := i
  let raw := h.foldl (fun acc (term : Permutation × SparsePoly2) =>
    let p := term.1
    let c := term.2
    let pos1 := Permutation.pos p v1
    let pos2 := Permutation.pos p v2
    match pos1, pos2 with
    | some idx1, some idx2 =>
      let p_prime := Permutation.swap_values p v1 v2
      if idx1 < idx2 then
        -- v1 before v2: length increases
        if inv then
          -- T⁻¹ = T - (q - q⁻¹)
          -- T⁻¹ p = p' - (q - q⁻¹) p
          let term1 := [(p_prime, c)]
          let term2 := [(p, SparsePoly2.mul_norm c poly_diff)]
          let term2_neg := term2.map (fun (perm, poly) => (perm, poly.map (fun (e1, e2, co) => (e1, e2, -co))))
          acc ++ term1 ++ term2_neg
        else
          -- T p = p'
          acc ++ [(p_prime, c)]
      else
        -- v1 after v2: length decreases
        if inv then
          -- T⁻¹ p = p'
          acc ++ [(p_prime, c)]
        else
          -- T p = (q - q⁻¹) p + p'
          let term1 := [(p, SparsePoly2.mul_norm c poly_diff)]
          let term2 := [(p_prime, c)]
          acc ++ term1 ++ term2
    | _, _ => acc
  ) []
  Hecke_elt.normalize raw

/-
Define helper constants and functions for HOMFLY-PT calculation.
poly_z = z.
poly_mu = (v - v^{-1})/z.
Permutation helpers: get value, swap positions, count inversions.
Writhe computation.
Braid to Hecke conversion.
-/
def poly_z : SparsePoly2 := [(0, 1, 1)]
def poly_mu : SparsePoly2 := [(1, -1, 1), (-1, -1, -1)] -- (v - v⁻¹)/z

def Permutation.get_val (p : Permutation) (i : Nat) : Nat :=
  match p.get? i with
  | some v => v
  | none => i

def Permutation.swap_pos (p : Permutation) (i j : Nat) : Permutation :=
  let indexed := p.zip (List.range p.length)
  indexed.map (fun (val, idx) =>
    if idx == i then p.get_val j
    else if idx == j then p.get_val i
    else val)

def Permutation.inversions (p : Permutation) : Nat :=
  let rec count (l : List Nat) : Nat :=
    match l with
    | [] => 0
    | h :: t => (t.filter (fun x => h > x)).length + count t
  count p

def compute_writhe (b : BraidWord) : Int :=
  b.foldl (fun acc gen => if gen > 0 then acc + 1 else acc - 1) 0

def braid_to_Hecke (n : Nat) (b : BraidWord) : Hecke_elt :=
  b.foldl (fun acc gen =>
    let idx := gen.natAbs
    let inv := gen < 0
    Hecke_elt.mul_gen acc idx inv
  ) [(Permutation.id n, [(0, 0, 1)])]

/-
Define the HOMFLY-PT polynomial computation and prove non-triviality for 6 knots.
The trace algorithm uses fuel to ensure termination.
Theorems use `native_decide` to verify the computation results are not equal to the unknot polynomial (1).
-/
def poly_diff_trace : SparsePoly2 := [(2, 0, 1), (-2, 0, -1)]

def trace_perm (fuel : Nat) (p : Permutation) : SparsePoly2 :=
  match fuel with
  | 0 => poly_mu
  | fuel + 1 =>
    let n := p.length
    let non_fixed := (List.range n).filter (fun idx => p.get_val idx != idx)
    match non_fixed.getLast? with
    | none => poly_mu
    | some k_idx =>
      let k := k_idx + 1
      let descents := (List.range k_idx).filter (fun idx => p.get_val idx > p.get_val (idx + 1))
      match descents.getLast? with
      | none => poly_mu
      | some i_minus_1 =>
        let i := i_minus_1 + 1
        if i == k then
          let p_next := Permutation.swap_pos p (k - 1) k
          SparsePoly2.mul_norm poly_z (trace_perm fuel p_next)
        else
          let p_si := Permutation.swap_pos p (i - 1) i
          let si_p_si := Permutation.swap_values p_si (i - 1) i
          let l_p := Permutation.inversions p
          let l_si_p_si := Permutation.inversions si_p_si
          if l_si_p_si < l_p then
             let term1 := SparsePoly2.mul_norm poly_diff_trace (trace_perm fuel p_si)
             let term2 := trace_perm fuel si_p_si
             SparsePoly2.add term1 term2
          else
             trace_perm fuel si_p_si

def Hecke_elt.ocneanu_trace (n : Nat) (h : Hecke_elt) : SparsePoly2 :=
  h.foldl (fun acc (p, c) =>
    SparsePoly2.add acc (SparsePoly2.mul_norm c (trace_perm 100 p))
  ) []

def homfly_normalize (p : SparsePoly2) (writhe : Int) : SparsePoly2 :=
  let writhe_factor := [(writhe, 0, -1)]
  SparsePoly2.mul_norm p writhe_factor

def homfly_polynomial_computable (b : BraidWord) : SparsePoly2 :=
  let n := b.foldl (fun m x => max m x.natAbs) 0 + 1
  let hecke := braid_to_Hecke n b
  let trace := Hecke_elt.ocneanu_trace n hecke
  let writhe := compute_writhe b
  homfly_normalize trace writhe

theorem homfly_neq_one_trefoil :
  homfly_polynomial_computable [1, 1, 1] ≠ [(0, 0, 1)] := by
  native_decide

theorem homfly_neq_one_figure_eight :
  homfly_polynomial_computable [1, -2, 1, -2] ≠ [(0, 0, 1)] := by
  native_decide

theorem homfly_neq_one_cinquefoil :
  homfly_polynomial_computable [1, 1, 1, 1, 1] ≠ [(0, 0, 1)] := by
  native_decide

theorem homfly_neq_one_three_twist :
  homfly_polynomial_computable [1, 1, 1, -2, -2] ≠ [(0, 0, 1)] := by
  native_decide

theorem homfly_neq_one_6_1 :
  homfly_polynomial_computable [1, 1, -2, -2, -2, 1] ≠ [(0, 0, 1)] := by
  native_decide

theorem homfly_neq_one_7_1 :
  homfly_polynomial_computable [1, 1, 1, 1, 1, 1, 1] ≠ [(0, 0, 1)] := by
  native_decide

/-
Evaluate the HOMFLY-PT polynomial for the trefoil knot to debug the mismatch.
-/
#eval homfly_polynomial_computable [1, 1, 1]

/-
Prove that the HOMFLY-PT polynomial for each of the 6 knots is not equal to the polynomial of the unknot (poly_mu).
-/
theorem homfly_non_trivial_trefoil :
  homfly_polynomial_computable [1, 1, 1] ≠ poly_mu := by
  native_decide

theorem homfly_non_trivial_figure_eight :
  homfly_polynomial_computable [1, -2, 1, -2] ≠ poly_mu := by
  native_decide

theorem homfly_non_trivial_cinquefoil :
  homfly_polynomial_computable [1, 1, 1, 1, 1] ≠ poly_mu := by
  native_decide

theorem homfly_non_trivial_three_twist :
  homfly_polynomial_computable [1, 1, 1, -2, -2] ≠ poly_mu := by
  native_decide

theorem homfly_non_trivial_6_1 :
  homfly_polynomial_computable [1, 1, -2, -2, -2, 1] ≠ poly_mu := by
  native_decide

theorem homfly_non_trivial_7_1 :
  homfly_polynomial_computable [1, 1, 1, 1, 1, 1, 1] ≠ poly_mu := by
  native_decide

/-
Define the unknot value explicitly and prove that the empty braid and trivial braid evaluate to it.
Then prove that the 6 test knots evaluate to something different.
-/
def poly_unknot_val : SparsePoly2 := [(-1, -1, 1), (1, -1, -1)]

theorem homfly_unknot_is_val :
  homfly_polynomial_computable [] = poly_unknot_val := by
  native_decide

theorem homfly_reidemeister_ii_is_val :
  homfly_polynomial_computable [1, -1] = poly_unknot_val := by
  native_decide

theorem homfly_trefoil_neq_unknot :
  homfly_polynomial_computable [1, 1, 1] ≠ poly_unknot_val := by
  native_decide

theorem homfly_figure_eight_neq_unknot :
  homfly_polynomial_computable [1, -2, 1, -2] ≠ poly_unknot_val := by
  native_decide

theorem homfly_cinquefoil_neq_unknot :
  homfly_polynomial_computable [1, 1, 1, 1, 1] ≠ poly_unknot_val := by
  native_decide

theorem homfly_three_twist_neq_unknot :
  homfly_polynomial_computable [1, 1, 1, -2, -2] ≠ poly_unknot_val := by
  native_decide

theorem homfly_6_1_neq_unknot :
  homfly_polynomial_computable [1, 1, -2, -2, -2, 1] ≠ poly_unknot_val := by
  native_decide

theorem homfly_7_1_neq_unknot :
  homfly_polynomial_computable [1, 1, 1, 1, 1, 1, 1] ≠ poly_unknot_val := by
  native_decide

/-
Define corrected HOMFLY-PT computation with proper writhe normalization.
Verify that the unknot and trivial braid evaluate to the normalized poly_mu.
Prove that all 6 test knots evaluate to polynomials distinct from poly_mu.
-/
def homfly_normalize_correct (p : SparsePoly2) (writhe : Int) : SparsePoly2 :=
  let writhe_factor := [(-writhe, 0, 1)] -- v^(-writhe)
  SparsePoly2.mul_norm p writhe_factor

def homfly_polynomial_computable_correct (b : BraidWord) : SparsePoly2 :=
  let n := b.foldl (fun m x => max m x.natAbs) 0 + 1
  let hecke := braid_to_Hecke n b
  let trace := Hecke_elt.ocneanu_trace n hecke
  let writhe := compute_writhe b
  homfly_normalize_correct trace writhe

theorem homfly_unknot_is_poly_mu :
  homfly_polynomial_computable_correct [] = SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_reidemeister_ii_is_poly_mu :
  homfly_polynomial_computable_correct [1, -1] = SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_trefoil_neq_poly_mu :
  homfly_polynomial_computable_correct [1, 1, 1] ≠ SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_figure_eight_neq_poly_mu :
  homfly_polynomial_computable_correct [1, -2, 1, -2] ≠ SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_cinquefoil_neq_poly_mu :
  homfly_polynomial_computable_correct [1, 1, 1, 1, 1] ≠ SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_three_twist_neq_poly_mu :
  homfly_polynomial_computable_correct [1, 1, 1, -2, -2] ≠ SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_6_1_neq_poly_mu :
  homfly_polynomial_computable_correct [1, 1, -2, -2, -2, 1] ≠ SparsePoly2.normalize poly_mu := by
  native_decide

theorem homfly_7_1_neq_poly_mu :
  homfly_polynomial_computable_correct [1, 1, 1, 1, 1, 1, 1] ≠ SparsePoly2.normalize poly_mu := by
  native_decide