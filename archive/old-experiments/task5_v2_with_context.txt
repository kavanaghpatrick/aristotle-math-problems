Extend the Jones Polynomial Formalization to Four Additional Knots (6₁, 6₂, 6₃, 7₁)

CONTEXT - JONES V2 FORMALIZATION:
Below is the COMPLETE Lean 4 formalization from project 2e358cc4. You can use ALL definitions from this code.

```lean
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2e358cc4-caf3-4e75-846d-60da35fb9b1e
-/

/-
We have formalized the Jones polynomial computation for specific low-crossing knots (Trefoil, Figure-Eight, Cinquefoil, Three-Twist).
We defined the knot diagrams using a planar diagram code.
We implemented a computable Kauffman bracket function `kauffman_bracket_computable_v3` and the Jones polynomial `jones_polynomial_computable_v4`.
We verified the computed Jones polynomials against the known results for these knots using `native_decide`.
We proved computational complexity bounds:
1. Upper bound: For the specific knots (c ≤ 5), the number of recursive steps is bounded by c^3 (specifically, we proved bounds like ≤ 27 for c=3, ≤ 64 for c=4, ≤ 125 for c=5).
2. Lower bound: We proved generally that the complexity is at least the crossing number c (`complexity_lower_bound`).
3. Evaluation at roots of unity: We verified the values at the 5th root of unity and proved that the evaluation complexity (number of terms) is bounded by c^2 for the target knots.
This confirms the tractability of the Jones polynomial for these specific instances and provides verified bounds.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for LinkDiagram and Crossing.
-/
open Polynomial

/-- A crossing in a planar diagram.
    Represents a crossing with 4 incident strands labeled by natural numbers.
    The sign indicates whether it is a positive or negative crossing.
    (i, j, k, l) in counter-clockwise order.
    Sign +1: j goes over l.
-/
structure Crossing where
  id : Nat
  s1 : Nat
  s2 : Nat
  s3 : Nat
  s4 : Nat
  sign : Int -- +1 or -1
  deriving Repr, DecidableEq

/-- A link diagram is a list of crossings. -/
def LinkDiagram := List Crossing

/-
Definitions for diagram operations and SkeinTree.
-/
/-- Switch a crossing in the diagram. -/
def switch_crossing (D : LinkDiagram) (id : Nat) : LinkDiagram :=
  D.map fun c => if c.id == id then { c with sign := -c.sign } else c

/-- Smooth a crossing in the diagram.
    Smoothing replaces the crossing with two non-intersecting arcs.
    In PD code, a crossing (s1, s2, s3, s4) becomes two arcs (s1, s2) and (s3, s4) or (s1, s4) and (s2, s3) depending on orientation.
    For the purpose of the Jones polynomial, the A-smoothing and B-smoothing are used.
    However, the skein relation uses L0 which is the "oriented smoothing".
    If the crossing is positive (L+), L0 is the smoothing consistent with orientation.
    We will represent the smoothed diagram by removing the crossing and updating connectivity.
    Since we don't track strands fully, we will just mark the crossing as "smoothed" or remove it.
    But removing it changes the strand numbering.
    For this formalization, we will assume we can represent the smoothed diagram.
    To keep it simple, we will use a "Fuel" approach or just abstractly represent the recursive step.
    Actually, let's define the specific knots and their skein trees manually.
-/
def smooth_crossing (D : LinkDiagram) (id : Nat) : LinkDiagram :=
  D.filter fun c => c.id != id -- This is a simplification; real smoothing merges strands.

/-- Base cases: Unknot and Unlink. -/
def is_unknot (D : LinkDiagram) : Bool := D.isEmpty -- Simplified: empty diagram is unknot? No, 0 crossings is unknot.

def is_unlink (D : LinkDiagram) (n : Nat) : Bool := D.isEmpty && n > 1 -- Simplified.

/-- A Skein Tree represents the computation of the Jones polynomial. -/
inductive SkeinTree : LinkDiagram → Type
| base (D : LinkDiagram) : SkeinTree D
| step (D : LinkDiagram) (id : Nat)
       (t_switch : SkeinTree (switch_crossing D id))
       (t_smooth : SkeinTree (smooth_crossing D id)) : SkeinTree D

/-- The complexity of a Skein Tree is the number of nodes. -/
def tree_complexity {D : LinkDiagram} (t : SkeinTree D) : Nat :=
  match t with
  | .base _ => 1
  | .step _ _ t1 t2 => 1 + tree_complexity t1 + tree_complexity t2

/-
Helper functions for Union-Find on strands (renamed to StrandPartition).
-/
instance : Inhabited Crossing := ⟨{ id := 0, s1 := 0, s2 := 0, s3 := 0, s4 := 0, sign := 1 }⟩

/-- A partition of strand indices to track connectivity. -/
def StrandPartition := List (List Nat)

/-- Initialize partition with singletons for each strand. -/
def init_partition (n : Nat) : StrandPartition :=
  (List.range n).map (fun i => [i + 1])

/-- Find the set containing a strand. -/
def find_set (P : StrandPartition) (s : Nat) : Option (List Nat) :=
  P.find? (fun set => set.contains s)

/-- Merge two sets in the partition. -/
def merge_sets (P : StrandPartition) (s1 s2 : Nat) : StrandPartition :=
  let set1 := find_set P s1
  let set2 := find_set P s2
  match set1, set2 with
  | some c1, some c2 =>
    if c1 == c2 then P
    else
      let P' := P.filter (fun c => c != c1 && c != c2)
      (c1 ++ c2) :: P'
  | _, _ => P

/-- Count number of sets. -/
def num_components (P : StrandPartition) : Nat := P.length

/-- Get max strand index in diagram. -/
def max_strand (D : LinkDiagram) : Nat :=
  D.foldl (fun m c => Nat.max m (Nat.max c.s1 (Nat.max c.s2 (Nat.max c.s3 c.s4)))) 0

/-
Definition of Kauffman bracket.
-/
open Polynomial

/-- The variable A for the Kauffman bracket. -/
def A : LaurentPolynomial ℤ := LaurentPolynomial.T 1

/-- The inverse variable A^(-1). -/
def A_inv : LaurentPolynomial ℤ := LaurentPolynomial.T (-1)

/-- The value of the loop (unknot component) d = -A^2 - A^(-2). -/
def loop_value : LaurentPolynomial ℤ := - (A^2) - (A_inv^2)

/-- Update partition for A-smoothing: merge (s1, s2) and (s3, s4). -/
def update_partition_A (P : StrandPartition) (c : Crossing) : StrandPartition :=
  let P1 := merge_sets P c.s1 c.s2
  merge_sets P1 c.s3 c.s4

/-- Update partition for B-smoothing: merge (s1, s4) and (s2, s3). -/
def update_partition_B (P : StrandPartition) (c : Crossing) : StrandPartition :=
  let P1 := merge_sets P c.s1 c.s4
  merge_sets P1 c.s2 c.s3

/-- The Kauffman bracket of a link diagram.
    Computes <D> as a Laurent polynomial in A.
    Recurses on the list of crossings.
-/
def kauffman_bracket (D : LinkDiagram) (P : StrandPartition) : LaurentPolynomial ℤ :=
  match D with
  | [] => loop_value ^ (num_components P - 1)
  | c :: rest =>
    -- We apply the relation <D> = A <D_A> + A^(-1) <D_B>
    -- Note: The choice of which smoothing gets A depends on the crossing type in standard projection.
    -- However, for a PD code, we need a convention.
    -- We will assume the "A-smoothing" corresponds to `update_partition_A`
    -- and "B-smoothing" corresponds to `update_partition_B`.
    -- We might need to swap these based on the crossing sign if we were doing skein relations directly,
    -- but the Kauffman bracket is defined on the unoriented diagram.
    -- The standard convention is usually fixed relative to the "regions".
    -- We will try this and see if it matches the Trefoil.
    let termA := A * kauffman_bracket rest (update_partition_A P c)
    let termB := A_inv * kauffman_bracket rest (update_partition_B P c)
    termA + termB

/-
Definitions for Writhe and Jones Polynomial (in A).
-/
open Polynomial

/-- Calculate the writhe of a diagram (sum of signs). -/
def writhe (D : LinkDiagram) : ℤ :=
  D.foldl (fun w c => w + c.sign) 0

/-- The Jones polynomial V_L(t) computed in terms of A = t^(-1/4).
    V_L(t) = (-A^3)^(-w(L)) * <L>
    Result is a LaurentPolynomial in A.
-/
def jones_polynomial_in_A (D : LinkDiagram) : LaurentPolynomial ℤ :=
  let w := writhe D
  let bracket := kauffman_bracket D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  -- (-A^3)^(-w) = (-1)^w * A^(-3w)
  let factor := (LaurentPolynomial.C coeff) * (LaurentPolynomial.T (-3 * w))
  factor * bracket

/-
Definitions of target knot diagrams.
-/
/-- Trefoil knot (3_1).
    PD Code: [(1,4,2,5), (3,6,4,1), (5,2,6,3)]
    Signs: All +1 (Left-handed trefoil) or All -1 (Right-handed).
    Let's try all -1 for positive trefoil (t + t^3 - t^4).
    Wait, Jones polynomial of right-handed trefoil is t + t^3 - t^4.
    Left-handed is t^-1 + t^-3 - t^-4.
    Let's try signs = -1.
-/
def trefoil_diagram : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 4, s3 := 2, s4 := 5, sign := -1 },
  { id := 2, s1 := 3, s2 := 6, s3 := 4, s4 := 1, sign := -1 },
  { id := 3, s1 := 5, s2 := 2, s3 := 6, s4 := 3, sign := -1 }
]

/-- Figure-eight knot (4_1).
    PD Code: [(4,2,5,1), (8,6,1,5), (6,3,7,4), (2,7,3,8)]
    Signs: Alternating +1, -1, +1, -1.
    Figure-eight is amphicheiral, so signs matter less for chirality, but matter for alternating.
    Let's try signs: -1, +1, -1, +1.
-/
def figure_eight_diagram : LinkDiagram := [
  { id := 1, s1 := 4, s2 := 2, s3 := 5, s4 := 1, sign := -1 },
  { id := 2, s1 := 8, s2 := 6, s3 := 1, s4 := 5, sign := 1 },
  { id := 3, s1 := 6, s2 := 3, s3 := 7, s4 := 4, sign := -1 },
  { id := 4, s1 := 2, s2 := 7, s3 := 3, s4 := 8, sign := 1 }
]

/-- Cinquefoil knot (5_1).
    PD Code: [(1,6,2,7), (3,8,4,9), (5,10,6,1), (7,2,8,3), (9,4,10,5)]
    Wait, this is not a valid loop?
    Let's use a standard 5_1 code.
    Star polygon.
    [(1,5,2,6), (3,7,4,8), (5,9,6,10), (7,1,8,2), (9,3,10,4)]?
    Let's use the code:
    [(1,6,2,7), (3,8,4,9), (5,10,6,1), (7,2,8,3), (9,4,10,5)]
    Let's check connectivity.
    1-6, 6-1 (in crossing 3).
    This looks like 5 crossings.
    Signs: All -1 (like Trefoil).
-/
def cinquefoil_diagram : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 6, s3 := 2, s4 := 7, sign := -1 },
  { id := 2, s1 := 3, s2 := 8, s3 := 4, s4 := 9, sign := -1 },
  { id := 3, s1 := 5, s2 := 10, s3 := 6, s4 := 1, sign := -1 },
  { id := 4, s1 := 7, s2 := 2, s3 := 8, s4 := 3, sign := -1 },
  { id := 5, s1 := 9, s2 := 4, s3 := 10, s4 := 5, sign := -1 }
]

/-- Three-twist knot (5_2).
    PD Code: [(1,4,2,5), (3,8,4,9), (5,10,6,1), (7,2,8,3), (9,6,10,7)]
    Signs: Alternating?
    5_2 is alternating.
    Let's try signs: -1, -1, -1, -1, -1? No, 5_2 is not a torus knot.
    Signs should be alternating in the sequence?
    Let's try to guess signs or use a standard property.
    Actually, I will define it with placeholders and we can adjust.
    Let's try signs: -1, 1, -1, 1, -1?
    Or maybe it's a twist knot.
    Let's try: -1, -1, -1, 1, 1?
    I'll start with all -1 and see what happens (unlikely correct).
    Actually, for 5_2, it has writhe different from 5_1.
    Let's try signs: -1, -1, -1, -1, -1.
    Wait, 5_2 is twist knot.
    Let's try: 1, 1, 1, -1, -1?
    I will define it with all -1 for now, and we can correct it if the verification fails.
-/
def three_twist_diagram : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 4, s3 := 2, s4 := 5, sign := -1 },
  { id := 2, s1 := 3, s2 := 8, s3 := 4, s4 := 9, sign := -1 },
  { id := 3, s1 := 5, s2 := 10, s3 := 6, s4 := 1, sign := -1 },
  { id := 4, s1 := 7, s2 := 2, s3 := 8, s4 := 3, sign := -1 },
  { id := 5, s1 := 9, s2 := 6, s3 := 10, s4 := 7, sign := -1 }
]

/-
Complexity bounds for Kauffman bracket.
-/
/-- The complexity of computing the Kauffman bracket (number of recursive steps).
    We count 1 for the current step + complexity of children.
    Base case: 1 (leaf).
-/
def bracket_complexity (D : LinkDiagram) : Nat :=
  match D with
  | [] => 1
  | _ :: rest => 1 + bracket_complexity rest + bracket_complexity rest

/-- Theorem: Complexity for Trefoil (c=3) is at most 3^3 = 27.
    Actual complexity: 1 + 2*(1 + 2*(1 + 2*1)) = 1 + 2*(1 + 6) = 15?
    Let's trace:
    len=0: 1
    len=1: 1 + 1 + 1 = 3
    len=2: 1 + 3 + 3 = 7
    len=3: 1 + 7 + 7 = 15
    len=c: 2^(c+1) - 1.
    For c=3, 15 <= 27.
-/
theorem trefoil_complexity_bound : bracket_complexity trefoil_diagram ≤ 27 := by
  native_decide

/-- Theorem: Complexity for Figure-Eight (c=4) is at most 4^3 = 64.
    For c=4, 2^5 - 1 = 31 <= 64.
-/
theorem figure_eight_complexity_bound : bracket_complexity figure_eight_diagram ≤ 64 := by
  native_decide

/-- Theorem: Complexity for Cinquefoil (c=5) is at most 5^3 = 125.
    For c=5, 2^6 - 1 = 63 <= 125.
-/
theorem cinquefoil_complexity_bound : bracket_complexity cinquefoil_diagram ≤ 125 := by
  native_decide

/-- Theorem: Complexity for Three-Twist (c=5) is at most 5^3 = 125. -/
theorem three_twist_complexity_bound : bracket_complexity three_twist_diagram ≤ 125 := by
  native_decide

/-- Lower bound: Complexity is at least c.
    2^(c+1) - 1 >= c.
    This is true for all c >= 0.
-/
theorem complexity_lower_bound (D : LinkDiagram) : bracket_complexity D ≥ D.length := by
  induction D with
  | nil => simp [bracket_complexity]
  | cons _ rest ih =>
    simp [bracket_complexity]
    -- 1 + 2 * complexity rest >= 1 + 2 * rest.length >= 1 + rest.length = length
    have h1 : bracket_complexity rest ≥ rest.length := ih
    linarith

/-
Corrected definitions and check_jones.
-/
open Polynomial

/-- Corrected Kauffman bracket with swapped smoothings to match standard conventions. -/
def kauffman_bracket' (D : LinkDiagram) (P : StrandPartition) : LaurentPolynomial ℤ :=
  match D with
  | [] => loop_value ^ (num_components P - 1)
  | c :: rest =>
    -- Swapped: A-term uses update_partition_B (s1-s4, s2-s3)
    -- B-term uses update_partition_A (s1-s2, s3-s4)
    -- This is based on the R1 check.
    let termA := A * kauffman_bracket' rest (update_partition_B P c)
    let termB := A_inv * kauffman_bracket' rest (update_partition_A P c)
    termA + termB

/-- Corrected Jones polynomial using kauffman_bracket'. -/
def jones_polynomial_in_A' (D : LinkDiagram) : LaurentPolynomial ℤ :=
  let w := writhe D
  let bracket := kauffman_bracket' D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  let factor := (LaurentPolynomial.C coeff) * (LaurentPolynomial.T (-3 * w))
  factor * bracket

/-- Check if the Jones polynomial matches a given polynomial in t.
    P_t is given as a LaurentPolynomial ℤ.
    We convert P_t to P_A by substituting t = A^(-4).
    Then we compare with jones_polynomial_in_A'.
-/
def check_jones (D : LinkDiagram) (P_t : LaurentPolynomial ℤ) : Bool :=
  let P_A_target := P_t.sum (fun n c => (LaurentPolynomial.C c) * (LaurentPolynomial.T (-4 * n)))
  let P_A_computed := jones_polynomial_in_A' D
  P_A_target == P_A_computed

/-
Definitions of target Jones polynomials.
-/
open Polynomial

/-- Target polynomial for Trefoil (3_1): t + t^3 - t^4. -/
def p3_1 : LaurentPolynomial ℤ :=
  (LaurentPolynomial.T 1) + (LaurentPolynomial.T 3) - (LaurentPolynomial.T 4)

/-- Target polynomial for Figure-Eight (4_1): -t^(-2) + 1 - t^2 + t^4 - t^6. -/
def p4_1 : LaurentPolynomial ℤ :=
  -(LaurentPolynomial.T (-2)) + 1 - (LaurentPolynomial.T 2) + (LaurentPolynomial.T 4) - (LaurentPolynomial.T 6)

/-- Target polynomial for Cinquefoil (5_1): t^2 + t^6 - t^8 + t^10 - t^12. -/
def p5_1 : LaurentPolynomial ℤ :=
  (LaurentPolynomial.T 2) + (LaurentPolynomial.T 6) - (LaurentPolynomial.T 8) + (LaurentPolynomial.T 10) - (LaurentPolynomial.T 12)

/-- Target polynomial for Three-Twist (5_2): t^(-2) - t^(-1) + 1 - t + 2*t^2 - t^3 + t^4 - t^5 + t^6. -/
def p5_2 : LaurentPolynomial ℤ :=
  (LaurentPolynomial.T (-2)) - (LaurentPolynomial.T (-1)) + 1 - (LaurentPolynomial.T 1) + 2 * (LaurentPolynomial.T 2) - (LaurentPolynomial.T 3) + (LaurentPolynomial.T 4) - (LaurentPolynomial.T 5) + (LaurentPolynomial.T 6)

/-
Computable definitions for verification (fixed).
-/
/-- A computable representation of Laurent polynomials as a list of (exponent, coefficient) pairs. -/
abbrev SparsePoly := List (Int × Int)

/-- Insertion sort for SparsePoly based on exponent. -/
def SparsePoly.insertionSort (l : SparsePoly) : SparsePoly :=
  let rec insert (x : Int × Int) (sorted : SparsePoly) : SparsePoly :=
    match sorted with
    | [] => [x]
    | y :: ys => if x.1 ≤ y.1 then x :: y :: ys else y :: insert x ys
  l.foldr insert []

/-- Merge duplicates in a sorted SparsePoly. -/
def SparsePoly.merge_duplicates (p : SparsePoly) : SparsePoly :=
  match p with
  | [] => []
  | [x] => if x.2 == 0 then [] else [x]
  | x :: y :: rest =>
    if x.1 == y.1 then
      SparsePoly.merge_duplicates ((x.1, x.2 + y.2) :: rest)
    else
      let merged_rest := SparsePoly.merge_duplicates (y :: rest)
      if x.2 == 0 then merged_rest else x :: merged_rest
  termination_by p.length

/-- Normalize a SparsePoly: sort, merge duplicates, remove zeros. -/
def SparsePoly.normalize (p : SparsePoly) : SparsePoly :=
  SparsePoly.merge_duplicates (SparsePoly.insertionSort p)

/-- Addition of SparsePoly. -/
def SparsePoly.add (p1 p2 : SparsePoly) : SparsePoly :=
  SparsePoly.normalize (List.append p1 p2)

/-- Negation of SparsePoly. -/
def SparsePoly.neg (p : SparsePoly) : SparsePoly :=
  p.map (fun (e, c) => (e, -c))

/-- Subtraction. -/
def SparsePoly.sub (p1 p2 : SparsePoly) : SparsePoly :=
  SparsePoly.add p1 (SparsePoly.neg p2)

/-- Multiplication by scalar. -/
def SparsePoly.smul (n : Int) (p : SparsePoly) : SparsePoly :=
  if n == 0 then []
  else p.map (fun (e, c) => (e, n * c))

/-- Multiplication by T^k. -/
def SparsePoly.mul_T (k : Int) (p : SparsePoly) : SparsePoly :=
  p.map (fun (e, c) => (e + k, c))

/-- Multiplication of SparsePoly. -/
def SparsePoly.mul (p1 p2 : SparsePoly) : SparsePoly :=
  let terms := p1.map (fun (e1, c1) => SparsePoly.smul c1 (SparsePoly.mul_T e1 p2))
  terms.foldl SparsePoly.add []

/-- The variable A. -/
def A_poly : SparsePoly := [(1, 1)]

/-- The inverse A^(-1). -/
def A_inv_poly : SparsePoly := [(-1, 1)]

/-- The loop value -A^2 - A^(-2). -/
def loop_value_poly : SparsePoly :=
  SparsePoly.sub (SparsePoly.neg (SparsePoly.mul_T 2 [(0, 1)])) (SparsePoly.mul_T (-2) [(0, 1)])

/-- Power of a SparsePoly. -/
def SparsePoly.pow (p : SparsePoly) (n : Nat) : SparsePoly :=
  match n with
  | 0 => [(0, 1)]
  | k + 1 => SparsePoly.mul p (SparsePoly.pow p k)

/-- Kauffman bracket using SparsePoly. -/
def kauffman_bracket_computable (D : LinkDiagram) (P : StrandPartition) : SparsePoly :=
  match D with
  | [] => SparsePoly.pow loop_value_poly (num_components P - 1)
  | c :: rest =>
    -- Swapped smoothings as per previous correction
    let termA := SparsePoly.mul A_poly (kauffman_bracket_computable rest (update_partition_B P c))
    let termB := SparsePoly.mul A_inv_poly (kauffman_bracket_computable rest (update_partition_A P c))
    SparsePoly.add termA termB

/-- Jones polynomial in A using SparsePoly. -/
def jones_polynomial_computable (D : LinkDiagram) : SparsePoly :=
  let w := writhe D
  let bracket := kauffman_bracket_computable D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  let factor : SparsePoly := [(-3 * w, coeff)]
  SparsePoly.mul factor bracket

/-- Target polynomials as SparsePoly. -/
def p3_1_poly : SparsePoly :=
  SparsePoly.normalize [(-4, 1), (-12, 1), (-16, -1)]

def p4_1_poly : SparsePoly :=
  SparsePoly.normalize [(8, -1), (0, 1), (-8, -1), (-16, 1), (-24, -1)]

def p5_1_poly : SparsePoly :=
  SparsePoly.normalize [(-8, 1), (-24, 1), (-32, -1), (-40, 1), (-48, -1)]

def p5_2_poly : SparsePoly :=
  SparsePoly.normalize [(8, 1), (4, -1), (0, 1), (-4, -1), (-8, 2), (-12, -1), (-16, 1), (-20, -1), (-24, 1)]

/-
Debug evaluation.
-/
#eval jones_polynomial_computable trefoil_diagram
#eval p3_1_poly

/-
Debug evaluation with corrected diagrams.
-/
/-- Trefoil knot (3_1) with positive crossings. -/
def trefoil_diagram_pos : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 4, s3 := 2, s4 := 5, sign := 1 },
  { id := 2, s1 := 3, s2 := 6, s3 := 4, s4 := 1, sign := 1 },
  { id := 3, s1 := 5, s2 := 2, s3 := 6, s4 := 3, sign := 1 }
]

/-- Cinquefoil knot (5_1) with positive crossings. -/
def cinquefoil_diagram_pos : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 6, s3 := 2, s4 := 7, sign := 1 },
  { id := 2, s1 := 3, s2 := 8, s3 := 4, s4 := 9, sign := 1 },
  { id := 3, s1 := 5, s2 := 10, s3 := 6, s4 := 1, sign := 1 },
  { id := 4, s1 := 7, s2 := 2, s3 := 8, s4 := 3, sign := 1 },
  { id := 5, s1 := 9, s2 := 4, s3 := 10, s4 := 5, sign := 1 }
]

/-- Three-twist knot (5_2).
    Let's try a specific crossing pattern.
    5_2 is the closure of braid sigma_1^5 sigma_2^-1? No.
    It's a rational knot.
    Let's try to use the PD code from a reliable source or just guess signs.
    If I use the same structure as 5_1 but change signs?
    No, 5_2 has a different graph structure (not a torus knot).
    My previous 5_2 diagram was just a copy of 5_1 structure?
    Let's check `three_twist_diagram` definition.
    It was:
    [(1,4,2,5), (3,8,4,9), (5,10,6,1), (7,2,8,3), (9,6,10,7)]
    Let's check connectivity.
    1-4, 4-9, 9-6, 6-1. Loop 1-4-9-6-1.
    This looks different from 5_1.
    Let's evaluate the Jones polynomial for this diagram with various sign combinations.
    I'll define a few variants.
-/
def three_twist_diagram_v1 : LinkDiagram := [
  { id := 1, s1 := 1, s2 := 4, s3 := 2, s4 := 5, sign := 1 },
  { id := 2, s1 := 3, s2 := 8, s3 := 4, s4 := 9, sign := 1 },
  { id := 3, s1 := 5, s2 := 10, s3 := 6, s4 := 1, sign := 1 },
  { id := 4, s1 := 7, s2 := 2, s3 := 8, s4 := 3, sign := -1 },
  { id := 5, s1 := 9, s2 := 6, s3 := 10, s4 := 7, sign := -1 }
]

#eval jones_polynomial_computable trefoil_diagram_pos
#eval jones_polynomial_computable figure_eight_diagram
#eval jones_polynomial_computable cinquefoil_diagram_pos
#eval jones_polynomial_computable three_twist_diagram_v1

/-
Verification of all target knots.
-/
/-- Correct target polynomial for Trefoil (3_1).
    Matches standard result: t + t^3 - t^4.
-/
def p3_1_correct : SparsePoly :=
  SparsePoly.normalize [(-16, -1), (-12, 1), (-4, 1)]

/-- Correct target polynomial for Figure-Eight (4_1).
    Matches standard result: t^-2 - t^-1 + 1 - t + t^2.
-/
def p4_1_correct : SparsePoly :=
  SparsePoly.normalize [(-8, 1), (-4, -1), (0, 1), (4, -1), (8, 1)]

/-- Correct target polynomial for Cinquefoil (5_1).
    Matches standard result: t^2 + t^4 - t^5 + t^6 - t^7.
-/
def p5_1_correct : SparsePoly :=
  SparsePoly.normalize [(-28, -1), (-24, 1), (-20, -1), (-16, 1), (-8, 1)]

/-- Correct target polynomial for Three-Twist (5_2).
    Matches standard result: t^-2 - t^-1 + 2 - t + t^2 - t^3.
-/
def p5_2_correct : SparsePoly :=
  SparsePoly.normalize [(-12, -1), (-8, 1), (-4, -1), (0, 2), (4, -1), (8, 1)]

/-- Verification for Trefoil (3_1). -/
theorem trefoil_verification_correct : jones_polynomial_computable trefoil_diagram_pos = p3_1_correct := by
  native_decide

/-- Verification for Figure-Eight (4_1). -/
theorem figure_eight_verification_correct : jones_polynomial_computable figure_eight_diagram = p4_1_correct := by
  native_decide

/-- Verification for Cinquefoil (5_1). -/
theorem cinquefoil_verification_correct : jones_polynomial_computable cinquefoil_diagram_pos = p5_1_correct := by
  native_decide

/-- Verification for Three-Twist (5_2). -/
theorem three_twist_verification_correct : jones_polynomial_computable three_twist_diagram_v1 = p5_2_correct := by
  native_decide

/-
Evaluation at roots of unity.
-/
/-- Reduce a SparsePoly modulo T^n - 1.
    This corresponds to setting T^n = 1.
    Exponents e become e % n.
-/
def SparsePoly.reduce_mod_T_n (p : SparsePoly) (n : Int) : SparsePoly :=
  if n <= 0 then p else
  let reduced := p.map (fun (e, c) => (e % n, c))
  SparsePoly.normalize reduced

/-- Evaluation of Jones polynomial at 5th root of unity (T^5 = 1).
    Note: The variable in our SparsePoly is A.
    The user asks for t = e^(2πi/5).
    We have t = A^(-4).
    So A^(-4) = e^(2πi/5).
    A^(-20) = 1.
    So we should reduce modulo A^20 - 1?
    Or does the user mean t is a root of unity, so we work in Z[t]/(t^5-1)?
    If t^5 = 1, then A^(-20) = 1.
    So we reduce exponents of A modulo 20.
-/
def jones_at_root_5 (D : LinkDiagram) : SparsePoly :=
  let p := jones_polynomial_computable D
  SparsePoly.reduce_mod_T_n p 20

/-- Verify evaluation for Trefoil. -/
theorem trefoil_root_5 : jones_at_root_5 trefoil_diagram_pos = SparsePoly.reduce_mod_T_n p3_1_correct 20 := by
  native_decide

/-- Verify evaluation for Figure-Eight. -/
theorem figure_eight_root_5 : jones_at_root_5 figure_eight_diagram = SparsePoly.reduce_mod_T_n p4_1_correct 20 := by
  native_decide

/-- Verify evaluation for Cinquefoil. -/
theorem cinquefoil_root_5 : jones_at_root_5 cinquefoil_diagram_pos = SparsePoly.reduce_mod_T_n p5_1_correct 20 := by
  native_decide

/-- Verify evaluation for Three-Twist. -/
theorem three_twist_root_5 : jones_at_root_5 three_twist_diagram_v1 = SparsePoly.reduce_mod_T_n p5_2_correct 20 := by
  native_decide

/-
Definitions for v2 computation.
-/
/-- Kauffman bracket using SparsePoly, respecting crossing signs. -/
def kauffman_bracket_computable_v2 (D : LinkDiagram) (P : StrandPartition) : SparsePoly :=
  match D with
  | [] => SparsePoly.pow loop_value_poly (num_components P - 1)
  | c :: rest =>
    let termA := kauffman_bracket_computable_v2 rest (update_partition_A P c)
    let termB := kauffman_bracket_computable_v2 rest (update_partition_B P c)
    if c.sign == 1 then
      -- Positive crossing: A * <A-smooth> + A^-1 * <B-smooth>
      SparsePoly.add (SparsePoly.mul A_poly termA) (SparsePoly.mul A_inv_poly termB)
    else
      -- Negative crossing: A^-1 * <A-smooth> + A * <B-smooth>
      SparsePoly.add (SparsePoly.mul A_inv_poly termA) (SparsePoly.mul A_poly termB)

/-- Jones polynomial in A using SparsePoly (v2). -/
def jones_polynomial_computable_v2 (D : LinkDiagram) : SparsePoly :=
  let w := writhe D
  let bracket := kauffman_bracket_computable_v2 D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  let factor : SparsePoly := [(-3 * w, coeff)]
  SparsePoly.mul factor bracket

/-
Debug difference.
-/
#eval SparsePoly.sub (jones_polynomial_computable_v2 trefoil_diagram_pos) p3_1_correct
#eval SparsePoly.sub (jones_polynomial_computable_v2 figure_eight_diagram) p4_1_correct

/-
Debug writhe and bracket.
-/
/-- Debug function to return writhe and raw bracket. -/
def debug_jones (D : LinkDiagram) : Int × SparsePoly :=
  (writhe D, kauffman_bracket_computable_v2 D (init_partition (max_strand D)))

#eval debug_jones trefoil_diagram_pos

/-
Corrected normalization and target polynomials.
-/
/-- Jones polynomial in A using SparsePoly (v3 - corrected normalization).
    Normalization factor: (-A^3)^w = (-1)^w * A^(3w).
-/
def jones_polynomial_computable_v3 (D : LinkDiagram) : SparsePoly :=
  let w := writhe D
  let bracket := kauffman_bracket_computable_v2 D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  let factor : SparsePoly := [(3 * w, coeff)]
  SparsePoly.mul factor bracket

/-- Target polynomial for Trefoil (3_1) from problem statement: t + t^3 - t^4. -/
def p3_1_target : SparsePoly :=
  SparsePoly.normalize [(-4, 1), (-12, 1), (-16, -1)]

/-- Target polynomial for Figure-Eight (4_1) from problem statement: -t^(-2) + 1 - t^2 + t^4 - t^6. -/
def p4_1_target : SparsePoly :=
  SparsePoly.normalize [(8, -1), (0, 1), (-8, -1), (-16, 1), (-24, -1)]

/-- Target polynomial for Cinquefoil (5_1) from problem statement: t^2 + t^6 - t^8 + t^10 - t^12. -/
def p5_1_target : SparsePoly :=
  SparsePoly.normalize [(-8, 1), (-24, 1), (-32, -1), (-40, 1), (-48, -1)]

/-- Target polynomial for Three-Twist (5_2) from problem statement:
    t^(-2) - t^(-1) + 1 - t + 2*t^2 - t^3 + t^4 - t^5 + t^6.
-/
def p5_2_target : SparsePoly :=
  SparsePoly.normalize [(8, 1), (4, -1), (0, 1), (-4, -1), (-8, 2), (-12, -1), (-16, 1), (-20, -1), (-24, 1)]

#eval jones_polynomial_computable_v3 trefoil_diagram == p3_1_target
#eval jones_polynomial_computable_v3 figure_eight_diagram == p4_1_target
#eval jones_polynomial_computable_v3 cinquefoil_diagram == p5_1_target
#eval jones_polynomial_computable_v3 three_twist_diagram == p5_2_target

/-
Debug v2 values.
-/
/-- Debug function for v2. -/
def debug_jones_v2 (D : LinkDiagram) : Int × SparsePoly × SparsePoly :=
  let w := writhe D
  let bracket := kauffman_bracket_computable_v2 D (init_partition (max_strand D))
  let jones := jones_polynomial_computable_v2 D
  (w, bracket, jones)

#eval debug_jones_v2 trefoil_diagram_pos
#eval p3_1_correct

/-
Debug v3 values.
-/
#eval jones_polynomial_computable_v3 trefoil_diagram
#eval p3_1_target
#eval jones_polynomial_computable_v3 figure_eight_diagram
#eval p4_1_target

/-
Debug values.
-/
#eval jones_polynomial_computable_v3 figure_eight_diagram
#eval p4_1_target
#eval jones_polynomial_computable_v3 cinquefoil_diagram
#eval p5_1_target
#eval jones_polynomial_computable_v3 three_twist_diagram
#eval p5_2_target

/-
Brute force search for correct signs.
-/
/-- Helper to generate all sign combinations for a diagram. -/
def all_sign_combinations (D : LinkDiagram) : List LinkDiagram :=
  match D with
  | [] => [[]]
  | c :: rest =>
    let rest_combs := all_sign_combinations rest
    let c_pos := { c with sign := 1 }
    let c_neg := { c with sign := -1 }
    (rest_combs.map (fun D' => c_pos :: D')) ++ (rest_combs.map (fun D' => c_neg :: D'))

/-- Find a diagram configuration that matches the target polynomial. -/
def find_matching_diagram (D : LinkDiagram) (target : SparsePoly) : Option LinkDiagram :=
  let combs := all_sign_combinations D
  combs.find? (fun D' => jones_polynomial_computable_v3 D' == target)

/-- Search for Figure Eight configuration. -/
def figure_eight_solution : Option LinkDiagram :=
  find_matching_diagram figure_eight_diagram p4_1_target

/-- Search for Cinquefoil configuration (using the diagram structure we have). -/
def cinquefoil_solution : Option LinkDiagram :=
  find_matching_diagram cinquefoil_diagram p5_1_target

/-- Search for Three-Twist configuration. -/
def three_twist_solution : Option LinkDiagram :=
  find_matching_diagram three_twist_diagram p5_2_target

#eval figure_eight_solution.isSome
#eval cinquefoil_solution.isSome
#eval three_twist_solution.isSome

/-
Final diagram definitions.
-/
/-- Correct Trefoil diagram (3_1). -/
def trefoil_final : LinkDiagram := trefoil_diagram_pos

/-- Correct Figure Eight diagram (4_1). -/
def figure_eight_final : LinkDiagram := figure_eight_diagram

/-- Correct Cinquefoil diagram (5_1).
    We use the diagram that produced the correct polynomial.
    This was previously named `three_twist_diagram`.
-/
def cinquefoil_final : LinkDiagram := three_twist_diagram

/-- Correct Three-Twist diagram (5_2).
    We use the diagram that produced the correct polynomial.
    This was previously named `three_twist_diagram_v1`.
-/
def three_twist_final : LinkDiagram := three_twist_diagram_v1

/-
Corrected computation v4.
-/
/-- Kauffman bracket v3: Corrected smoothing assignment.
    A-smoothing (coeff A) should use update_partition_B (s2-s3, s4-s1).
    B-smoothing (coeff A^-1) should use update_partition_A (s1-s2, s3-s4).
-/
def kauffman_bracket_computable_v3 (D : LinkDiagram) (P : StrandPartition) : SparsePoly :=
  match D with
  | [] => SparsePoly.pow loop_value_poly (num_components P - 1)
  | c :: rest =>
    -- Corrected: termA uses B-partition, termB uses A-partition
    let termA := kauffman_bracket_computable_v3 rest (update_partition_B P c)
    let termB := kauffman_bracket_computable_v3 rest (update_partition_A P c)
    if c.sign == 1 then
      -- Positive crossing: A * <A-smooth> + A^-1 * <B-smooth>
      SparsePoly.add (SparsePoly.mul A_poly termA) (SparsePoly.mul A_inv_poly termB)
    else
      -- Negative crossing: A^-1 * <A-smooth> + A * <B-smooth>
      SparsePoly.add (SparsePoly.mul A_inv_poly termA) (SparsePoly.mul A_poly termB)

/-- Jones polynomial v4: Corrected normalization (-3w). -/
def jones_polynomial_computable_v4 (D : LinkDiagram) : SparsePoly :=
  let w := writhe D
  let bracket := kauffman_bracket_computable_v3 D (init_partition (max_strand D))
  let coeff := if w % 2 == 0 then 1 else -1
  -- (-A^3)^(-w) = (-1)^w * A^(-3w)
  let factor : SparsePoly := [(-3 * w, coeff)]
  SparsePoly.mul factor bracket

#eval jones_polynomial_computable_v4 trefoil_final == p3_1_target
#eval jones_polynomial_computable_v4 figure_eight_final == p4_1_target
#eval jones_polynomial_computable_v4 cinquefoil_final == p5_1_target
#eval jones_polynomial_computable_v4 three_twist_final == p5_2_target

/-
Debug root of unity evaluation.
-/
/-- Evaluation of Jones polynomial v4 at 5th root of unity (T^5 = 1 => A^20 = 1). -/
def jones_at_root_5_v4 (D : LinkDiagram) : SparsePoly :=
  let p := jones_polynomial_computable_v4 D
  SparsePoly.reduce_mod_T_n p 20

/-- Complexity of evaluating a SparsePoly (number of terms). -/
def eval_complexity (p : SparsePoly) : Nat := p.length

#eval jones_at_root_5_v4 figure_eight_final
#eval SparsePoly.reduce_mod_T_n p4_1_target 20

/-
Evaluation complexity bounds (v2).
-/
/-- Complexity of evaluating a SparsePoly (number of terms). -/
def eval_complexity_v2 (p : SparsePoly) : Nat := p.length

/-- Theorem: Evaluation complexity for Trefoil is small (<= 9). -/
theorem trefoil_eval_complexity_v2 : eval_complexity_v2 (jones_polynomial_computable_v4 trefoil_final) ≤ 9 := by
  native_decide

/-- Theorem: Evaluation complexity for Figure-Eight is small (<= 16). -/
theorem figure_eight_eval_complexity_v2 : eval_complexity_v2 (jones_polynomial_computable_v4 figure_eight_final) ≤ 16 := by
  native_decide

/-- Theorem: Evaluation complexity for Cinquefoil is small (<= 25). -/
theorem cinquefoil_eval_complexity_v2 : eval_complexity_v2 (jones_polynomial_computable_v4 cinquefoil_final) ≤ 25 := by
  native_decide

/-- Theorem: Evaluation complexity for Three-Twist is small (<= 25). -/
theorem three_twist_eval_complexity_v2 : eval_complexity_v2 (jones_polynomial_computable_v4 three_twist_final) ≤ 25 := by
  native_decide
```

TASK - VERIFY 4 NEW KNOTS:

Use the definitions above (Crossing, LinkDiagram, kauffman_bracket_computable_v4, jones_polynomial_computable_v4, SparsePoly, etc.) to verify 4 additional knots:

**Knot 6₁ (Stevedore's knot)**:
- PD Code: X1,4,2,5 X7,10,8,11 X3,9,4,8 X9,3,10,2 X5,12,6,1 X11,6,12,7
- Jones polynomial V(q): q² - q + 2 - 2q⁻¹ + q⁻² - q⁻³ + q⁻⁴
- In t (where q=t⁻¹): t⁻⁴ - t⁻³ + t⁻² - 2t⁻¹ + 2 - t + t²
- In A (where t=A⁻⁴): Convert to SparsePoly format

**Knot 6₂ (Miller Institute knot)**:
- PD Code: X1,4,2,5 X5,10,6,11 X3,9,4,8 X9,3,10,2 X7,12,8,1 X11,6,12,7
- Jones polynomial V(q): q - 1 + 2q⁻¹ - 2q⁻² + 2q⁻³ - 2q⁻⁴ + q⁻⁵
- In t: t⁻⁵ - 2t⁻⁴ + 2t⁻³ - 2t⁻² + 2t⁻¹ - 1 + t

**Knot 6₃ (Eskimo Bowline)**:
- PD Code: X4,2,5,1 X8,4,9,3 X12,9,1,10 X10,5,11,6 X6,11,7,12 X2,8,3,7
- Jones polynomial V(q): −q³ + 2q² − 2q + 3 − 2q⁻¹ + 2q⁻² − q⁻³
- In t: −t⁻³ + 2t⁻² − 2t⁻¹ + 3 − 2t + 2t² − t³

**Knot 7₁ (Septafoil - (7,2)-torus knot)**:
- PD Code: X1,8,2,9 X3,10,4,11 X5,12,6,13 X7,14,8,1 X9,2,10,3 X11,4,12,5 X13,6,14,7
- Jones polynomial V(q): −q⁻¹⁰ + q⁻⁹ − q⁻⁸ + q⁻⁷ − q⁻⁶ + q⁻⁵ + q⁻³
- In t: −t¹⁰ + t⁹ − t⁸ + t⁷ − t⁶ + t⁵ + t³
- Note: (7,2)-torus knot like trefoil (3,2) and cinquefoil (5,2) - use same sign pattern

REQUIREMENTS:
1. Define knot diagrams using LinkDiagram structure from above
2. Define target polynomials as SparsePoly (in A variable, using t=A⁻⁴)
3. Prove verification theorems using native_decide
4. Prove complexity bounds: ≤ 216 for 6-crossing, ≤ 343 for 7-crossing

Follow the EXACT pattern from trefoil_final, figure_eight_final, cinquefoil_final, three_twist_final in the code above.
