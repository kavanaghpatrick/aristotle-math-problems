/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 99a0fbd4-de8a-417d-b085-ff075925127b

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of adjacency eigenvalues, second largest eigenvalue, spectral gap, 3-regularity, and diameter 5.
-/
open SimpleGraph

variable {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V)

lemma adjacencyMatrix_isHermitian : (G.adjMatrix ℝ).IsHermitian := by
  -- The adjacency matrix of a simple graph is symmetric, hence Hermitian.
  simp [Matrix.IsHermitian]

noncomputable def adjacencyEigenvalues : Multiset ℝ :=
  let hA := adjacencyMatrix_isHermitian G
  let evs := hA.eigenvalues
  Multiset.map evs Finset.univ.val

noncomputable def secondLargestEigenvalue : ℝ :=
  let evs := (adjacencyEigenvalues G).sort (· ≥ ·)
  if h : evs.length ≥ 2 then
    evs.get ⟨1, h⟩
  else
    0

noncomputable def spectralGap (d : ℕ) : ℝ :=
  d - secondLargestEigenvalue G

def IsThreeRegular : Prop := G.IsRegularOfDegree 3

def HasDiameterFive : Prop := G.diam = 5

/-
Definition of Generalized Petersen Graph and helper functions to compute diameter and spectral gap.
-/
open SimpleGraph

/-- The Generalized Petersen Graph GP(n, k) with vertices (0, i) and (1, i) for i in Z_n. -/
def GeneralizedPetersenGraph (n k : ℕ) : SimpleGraph (Fin 2 × Fin n) :=
  SimpleGraph.fromRel (fun u v =>
    match u, v with
    | (0, i), (0, j) => (j.val = (i.val + 1) % n) ∨ (i.val = (j.val + 1) % n) -- Outer cycle
    | (1, i), (1, j) => (j.val = (i.val + k) % n) ∨ (i.val = (j.val + k) % n) -- Inner edges
    | (0, i), (1, j) => i = j -- Spokes
    | (1, i), (0, j) => i = j -- Spokes
    | _, _ => false
  )

/-- Check if a graph is 3-regular. -/
def checkThreeRegular (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] : Bool :=
  let degrees := (Finset.univ : Finset V).image (fun v => G.degree v)
  degrees.card == 1 && degrees.min == some 3

/-- Compute the diameter of a graph. -/
def computeDiameter (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] : ℕ :=
  G.diam

/-- Compute the second largest eigenvalue of the adjacency matrix. -/
noncomputable def computeSecondEigenvalue (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] : ℝ :=
  let A := G.adjMatrix ℝ
  let hA : A.IsHermitian := by
    -- Since the adjacency matrix of a simple graph is symmetric, it is Hermitian.
    simp [A, Matrix.IsHermitian]
  let evs_func := hA.eigenvalues
  let evs_multiset := (Finset.univ.val.map evs_func)
  let evs := evs_multiset.sort (· ≥ ·)
  if h : evs.length ≥ 2 then
    evs.get ⟨1, h⟩
  else
    0

noncomputable def computeSpectralGap (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] : ℝ :=
  3 - computeSecondEigenvalue G

/-
Define Desargues graph and state that it is 3-regular.
-/
open SimpleGraph

/-- The Desargues Graph GP(10, 3). -/
def DesarguesGraph : SimpleGraph (Fin 2 × Fin 10) := GeneralizedPetersenGraph 10 3

/-- The Desargues graph is 3-regular. -/
theorem desargues_is_3_regular : DesarguesGraph.IsRegularOfDegree 3 := by
  -- We can check this by computation since the graph is small.
  -- However, `native_decide` might struggle with the definition of `IsRegularOfDegree`.
  -- Let's try to use the helper function `checkThreeRegular` if it works, or just prove it directly.
  rw [IsRegularOfDegree]
  intro v
  -- The degree of every vertex in GP(n, k) is 3.
  -- Vertices are (0, i) and (1, i).
  -- (0, i) is connected to (0, i+1), (0, i-1), (1, i). Degree 3.
  -- (1, i) is connected to (1, i+k), (1, i-k), (0, i). Degree 3.
  -- This holds for any n, k.
  -- By definition of Desargues graph, each vertex has degree 3.
  have h_deg : ∀ v : Fin 2 × Fin 10, (DesarguesGraph.degree v) = 3 := by
    simp +decide [ SimpleGraph.degree, SimpleGraph.neighborFinset ];
    simp +decide [ Finset.card, DesarguesGraph ];
    simp +decide [ Finset.univ, Multiset.filter ];
    bound;
    · fin_cases b <;> simp +decide [ Fintype.elems ];
      all_goals erw [ Quot.liftOn_mk ] ; simp +decide [ Finset.univ ] ;
      all_goals simp +decide [ List.finRange, GeneralizedPetersenGraph ] ;
    · erw [ Quot.liftOn_mk ] ; fin_cases b <;> simp +decide [ Fintype.elems ];
      all_goals simp +decide [ List.finRange, GeneralizedPetersenGraph ] ;
  exact h_deg v

/-
Define distance sets S0 to S5.
-/
open SimpleGraph

/-- Distance sets from (0, 0). -/
def S0 : Finset (Fin 2 × Fin 10) := {(0, 0)}
def S1 : Finset (Fin 2 × Fin 10) := {(0, 1), (0, 9), (1, 0)}
def S2 : Finset (Fin 2 × Fin 10) := {(0, 2), (0, 8), (1, 1), (1, 9), (1, 3), (1, 7)}
def S3 : Finset (Fin 2 × Fin 10) := {(0, 3), (0, 7), (1, 2), (1, 4), (1, 6), (1, 8)}
def S4 : Finset (Fin 2 × Fin 10) := {(0, 4), (0, 6), (1, 5)}
def S5 : Finset (Fin 2 × Fin 10) := {(0, 5)}

/-
Prove that the union of S0 to S5 is the universe.
-/
theorem S_union_eq_univ : S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4 ∪ S5 = Finset.univ := by
  ext x
  simp [S0, S1, S2, S3, S4, S5]
  -- Since the domain is finite (Fin 2 × Fin 10), we can just check every element.
  fin_cases x
  all_goals simp
  all_goals try trivial

/-
Prove that the sets S0 to S5 are pairwise disjoint.
-/
theorem S_disjoint :
  Disjoint S0 S1 ∧ Disjoint S0 S2 ∧ Disjoint S0 S3 ∧ Disjoint S0 S4 ∧ Disjoint S0 S5 ∧
  Disjoint S1 S2 ∧ Disjoint S1 S3 ∧ Disjoint S1 S4 ∧ Disjoint S1 S5 ∧
  Disjoint S2 S3 ∧ Disjoint S2 S4 ∧ Disjoint S2 S5 ∧
  Disjoint S3 S4 ∧ Disjoint S3 S5 ∧
  Disjoint S4 S5 := by
    all_goals native_decide;

/-
Prove distances for S0 and S1.
-/
theorem dist_0 : ∀ v ∈ S0, DesarguesGraph.dist (0, 0) v = 0 := by
  unfold S0; aesop;

theorem dist_1 : ∀ v ∈ S1, DesarguesGraph.dist (0, 0) v = 1 := by
  unfold DesarguesGraph;
  unfold GeneralizedPetersenGraph;
  simp +decide [ SimpleGraph.dist ]

/-
Prove distance for S2 is at most 2.
-/
theorem dist_le_2 : ∀ v ∈ S2, DesarguesGraph.dist (0, 0) v ≤ 2 := by
  intro v hv;
  -- By examining the edges of the Desargues graph, we can see that from (0, 0), we can reach all vertices in S2 in at most 2 steps.
  have h_edges : ∀ v ∈ S2, ∃ u ∈ S1, DesarguesGraph.Adj (0, 0) u ∧ DesarguesGraph.Adj u v := by
    simp +decide [ S2, S1, DesarguesGraph ];
    simp +decide [ GeneralizedPetersenGraph ];
  obtain ⟨ u, hu₁, hu₂, hu₃ ⟩ := h_edges v hv;
  refine' le_trans ( SimpleGraph.dist_le _ ) _;
  exacts [ SimpleGraph.Walk.cons hu₂ ( SimpleGraph.Walk.cons hu₃ SimpleGraph.Walk.nil ), by simp +decide ]

/-
Prove distance for S3 is at most 3.
-/
theorem dist_le_3 : ∀ v ∈ S3, DesarguesGraph.dist (0, 0) v ≤ 3 := by
  unfold DesarguesGraph S3;
  unfold GeneralizedPetersenGraph;
  simp +decide [ SimpleGraph.fromRel ];
  refine' ⟨ _, _, _, _, _ ⟩;
  · refine' le_trans ( SimpleGraph.dist_le _ ) _;
    constructor;
    rotate_left;
    rotate_left;
    exact ( 0, 1 );
    rotate_left;
    exact ⟨ by decide, by decide ⟩;
    constructor;
    rotate_left;
    rotate_left;
    exact ( 0, 2 );
    rotate_left;
    exact ⟨ by decide, by decide ⟩;
    exact SimpleGraph.Walk.cons ( by decide ) SimpleGraph.Walk.nil;
    decide +revert;
  · refine' Nat.le_trans ( ENat.toNat_le_toNat _ _ ) _;
    exact 3;
    · refine' le_trans ( ciInf_le _ _ ) _;
      exact ⟨ 0, Set.forall_mem_range.mpr fun _ => Nat.cast_nonneg _ ⟩;
      refine' SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.nil ) ) );
      rotate_left;
      exact ( 1, 0 );
      rotate_left;
      exact ( 1, 7 );
      all_goals simp +decide [ SimpleGraph.Walk.cons ];
    · decide +revert;
    · decide +revert;
  · refine' le_trans ( SimpleGraph.dist_le _ ) _;
    refine' SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ SimpleGraph.Walk.nil ) );
    rotate_left;
    exact ( 0, 1 );
    rotate_left;
    exact ( 0, 2 );
    all_goals simp +decide;
  · refine' Nat.le_trans ( SimpleGraph.dist_le _ ) _;
    refine' SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.cons _ ( SimpleGraph.Walk.nil ) ) );
    rotate_left;
    exact ( 0, 1 );
    rotate_left;
    exact ( 1, 1 );
    all_goals simp +decide [ SimpleGraph.adj_comm ];
  · constructor;
    · refine' Nat.le_of_lt_succ ( _ );
      refine' lt_of_le_of_lt ( SimpleGraph.dist_le _ ) _;
      refine' SimpleGraph.Walk.cons _ _;
      exact ( 1, 0 );
      exact ⟨ by decide, by decide ⟩;
      refine' SimpleGraph.Walk.cons _ _;
      exact ( 1, 3 );
      exact ⟨ by decide, by decide ⟩;
      exact SimpleGraph.Walk.cons ( by decide ) SimpleGraph.Walk.nil;
      decide +revert;
    · refine' le_trans ( SimpleGraph.dist_le _ ) _;
      refine' SimpleGraph.Walk.cons _ _;
      exact ( 0, 1 );
      exact ⟨ by decide, by decide ⟩;
      refine' SimpleGraph.Walk.cons _ _;
      exact ( 1, 1 );
      exact ⟨ by decide, by decide ⟩;
      exact SimpleGraph.Walk.cons ( by decide ) ( SimpleGraph.Walk.nil );
      decide +revert

/-
Prove distance for S4 is at most 4.
-/
theorem dist_le_4 : ∀ v ∈ S4, DesarguesGraph.dist (0, 0) v ≤ 4 := by
  unfold DesarguesGraph S4;
  unfold GeneralizedPetersenGraph;
  simp +decide [ SimpleGraph.fromRel ];
  refine' ⟨ _, _, _ ⟩;
  · refine' Nat.le_trans ( SimpleGraph.dist_le _ ) _;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 0, 1 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 1 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 4 );
    exact ⟨ by decide, by decide ⟩;
    exact SimpleGraph.Walk.cons ( by decide ) ( SimpleGraph.Walk.nil );
    decide +revert;
  · refine' Nat.le_trans ( SimpleGraph.dist_le _ ) _;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 0, 9 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 9 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 6 );
    exact ⟨ by decide, by decide ⟩;
    exact SimpleGraph.Walk.cons ( by decide ) ( SimpleGraph.Walk.nil );
    decide +revert;
  · refine' Nat.le_trans ( SimpleGraph.dist_le _ ) _;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 0, 1 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 1 );
    exact ⟨ by decide, by decide ⟩;
    refine' SimpleGraph.Walk.cons _ _;
    exact ( 1, 8 );
    exact ⟨ by decide, by decide ⟩;
    exact SimpleGraph.Walk.cons ( by decide ) ( SimpleGraph.Walk.nil );
    decide +revert

/-
Prove distance for S5 is at most 5.
-/
theorem dist_le_5 : ∀ v ∈ S5, DesarguesGraph.dist (0, 0) v ≤ 5 := by
  norm_num +zetaDelta at *;
  unfold S5;
  simp +zetaDelta at *;
  -- By definition of distance, we need to show that there exists a path from $(0, 0)$ to $(0, 5)$ with length at most 5.
  have h_path : ∃ p : SimpleGraph.Walk DesarguesGraph (0, 0) (0, 5), p.length ≤ 5 := by
    -- Let's construct the walk explicitly.
    use SimpleGraph.Walk.cons (show DesarguesGraph.Adj (0, 0) (1, 0) from by
                                constructor;
                                · decide;
                                · exact Or.inl rfl) (SimpleGraph.Walk.cons (show DesarguesGraph.Adj (1, 0) (1, 3) from by
                                                                                                              -- In the Desargues graph, the adjacency between (1, 0) and (1, 3) is defined by the inner edges.
                                                                                                              simp [DesarguesGraph, GeneralizedPetersenGraph]) (SimpleGraph.Walk.cons (show DesarguesGraph.Adj (1, 3) (1, 6) from by
                                                                                                                                                                                          simp ( config := { decide := Bool.true } ) [ DesarguesGraph ];
                                                                                                                                                                                          simp ( config := { decide := Bool.true } ) [ GeneralizedPetersenGraph ]) (SimpleGraph.Walk.cons (show DesarguesGraph.Adj (1, 6) (0, 6) from by
                                                                                                                                                                                                                                                                        unfold DesarguesGraph;
                                                                                                                                                                                                                                                                        simp ( config := { decide := Bool.true } ) [ GeneralizedPetersenGraph ]) (SimpleGraph.Walk.cons (show DesarguesGraph.Adj (0, 6) (0, 5) from by
                                                                                                                                                                                                                                                                                                                                                    simp ( config := { decide := Bool.true } ) [ DesarguesGraph ];
                                                                                                                                                                                                                                                                                                                                                    simp ( config := { decide := Bool.true } ) [ GeneralizedPetersenGraph ]) SimpleGraph.Walk.nil))));
    all_goals generalize_proofs at *;
    simp +arith +decide;
  exact le_trans ( SimpleGraph.dist_le _ ) h_path.choose_spec

/-
Prove neighborhood inclusion properties for S0 to S4.
-/
open SimpleGraph

theorem neighbor_S0 : ∀ u ∈ S0, ∀ v, DesarguesGraph.Adj u v → v ∈ S0 ∪ S1 := by
  unfold DesarguesGraph S0 S1; simp +decide [ SimpleGraph.fromRel_adj ] ;
  unfold GeneralizedPetersenGraph; simp +decide ;

theorem neighbor_S0_S1 : ∀ u ∈ S0 ∪ S1, ∀ v, DesarguesGraph.Adj u v → v ∈ S0 ∪ S1 ∪ S2 := by
  simp +decide [ S0, S1, S2, DesarguesGraph ];
  simp +decide [ GeneralizedPetersenGraph ]

theorem neighbor_S0_S1_S2 : ∀ u ∈ S0 ∪ S1 ∪ S2, ∀ v, DesarguesGraph.Adj u v → v ∈ S0 ∪ S1 ∪ S2 ∪ S3 := by
  unfold DesarguesGraph;
  unfold S0 S1 S2 S3; simp +decide [ GeneralizedPetersenGraph ] ;

theorem neighbor_S0_S1_S2_S3 : ∀ u ∈ S0 ∪ S1 ∪ S2 ∪ S3, ∀ v, DesarguesGraph.Adj u v → v ∈ S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4 := by
  simp +decide [ DesarguesGraph, S0, S1, S2, S3, S4 ];
  simp +decide [ GeneralizedPetersenGraph ]

theorem neighbor_S0_S1_S2_S3_S4 : ∀ u ∈ S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4, ∀ v, DesarguesGraph.Adj u v → v ∈ S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4 ∪ S5 := by
  simp +decide [ Fin.forall_fin_succ, S0, S1, S2, S3, S4, S5 ]

/-
Define cumulative sets U0 to U5.
-/
open SimpleGraph

def U0 := S0
def U1 := S0 ∪ S1
def U2 := S0 ∪ S1 ∪ S2
def U3 := S0 ∪ S1 ∪ S2 ∪ S3
def U4 := S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4
def U5 := S0 ∪ S1 ∪ S2 ∪ S3 ∪ S4 ∪ S5

/-
Prove dist <= 0 implies mem U0.
-/
theorem dist_le_0_implies_mem_U0 : ∀ v, DesarguesGraph.dist (0, 0) v ≤ 0 → v ∈ U0 := by
  simp +decide [ U0 ];
  unfold S0; aesop;
  · revert h_1;
    contrapose!;
    unfold DesarguesGraph;
    revert b; simp +decide [ GeneralizedPetersenGraph ] ;
    intro b hb;
    induction' b using Fin.inductionOn with b ih;
    · contradiction;
    · by_cases h : b.castSucc = 0 <;> simp_all +decide;
      · exact SimpleGraph.Adj.reachable ( by simp +decide );
      · refine' ih.trans _;
        exact SimpleGraph.Adj.reachable ( by fin_cases b <;> trivial );
  · -- Since (0, 0) is connected to (1, 0) by a spoke, we can reach (1, b) from (0, 0) by first reaching (1, 0) and then moving along the inner cycle.
    have h_inner : ∀ b : Fin 10, DesarguesGraph.Reachable (1, 0) (1, b) := by
      intro b;
      -- Since the inner cycle is a cycle of length 10, any two vertices in the inner cycle are reachable from each other.
      have h_inner_cycle : ∀ a b : Fin 10, DesarguesGraph.Adj (1, a) (1, (a + 3) % 10) := by
        aesop;
        fin_cases a <;> trivial;
      have h_inner_cycle : ∀ a b : Fin 10, DesarguesGraph.Reachable (1, a) (1, (a + 3) % 10) := by
        exact fun a b => SimpleGraph.Adj.reachable ( h_inner_cycle a b );
      have h_inner_cycle : ∀ a : Fin 10, DesarguesGraph.Reachable (1, 0) (1, a) := by
        intro a;
        have h_inner_cycle : ∀ a : Fin 10, DesarguesGraph.Reachable (1, 0) (1, (0 + 3 * a) % 10) := by
          intro a
          induction' a using Fin.induction with a ih;
          · exact SimpleGraph.Reachable.refl _;
          · convert ih.trans ( h_inner_cycle _ _ ) using 1;
            · fin_cases a <;> trivial;
            · exact 0;
        convert h_inner_cycle ( a * 7 ) using 1 ; fin_cases a <;> trivial;
      exact h_inner_cycle b;
    exact SimpleGraph.Reachable.trans ( SimpleGraph.Adj.reachable ( by fin_cases b <;> trivial ) ) ( h_inner b )

/-
Prove that neighbors of (0,0) are in S1.
-/
theorem adj_zero_zero_implies_mem_S1 : ∀ v, DesarguesGraph.Adj (0, 0) v → v ∈ S1 := by
  simp +decide [ DesarguesGraph ];
  simp +decide [ GeneralizedPetersenGraph ]

/-
Prove S1 is the set of neighbors of (0,0).
-/
theorem S1_eq_neighbors : S1 = DesarguesGraph.neighborFinset (0, 0) := by
  ext v
  simp [S1, DesarguesGraph, GeneralizedPetersenGraph, SimpleGraph.neighborFinset, Set.mem_setOf_eq]
  -- We can check equality by cases on v
  fin_cases v
  all_goals simp
  all_goals try decide

/-
Prove dist <= 1 implies mem U1 using structured proof.
-/
theorem dist_le_1_implies_mem_U1 : ∀ v, DesarguesGraph.dist (0, 0) v ≤ 1 → v ∈ U1 := by
  intro v h
  have h_cases : DesarguesGraph.dist (0, 0) v = 0 ∨ DesarguesGraph.dist (0, 0) v = 1 := by
    exact Nat.le_one_iff_eq_zero_or_eq_one.mp h
  rcases h_cases with h0 | h1
  · -- Case dist = 0
    have h_in_U0 : v ∈ U0 := dist_le_0_implies_mem_U0 v (le_of_eq h0)
    apply Finset.mem_union_left
    exact h_in_U0
  · -- Case dist = 1
    rw [SimpleGraph.dist_eq_one_iff_adj] at h1
    have h_adj : DesarguesGraph.Adj (0, 0) v := h1
    have h_in_S1 : v ∈ S1 := adj_zero_zero_implies_mem_S1 v h_adj
    apply Finset.mem_union_right
    exact h_in_S1

/-
Prove dist = 1 implies mem S1, and dist <= 1 implies mem U1 (renamed).
-/
theorem dist_eq_1_implies_mem_S1 : ∀ v, DesarguesGraph.dist (0, 0) v = 1 → v ∈ S1 := by
  intro v h
  rw [SimpleGraph.dist_eq_one_iff_adj] at h
  exact adj_zero_zero_implies_mem_S1 v h

theorem dist_le_1_implies_mem_U1_new : ∀ v, DesarguesGraph.dist (0, 0) v ≤ 1 → v ∈ U1 := by
  intro v h
  have h_cases : DesarguesGraph.dist (0, 0) v = 0 ∨ DesarguesGraph.dist (0, 0) v = 1 := by
    exact Nat.le_one_iff_eq_zero_or_eq_one.mp h
  rcases h_cases with h0 | h1
  · apply Finset.mem_union_left
    apply dist_le_0_implies_mem_U0
    exact le_of_eq h0
  · apply Finset.mem_union_right
    apply dist_eq_1_implies_mem_S1
    exact h1

/-
Prove dist = 1 implies mem S1, and dist <= 1 implies mem U1 (renamed).
-/
theorem dist_eq_1_implies_mem_S1_aux : ∀ v, DesarguesGraph.dist (0, 0) v = 1 → v ∈ S1 := by
  intro v h
  rw [SimpleGraph.dist_eq_one_iff_adj] at h
  exact adj_zero_zero_implies_mem_S1 v h

theorem dist_le_1_implies_mem_U1_aux : ∀ v, DesarguesGraph.dist (0, 0) v ≤ 1 → v ∈ U1 := by
  intro v h
  have h_cases : DesarguesGraph.dist (0, 0) v = 0 ∨ DesarguesGraph.dist (0, 0) v = 1 := by
    exact Nat.le_one_iff_eq_zero_or_eq_one.mp h
  rcases h_cases with h0 | h1
  · apply Finset.mem_union_left
    apply dist_le_0_implies_mem_U0
    exact le_of_eq h0
  · apply Finset.mem_union_right
    apply dist_eq_1_implies_mem_S1_aux
    exact h1

/-
Prove dist = 1 implies mem S1, and dist <= 1 implies mem U1 (using new names).
-/
theorem dist_eq_1_implies_mem_S1_v2 : ∀ v, DesarguesGraph.dist (0, 0) v = 1 → v ∈ S1 := by
  intro v h
  rw [SimpleGraph.dist_eq_one_iff_adj] at h
  exact adj_zero_zero_implies_mem_S1 v h

theorem dist_le_1_implies_mem_U1_v2 : ∀ v, DesarguesGraph.dist (0, 0) v ≤ 1 → v ∈ U1 := by
  intro v h
  have h_cases : DesarguesGraph.dist (0, 0) v = 0 ∨ DesarguesGraph.dist (0, 0) v = 1 := by
    exact Nat.le_one_iff_eq_zero_or_eq_one.mp h
  rcases h_cases with h0 | h1
  · apply Finset.mem_union_left
    apply dist_le_0_implies_mem_U0
    exact le_of_eq h0
  · apply Finset.mem_union_right
    apply dist_eq_1_implies_mem_S1_v2
    exact h1

/-
Prove dist = 2 implies mem S2.
-/
theorem dist_eq_2_implies_mem_S2 : ∀ v, DesarguesGraph.dist (0, 0) v = 2 → v ∈ S2 := by
  bound;
  have := a ▸ SimpleGraph.exists_walk_of_dist_ne_zero ( by aesop_cat : DesarguesGraph.dist ( 0, 0 ) ( fst, snd ) ≠ 0 );
  obtain ⟨ p, hp ⟩ := this; rcases p with ( _ | ⟨ _, _, p ⟩ ) <;> aesop;
  cases p <;> aesop;
  unfold DesarguesGraph at *;
  fin_cases fst_1 <;> fin_cases snd_1 <;> simp +decide [ GeneralizedPetersenGraph ] at h h_1 ⊢;
  · fin_cases fst <;> fin_cases snd <;> simp +decide at h_1 ⊢;
    exact absurd a ( by erw [ SimpleGraph.dist_self ] ; decide );
  · fin_cases fst <;> fin_cases snd <;> simp +decide at h_1 ⊢;
    exact absurd a ( by erw [ SimpleGraph.dist_self ] ; decide );
  · fin_cases fst <;> fin_cases snd <;> simp +decide at h_1 ⊢;
    exact absurd a ( by erw [ SimpleGraph.dist_self ] ; decide )