# SAT LRAT Proof Verification (Certificate-Based)

## Problem Statement

Verify that a given LRAT (Linear Resolution Asymmetric Tautology) proof certificate correctly proves the unsatisfiability of the Pigeonhole Principle formula PHP-4-3 (4 pigeons, 3 holes).

**Important**: Do NOT solve the SAT problem from scratch. You will VERIFY a provided LRAT proof certificate.

## Background

LRAT is a proof format produced by modern SAT solvers (CaDiCaL, Kissat, etc.) to provide machine-checkable certificates of unsatisfiability. An LRAT proof is a sequence of clause additions and deletions, where each addition includes "hints" (clause IDs) that justify the addition via resolution.

**Key properties**:
- LRAT proofs are **self-certifying**: verification only requires checking resolution steps
- Verification is **decidable**: finite proof, finite formula
- Modern solvers produce LRAT natively (more explicit than DRAT)

## Strategic Context

This problem aligns with Aristotle's strengths:
- ✅ **Certificate verification** (not search/computation)
- ✅ **Decidable** (finite proof steps)
- ✅ **Complete data** (full LRAT proof provided inline)
- ✅ **Computable types** (List, Nat, decidable predicates)

## Complete Data (Inline)

### PHP-4-3 CNF Formula

4 pigeons, 3 holes: UNSATISFIABLE by pigeonhole principle.

**Variables** (12 total):
- v_{i,j} = "pigeon i in hole j" where i ∈ {1,2,3,4}, j ∈ {1,2,3}
- Encoding: v_{i,j} → variable (3*(i-1) + j)

**Clauses** (22 total):

*At-least-one constraints* (4 clauses - each pigeon in some hole):
```
1. [1, 2, 3]        -- Pigeon 1 in hole 1, 2, or 3
2. [4, 5, 6]        -- Pigeon 2 in hole 1, 2, or 3
3. [7, 8, 9]        -- Pigeon 3 in hole 1, 2, or 3
4. [10, 11, 12]     -- Pigeon 4 in hole 1, 2, or 3
```

*At-most-one constraints* (18 clauses - no two pigeons in same hole):

Hole 1 (pigeons 1,2,3,4 - 6 pairs):
```
5. [-1, -4]         -- Not both pigeon 1 and 2 in hole 1
6. [-1, -7]         -- Not both pigeon 1 and 3 in hole 1
7. [-1, -10]        -- Not both pigeon 1 and 4 in hole 1
8. [-4, -7]         -- Not both pigeon 2 and 3 in hole 1
9. [-4, -10]        -- Not both pigeon 2 and 4 in hole 1
10. [-7, -10]       -- Not both pigeon 3 and 4 in hole 1
```

Hole 2 (pigeons 1,2,3,4 - 6 pairs):
```
11. [-2, -5]
12. [-2, -8]
13. [-2, -11]
14. [-5, -8]
15. [-5, -11]
16. [-8, -11]
```

Hole 3 (pigeons 1,2,3,4 - 6 pairs):
```
17. [-3, -6]
18. [-3, -9]
19. [-3, -12]
20. [-6, -9]
21. [-6, -12]
22. [-9, -12]
```

### LRAT Proof Certificate

**NOTE**: This section will be filled with actual LRAT proof from SAT solver.

Format:
```
<clause_id> <lit1> <lit2> ... 0 <hint1> <hint2> ... 0
```

Example structure (actual proof to be generated):
```
23 -1 -2 -3 0 1 5 11 17 0     -- Derive contradiction using clauses 1, 5, 11, 17
d 1 0                          -- Delete clause 1 (optional optimization)
...
0                              -- Empty clause (contradiction)
```

**TODO**: Insert actual LRAT proof here (will be generated by CaDiCaL/Kissat).

## Task for Aristotle

Create a Lean 4 file that:

1. **Define LRAT proof format**:
   ```lean
   inductive LRATStep where
     | add (id : Nat) (clause : List Int) (hints : List Nat)
     | delete (id : Nat)

   def LRATProof := List LRATStep
   ```

2. **Define CNF and assignment**:
   ```lean
   def Literal := Int  -- positive = var, negative = ¬var
   def Clause := List Literal
   def CNF := List Clause

   def php_4_3 : CNF := [
     [1, 2, 3],
     [4, 5, 6],
     -- ... (all 22 clauses)
   ]
   ```

3. **Define LRAT verification**:
   ```lean
   -- Check if clause is resolvant of given clauses
   def check_resolution (new_clause : Clause) (hints : List Nat) (formula : CNF) : Bool :=
     -- Implementation: verify resolution chain
     sorry  -- Aristotle fills this

   -- Verify entire LRAT proof
   def verify_lrat_proof (formula : CNF) (proof : LRATProof) : Bool :=
     -- Implementation: step through proof, verify each step
     sorry  -- Aristotle fills this
   ```

4. **Prove verification succeeds**:
   ```lean
   def php_4_3_lrat_proof : LRATProof := [
     -- Insert actual LRAT proof steps
   ]

   theorem php_4_3_lrat_valid :
     verify_lrat_proof php_4_3 php_4_3_lrat_proof = true := by
     native_decide  -- Decidable verification!
   ```

## Implementation Hints

**For resolution checking**:
- Resolution on variable v: combine clauses C1 (contains v) and C2 (contains ¬v)
- Resulting clause: (C1 \ {v}) ∪ (C2 \ {¬v})
- LRAT hints specify which clauses to resolve

**For proof verification**:
- Start with original formula
- For each "add" step: check resolution justification, add clause
- For each "delete" step: remove clause from active set
- Success: derive empty clause []

**Decidability**:
- Finite proof (bounded steps)
- Finite formula (22 clauses, 12 variables)
- Each resolution step is decidable check
- → Entire verification is decidable via `native_decide`

## Success Criteria

- ✅ File compiles without errors
- ✅ Defines LRAT proof format
- ✅ Implements LRAT verification algorithm
- ✅ Proves `php_4_3_lrat_valid` (zero sorries)
- ✅ Uses `native_decide` (no manual proof tactics needed)
- ✅ Total file size < 500 lines
- ✅ Execution time < 5 minutes

## Why This Is A Breakthrough

**Compared to PHP-3-2 direct proof**:
- PHP-3-2: "Trivial hello world" (per Grok/Gemini)
- LRAT verification: **Certifying SAT solver correctness**

**Real-world impact**:
- ✅ SAT solvers used in hardware verification, software testing, AI
- ✅ LRAT certificates provide formal guarantees
- ✅ First formal LRAT verification in Lean 4 = publishable (FMCAD/CAV)

**Complexity escalation**:
- PHP-3-2: 6 variables, 9 clauses
- PHP-4-3: 12 variables, 22 clauses, **+ proof certificate verification**
- Shows **verification at scale**, not just toy examples

## References

- LRAT specification: [To be added from research]
- CaDiCaL solver: https://github.com/arminbiere/cadical
- Existing work: [To be added from research]

---

**Status**: DRAFT - awaiting research results and actual LRAT proof generation.
