/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 834eed91-57e1-4560-b7a1-74253b625f37

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of Latin Square, Orthogonal Latin Squares, and Three Mutually Orthogonal Latin Squares of order 10.
-/
def IsLatinSquare {n : ℕ} (M : Matrix (Fin n) (Fin n) (Fin n)) : Prop :=
  (∀ r, Function.Injective (M r)) ∧
  (∀ c, Function.Injective (fun r => M r c))

def AreOrthogonal {n : ℕ} (A B : Matrix (Fin n) (Fin n) (Fin n)) : Prop :=
  Function.Injective (fun p : Fin n × Fin n => (A p.1 p.2, B p.1 p.2))

def ThreeMOLS (L1 L2 L3 : Matrix (Fin 10) (Fin 10) (Fin 10)) : Prop :=
  IsLatinSquare L1 ∧ IsLatinSquare L2 ∧ IsLatinSquare L3 ∧
  AreOrthogonal L1 L2 ∧ AreOrthogonal L1 L3 ∧ AreOrthogonal L2 L3

/-
Formal statement of the open problem for n=10, and a proof of existence for n=5 to verify definitions.
-/
def ThreeMOLSConjecture : Prop :=
  ∃ L1 L2 L3 : Matrix (Fin 10) (Fin 10) (Fin 10), ThreeMOLS L1 L2 L3

theorem ExistenceOfThreeMOLS5 : ∃ L1 L2 L3 : Matrix (Fin 5) (Fin 5) (Fin 5),
  IsLatinSquare L1 ∧ IsLatinSquare L2 ∧ IsLatinSquare L3 ∧
  AreOrthogonal L1 L2 ∧ AreOrthogonal L1 L3 ∧ AreOrthogonal L2 L3 := by
  by_contra h;
  -- Let's choose any three mutually orthogonal Latin squares of order 5.
  obtain ⟨L1, L2, L3, hL1, hL2, hL3⟩ : ∃ L1 L2 L3 : Matrix (Fin 5) (Fin 5) (Fin 5), (IsLatinSquare L1 ∧ IsLatinSquare L2 ∧ IsLatinSquare L3 ∧ AreOrthogonal L1 L2 ∧ AreOrthogonal L1 L3 ∧ AreOrthogonal L2 L3) := by
    simp +zetaDelta at *;
    -- Let's choose the specific matrices L1, L2, and L3 from the provided solution.
    use !![0, 1, 2, 3, 4; 1, 2, 3, 4, 0; 2, 3, 4, 0, 1; 3, 4, 0, 1, 2; 4, 0, 1, 2, 3], by
      exact ⟨ by decide, by decide ⟩, !![0, 1, 2, 3, 4; 2, 3, 4, 0, 1; 4, 0, 1, 2, 3; 1, 2, 3, 4, 0; 3, 4, 0, 1, 2], by
      exact ⟨ by decide, by decide ⟩, !![0, 1, 2, 3, 4; 3, 4, 0, 1, 2; 1, 2, 3, 4, 0; 4, 0, 1, 2, 3; 2, 3, 4, 0, 1], by
      constructor <;> simp +decide [ Function.Injective ];
    simp +decide [ AreOrthogonal ];
  exact h ⟨ L1, L2, L3, hL1, hL2, hL3 ⟩

/-
Definition of a family of k mutually orthogonal Latin squares of order n.
-/
def IsMOLSFamily {n k : ℕ} (L : Fin k → Matrix (Fin n) (Fin n) (Fin n)) : Prop :=
  (∀ i, IsLatinSquare (L i)) ∧
  (∀ i j, i ≠ j → AreOrthogonal (L i) (L j))

/-
Theorem: The size of a family of mutually orthogonal Latin squares of order n is at most n-1.
-/
theorem MOLS_upper_bound {n k : ℕ} (hn : n > 1) (L : Fin k → Matrix (Fin n) (Fin n) (Fin n))
  (h : IsMOLSFamily L) : k ≤ n - 1 := by
  -- By permuting the symbols of each Latin square, we can assume without loss of generality that the first row of each Latin square is $0, 1, \dots, n-1$.
  obtain ⟨L', hL'⟩ : ∃ L' : Fin k → Matrix (Fin n) (Fin n) (Fin n), (∀ i, IsLatinSquare (L' i)) ∧ (∀ i j, i ≠ j → AreOrthogonal (L' i) (L' j)) ∧ (∀ i, ∀ c, L' i ⟨0, by linarith⟩ c = c) := by
    -- For each $i$, let $σ_i$ be a permutation of $\{0, 1, \dots, n-1\}$ such that $σ_i(L_i(0, c)) = c$ for all $c$.
    obtain ⟨σ, hσ⟩ : ∃ σ : Fin k → Equiv.Perm (Fin n), ∀ i, ∀ c, σ i (L i ⟨0, by linarith⟩ c) = c := by
      have h_perm : ∀ i, Function.Bijective (fun c => L i ⟨0, by linarith⟩ c) := by
        exact fun i => ⟨ h.1 i |>.1 _, Finite.injective_iff_surjective.mp ( h.1 i |>.1 _ ) ⟩
      generalize_proofs at *; (
      exact ⟨ fun i => Equiv.symm ( Equiv.ofBijective _ ( h_perm i ) ), fun i c => Equiv.symm_apply_apply _ _ ⟩);
    refine' ⟨ fun i => fun r c => σ i ( L i r c ), _, _, _ ⟩;
    · bound;
      have := h.1 i; unfold IsLatinSquare at this; aesop;
      exact ⟨ fun r => Equiv.injective _ |> Function.Injective.comp <| left r, fun c => Equiv.injective _ |> Function.Injective.comp <| right c ⟩;
    · intro i j hij; intro p q; have := h.2 i j hij; aesop;
      · have := @this ( fst, snd ) ( fst_1, snd_1 ) ; aesop;
      · have := @this ( fst, snd ) ( fst_1, snd_1 ) ; aesop;
    · aesop;
  -- Consider the entry at position $(1, 0)$ (second row, first column) for each square $L'_i$.
  -- Let $x_i = L'_i(1, 0)$.
  set x : Fin k → Fin n := fun i => L' i ⟨1, by linarith⟩ ⟨0, by linarith⟩;
  -- 1. $x_i \neq 0$. Proof: In $L'_i$, 0 is already in the first column at position $(0, 0)$ (since the first row is $0, 1, \dots, n-1$, so $L'_i(0, 0) = 0$). Since it's a Latin square, 0 cannot appear again in the first column.
  have hx_ne_zero : ∀ i, x i ≠ ⟨0, by linarith⟩ := by
    intro i hi; have := hL'.1 i; have := this.2; have := @this ⟨ 0, by linarith ⟩ ; aesop;
    have := @this_2 ⟨ 0, by linarith ⟩ ⟨ 0, by linarith ⟩ ⟨ 1, by linarith ⟩ ; aesop;
  -- 2. If $i \neq j$, then $x_i \neq x_j$. Proof: Suppose $x_i = x_j = x$. Then the pair $(x, x)$ appears at position $(1, 0)$ in the superposition of $L'_i$ and $L'_j$.
  have hx_distinct : ∀ i j, i ≠ j → x i ≠ x j := by
    intro i j hij h_eq; have := hL'.2.1 i j hij; simp_all +decide [ Function.Injective ] ;
    have := hL'.2.1 i j hij; have := @this ( ⟨ 1, by linarith ⟩, ⟨ 0, by linarith ⟩ ) ( ⟨ 0, by linarith ⟩, x i ) ; simp_all +decide ;
    exact this h_eq rfl;
  -- Thus, $x_1, \dots, x_k$ are distinct elements of $\{1, \dots, n-1\}$.
  have hx_subset : Finset.image x Finset.univ ⊆ Finset.univ.erase ⟨0, by linarith⟩ := by
    exact Finset.image_subset_iff.mpr fun i _ => Finset.mem_erase_of_ne_of_mem ( hx_ne_zero i ) ( Finset.mem_univ _ );
  have := Finset.card_le_card hx_subset; simp_all +decide [ Finset.card_image_of_injective _ fun i j hij => not_imp_not.mp ( hx_distinct i j ) hij ] ;

/-
Theorem: There is no field of order 10.
-/
theorem NoFieldOrder10 : ¬ ∃ (F : Type) (hF : Field F) (hFin : Fintype F), Fintype.card F = 10 := by
  aesop;
  -- Since the cardinality of the field is 10, it must be of the form $p^k$ for some prime number $p$ and integer $k \geq 1$.
  obtain ⟨p, k, hp, hk⟩ : ∃ p k : ℕ, Nat.Prime p ∧ k ≥ 1 ∧ Fintype.card x = p^k := by
    have := FiniteField.card x ( ringChar x ) ; aesop;
    exact ⟨ _, left, _, PNat.pos _, rfl ⟩;
  have := hp.eq_two_or_odd'; aesop;
  · linarith [ Nat.pow_le_pow_right ( show 1 ≤ 2 by norm_num ) ( show k ≥ 6 by contrapose! a_1; interval_cases k <;> trivial ) ];
  · exact absurd ( congr_arg Even a_1 ) ( by norm_num [ h_1, parity_simps ] )

/-
Theorem: There are no two orthogonal linear Latin squares of order 10.
-/
def LinearLatinSquare (n : ℕ) (k : ZMod n) : Matrix (ZMod n) (ZMod n) (ZMod n) :=
  fun i j => k * i + j

theorem NoLinearMOLS10 : ¬ ∃ k1 k2 : ZMod 10,
  IsLatinSquare (LinearLatinSquare 10 k1) ∧
  IsLatinSquare (LinearLatinSquare 10 k2) ∧
  AreOrthogonal (LinearLatinSquare 10 k1) (LinearLatinSquare 10 k2) := by
  unfold IsLatinSquare AreOrthogonal LinearLatinSquare;
  native_decide +revert

/-
Definitions of Transversal and Transversal Decomposition for a Latin Square.
-/
def IsTransversal {n : ℕ} (M : Matrix (Fin n) (Fin n) (Fin n)) (S : Set (Fin n × Fin n)) : Prop :=
  S.ncard = n ∧
  (∀ r, ∃ c, (r, c) ∈ S) ∧
  (∀ c, ∃ r, (r, c) ∈ S) ∧
  (Set.InjOn (fun p : Fin n × Fin n => M p.1 p.2) S)

def IsTransversalDecomposition {n : ℕ} (M : Matrix (Fin n) (Fin n) (Fin n)) (T : Fin n → Set (Fin n × Fin n)) : Prop :=
  (∀ k, IsTransversal M (T k)) ∧
  (∀ k1 k2, k1 ≠ k2 → Disjoint (T k1) (T k2)) ∧
  (⋃ k, T k) = Set.univ

/-
Lemma: If a Latin square has an orthogonal mate, it has a transversal decomposition.
-/
lemma OrthogonalMate_implies_TransversalDecomposition {n : ℕ} (L : Matrix (Fin n) (Fin n) (Fin n)) :
  (∃ L', IsLatinSquare L' ∧ AreOrthogonal L L') →
  (∃ T : Fin n → Set (Fin n × Fin n), IsTransversalDecomposition L T) := by
  simp +zetaDelta at *;
  intro L' hL' hL''; use fun k => { p | L' p.1 p.2 = k } ; unfold IsTransversalDecomposition; aesop;
  · refine' ⟨ _, _, _, _ ⟩;
    · -- By definition of $L'$ being a Latin square, each row and each column contains exactly one occurrence of each element.
      have h_row_col : ∀ r, ∃! c, L' r c = k := by
        unfold IsLatinSquare at hL'; aesop;
        exact ⟨ Classical.choose ( Finite.injective_iff_surjective.mp ( left r ) k ), Classical.choose_spec ( Finite.injective_iff_surjective.mp ( left r ) k ), fun c hc => left r <| hc.trans <| Eq.symm <| Classical.choose_spec ( Finite.injective_iff_surjective.mp ( left r ) k ) ⟩;
      choose f hf using h_row_col;
      rw [ show { p : Fin n × Fin n | L' p.1 p.2 = k } = Set.image ( fun r => ( r, f r ) ) ( Set.univ : Set ( Fin n ) ) from ?_, Set.ncard_image_of_injective _ fun x y hxy => by aesop ] ; norm_num [ Set.ncard_univ ];
      ext ⟨ r, c ⟩ ; specialize hf r ; aesop;
    · intro r;
      have := hL'.1 r;
      have := Finite.injective_iff_surjective.mp this k; aesop;
    · have := hL'.1; aesop;
      exact Finite.injective_iff_surjective.mp ( show Function.Injective ( fun r => L' r c ) from fun a b h => by have := @this a; have := @this; have := @hL'.2 c; aesop ) k;
    · intro p hp q hq; have := @hL'' p q; aesop;
  · exact Set.disjoint_left.mpr fun p hp1 hp2 => a <| hp1.symm.trans hp2;
  · ext ⟨ i, j ⟩ ; aesop

/-
Lemma: If a Latin square has a transversal decomposition, it has an orthogonal mate.
-/
lemma TransversalDecomposition_implies_OrthogonalMate {n : ℕ} (L : Matrix (Fin n) (Fin n) (Fin n)) :
  (∃ T : Fin n → Set (Fin n × Fin n), IsTransversalDecomposition L T) →
  (∃ L', IsLatinSquare L' ∧ AreOrthogonal L L') := by
  rintro ⟨ T, hT ⟩;
  obtain ⟨hT_ball, hT_disjoint, hT_union⟩ := hT;
  -- Define L'(i, j) = k where (i, j) is in T_k.
  obtain ⟨L', hL'⟩ : ∃ L' : Matrix (Fin n) (Fin n) (Fin n), (∀ i j, (i, j) ∈ T (L' i j)) := by
    simp_all +decide [ Set.ext_iff ];
    exact ⟨ fun i j => Classical.choose ( hT_union i j ), fun i j => Classical.choose_spec ( hT_union i j ) ⟩;
  refine' ⟨ L', _, _ ⟩;
  · constructor <;> intro r <;> refine' Finite.injective_iff_surjective.2 _;
    · intro k; specialize hT_ball k; rcases hT_ball.2.1 r with ⟨ c, hc ⟩ ; aesop;
      exact ⟨ c, by_contradiction fun h => Set.disjoint_left.mp ( hT_disjoint _ _ h ) ( hL' _ _ ) hc ⟩;
    · intro k; specialize hT_ball k; unfold IsTransversal at hT_ball; aesop;
      cases' left_2 r with a ha ; use a ; specialize hL' a r ; simp_all +decide [ Set.disjoint_left ];
      exact Classical.not_not.1 fun h => hT_disjoint _ _ h _ _ hL' ha;
  · intro p q h; have := hL' p.1 p.2; have := hL' q.1 q.2; aesop;
    · have := hT_ball ( L' fst_1 snd_1 ) |>.2.2.2 ( show ( fst, snd ) ∈ T ( L' fst_1 snd_1 ) from this_1 ) ( show ( fst_1, snd_1 ) ∈ T ( L' fst_1 snd_1 ) from hL' _ _ ) ; aesop;
    · have := hT_ball ( L' fst_1 snd_1 ) ; cases this ; aesop;
      have := right_1 this_1 ( hL' fst_1 snd_1 ) ; aesop;

/-
Definition of orthogonal transversal decompositions.
-/
def AreOrthogonalDecompositions {n : ℕ} (T U : Fin n → Set (Fin n × Fin n)) : Prop :=
  ∀ k m, (T k ∩ U m).ncard = 1

/-
Lemma: Orthogonal transversal decompositions imply orthogonal Latin squares.
-/
lemma OrthogonalDecompositions_implies_OrthogonalSquares {n : ℕ}
  (T : Fin n → Set (Fin n × Fin n)) (U : Fin n → Set (Fin n × Fin n))
  (L2 L3 : Matrix (Fin n) (Fin n) (Fin n))
  (hL2 : ∀ i j k, L2 i j = k ↔ (i, j) ∈ T k)
  (hL3 : ∀ i j m, L3 i j = m ↔ (i, j) ∈ U m)
  (hOrth : AreOrthogonalDecompositions T U) :
  AreOrthogonal L2 L3 := by
  intro p q h_eq;
  aesop;
  · have := hOrth ( L2 fst_1 snd_1 ) ( L3 fst_1 snd_1 ) ; simp_all +decide [ Set.eq_singleton_iff_unique_mem ] ;
    grind +ring;
  · have := hOrth ( L2 fst_1 snd_1 ) ( L3 fst_1 snd_1 ) ; simp_all +decide [ Set.ncard_eq_toFinset_card' ] ;
    rw [ Finset.card_eq_one ] at this;
    simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
    grind

/-
Lemma: Orthogonal Latin squares imply orthogonal transversal decompositions.
-/
lemma OrthogonalSquares_implies_OrthogonalDecompositions {n : ℕ}
  (T : Fin n → Set (Fin n × Fin n)) (U : Fin n → Set (Fin n × Fin n))
  (L2 L3 : Matrix (Fin n) (Fin n) (Fin n))
  (hL2 : ∀ i j k, L2 i j = k ↔ (i, j) ∈ T k)
  (hL3 : ∀ i j m, L3 i j = m ↔ (i, j) ∈ U m)
  (hOrth : AreOrthogonal L2 L3) :
  AreOrthogonalDecompositions T U := by
  -- By definition of $T$ and $U$, we know that for any $k$ and $m$, the set $T_k \cap U_m$ is exactly the set of cells where $L2 i j = k$ and $L3 i j = m$.
  intros k m
  set S := T k ∩ U m;
  -- Since $L2$ and $L3$ are orthogonal, the map $(i, j) \mapsto (L2(i, j), L3(i, j))$ is injective.
  have h_inj : Function.Injective (fun p : Fin n × Fin n => (L2 p.1 p.2, L3 p.1 p.2)) := by
    exact hOrth;
  -- Since $L2$ and $L3$ are orthogonal, the set $S$ must contain exactly one element.
  have hS_card : S.ncard = 1 := by
    have hS_nonempty : ∃ p : Fin n × Fin n, p ∈ S := by
      have := Finite.injective_iff_surjective.1 h_inj ( k, m ) ; aesop;
    obtain ⟨ p, hp ⟩ := hS_nonempty; rw [ Set.ncard_eq_one ] ; use p; ext q; aesop;
    · have := @h_inj ( fst_1, snd_1 ) ( fst, snd ) ; aesop;
      exact this ( by simpa [ hL2 _ _ _ |>.2 left ] using left_1 ) ( by simpa [ hL3 _ _ _ |>.2 right ] using right_1 ) |>.1;
    · have := @h_inj ( fst, snd ) ( fst_1, snd_1 ) ; aesop;
      grind;
  exact hS_card

/-
Lemma: The canonical decomposition induced by an orthogonal mate is a transversal decomposition.
-/
def CanonicalDecomposition {n : ℕ} (L : Matrix (Fin n) (Fin n) (Fin n)) : Fin n → Set (Fin n × Fin n) :=
  fun k => { p | L p.1 p.2 = k }

lemma CanonicalDecomposition_is_TransversalDecomposition {n : ℕ} (L1 L2 : Matrix (Fin n) (Fin n) (Fin n))
  (hL2 : IsLatinSquare L2) (hOrth : AreOrthogonal L1 L2) :
  IsTransversalDecomposition L1 (CanonicalDecomposition L2) := by
  unfold IsTransversalDecomposition; aesop;
  · refine' ⟨ _, _, _, _ ⟩;
    · unfold CanonicalDecomposition;
      have := hL2.2;
      -- Since $L2$ is a Latin square, each element $k$ appears exactly once in each row and column.
      have h_row_col : ∀ c, ∃ r, L2 r c = k := by
        exact fun c => Finite.injective_iff_surjective.mp ( this c ) k;
      choose f hf using h_row_col;
      rw [ show { p : Fin n × Fin n | L2 p.1 p.2 = k } = Set.image ( fun c => ( f c, c ) ) ( Set.univ : Set ( Fin n ) ) from ?_, Set.ncard_image_of_injective _ fun x y hxy => by aesop ];
      · norm_num [ Set.ncard_univ ];
      · ext ⟨ r, c ⟩ ; aesop;
    · intro r;
      have := hL2.1 r;
      have := Finite.injective_iff_surjective.mp this k; aesop;
    · intro c;
      have := hL2.2 c;
      have := Finite.injective_iff_surjective.1 this k; aesop;
    · intro p hp q hq; have := @hOrth p q; aesop;
      · unfold CanonicalDecomposition at hp hq; aesop;
      · unfold CanonicalDecomposition at hp hq; aesop;
  · exact Set.disjoint_left.mpr fun x hx1 hx2 => a <|hx1.symm.trans hx2;
  · ext ⟨ i, j ⟩ ; aesop

/-
Definition of three mutually orthogonal Latin squares of order n.
-/
def ThreeMOLS_n {n : ℕ} (L1 L2 L3 : Matrix (Fin n) (Fin n) (Fin n)) : Prop :=
  IsLatinSquare L1 ∧ IsLatinSquare L2 ∧ IsLatinSquare L3 ∧
  AreOrthogonal L1 L2 ∧ AreOrthogonal L1 L3 ∧ AreOrthogonal L2 L3

/-
Lemma: Existence of 3 MOLS implies existence of orthogonal transversal decompositions.
-/
lemma ThreeMOLS_implies_OrthogonalDecompositions {n : ℕ} :
  (∃ L1 L2 L3 : Matrix (Fin n) (Fin n) (Fin n), ThreeMOLS_n L1 L2 L3) →
  (∃ L1 : Matrix (Fin n) (Fin n) (Fin n), IsLatinSquare L1 ∧
    ∃ T U : Fin n → Set (Fin n × Fin n),
      IsTransversalDecomposition L1 T ∧
      IsTransversalDecomposition L1 U ∧
      AreOrthogonalDecompositions T U) := by
  rintro ⟨ L1, L2, L3, h ⟩;
  use L1;
  refine' ⟨ h.1, CanonicalDecomposition L2, CanonicalDecomposition L3, _, _, _ ⟩;
  · exact CanonicalDecomposition_is_TransversalDecomposition L1 L2 h.2.1 h.2.2.2.1;
  · exact CanonicalDecomposition_is_TransversalDecomposition L1 L3 h.2.2.1 h.2.2.2.2.1;
  · have h_orthogonal : AreOrthogonal L2 L3 := by
      exact h.2.2.2.2.2;
    apply_rules [ OrthogonalSquares_implies_OrthogonalDecompositions ];
    · aesop;
    · exact?

/-
Lemma: A transversal decomposition induces a Latin square with specific properties.
-/
lemma TransversalDecomposition_induces_LatinSquare {n : ℕ} (L : Matrix (Fin n) (Fin n) (Fin n))
  (T : Fin n → Set (Fin n × Fin n)) (hT : IsTransversalDecomposition L T) :
  ∃ L' : Matrix (Fin n) (Fin n) (Fin n),
    IsLatinSquare L' ∧
    AreOrthogonal L L' ∧
    ∀ i j k, L' i j = k ↔ (i, j) ∈ T k := by
  -- The construction of L' is given by L'(i, j) = k where (i, j) ∈ T_k.
  obtain ⟨L', hL'⟩ : ∃ L' : Matrix (Fin n) (Fin n) (Fin n), ∀ i j k, L' i j = k ↔ (i, j) ∈ T k := by
    cases hT ; aesop;
    simp_all +decide [ Set.ext_iff ];
    choose f hf using right; use fun i j => f i j; aesop;
    exact Classical.not_not.1 fun h => Set.disjoint_left.mp ( left_1 _ _ h ) ( hf _ _ ) a;
  use L';
  cases hT ; aesop;
  · constructor <;> intro i <;> refine' Finite.injective_iff_surjective.2 _ <;> intro j <;> specialize left j <;> aesop;
    · have := left.2.1 i; aesop;
    · have := left.2.2; aesop;
  · intro p1 p2 h_eq; have := left p1.1; have := left p2.1; aesop;
    · have := left ( L' fst_1 snd_1 ) ; unfold IsTransversal at this; aesop;
      have := right_2 right_1 ( hL' _ _ _ |>.1 rfl ) ; aesop;
    · have := left ( L' fst_1 snd_1 ) ; have := this.2.2; aesop;
      have := right_2 right_1 ( hL' _ _ _ |>.1 rfl ) ; aesop;