# Complete Ramsey Number Formalization

The following Lean 4 code formalizes Ramsey number theory and is 95% complete. It proves R(3,3)=6, Ramsey's theorem, and key lemmas. Only 3 small gaps remain where `exact?` timed out.

## Task

Complete this formalization by filling the 3 `exact?` gaps with appropriate Mathlib lemmas:

### Gap 1 (Line ~114): Subset extraction
```lean
obtain ⟨T, hT⟩ : ∃ T : Finset (Fin 6), T ⊆ S ∧ T.card = 3 := by
  exact?;
```
**Hint**: Use `Finset.exists_subset_card_eq` with the hypothesis that S.card ≥ 3

### Gap 2 (Line ~223): Same pattern
```lean
obtain ⟨M, hM⟩ : ∃ M : Finset (Fin (n + m)), M ⊆ [filter] ∧ M.card = m := by
  exact?;
```
**Hint**: Use `Finset.exists_subset_card_eq` with the cardinality hypothesis

### Gap 3 (Line ~282): Reference existing theorem
```lean
exact Nat.sInf_mem ( show ∃ n, RamseyProp n ( s - 1 ) t from by exact? );
```
**Hint**: Use `ramsey_theorem_exists (s-1) t` which is already proven in this file

## Success Criteria
- All 3 `exact?` replaced with working lemma invocations
- File compiles with zero errors
- All theorems proven (no sorries)

## The Code

```lean
import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000

noncomputable section

/-- RamseyProp n s t means every graph on n vertices has clique of size s or independent set of size t -/
def RamseyProp (n s t : ℕ) : Prop :=
  ∀ (G : SimpleGraph (Fin n)) [DecidableRel G.Adj], (∃ k, G.IsNClique s k) ∨ (∃ k, G.IsNIndepSet t k)

/-- The Ramsey number R(s, t) is the smallest n such that RamseyProp n s t holds -/
noncomputable def RamseyNumber (s t : ℕ) : ℕ :=
  sInf { n | RamseyProp n s t }

/-- R(3,3) = 6 -/
theorem ramsey_3_3_eq_6 : RamseyNumber 3 3 = 6 := by
  refine' le_antisymm _ ( _ : 6 ≤ _ );
  · refine' Nat.sInf_le _;
    intro G
    by_contra h_no_clique_or_indep;
    simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
    -- Pigeonhole: vertex 0 has ≥3 neighbors or ≥3 non-neighbors
    have h_pigeonhole : ∀ x : Fin 6, (Finset.filter (fun y => G.Adj x y) (Finset.univ.erase x)).card ≥ 3 ∨
                                      (Finset.filter (fun y => ¬G.Adj x y) (Finset.univ.erase x)).card ≥ 3 := by
      intro x;
      have h : Finset.card (Finset.filter (fun y => G.Adj x y) (Finset.univ.erase x)) +
               Finset.card (Finset.filter (fun y => ¬G.Adj x y) (Finset.univ.erase x)) = 5 := by
        rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ; simp +decide;
      omega;
    obtain h | h := h_pigeonhole 0;
    -- Case: ≥3 neighbors
    · set S := Finset.filter (fun y => G.Adj 0 y) (Finset.univ.erase 0);
      by_cases h_triangle : ∃ u w : Fin 6, u ∈ S ∧ w ∈ S ∧ u ≠ w ∧ G.Adj u w;
      · -- Found triangle with 0
        obtain ⟨ u, w, hu, hw, hne, hadj ⟩ := h_triangle;
        have h_clique : G.IsClique {0, u, w} := by aesop;
        exact h_no_clique_or_indep.1 {0, u, w} h_clique (by simp +decide [hne, Finset.card_insert_of_notMem]; aesop);
      · -- No edges in S → independent set of size 3
        push_neg at h_triangle;
        have h_indep : G.IsIndepSet (S : Set (Fin 6)) := by
          intro u hu w hw hne; exact h_triangle u w hu hw hne;
        -- GAP 1: Extract 3-element subset
        obtain ⟨T, hT_sub, hT_card⟩ : ∃ T : Finset (Fin 6), T ⊆ S ∧ T.card = 3 :=
          Finset.exists_subset_card_eq h;  -- USE THIS LEMMA
        exact h_no_clique_or_indep.2 T (h_indep.mono hT_sub) hT_card;
    -- Case: ≥3 non-neighbors (similar)
    · obtain ⟨ w₁, hw₁, w₂, hw₂, w₃, hw₃, h_distinct ⟩ := Finset.two_lt_card.1 h;
      -- Check all cases for edges among w₁, w₂, w₃
      by_cases h₁ : G.Adj w₁ w₂ <;> by_cases h₂ : G.Adj w₁ w₃ <;> by_cases h₃ : G.Adj w₂ w₃ <;>
      simp_all +decide [ SimpleGraph.adj_comm ];
      -- Each case leads to triangle or independent set
      all_goals (first | exact h_no_clique_or_indep.1 _ (by aesop) (by simp +decide) |
                        exact h_no_clique_or_indep.2 _ (by aesop) (by simp +decide));
  · refine' le_csInf _ _;
    · use 6; exact fun G => by decide;
    · aesop;

/-- RamseyProp is monotonic -/
theorem RamseyProp_mono {n m s t : ℕ} (h : n ≤ m) (hR : RamseyProp n s t) : RamseyProp m s t := by
  intro G;
  obtain ⟨H, hH⟩ : ∃ H : Fin n → Fin m, Function.Injective H := by
    exact ⟨ fun i => ⟨ i, by linarith [ Fin.is_lt i ] ⟩, fun i j hij => by simpa [ Fin.ext_iff ] using hij ⟩;
  specialize hR ( G.comap H ) ; aesop;
  · refine Or.inl ⟨ w.image H, ?_ ⟩;
    simp_all +decide [ SimpleGraph.isNClique_iff, Finset.card_image_of_injective _ hH ];
  · refine Or.inr ⟨ Finset.image H w, ?_ ⟩;
    simp_all +decide [ SimpleGraph.isNIndepSet_iff, Finset.card_image_of_injective _ hH ];

/-- Inductive step: R(s,t) ≤ R(s-1,t) + R(s,t-1) -/
theorem ramsey_step (n m s t : ℕ) (hs : s > 1) (ht : t > 1)
    (hn : RamseyProp n (s - 1) t) (hm : RamseyProp m s (t - 1)) :
    RamseyProp (n + m) s t := by
  intro G
  -- Pick vertex v, partition others by adjacency
  obtain ⟨v, hv⟩ : ∃ v : Fin (n + m),
    (Finset.filter (fun w => G.Adj v w) (Finset.univ.erase v)).card ≥ n ∨
    (Finset.filter (fun w => ¬G.Adj v w) (Finset.univ.erase v)).card ≥ m := by
    by_contra! h;
    have h_card : ∀ x : Fin (n + m),
      (Finset.filter (fun w => G.Adj x w) (Finset.univ.erase x)).card +
      (Finset.filter (fun w => ¬G.Adj x w) (Finset.univ.erase x)).card = n + m - 1 := by
      intro x; rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ;
      simp +decide [ Finset.card_erase_of_mem ( Finset.mem_univ x ) ] ;
    rcases n with ( _ | n ) <;> rcases m with ( _ | m ) <;> aesop;
    exact absurd ( h_card 0 ) ( by linarith [ h 0 ] );
  cases hv;
  -- Case: ≥n neighbors
  · obtain ⟨ S, hS ⟩ := Finset.exists_subset_card_eq ‹_›;
    have h_subgraph := hn ( SimpleGraph.comap ( fun x : Fin n => S.orderEmbOfFin hS.2 x ) G );
    aesop;
    · refine Or.inl ⟨ Insert.insert v (Finset.image (S.orderEmbOfFin hS.2) w), ?_ ⟩;
      simp_all +decide [ SimpleGraph.isNClique_iff ];
      constructor <;> aesop;
    · exact Or.inr ⟨ Finset.image (S.orderEmbOfFin hS.2) w, by aesop ⟩;
  -- Case: ≥m non-neighbors
  · -- GAP 2: Extract m-element subset
    obtain ⟨M, hM_sub, hM_card⟩ : ∃ M : Finset (Fin (n + m)),
      M ⊆ Finset.filter (fun w => ¬G.Adj v w) (Finset.univ.erase v) ∧ M.card = m :=
      Finset.exists_subset_card_eq ‹_›;  -- USE THIS LEMMA
    have h_ind := hm ( G.comap ( M.orderEmbOfFin hM_card ) );
    aesop;
    · exact Or.inl ⟨ Finset.image (M.orderEmbOfFin hM_card) w, by aesop ⟩;
    · refine Or.inr ⟨ Insert.insert v (Finset.image (M.orderEmbOfFin hM_card) w), ?_ ⟩;
      simp_all +decide [ SimpleGraph.isNIndepSet_iff ];

/-- Ramsey's theorem: For all s, t, there exists n such that RamseyProp n s t holds -/
theorem ramsey_theorem_exists (s t : ℕ) : ∃ n, RamseyProp n s t := by
  induction' s using Nat.strong_induction_on with s ih_s generalizing t;
  by_cases hs : s ≤ 1;
  · rcases s with ( _ | _ | s ) <;> simp_all +decide;
    · use 0; simp [RamseyProp];
    · use 1; intro G; left; use { ⟨0, by norm_num⟩ }; simp +decide [ SimpleGraph.isNClique_iff ];
  · push_neg at hs;
    induction' t using Nat.strong_induction_on with t ih_t;
    by_cases ht : t ≤ 1;
    · rcases t with ( _ | _ | t ) <;> simp_all +decide;
      · use s; intro G; right; use ∅; simp +decide [ SimpleGraph.isNIndepSet_iff ];
      · use 1; intro G; right; use { 0 }; simp +decide [ SimpleGraph.isNIndepSet_iff ];
    · push_neg at ht;
      -- GAP 3: Use ramsey_theorem_exists recursively
      obtain ⟨n1, hn1⟩ := ih_s (s - 1) (Nat.pred_lt (by omega)) t;
      obtain ⟨n2, hn2⟩ := ih_t (t - 1) (Nat.pred_lt (by omega));
      exact ⟨ n1 + n2, ramsey_step n1 n2 s t (by omega) (by omega) hn1 hn2 ⟩;

/-- R(2, t) = t -/
theorem ramsey_2_t (t : ℕ) (ht : t ≥ 2) : RamseyNumber 2 t = t := by
  refine' le_antisymm _ _;
  · have h_ramsey_2t : RamseyProp t 2 t := by
      intro G;
      by_cases h : ∃ k : Finset ( Fin t ), G.IsNClique 2 k <;> aesop;
      use Finset.univ; simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
    exact Nat.sInf_le h_ramsey_2t;
  · refine' le_csInf _ _;
    · exact Exists.elim ( ramsey_theorem_exists 2 t ) fun n hn => ⟨ n, hn ⟩;
    · aesop;

/-- R(s, 2) = s -/
theorem ramsey_s_2 (s : ℕ) (hs : s ≥ 2) : RamseyNumber s 2 = s := by
  refine' le_antisymm ( Nat.sInf_le _ ) _;
  · intro G;
    by_cases h : ∃ k : Finset ( Fin s ), G.IsNClique s k <;> aesop;
    contrapose! h;
    use Finset.univ;
    simp_all +decide [ SimpleGraph.isNClique_iff ];
  · refine' le_csInf _ _;
    · exact Exists.elim ( ramsey_theorem_exists s 2 ) fun n hn => ⟨ n, hn ⟩;
    · intro n hn; contrapose! hn; aesop;

end
```
