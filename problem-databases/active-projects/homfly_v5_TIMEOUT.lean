/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 807cfd57-9ae1-4c41-acd8-bb69d8a4a422

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise




open scoped BigOperators Real Nat Classical Pointwise

abbrev SparsePoly2 := List (Int × Int × Int)

def SparsePoly2.merge (fuel : Nat) (p : SparsePoly2) : SparsePoly2 :=
  match fuel with
  | 0 => []
  | fuel + 1 =>
    match p with
    | [] => []
    | [x] => if x.2.2 == 0 then [] else [x]
    | x :: y :: rest =>
      if x.1 == y.1 && x.2.1 == y.2.1 then
        merge fuel ((x.1, x.2.1, x.2.2 + y.2.2) :: rest)
      else
        if x.2.2 == 0 then merge fuel (y :: rest) else x :: merge fuel (y :: rest)

def SparsePoly2.normalize (p : SparsePoly2) : SparsePoly2 :=
  let sorted := p.mergeSort (fun a b => if a.1 != b.1 then a.1 < b.1 else a.2.1 < b.2.1)
  SparsePoly2.merge (sorted.length + 1) sorted

def SparsePoly2.add (p1 p2 : SparsePoly2) : SparsePoly2 :=
  SparsePoly2.normalize (p1 ++ p2)

def SparsePoly2.mul (p1 p2 : SparsePoly2) : SparsePoly2 :=
  let raw := p1.foldl (fun acc t1 =>
    acc ++ p2.map (fun t2 => (t1.1 + t2.1, t1.2.1 + t2.2.1, t1.2.2 * t2.2.2))) []
  SparsePoly2.normalize raw

def SparsePoly2.mul_norm (p1 p2 : SparsePoly2) : SparsePoly2 :=
  (SparsePoly2.mul p1 p2).normalize

abbrev BraidWord := List Int
abbrev Permutation := List Nat
abbrev Hecke_elt := List (Permutation × SparsePoly2)

def Permutation.id (n : Nat) : Permutation :=
  List.range n

def Permutation.swap_values (p : Permutation) (v1 v2 : Nat) : Permutation :=
  p.map (fun x => if x == v1 then v2 else if x == v2 then v1 else x)

def Permutation.pos (p : Permutation) (v : Nat) : Option Nat :=
  let rec aux (l : List Nat) (i : Nat) : Option Nat :=
    match l with
    | [] => none
    | h :: t => if h == v then some i else aux t (i+1)
  aux p 0

def poly_q : SparsePoly2 := [(2, 0, 1)]
def poly_q_inv : SparsePoly2 := [(-2, 0, 1)]
def poly_diff : SparsePoly2 := [(2, 0, 1), (-2, 0, -1)] -- q - q⁻¹

def Hecke_elt.merge (fuel : Nat) (h : Hecke_elt) : Hecke_elt :=
  match fuel with
  | 0 => []
  | fuel + 1 =>
    match h with
    | [] => []
    | [x] => if x.2 == [] then [] else [x]
    | x :: y :: rest =>
      if x.1 == y.1 then
        merge fuel ((x.1, SparsePoly2.add x.2 y.2) :: rest)
      else
        if x.2 == [] then merge fuel (y :: rest) else x :: merge fuel (y :: rest)

def Hecke_elt.normalize (h : Hecke_elt) : Hecke_elt :=
  let sorted := h.mergeSort (fun a b => a.1 < b.1)
  Hecke_elt.merge (sorted.length + 1) sorted

def Hecke_elt.scale (h : Hecke_elt) (s : SparsePoly2) : Hecke_elt :=
  h.map (fun (p, c) => (p, SparsePoly2.mul_norm c s))

def Hecke_elt.add (h1 h2 : Hecke_elt) : Hecke_elt :=
  Hecke_elt.normalize (h1 ++ h2)

def Hecke_elt.mul_gen (h : Hecke_elt) (i : Nat) (inv : Bool) : Hecke_elt :=
  let v1 := i - 1
  let v2 := i
  let raw := h.foldl (fun acc (term : Permutation × SparsePoly2) =>
    let p := term.1
    let c := term.2
    let pos1 := Permutation.pos p v1
    let pos2 := Permutation.pos p v2
    match pos1, pos2 with
    | some idx1, some idx2 =>
      let p_prime := Permutation.swap_values p v1 v2
      if idx1 < idx2 then
        if inv then
          let term1 := [(p_prime, c)]
          let term2 := [(p, SparsePoly2.mul_norm c poly_diff)]
          let term2_neg := term2.map (fun (perm, poly) => (perm, poly.map (fun (e1, e2, co) => (e1, e2, -co))))
          acc ++ term1 ++ term2_neg
        else
          acc ++ [(p_prime, c)]
      else
        if inv then
          acc ++ [(p_prime, c)]
        else
          let term1 := [(p, SparsePoly2.mul_norm c poly_diff)]
          let term2 := [(p_prime, c)]
          acc ++ term1 ++ term2
    | _, _ => acc
  ) []
  Hecke_elt.normalize raw

def poly_z : SparsePoly2 := [(0, 1, 1)]
def poly_mu : SparsePoly2 := [(1, -1, 1), (-1, -1, -1)]

def Permutation.get_val (p : Permutation) (i : Nat) : Nat :=
  match p.get? i with
  | some v => v
  | none => i

def Permutation.swap_pos (p : Permutation) (i j : Nat) : Permutation :=
  let indexed := p.zip (List.range p.length)
  indexed.map (fun (val, idx) =>
    if idx == i then p.get_val j
    else if idx == j then p.get_val i
    else val)

def Permutation.inversions (p : Permutation) : Nat :=
  let rec count (l : List Nat) : Nat :=
    match l with
    | [] => 0
    | h :: t => (t.filter (fun x => h > x)).length + count t
  count p

def compute_writhe (b : BraidWord) : Int :=
  b.foldl (fun acc gen => if gen > 0 then acc + 1 else acc - 1) 0

def braid_to_Hecke (n : Nat) (b : BraidWord) : Hecke_elt :=
  b.foldl (fun acc gen =>
    let idx := gen.natAbs
    let inv := gen < 0
    Hecke_elt.mul_gen acc idx inv
  ) [(Permutation.id n, [(0, 0, 1)])]

def poly_diff_trace : SparsePoly2 := [(2, 0, 1), (-2, 0, -1)]

def trace_perm (fuel : Nat) (p : Permutation) : SparsePoly2 :=
  match fuel with
  | 0 => poly_mu
  | fuel + 1 =>
    let n := p.length
    let non_fixed := (List.range n).filter (fun idx => p.get_val idx != idx)
    match non_fixed.getLast? with
    | none => poly_mu
    | some k_idx =>
      let k := k_idx + 1
      let descents := (List.range k_idx).filter (fun idx => p.get_val idx > p.get_val (idx + 1))
      match descents.getLast? with
      | none => poly_mu
      | some i_minus_1 =>
        let i := i_minus_1 + 1
        if i == k then
          let p_next := Permutation.swap_pos p (k - 1) k
          SparsePoly2.mul_norm poly_z (trace_perm fuel p_next)
        else
          let p_si := Permutation.swap_pos p (i - 1) i
          let si_p_si := Permutation.swap_values p_si (i - 1) i
          let l_p := Permutation.inversions p
          let l_si_p_si := Permutation.inversions si_p_si
          if l_si_p_si < l_p then
             let term1 := SparsePoly2.mul_norm poly_diff_trace (trace_perm fuel p_si)
             let term2 := trace_perm fuel si_p_si
             SparsePoly2.add term1 term2
          else
             trace_perm fuel si_p_si

def Hecke_elt.ocneanu_trace (n : Nat) (h : Hecke_elt) : SparsePoly2 :=
  h.foldl (fun acc (p, c) =>
    SparsePoly2.add acc (SparsePoly2.mul_norm c (trace_perm 100 p))
  ) []

def homfly_normalize (p : SparsePoly2) (writhe : Int) : SparsePoly2 :=
  let writhe_factor := [(writhe, 0, -1)]
  SparsePoly2.mul_norm p writhe_factor

def homfly_polynomial_computable (b : BraidWord) : SparsePoly2 :=
  let n := b.foldl (fun m x => max m x.natAbs) 0 + 1
  let hecke := braid_to_Hecke n b
  let trace := Hecke_elt.ocneanu_trace n hecke
  let writhe := compute_writhe b
  homfly_normalize trace writhe

#check AddMonoidAlgebra
#synth Zero (AddMonoidAlgebra Int (Int × Int))
#synth Add (AddMonoidAlgebra Int (Int × Int))
#check AddMonoidAlgebra.single

abbrev LaurentPolynomial2 := AddMonoidAlgebra Int (Int × Int)

def SparsePoly2.toLaurent (p : SparsePoly2) : LaurentPolynomial2 :=
  p.foldl (fun acc (e1, e2, c) => acc + AddMonoidAlgebra.single (e1, e2) c) 0

theorem SparsePoly2.toLaurent_add (p1 p2 : SparsePoly2) :
  (SparsePoly2.add p1 p2).toLaurent = p1.toLaurent + p2.toLaurent := by
  unfold SparsePoly2.add;
  unfold SparsePoly2.normalize;
  -- By definition of `SparsePoly2.merge`, it combines the two lists and removes duplicates, which corresponds to adding the two Laurent polynomials.
  have h_merge : ∀ (l1 l2 : SparsePoly2), List.sum (l1.map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c)) + List.sum (l2.map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c)) = List.sum ((SparsePoly2.merge (l1.length + l2.length + 1) (List.mergeSort (l1 ++ l2) (fun (a b : ℤ × ℤ × ℤ) => if (a.1 != b.1) = Bool.true then Decidable.decide (a.1 < b.1) else Decidable.decide (a.2.1 < b.2.1)))).map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c)) := by
    intro l1 l2;
    -- By induction on the length of the list, we can show that the sum of the Laurent polynomials of the merged list is equal to the sum of the Laurent polynomials of the original lists.
    have h_merge_ind : ∀ (l : SparsePoly2) (fuel : Nat), fuel ≥ l.length → List.sum (l.map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c)) = List.sum ((SparsePoly2.merge fuel l).map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c)) := by
      intros l fuel hfuel
      induction' fuel with fuel ih generalizing l;
      · cases l <;> aesop;
      · rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp +arith +decide [ SparsePoly2.merge ] at hfuel ⊢;
        · aesop;
        · split_ifs <;> simp_all +decide [ ← add_assoc ];
          · specialize ih ( ( y.1, y.2.1, x.2.2 + y.2.2 ) :: l ) ; aesop;
          · specialize ih ( y :: l ) ; aesop;
          · rw [ ← ih ( y :: l ) ( by simpa using by linarith ) ] ; simp +decide [ add_assoc ];
    rw [ ← h_merge_ind ];
    · -- Since merge sort is a permutation of the original list, the sum of the elements is preserved.
      have h_perm : List.Perm (List.mergeSort (l1 ++ l2) (fun (a b : ℤ × ℤ × ℤ) => if (a.1 != b.1) = Bool.true then Decidable.decide (a.1 < b.1) else Decidable.decide (a.2.1 < b.2.1))) (l1 ++ l2) := by
        exact?;
      rw [ ← List.sum_append ];
      rw [ ← List.map_append, h_perm.map _ |> List.Perm.sum_eq ];
    · rw [ List.length_mergeSort ] ; simp +arith +decide;
  unfold SparsePoly2.toLaurent; aesop;
  convert h_merge p1 p2 |> Eq.symm using 1;
  · rw [ List.sum_eq_foldl ];
    rw [ List.foldl_map ];
  · congr! 1;
    · rw [ List.sum_eq_foldl ];
      rw [ List.foldl_map ];
    · induction p2 using List.reverseRecOn <;> aesop

theorem SparsePoly2.toLaurent_normalize (p : SparsePoly2) :
  p.normalize.toLaurent = p.toLaurent := by
    -- By definition of `normalize`, we know that `normalize p` is equivalent to `p` in terms of their Laurent polynomial representations.
    have h_normalize_eq : SparsePoly2.toLaurent (SparsePoly2.normalize p) = SparsePoly2.toLaurent p := by
      have h_sorted : SparsePoly2.toLaurent (List.mergeSort p (fun a b => if a.1 != b.1 then a.1 < b.1 else a.2.1 < b.2.1)) = SparsePoly2.toLaurent p := by
        have h_foldl_eq : ∀ (l1 l2 : SparsePoly2), List.Perm l1 l2 → SparsePoly2.toLaurent l1 = SparsePoly2.toLaurent l2 := by
          intros l1 l2 h_perm
          have h_foldl_eq : ∀ (l : SparsePoly2), SparsePoly2.toLaurent l = List.sum (List.map (fun (e1, e2, c) => AddMonoidAlgebra.single (e1, e2) c) l) := by
            unfold SparsePoly2.toLaurent; aesop;
            induction l using List.reverseRecOn <;> aesop
          generalize_proofs at *; (
          rw [ h_foldl_eq, h_foldl_eq ] ; exact h_perm.map _ |> List.Perm.sum_eq;)
        generalize_proofs at *; (
        exact h_foldl_eq _ _ ( List.Perm.symm <| by exact? ))
      have h_merge : SparsePoly2.toLaurent (SparsePoly2.merge (List.length p + 1) (List.mergeSort p (fun a b => if a.1 != b.1 then a.1 < b.1 else a.2.1 < b.2.1))) = SparsePoly2.toLaurent (List.mergeSort p (fun a b => if a.1 != b.1 then a.1 < b.1 else a.2.1 < b.2.1)) := by
        have h_merge_eq : ∀ (l : List (Int × Int × Int)), SparsePoly2.toLaurent (SparsePoly2.merge (List.length l + 1) l) = SparsePoly2.toLaurent l := by
          intro l;
          induction' n : l.length + 1 with n ih generalizing l <;> simp_all +decide [ List.mergeSort ];
          rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide [ SparsePoly2.merge ];
          · unfold SparsePoly2.toLaurent; aesop;
          · split_ifs <;> simp_all +decide [ SparsePoly2.toLaurent ];
            specialize ih ( y :: l ) ; aesop;
            convert congr_arg ( fun x => AddMonoidAlgebra.single ( fst, fst_2 ) snd + x ) ih using 1;
            · induction' ( SparsePoly2.merge ( l.length + 1 + 1 ) ( ( fst_1, fst_3, snd_1 ) :: l ) ) using List.reverseRecOn with x l ih <;> aesop;
              rw [ add_assoc ];
            · clear ih h_sorted h_1 h; induction' l using List.reverseRecOn with l ih <;> aesop;
              rw [ add_assoc ];
        convert h_merge_eq ( List.mergeSort p ( fun a b => if ( a.1 != b.1 ) = Bool.true then Decidable.decide ( a.1 < b.1 ) else Decidable.decide ( a.2.1 < b.2.1 ) ) ) using 1;
        rw [ List.length_mergeSort ]
      unfold SparsePoly2.normalize; aesop;
    generalize_proofs at *;
    exact h_normalize_eq

theorem SparsePoly2.toLaurent_mul (p1 p2 : SparsePoly2) :
  (SparsePoly2.mul p1 p2).toLaurent = p1.toLaurent * p2.toLaurent := by
    unfold SparsePoly2.mul;
    rw [ SparsePoly2.toLaurent_normalize ];
    induction p1 using List.reverseRecOn <;> aesop;
    · unfold SparsePoly2.toLaurent; aesop;
    · unfold SparsePoly2.toLaurent at * ; aesop;
      -- By the distributive property of multiplication over addition, we can split the foldl into two parts.
      have h_dist : ∀ (acc : LaurentPolynomial2) (p2 : SparsePoly2), List.foldl (fun (acc : LaurentPolynomial2) (x : ℤ × ℤ × ℤ) => acc + AddMonoidAlgebra.single (x.1, x.2.1) x.2.2) acc (List.map (fun (t2 : ℤ × ℤ × ℤ) => (fst + t2.1, fst_1 + t2.2.1, snd * t2.2.2)) p2) = acc + AddMonoidAlgebra.single (fst, fst_1) snd * List.foldl (fun (acc : LaurentPolynomial2) (x : ℤ × ℤ × ℤ) => acc + AddMonoidAlgebra.single (x.1, x.2.1) x.2.2) 0 p2 := by
        intros acc p2; induction' p2 using List.reverseRecOn with p2 ih <;> aesop;
        simp +decide [ mul_add, add_assoc ];
      rw [ h_dist, add_mul ]

def Hecke_elt.to_fun (h : Hecke_elt) (p : Permutation) : LaurentPolynomial2 :=
  h.foldl (fun acc (p', c) => if p' == p then acc + c.toLaurent else acc) 0

theorem Hecke_elt.to_fun_add (h1 h2 : Hecke_elt) :
  (Hecke_elt.add h1 h2).to_fun = h1.to_fun + h2.to_fun := by
  -- By definition of `Hecke_elt.merge`, it combines like terms and removes zero coefficients.
  have h_merge : ∀ (h : Hecke_elt), (Hecke_elt.normalize h).to_fun = h.to_fun := by
    unfold Hecke_elt.normalize;
    -- By definition of `Hecke_elt.merge`, it combines like terms and removes zero coefficients, which is already captured by the linearCombination function.
    have h_merge : ∀ (h : Hecke_elt), (Hecke_elt.merge (h.length + 1) h).to_fun = h.to_fun := by
      intro h;
      induction' n : List.length h with n ih generalizing h;
      · cases h <;> aesop;
      · rcases h with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide;
        · -- By definition of `merge`, when the list has only one element, it returns that element.
          simp [Hecke_elt.merge];
          unfold Hecke_elt.to_fun; aesop;
        · rw [ Hecke_elt.merge ];
          aesop;
          · unfold Hecke_elt.to_fun; aesop;
            congr! 3;
            exact?;
          · unfold Hecke_elt.to_fun; aesop;
          · specialize ih ( ( fst_1, snd_1 ) :: l ) ; aesop;
            unfold Hecke_elt.to_fun at * ; aesop;
            ext p; specialize ih; replace ih := congr_fun ih p; aesop;
            -- By definition of foldl, we can split the operation into the initial value and the foldl on the rest of the list.
            have h_foldl_split : ∀ (l : List (Permutation × SparsePoly2)) (init : LaurentPolynomial2), List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) init l = init + List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) 0 l := by
              intro l init; induction' l using List.reverseRecOn with l ih <;> aesop;
              ring;
            grind;
    intros h;
    specialize h_merge ( List.mergeSort h fun ( a b : Permutation × SparsePoly2 ) => Decidable.decide ( a.1 < b.1 ) ) ; aesop;
    -- Since the merge sort is a permutation of the original list, their linear combinations are equal.
    have h_perm : List.Perm (List.mergeSort h fun (a b : Permutation × SparsePoly2) => Decidable.decide (a.1 < b.1)) h := by
      exact?;
    have h_perm : ∀ (l1 l2 : Hecke_elt), List.Perm l1 l2 → l1.to_fun = l2.to_fun := by
      intros l1 l2 h_perm; induction h_perm <;> aesop;
      · unfold Hecke_elt.to_fun at *; aesop;
        ext p; specialize a_ih; replace a_ih := congr_fun a_ih p; aesop;
        have h_foldl_eq : ∀ (l : List (Permutation × SparsePoly2)) (acc : LaurentPolynomial2), List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) acc l = acc + List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) 0 l := by
          intro l acc; induction' l using List.reverseRecOn with l ih <;> aesop;
          rw [ add_assoc ];
        rw [ h_foldl_eq l₁ snd.toLaurent, h_foldl_eq l₂ snd.toLaurent, a_ih ];
      · unfold Hecke_elt.to_fun; simp +decide [ add_comm ] ;
        grind +ring;
    exact h_perm _ _ ‹_›;
  unfold Hecke_elt.add; aesop;
  unfold Hecke_elt.to_fun; aesop;
  ext p; simp +decide [ List.foldl_assoc ] ;
  induction h2 using List.reverseRecOn <;> aesop;
  ring

def Hecke_elt.mul_gen_term (term : Permutation × SparsePoly2) (i : Nat) (inv : Bool) : Hecke_elt :=
  let v1 := i - 1
  let v2 := i
  let p := term.1
  let c := term.2
  let pos1 := Permutation.pos p v1
  let pos2 := Permutation.pos p v2
  match pos1, pos2 with
  | some idx1, some idx2 =>
    let p_prime := Permutation.swap_values p v1 v2
    if idx1 < idx2 then
      if inv then
        let term1 := [(p_prime, c)]
        let term2 := [(p, SparsePoly2.mul_norm c poly_diff)]
        let term2_neg := term2.map (fun (perm, poly) => (perm, poly.map (fun (e1, e2, co) => (e1, e2, -co))))
        term1 ++ term2_neg
      else
        [(p_prime, c)]
    else
      if inv then
        [(p_prime, c)]
      else
        let term1 := [(p, SparsePoly2.mul_norm c poly_diff)]
        let term2 := [(p_prime, c)]
        term1 ++ term2
  | _, _ => []

theorem Hecke_elt.mul_gen_eq_flatMap (h : Hecke_elt) (i : Nat) (inv : Bool) :
  Hecke_elt.to_fun (Hecke_elt.mul_gen h i inv) =
  Hecke_elt.to_fun (h.flatMap (fun t => Hecke_elt.mul_gen_term t i inv)) := by
  unfold Hecke_elt.mul_gen; aesop;
  · unfold Hecke_elt.to_fun; aesop;
    unfold Hecke_elt.mul_gen_term; aesop;
    congr! 1;
    -- By induction on the list, we can show that the foldl of the normalized list is equal to the foldl of the flatMap.
    have h_ind : ∀ (l : List (Permutation × SparsePoly2)), List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 (Hecke_elt.normalize l) = List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 l := by
      intro l;
      -- By definition of merge, the foldl of the merged list is the same as the foldl of the original list.
      have h_merge : ∀ (l : List (Permutation × SparsePoly2)), List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 (Hecke_elt.merge (List.length l + 1) l) = List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 l := by
        intro l; induction' n : l.length using Nat.strong_induction_on with n ih generalizing l; rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide ;
        · aesop;
        · bound;
          · simp +decide [ Hecke_elt.merge ];
            aesop;
          · simp +decide [ Hecke_elt.merge ];
            aesop;
        · rw [ Hecke_elt.merge ] ; aesop;
          · congr! 1;
            exact?;
          · specialize ih ( l.length + 1 ) ( by linarith ) ( ( fst_1, snd_1 ) :: l ) ; aesop;
            convert congr_arg ( fun x => snd.toLaurent + x ) ih using 1;
            · induction' ( Hecke_elt.merge ( l.length + 2 ) ( ( fst_1, snd_1 ) :: l ) ) using List.reverseRecOn with x xs ih <;> aesop;
              ring;
            · clear ih h_1 h_2 h_3;
              induction l using List.reverseRecOn <;> aesop;
              ring;
      convert h_merge ( List.mergeSort l ( fun a b => a.1 < b.1 ) ) using 1;
      have h_perm : List.Perm l (List.mergeSort l (fun a b => a.1 < b.1)) := by
        exact?;
      have h_foldl_perm : ∀ (l1 l2 : List (Permutation × SparsePoly2)), List.Perm l1 l2 → List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 l1 = List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = ‹Permutation› then acc + x.2.toLaurent else acc) 0 l2 := by
        intros l1 l2 h_perm; induction' h_perm with l1 l2 h_perm ih <;> aesop;
        · have h_foldl_perm : ∀ (l1 l2 : List (Permutation × SparsePoly2)), List.Perm l1 l2 → ∀ (acc : LaurentPolynomial2), List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) acc l1 = List.foldl (fun (acc : LaurentPolynomial2) (x : Permutation × SparsePoly2) => if x.1 = fst then acc + x.2.toLaurent else acc) acc l2 := by
            intros l1 l2 h_perm acc; induction' h_perm with l1 l2 h_perm ih generalizing acc <;> aesop;
            ac_rfl;
          exact h_foldl_perm _ _ ih _;
        · rw [ add_comm ];
      exact h_foldl_perm _ _ h_perm;
    convert h_ind _ using 2;
    induction' h using List.reverseRecOn with h ih;
    · rfl;
    · simp +decide [ *, List.flatMap_append ];
      cases h : ih.1.pos ( i - 1 ) <;> cases h' : ih.1.pos i <;> simp +decide [ h, h' ];
      grind;
  · -- By definition of `Hecke_elt.to_fun`, we can expand the left-hand side.
    have h_expand : ∀ (h : Hecke_elt), (Hecke_elt.normalize h).to_fun = h.to_fun := by
      intro h;
      -- By definition of `Hecke_elt.to_fun`, we can expand the left-hand side using the properties of `merge` and `foldl`.
      have h_expand : ∀ (h : Hecke_elt), (Hecke_elt.merge (h.length + 1) h).to_fun = h.to_fun := by
        intro h;
        induction' n : List.length h + 1 with n ih generalizing h <;> aesop;
        rcases h with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide;
        · rfl;
        · -- By definition of `Hecke_elt.merge`, merging a list with one element returns the list itself.
          simp [Hecke_elt.merge];
          unfold Hecke_elt.to_fun; aesop;
        · rw [ Hecke_elt.merge ] ; aesop;
          · unfold Hecke_elt.to_fun; aesop;
            congr! 3;
            exact?;
          · unfold Hecke_elt.to_fun; aesop;
          · specialize ih ( ( fst_1, snd_1 ) :: l ) ; aesop;
            unfold Hecke_elt.to_fun at * ; aesop;
            simp_all +decide [ funext_iff ];
            intro x; specialize ih x; split_ifs at * <;> simp_all +decide [ add_comm, add_left_comm, add_assoc ] ;
            convert congr_arg ( fun y => snd.toLaurent + y ) ih using 1;
            · induction' ( Hecke_elt.merge ( l.length + 2 ) ( ( fst_1, snd_1 ) :: l ) ) using List.reverseRecOn with l ih <;> aesop;
              ring;
            · clear ih h_3 h_2 h_1 ‹fst = x› ‹¬fst_1 = x›; induction' l using List.reverseRecOn with l ih <;> aesop;
              ring;
      convert h_expand _ using 1;
      -- Since the order of elements in the list doesn't affect the sum, we can conclude that the to_fun of the sorted list is equal to the to_fun of the original list.
      have h_sum_eq : ∀ (l1 l2 : Hecke_elt), List.Perm l1 l2 → l1.to_fun = l2.to_fun := by
        intros l1 l2 h_perm
        have h_sum_eq : ∀ (p : Permutation), (l1.foldl (fun acc (p', c) => if p' == p then acc + c.toLaurent else acc) 0) = (l2.foldl (fun acc (p', c) => if p' == p then acc + c.toLaurent else acc) 0) := by
          intro p; exact (by
          have h_sum_eq : ∀ (l : Hecke_elt), List.foldl (fun acc (p', c) => if p' == p then acc + c.toLaurent else acc) 0 l = List.sum (List.map (fun (p', c) => if p' == p then c.toLaurent else 0) l) := by
            intro l; induction' l using List.reverseRecOn with l ih <;> aesop;
          rw [ h_sum_eq l1, h_sum_eq l2, h_perm.map _ |> List.Perm.sum_eq ]);
        exact?;
      exact h_sum_eq _ _ ( List.Perm.symm <| by exact? );
    convert h_expand _ using 1;
    unfold Hecke_elt.mul_gen_term; aesop;
    -- By definition of `List.flatMap`, we can rewrite the left-hand side as a foldl operation.
    have h_flatMap_foldl : ∀ (l : List (Permutation × SparsePoly2)) (f : Permutation × SparsePoly2 → List (Permutation × SparsePoly2)), List.flatMap f l = List.foldl (fun acc term => acc ++ f term) [] l := by
      intros l f; induction' l using List.reverseRecOn with l ih <;> aesop;
    congr! 1;
    convert h_flatMap_foldl h _ using 3;
    ext ⟨p, c⟩; simp [List.flatMap];
    cases h : p.pos ( i - 1 ) <;> cases h' : p.pos i <;> simp +decide [ h, h' ];
    split_ifs <;> simp +decide [ *, List.getElem?_append ]

#check Hecke_elt.mul_gen_term

theorem SparsePoly2.toLaurent_map_neg (p : SparsePoly2) :
  SparsePoly2.toLaurent (p.map (fun (e1, e2, c) => (e1, e2, -c))) = - SparsePoly2.toLaurent p := by
    unfold SparsePoly2.toLaurent;
    induction p using List.reverseRecOn <;> aesop;
    -- Apply the commutativity of addition in the Laurent polynomial ring.
    apply add_comm

theorem Hecke_elt.to_fun_append (h1 h2 : Hecke_elt) :
  (h1 ++ h2).to_fun = h1.to_fun + h2.to_fun := by
    -- By definition of `Hecke_elt.to_fun`, we can rewrite the left-hand side as the foldl of the sum of the terms in `h1` and `h2`.
    apply funext; intro p; simp [Hecke_elt.to_fun];
    -- The foldl operation is associative, so combining two folds is the same as combining their results.
    have h_assoc : ∀ (l1 l2 : Hecke_elt), List.foldl (fun acc x => if x.1 = p then acc + x.2.toLaurent else acc) 0 (l1 ++ l2) = List.foldl (fun acc x => if x.1 = p then acc + x.2.toLaurent else acc) 0 l1 + List.foldl (fun acc x => if x.1 = p then acc + x.2.toLaurent else acc) 0 l2 := by
      intros l1 l2; induction' l2 using List.reverseRecOn with l2 ih <;> aesop;
      rw [ add_assoc ];
    rw [ ← h_assoc, List.foldl_append ]

theorem Hecke_elt.to_fun_mul_gen_term_add (p : Permutation) (c1 c2 : SparsePoly2) (i : Nat) (inv : Bool) :
  Hecke_elt.to_fun (Hecke_elt.mul_gen_term (p, SparsePoly2.add c1 c2) i inv) =
  Hecke_elt.to_fun (Hecke_elt.mul_gen_term (p, c1) i inv) + Hecke_elt.to_fun (Hecke_elt.mul_gen_term (p, c2) i inv) := by
    unfold Hecke_elt.mul_gen_term; aesop;
    · unfold Hecke_elt.to_fun;
      ext p_1; simp +decide [ List.foldl ] ;
      -- By definition of `SparsePoly2.toLaurent`, we can rewrite the goal in terms of the Laurent polynomials.
      have h_toLaurent : (SparsePoly2.add c1 c2).toLaurent = c1.toLaurent + c2.toLaurent := by
        exact?;
      have h_toLaurent_mul : (SparsePoly2.mul_norm (c1.add c2) poly_diff).toLaurent = (c1.add c2).toLaurent * poly_diff.toLaurent := by
        -- By definition of multiplication in the Hecke algebra, we can expand the product using the distributive property.
        have h_mul_expand : ∀ (p1 p2 : SparsePoly2), (p1.mul p2).toLaurent = p1.toLaurent * p2.toLaurent := by
          exact?;
        unfold SparsePoly2.mul_norm; aesop;
        rw [ ← h_toLaurent, ← h_mul_expand ];
        exact?;
      have h_toLaurent_mul : (SparsePoly2.mul_norm c1 poly_diff).toLaurent = c1.toLaurent * poly_diff.toLaurent ∧ (SparsePoly2.mul_norm c2 poly_diff).toLaurent = c2.toLaurent * poly_diff.toLaurent := by
        bound;
        · convert SparsePoly2.toLaurent_mul c1 poly_diff using 1;
          unfold SparsePoly2.mul_norm;
          exact?;
        · convert SparsePoly2.toLaurent_mul c2 poly_diff using 1;
          unfold SparsePoly2.mul_norm; aesop;
          exact?;
      have h_toLaurent_map_neg : (SparsePoly2.toLaurent (List.map (fun (x : ℤ × ℤ × ℤ) => (x.1, x.2.1, -x.2.2)) ((c1.add c2).mul_norm poly_diff))) = - (SparsePoly2.toLaurent ((c1.add c2).mul_norm poly_diff)) ∧ (SparsePoly2.toLaurent (List.map (fun (x : ℤ × ℤ × ℤ) => (x.1, x.2.1, -x.2.2)) (c1.mul_norm poly_diff))) = - (SparsePoly2.toLaurent (c1.mul_norm poly_diff)) ∧ (SparsePoly2.toLaurent (List.map (fun (x : ℤ × ℤ × ℤ) => (x.1, x.2.1, -x.2.2)) (c2.mul_norm poly_diff))) = - (SparsePoly2.toLaurent (c2.mul_norm poly_diff)) := by
        exact ⟨ by exact? , by exact? , by exact? ⟩;
      split_ifs <;> simp_all +decide [ add_mul, mul_add, add_assoc, add_left_comm, add_comm ];
    · unfold Hecke_elt.to_fun; aesop;
      ext; aesop;
      convert congr_arg ( fun x : LaurentPolynomial2 => x ( fst, snd ) ) ( SparsePoly2.toLaurent_add c1 c2 ) using 1;
    · -- By definition of `add`, we can split the sum into two parts.
      have h_add : (c1.add c2).toLaurent = c1.toLaurent + c2.toLaurent := by
        exact?;
      unfold Hecke_elt.to_fun; aesop;
    · unfold Hecke_elt.to_fun; aesop;
      ext; simp [SparsePoly2.toLaurent_add];
      split_ifs <;> simp_all +decide [ add_assoc ];
      · simp +decide only [add_left_comm, add_comm];
        simp +decide [ SparsePoly2.mul_norm, SparsePoly2.toLaurent_mul ];
        simp +decide [ SparsePoly2.toLaurent_mul, SparsePoly2.toLaurent_add, SparsePoly2.toLaurent_normalize ];
        simp +decide [ add_mul ];
      · -- By definition of multiplication in the Laurent polynomial ring, we can expand the left-hand side.
        have h_expand : ∀ (p1 p2 : SparsePoly2), (SparsePoly2.mul p1 p2).toLaurent = p1.toLaurent * p2.toLaurent := by
          exact?;
        unfold SparsePoly2.mul_norm; aesop;
        simp_all +decide [ SparsePoly2.toLaurent_normalize, SparsePoly2.toLaurent_add ];
        simp +decide [ add_mul ]

theorem Hecke_elt.to_fun_mul_gen_append (h1 h2 : Hecke_elt) (i : Nat) (inv : Bool) :
  (Hecke_elt.mul_gen (h1 ++ h2) i inv).to_fun = (Hecke_elt.mul_gen h1 i inv).to_fun + (Hecke_elt.mul_gen h2 i inv).to_fun := by
  rw [Hecke_elt.mul_gen_eq_flatMap]
  rw [Hecke_elt.mul_gen_eq_flatMap]
  rw [Hecke_elt.mul_gen_eq_flatMap]
  rw [List.flatMap_append]
  rw [Hecke_elt.to_fun_append]

theorem Hecke_elt.to_fun_mul_gen_normalize (h : Hecke_elt) (i : Nat) (inv : Bool) :
  (Hecke_elt.mul_gen (Hecke_elt.normalize h) i inv).to_fun = (Hecke_elt.mul_gen h i inv).to_fun := by
  rw [Hecke_elt.mul_gen_eq_flatMap]
  rw [Hecke_elt.mul_gen_eq_flatMap]
  -- We need to show to_fun (flatMap ... (normalize h)) = to_fun (flatMap ... h)
  -- normalize h = merge (sort h)
  -- Step 1: sort
  -- to_fun (flatMap ... (sort h)) = to_fun (flatMap ... h) because sort is a permutation
  -- Step 2: merge
  -- to_fun (flatMap ... (merge l)) = to_fun (flatMap ... l)
  -- This relies on mul_gen_term being linear in the coefficient
  -- By definition of `normalize`, we know that `h.normalize` is equal to `h` in terms of their to_fun. Therefore, we can conclude the proof.
  apply Eq.symm;
  apply Eq.symm; exact (by
    have h_order : ∀ (l : List (Permutation × SparsePoly2)), Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) (Hecke_elt.merge (List.length l + 1) l)) = Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) l) := by
      intro l
      induction' n : l.length using Nat.strong_induction_on with n ih generalizing l;
      rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide;
      · aesop;
      · aesop;
        -- By definition of `merge`, we know that `merge 2 [(fst, snd)]` is equivalent to `merge 1 [(fst, snd)]`.
        have h_merge_2 : Hecke_elt.merge 2 [(fst, snd)] = if snd == [] then [] else [(fst, snd)] := by
          exact?;
        unfold Hecke_elt.to_fun; aesop;
        unfold Hecke_elt.mul_gen_term; aesop;
        · -- Since the empty list's Laurent polynomial is zero, the second function simplifies to zero in all cases.
          funext p; simp [SparsePoly2.toLaurent];
          unfold SparsePoly2.mul_norm; aesop;
          unfold SparsePoly2.mul; aesop;
          unfold SparsePoly2.normalize; aesop;
          -- Since the empty list's Laurent polynomial is zero, the foldl operation on the empty list is zero.
          simp [SparsePoly2.merge, List.mergeSort];
        · unfold SparsePoly2.toLaurent; aesop;
        · unfold SparsePoly2.toLaurent; aesop;
        · -- Since `SparsePoly2.mul_norm [] poly_diff` is the empty list, its `toLaurent` is zero.
          have h_empty : SparsePoly2.mul_norm [] poly_diff = [] := by
            native_decide +revert;
          unfold SparsePoly2.toLaurent; aesop;
      · rw [ show Hecke_elt.merge ( _ + 1 ) ( x :: y :: l ) = if x.1 = y.1 then Hecke_elt.merge ( _ + 1 ) ( ( x.1, SparsePoly2.add x.2 y.2 ) :: l ) else if x.2 = [] then Hecke_elt.merge ( _ + 1 ) ( y :: l ) else x :: Hecke_elt.merge ( _ + 1 ) ( y :: l ) from ?_ ];
        any_goals exact l.length + 1;
        · aesop;
          · simp +decide [ ← add_assoc, ← List.append_assoc, Hecke_elt.to_fun_append ];
            exact?;
          · -- Since appending an element to a list doesn't change the sum if the element is zero, we can conclude that the two sums are equal.
            have h_append_zero : ∀ (l : List (Permutation × SparsePoly2)), Hecke_elt.to_fun (Hecke_elt.mul_gen_term (fst, []) i inv ++ l) = Hecke_elt.to_fun l := by
              unfold Hecke_elt.mul_gen_term; aesop;
              · unfold Hecke_elt.to_fun; aesop;
                -- Since the empty list's Laurent polynomial is zero, adding it to any function should just return the function itself.
                funext p; simp [SparsePoly2.toLaurent];
                unfold SparsePoly2.mul_norm; aesop;
                unfold SparsePoly2.mul; aesop;
                unfold SparsePoly2.normalize; aesop;
                -- Since the empty list's Laurent polynomial is zero, adding it to any function should just return the function itself. Therefore, the two foldl operations are equal.
                simp [SparsePoly2.merge];
              · unfold Hecke_elt.to_fun; aesop;
              · unfold Hecke_elt.to_fun; aesop;
              · unfold Hecke_elt.to_fun; aesop;
                -- Since the empty list's toLaurent is zero, the if statement simplifies to zero.
                have h_empty : (SparsePoly2.mul_norm [] poly_diff).toLaurent = 0 := by
                  -- Since the empty list multiplied by any polynomial is the empty list, and the toLaurent of the empty list is zero, we have:
                  have h_empty : SparsePoly2.mul_norm [] poly_diff = [] := by
                    native_decide +revert;
                  aesop;
                aesop;
            rw [ h_append_zero ];
          · specialize ih ( List.length ( ( fst_1, snd_1 ) :: l ) ) ; aesop;
            convert congr_arg ( fun f => Hecke_elt.to_fun ( Hecke_elt.mul_gen_term ( fst, snd ) i inv ) + f ) ( ih ( ( fst_1, snd_1 ) :: l ) ( by simp +arith +decide ) ) using 1;
            · exact?;
            · convert Hecke_elt.to_fun_append _ _ using 1;
        · bound;
          · exact if_pos ( by aesop );
          · exact if_neg ( by aesop ) |> fun h => h.trans ( if_pos rfl );
          · exact if_neg ( by aesop ) |> fun h => h.trans ( if_neg ( by aesop ) )
    apply Eq.symm; exact (by
      have h_order : Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) (h.mergeSort (fun a b => a.1 < b.1))) = Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) h) := by
        have h_order : List.Perm (List.mergeSort h (fun a b => a.1 < b.1)) h := by
          exact?;
        have h_order : ∀ (l1 l2 : List (Permutation × SparsePoly2)), List.Perm l1 l2 → Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) l1) = Hecke_elt.to_fun (List.flatMap (fun t => Hecke_elt.mul_gen_term t i inv) l2) := by
          intros l1 l2 h_perm;
          induction h_perm <;> aesop;
          · rw [ Hecke_elt.to_fun_append, Hecke_elt.to_fun_append, a_ih ];
          · -- Since the order of the terms in the list doesn't affect the sum, the to_fun of the two lists should be equal.
            have h_comm : ∀ (l1 l2 : List (Permutation × SparsePoly2)), Hecke_elt.to_fun (l1 ++ l2) = Hecke_elt.to_fun l1 + Hecke_elt.to_fun l2 := by
              exact?;
            simp +decide [ h_comm, add_comm, add_left_comm, add_assoc ];
        exact h_order _ _ ‹_›
      convert h_order.symm using 1;
      exact?
    )
  )

theorem Hecke_elt.to_fun_mul_gen_add (h1 h2 : Hecke_elt) (i : Nat) (inv : Bool) :
  (Hecke_elt.mul_gen (Hecke_elt.add h1 h2) i inv).to_fun =
  (Hecke_elt.mul_gen h1 i inv).to_fun + (Hecke_elt.mul_gen h2 i inv).to_fun := by
  unfold Hecke_elt.add
  rw [Hecke_elt.to_fun_mul_gen_normalize]
  rw [Hecke_elt.to_fun_mul_gen_append]

def sigma (i : Nat) (h : Hecke_elt) : Hecke_elt := Hecke_elt.mul_gen h i false
def sigma_inv (i : Nat) (h : Hecke_elt) : Hecke_elt := Hecke_elt.mul_gen h i true

theorem Hecke_elt.to_fun_scale (h : Hecke_elt) (s : SparsePoly2) :
  (Hecke_elt.scale h s).to_fun = h.to_fun * (fun _ => s.toLaurent) := by
  -- By definition of `Hecke_elt.scale`, we can rewrite the left-hand side of the equation as the right-hand side using the properties of function composition and multiplication.
  funext p;
  -- By definition of to_fun and the properties of polynomial multiplication, the sums should be equal.
  simp [Hecke_elt.to_fun, Polynomial.eval];
  induction h using List.reverseRecOn <;> aesop;
  · simp_all +decide [ add_mul, Hecke_elt.scale ];
    -- By definition of `mul_norm`, we know that `snd.mul_norm s` is the normalized version of `snd * s`.
    have h_mul_norm : snd.mul_norm s = (snd.mul s).normalize := by
      rfl;
    rw [ h_mul_norm, SparsePoly2.toLaurent_normalize, SparsePoly2.toLaurent_mul ];
  · unfold Hecke_elt.scale at * ; aesop

def is_ascent (p : Permutation) (i : Nat) : Prop :=
  match p.pos (i-1), p.pos i with
  | some idx1, some idx2 => idx1 < idx2
  | _, _ => False

def is_descent (p : Permutation) (i : Nat) : Prop :=
  match p.pos (i-1), p.pos i with
  | some idx1, some idx2 => idx2 < idx1
  | _, _ => False

theorem swap_values_is_descent (p : Permutation) (i : Nat) (h : is_ascent p i) :
  is_descent (p.swap_values (i-1) i) i := by
  unfold is_ascent at h
  unfold is_descent
  unfold Permutation.swap_values
  unfold Permutation.pos
  -- By definition of permutation swap, the positions of i-1 and i are swapped.
  have h_swap_pos : (p.map (fun x => if x == i - 1 then i else if x == i then i - 1 else x)) = Permutation.swap_values p (i - 1) i := by
    unfold Permutation.swap_values; aesop;
  unfold Permutation.swap_values at h_swap_pos;
  -- By definition of permutation swap, the positions of i-1 and i are swapped. Therefore, the match expression in the goal should evaluate to true.
  have h_swap_pos : ∀ (l : List ℕ) (i : ℕ) (acc : ℕ), Permutation.pos.aux (i - 1) (List.map (fun x => if x == i - 1 then i else if x == i then i - 1 else x) l) acc = Permutation.pos.aux i l acc ∧ Permutation.pos.aux i (List.map (fun x => if x == i - 1 then i else if x == i then i - 1 else x) l) acc = Permutation.pos.aux (i - 1) l acc := by
    intros l i acc; induction' l with hd tl ih generalizing acc <;> simp +decide [ Permutation.pos.aux ] ;
    grind;
  unfold Permutation.pos at h; aesop;

theorem pos_swap_values (p : Permutation) (v1 v2 : Nat) (h_neq : v1 ≠ v2) :
  (p.swap_values v1 v2).pos v1 = p.pos v2 ∧ (p.swap_values v1 v2).pos v2 = p.pos v1 := by
  unfold Permutation.swap_values
  unfold Permutation.pos
  -- We need to show that finding v1 in the mapped list is the same as finding v2 in the original list
  -- and vice versa.
  have h_pos_swap : ∀ (l : List ℕ) (i : ℕ), Permutation.pos.aux v1 (List.map (fun x => if x == v1 then v2 else if x == v2 then v1 else x) l) i = Permutation.pos.aux v2 l i ∧ Permutation.pos.aux v2 (List.map (fun x => if x == v1 then v2 else if x == v2 then v1 else x) l) i = Permutation.pos.aux v1 l i := by
    intros l i; induction l generalizing i <;> simp +decide [ *, Permutation.pos.aux ] ;
    grind;
  -- Apply the hypothesis h_pos_swap with l = p and i = 0.
  apply h_pos_swap

theorem swap_values_involutive (p : Permutation) (v1 v2 : Nat) :
  (p.swap_values v1 v2).swap_values v1 v2 = p := by
  unfold Permutation.swap_values
  rw [List.map_map]
  have h_comp : (fun x => if x == v1 then v2 else if x == v2 then v1 else x) ∘ (fun x => if x == v1 then v2 else if x == v2 then v1 else x) = id := by
    funext x
    simp
    split_ifs <;> simp_all
  rw [h_comp]
  simp

theorem swap_values_is_ascent (p : Permutation) (i : Nat) (h : is_descent p i) :
  is_ascent (p.swap_values (i-1) i) i := by
    have h_posipped : (p.swap_values (i-1) i).pos (i-1) = p.pos i ∧ (p.swap_values (i-1) i).pos i = p.pos (i-1) := by
      -- By definition of swap_values, we know that pos (i-1) and pos i are swapped.
      apply pos_swap_values;
      unfold is_descent at h; aesop;
    unfold is_ascent is_descent at *; aesop;

theorem sigma_ascent_to_fun (p : Permutation) (c : SparsePoly2) (i : Nat) (h : is_ascent p i) :
  (sigma i [(p, c)]).to_fun = Hecke_elt.to_fun [(p.swap_values (i-1) i, c)] := by
    unfold sigma;
    unfold Hecke_elt.mul_gen;
    unfold is_ascent at h; aesop;
    unfold Hecke_elt.normalize; aesop;
    -- Since the list has only one element, the merge operation doesn't change anything.
    simp [Hecke_elt.merge];
    unfold Hecke_elt.to_fun; aesop;

theorem sigma_descent_to_fun (p : Permutation) (c : SparsePoly2) (i : Nat) (h : is_descent p i) :
  (sigma i [(p, c)]).to_fun = Hecke_elt.to_fun ([(p, SparsePoly2.mul_norm c poly_diff)] ++ [(p.swap_values (i-1) i, c)]) := by
    -- By definition of `mul_gen`, we can split the multiplication into the two terms and apply the linearity of the `to_fun` function.
    have h_mul_gen : (sigma i [(p, c)]).to_fun = (Hecke_elt.mul_gen_term (p, c) i false).to_fun := by
      convert Hecke_elt.mul_gen_eq_flatMap _ _ _ using 2;
      norm_num +zetaDelta at *;
    unfold Hecke_elt.mul_gen_term at h_mul_gen; aesop;
    · unfold is_descent at h; aesop;
      linarith;
    · cases h : p.pos ( i - 1 ) <;> cases h' : p.pos i <;> aesop;
      · unfold is_descent at h_1; aesop;
      · unfold is_descent at h_1; aesop;
      · unfold is_descent at h_1; aesop;

lemma sigma_ascent_eq_normalize (p : Permutation) (c : SparsePoly2) (i : Nat) (h : is_ascent p i) :
  sigma i [(p, c)] = Hecke_elt.normalize [(p.swap_values (i-1) i, c)] := by
    unfold sigma;
    unfold Hecke_elt.mul_gen;
    unfold is_ascent at h; aesop;

lemma quadratic_relation_ascent (p : Permutation) (c : SparsePoly2) (i : Nat) (hi : is_ascent p i) :
  (sigma i (sigma i [(p, c)])).to_fun =
  (Hecke_elt.add (Hecke_elt.scale (sigma i [(p, c)]) poly_diff) [(p, c)]).to_fun := by
    have h_expand : (sigma i (sigma i [(p, c)])).to_fun = (sigma i [(p.swap_values (i-1) i, c)]).to_fun := by
      have h_expand : sigma i [(p, c)] = Hecke_elt.normalize [(p.swap_values (i-1) i, c)] := by
        exact?;
      rw [h_expand];
      apply Hecke_elt.to_fun_mul_gen_normalize;
    have h_expand : (sigma i [(p.swap_values (i-1) i, c)]).to_fun = Hecke_elt.to_fun ([(p.swap_values (i-1) i, SparsePoly2.mul_norm c poly_diff)] ++ [(p, c)]) := by
      convert sigma_descent_to_fun ( p.swap_values ( i - 1 ) i ) c i _ using 1;
      · rw [ show ( p.swap_values ( i - 1 ) i ).swap_values ( i - 1 ) i = p by exact? ];
      · exact?;
    have h_expand : (sigma i [(p, c)]).to_fun = Hecke_elt.to_fun [(p.swap_values (i-1) i, c)] := by
      exact?;
    rw [Hecke_elt.to_fun_add];
    rw [Hecke_elt.to_fun_scale];
    aesop;
    ext; simp [Hecke_elt.to_fun];
    split_ifs <;> simp_all +decide [ add_comm ];
    · rw [ ← SparsePoly2.toLaurent_mul ];
      unfold SparsePoly2.mul_norm;
      rw [ SparsePoly2.toLaurent_normalize ];
    · rw [ ← SparsePoly2.toLaurent_mul ];
      unfold SparsePoly2.mul_norm; aesop;
      rw [ SparsePoly2.toLaurent_normalize ]