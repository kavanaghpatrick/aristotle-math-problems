/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c70f1810-c5fe-44f2-9bab-58f4012d3c1f

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of Ramsey property and Ramsey number. RamseyProp n s t means every graph on n vertices has a clique of size s or an independent set of size t. RamseyNumber s t is the minimum such n.
-/
/-- The property that every graph on `n` vertices has a clique of size `s` or an independent set of size `t`. -/
def RamseyProp (n s t : ℕ) : Prop :=
  ∀ (G : SimpleGraph (Fin n)) [DecidableRel G.Adj], (∃ k, G.IsNClique s k) ∨ (∃ k, G.IsNIndepSet t k)

/-- The Ramsey number R(s, t) is the smallest n such that RamseyProp n s t holds. -/
noncomputable def RamseyNumber (s t : ℕ) : ℕ :=
  sInf { n | RamseyProp n s t }

/-
Definition of IsRamseyWitness.
-/
/-- A graph on `Fin n` is a (s, t)-Ramsey witness if it has no clique of size s and no independent set of size t. -/
def IsRamseyWitness (n s t : ℕ) (G : SimpleGraph (Fin n)) : Prop :=
  (∀ k, ¬G.IsNClique s k) ∧ (∀ k, ¬G.IsNIndepSet t k)

/-
Definition of a candidate graph on 42 vertices using distances {1, 2, 4, 8, 16, 32}.
-/
/-- A candidate graph on 42 vertices constructed from a set of distances. -/
def candidateGraph42 : SimpleGraph (Fin 42) :=
  SimpleGraph.fromRel (fun i j => (j - i : Fin 42) ∈ ({1, 2, 4, 8, 16, 32} : Finset (Fin 42)) ∨ (i - j : Fin 42) ∈ ({1, 2, 4, 8, 16, 32} : Finset (Fin 42)))

/-- The set of distances used in the candidate graph. -/
def distances42 : Finset (Fin 42) := {1, 2, 4, 8, 16, 32}

/-
Theorem: The Ramsey number R(3,3) is equal to 6.
-/
/-- R(3,3) = 6. -/
theorem ramsey_3_3_eq_6 : RamseyNumber 3 3 = 6 := by
  refine' le_antisymm _ ( _ : 6 ≤ _ );
  · refine' Nat.sInf_le _;
    -- Let's choose any graph on 6 vertices.
    intro G
    by_contra h_no_clique_or_indep;
    simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
    obtain ⟨x, hx⟩ : ∃ x : Fin 6, ∃ y : Fin 6, ∃ z : Fin 6, x ≠ y ∧ x ≠ z ∧ y ≠ z ∧ (G.Adj x y ∧ G.Adj x z ∧ G.Adj y z ∨ ¬G.Adj x y ∧ ¬G.Adj x z ∧ ¬G.Adj y z) := by
      -- By the pigeonhole principle, for any vertex $x$, there must be three vertices $y$, $z$, and $w$ such that either all three are adjacent to $x$ or none are adjacent to $x$.
      obtain ⟨x, hx⟩ : ∃ x : Fin 6, ∃ y z w : Fin 6, y ≠ x ∧ z ≠ x ∧ w ≠ x ∧ y ≠ z ∧ y ≠ w ∧ z ≠ w ∧ ((G.Adj x y ∧ G.Adj x z ∧ G.Adj x w) ∨ (¬G.Adj x y ∧ ¬G.Adj x z ∧ ¬G.Adj x w)) := by
        have h_pigeonhole : ∀ x : Fin 6, (Finset.filter (fun y => G.Adj x y) (Finset.univ.erase x)).card ≥ 3 ∨ (Finset.filter (fun y => ¬G.Adj x y) (Finset.univ.erase x)).card ≥ 3 := by
          intro x;
          have h_pigeonhole : Finset.card (Finset.filter (fun y => G.Adj x y) (Finset.univ.erase x)) + Finset.card (Finset.filter (fun y => ¬G.Adj x y) (Finset.univ.erase x)) = 5 := by
            rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ; simp +decide;
          omega;
        obtain h | h := h_pigeonhole 0;
        · obtain ⟨ y, hy, z, hz, w, hw, h ⟩ := Finset.two_lt_card.1 h;
          exact ⟨ 0, y, z, w, by aesop ⟩;
        · obtain ⟨ y, hy, z, hz, w, hw, h ⟩ := Finset.two_lt_card.1 h;
          exact ⟨ 0, y, z, w, by aesop ⟩;
      grind;
    obtain ⟨ y, z, hxy, hxz, hyz, h | h ⟩ := hx <;> have := h_no_clique_or_indep.1 { x, y, z } <;> have := h_no_clique_or_indep.2 { x, y, z } <;> simp_all +decide [ SimpleGraph.isClique_iff, SimpleGraph.isIndepSet_iff ];
    simp_all +decide [ Set.Pairwise ];
    simp_all +decide [ SimpleGraph.adj_comm ];
  · refine' le_csInf _ _;
    · use 6;
      -- Let's choose any graph $G$ on 6 vertices.
      intro G hG
      by_contra h_contra;
      simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
      -- Let's pick any vertex $v$ in $G$.
      obtain ⟨v, hv⟩ : ∃ v : Fin 6, (Finset.filter (fun w => G.Adj v w) (Finset.univ \ {v})).card ≥ 3 ∨ (Finset.filter (fun w => ¬G.Adj v w) (Finset.univ \ {v})).card ≥ 3 := by
        have h_pigeonhole : ∀ v : Fin 6, (Finset.filter (fun w => G.Adj v w) (Finset.univ \ {v})).card + (Finset.filter (fun w => ¬G.Adj v w) (Finset.univ \ {v})).card = 5 := by
          exact fun v => by rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ; simp +decide [ Finset.card_sdiff ] ;
        exact ⟨ 0, by have := h_pigeonhole 0; omega ⟩;
      obtain hv | hv := hv;
      · -- Let $S$ be the set of vertices adjacent to $v$.
        set S := Finset.filter (fun w => G.Adj v w) (Finset.univ \ {v});
        -- If any two vertices in $S$ are adjacent, then we have a triangle.
        by_cases h_triangle : ∃ u w : Fin 6, u ∈ S ∧ w ∈ S ∧ G.Adj u w;
        · obtain ⟨ u, w, hu, hw, h ⟩ := h_triangle;
          have h_triangle : G.IsClique {v, u, w} := by
            aesop;
          bound;
          exact left { v, u, w } ( by simpa using h_triangle ) ( by rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> aesop );
        · -- If no two vertices in $S$ are adjacent, then $S$ forms an independent set of size at least 3.
          have h_indep : G.IsIndepSet (S : Set (Fin 6)) := by
            intro u hu w hw; aesop;
          -- Since $S$ is an independent set and has at least 3 elements, we can choose any 3 elements from $S$ to form an independent set of size 3.
          obtain ⟨T, hT⟩ : ∃ T : Finset (Fin 6), T ⊆ S ∧ T.card = 3 := by
            exact?;
          exact h_contra.2 T ( h_indep.mono hT.1 ) hT.2;
      · obtain ⟨ w₁, hw₁, w₂, hw₂, w₃, hw₃, h ⟩ := Finset.two_lt_card.1 hv;
        have := h_contra.2 { w₁, w₂, w₃ } ; simp_all +decide [ Set.Pairwise ];
        by_cases h₁ : G.Adj w₁ w₂ <;> by_cases h₂ : G.Adj w₁ w₃ <;> by_cases h₃ : G.Adj w₂ w₃ <;> simp_all +decide [ SimpleGraph.adj_comm ];
        all_goals have := h_contra.1 { w₁, w₂, w₃ } ; simp_all +decide [ SimpleGraph.adj_comm ];
        all_goals have := h_contra.2 { w₁, w₂, v } ; simp_all +decide [ SimpleGraph.adj_comm ];
        · have := h_contra.2 { w₂, w₃, v } ; simp_all +decide [ SimpleGraph.adj_comm ];
        · have := h_contra.2 { w₁, w₃, v } ; simp_all +decide [ SimpleGraph.adj_comm ];
        · have := h_contra.2 { w₁, w₃, v } ; simp_all +decide [ SimpleGraph.adj_comm ];
    · aesop;
      contrapose! a;
      intro h;
      have := h ( SimpleGraph.fromRel fun x y => x.val % 2 = y.val % 2 ) ; simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
      interval_cases b <;> simp_all +decide [ SimpleGraph.IsClique, SimpleGraph.IsIndepSet ];
      · exact absurd this ( by rintro ⟨ k, hk₁, hk₂ ⟩ ; exact absurd ( Finset.card_le_univ k ) ( by norm_num [ hk₂ ] ) );
      · simp_all +decide [ Set.Pairwise ];
      · simp_all +decide [ Set.Pairwise ];
      · have := h ( SimpleGraph.cycleGraph 5 );
        simp_all +decide [ SimpleGraph.IsNClique, SimpleGraph.IsNIndepSet ]

/-
Definition of Paley graph 17 on Fin 17 and theorem that it is a witness for R(4,4) > 17.
-/
/-- The Paley graph on 17 vertices. -/
def paleyGraph17 : SimpleGraph (Fin 17) :=
  let G : SimpleGraph (ZMod 17) := SimpleGraph.fromRel (fun a b => IsSquare (a - b))
  G.map (ZMod.finEquiv 17).symm.toEmbedding

/-- The Paley graph on 17 vertices is a witness for R(4,4) > 17. -/
theorem ramsey_4_4_gt_17 : IsRamseyWitness 17 4 4 paleyGraph17 := by
  constructor;
  · aesop;
    -- By contradiction, assume there exists a clique of size 4 in the Paley graph on 17 vertices.
    have h_clique : ∃ k : Finset (Fin 17), k.card = 4 ∧ ∀ u ∈ k, ∀ v ∈ k, u ≠ v → (u - v : Fin 17).val ∈ ({1, 2, 4, 8, 9, 13, 15, 16} : Finset ℕ) := by
      use k;
      aesop;
      · exact a.card_eq;
      · have := a.1 a_1 a_2 a_3; simp_all +decide [ paleyGraph17 ] ;
        rcases this with ⟨ u', v', ⟨ hne, hsq ⟩, rfl, rfl ⟩ ; fin_cases u' <;> fin_cases v' <;> trivial;
    exact absurd h_clique ( by native_decide );
  · unfold paleyGraph17;
    intro k hk; have := hk.2; simp_all +decide [ Finset.card_image_of_injective, Function.Injective ] ;
    -- By examining all possible 4-element subsets of Fin 17, we can verify that each subset contains at least one pair of connected vertices in the Paley graph.
    have h_check : ∀ s : Finset (Fin 17), s.card = 4 → ∃ a ∈ s, ∃ b ∈ s, a ≠ b ∧ IsSquare (a - b : ZMod 17) := by
      native_decide +revert;
    obtain ⟨ a, ha, b, hb, hab, h ⟩ := h_check k this;
    have := hk.1 ha hb;
    simp +zetaDelta at *;
    exact this hab ( ZMod.finEquiv 17 a ) ( ZMod.finEquiv 17 b ) ( by simpa [ Fin.ext_iff, ZMod.natCast_eq_natCast_iff ] using hab ) ( by simpa [ Fin.ext_iff, ZMod.natCast_eq_natCast_iff ] using Or.inl h ) ( by simp +decide [ ZMod.finEquiv ] ) ( by simp +decide [ ZMod.finEquiv ] )

/-
Theorem: If RamseyProp holds for n, it holds for any m ≥ n.
-/
/-- RamseyProp is monotonic. -/
theorem RamseyProp_mono {n m s t : ℕ} (h : n ≤ m) (hR : RamseyProp n s t) : RamseyProp m s t := by
  intro G;
  -- Let $H$ be the subgraph of $G$ induced by any $n$ vertices.
  obtain ⟨H, hH⟩ : ∃ H : Fin n → Fin m, Function.Injective H := by
    exact ⟨ fun i => ⟨ i, by linarith [ Fin.is_lt i ] ⟩, fun i j hij => by simpa [ Fin.ext_iff ] using hij ⟩;
  -- Since $G$ is a graph on $m$ vertices, and $H$ is a subgraph of $G$ on $n$ vertices, we can apply Ramsey's theorem to $H$.
  have hH_ramsey : RamseyProp n s t := by
    assumption;
  specialize hH_ramsey ( G.comap H ) ; aesop;
  · refine Or.inl ⟨ w.image H, ?_ ⟩;
    simp_all +decide [ SimpleGraph.isNClique_iff, Finset.card_image_of_injective _ hH ];
    intro x hx y hy; aesop;
  · refine Or.inr ⟨ Finset.image H w, ?_ ⟩;
    simp_all +decide [ SimpleGraph.isNIndepSet_iff, Finset.card_image_of_injective _ hH ];
    intro x hx y hy; aesop;

/-
Lemma: If RamseyProp n (s-1) t and RamseyProp m s (t-1) hold, then RamseyProp (n+m) s t holds.
-/
/-- The inductive step for Ramsey numbers: if R(s-1, t) ≤ n and R(s, t-1) ≤ m, then R(s, t) ≤ n + m. -/
theorem ramsey_step (n m s t : ℕ) (hs : s > 1) (ht : t > 1)
    (hn : RamseyProp n (s - 1) t) (hm : RamseyProp m s (t - 1)) :
    RamseyProp (n + m) s t := by
      -- Let $G$ be a graph on $n + m$ vertices.
      intro G
      obtain ⟨v, hv⟩ : ∃ v : Fin (n + m), (Finset.filter (fun w => G.Adj v w) (Finset.univ.erase v)).card ≥ n ∨ (Finset.filter (fun w => ¬G.Adj v w) (Finset.univ.erase v)).card ≥ m := by
        by_contra! h;
        have h_card : ∀ x : Fin (n + m), (Finset.filter (fun w => G.Adj x w) (Finset.univ.erase x)).card + (Finset.filter (fun w => ¬G.Adj x w) (Finset.univ.erase x)).card = n + m - 1 := by
          intro x; rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ; simp +decide [ Finset.card_erase_of_mem ( Finset.mem_univ x ) ] ;
        rcases n with ( _ | n ) <;> rcases m with ( _ | m ) <;> aesop;
        · rcases s with ( _ | _ | s ) <;> rcases t with ( _ | _ | t ) <;> simp_all +arith +decide [ RamseyProp ];
          simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
          simp_all +decide [ Finset.eq_empty_of_forall_notMem ];
        · exact absurd ( h_card 0 ) ( by linarith [ h 0 ] );
      cases hv;
      · obtain ⟨ S, hS ⟩ := Finset.exists_subset_card_eq ‹_›;
        -- Since $S$ is a subset of the neighbors of $v$, the subgraph induced by $S$ has a clique of size $s-1$ or an independent set of size $t$.
        have h_subgraph : ∃ k : Finset (Fin (n + m)), k ⊆ S ∧ (G.IsNClique (s - 1) k ∨ G.IsNIndepSet t k) := by
          have := hn ( SimpleGraph.comap ( fun x : Fin n => S.orderEmbOfFin ( by aesop ) x ) G ) ; aesop;
          · use Finset.image ( fun x => S.orderEmbOfFin ( by aesop ) x ) w;
            simp_all +decide [ Finset.subset_iff, SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
            simp_all +decide [ Set.Pairwise, SimpleGraph.IsClique, SimpleGraph.IsIndepSet ];
            exact Or.inl ( by rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa [ Fin.ext_iff ] using hxy, h_1.2 ] );
          · use Finset.image ( fun x : Fin n => S.orderEmbOfFin ( by aesop ) x ) w; aesop;
            · exact Finset.image_subset_iff.mpr fun x hx => Finset.orderEmbOfFin_mem _ _ _;
            · simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
              simp_all +decide [ Set.Pairwise, Finset.card_image_of_injective, Function.Injective ];
        aesop;
        · refine Or.inl ⟨ Insert.insert v w, ?_ ⟩;
          rcases s with ( _ | _ | s ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ];
          grind;
        · exact Or.inr ⟨ w, h_2 ⟩;
      · -- Let $M$ be the set of non-neighbors of $v$. Since $|M| \geq m$, by the induction hypothesis, the subgraph induced by $M$ contains either a clique of size $s$ or an independent set of size $t-1$.
        obtain ⟨M, hM⟩ : ∃ M : Finset (Fin (n + m)), M ⊆ Finset.filter (fun w => ¬G.Adj v w) (Finset.univ.erase v) ∧ M.card = m := by
          exact?;
        have h_ind : (∃ k : Finset (Fin (n + m)), k ⊆ M ∧ G.IsNClique s k) ∨ (∃ k : Finset (Fin (n + m)), k ⊆ M ∧ G.IsNIndepSet (t - 1) k) := by
          have := hm;
          have := this ( G.comap ( M.orderEmbOfFin hM.2 ) ) ; aesop;
          · refine Or.inl ⟨ Finset.image ( M.orderEmbOfFin right ) w, Finset.image_subset_iff.mpr fun x hx => Finset.orderEmbOfFin_mem _ _ _, ?_ ⟩;
            simp_all +decide [ SimpleGraph.isNClique_iff ];
            simp_all +decide [ SimpleGraph.IsClique, Finset.card_image_of_injective, Function.Injective ];
            intro x hx y hy hxy; aesop;
          · refine Or.inr ⟨ Finset.image ( M.orderEmbOfFin right ) w, ?_, ?_ ⟩ <;> simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ];
            · exact Finset.image_subset_iff.mpr fun x hx => Finset.orderEmbOfFin_mem _ _ _;
            · simp_all +decide [ Set.Pairwise, Finset.card_image_of_injective, Function.Injective ];
        aesop;
        · exact Or.inl ⟨ w, right_1 ⟩;
        · refine Or.inr ⟨ Insert.insert v w, ?_, ?_ ⟩ <;> simp_all +decide [ Finset.subset_iff, SimpleGraph.IsNIndepSet ];
          · intro x hx y hy; aesop;
            · exact left ( left_1 h_2 ) |>.2 ( a_1.symm );
            · have := right_1.2; simp_all +decide [ SimpleGraph.isNIndepSet_iff ] ;
              exact right_1 h_2 h_3 a a_1;
          · rw [ Finset.card_insert_of_notMem, right_1.card_eq ];
            · rw [ Nat.sub_add_cancel ht.le ];
            · exact fun h => left ( left_1 h ) |>.1 rfl

/-
Theorem: For any s and t, there exists an n such that RamseyProp n s t is true.
-/
/-- Ramsey's Theorem: For all s, t, there exists n such that RamseyProp n s t holds. -/
theorem ramsey_theorem_exists (s t : ℕ) : ∃ n, RamseyProp n s t := by
  induction' s using Nat.strong_induction_on with s ih generalizing t;
  by_cases hs : s = 0 ∨ s = 1;
  · aesop;
    · -- If $n = 0$, then any graph on $0$ vertices trivially has a clique of size $0$.
      use 0
      simp [RamseyProp];
    · exact ⟨ 1, fun G => Or.inl ⟨ { ⟨ 0, by norm_num ⟩ }, by simp +decide [ SimpleGraph.isNClique_iff ] ⟩ ⟩;
  · induction' t using Nat.strong_induction_on with t ih generalizing s;
    by_cases ht : t = 0 ∨ t = 1;
    · rcases ht with ( rfl | rfl );
      · use s;
        unfold RamseyProp; aesop;
        exact Or.inr ⟨ ∅, by simp +decide [ SimpleGraph.isNIndepSet_iff ] ⟩;
      · use 1;
        intro G hG; right; use { 0 } ; simp +decide [ SimpleGraph.isNIndepSet_iff ] ;
    · obtain ⟨n1, hn1⟩ : ∃ n1, RamseyProp n1 (s - 1) t := by
        exact ih _ ( Nat.pred_lt ( by tauto ) ) _
      obtain ⟨n2, hn2⟩ : ∃ n2, RamseyProp n2 s (t - 1) := by
        rcases t with ( _ | _ | t ) <;> simp_all +decide;
      exact ⟨ n1 + n2, ramsey_step n1 n2 s t ( Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨ by tauto, by tauto ⟩ ) ( Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨ by tauto, by tauto ⟩ ) hn1 hn2 ⟩

/-
Theorem: The Ramsey number R(s, t) is less than or equal to R(s-1, t) + R(s, t-1) for s, t > 1.
-/
/-- The Ramsey recurrence inequality: R(s, t) ≤ R(s-1, t) + R(s, t-1). -/
theorem ramsey_recurrence (s t : ℕ) (hs : s > 1) (ht : t > 1) :
    RamseyNumber s t ≤ RamseyNumber (s - 1) t + RamseyNumber s (t - 1) := by
      apply csInf_le;
      · exact ⟨ 0, fun n hn => Nat.zero_le _ ⟩;
      · apply ramsey_step;
        · assumption;
        · assumption;
        · exact Nat.sInf_mem ( show ∃ n, RamseyProp n ( s - 1 ) t from by exact? );
        · exact Nat.sInf_mem ( show ∃ n, RamseyProp n s ( t - 1 ) from ramsey_theorem_exists s ( t - 1 ) )

/-
Theorem: R(2, t) = t for t ≥ 2.
-/
/-- R(2, t) = t. -/
theorem ramsey_2_t (t : ℕ) (ht : t ≥ 2) : RamseyNumber 2 t = t := by
  refine' le_antisymm _ _;
  · -- Any graph on $t$ vertices either contains an edge or is empty.
    have h_ramsey_2t : RamseyProp t 2 t := by
      intro G;
      by_cases h : ∃ k : Finset ( Fin t ), G.IsNClique 2 k <;> aesop;
      use Finset.univ; simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.isNIndepSet_iff ] ;
      intro x hx y hy; specialize h { x, y } ; aesop;
    exact Nat.sInf_le h_ramsey_2t;
  · refine' le_csInf _ _;
    · exact Exists.elim ( ramsey_theorem_exists 2 t ) fun n hn => ⟨ n, hn ⟩;
    · aesop;
      cases' a ( ⊥ : SimpleGraph ( Fin b ) ) with h h <;> aesop;
      exact h.2 ▸ le_trans ( Finset.card_le_univ _ ) ( by simpa )

/-
Theorem: R(s, 2) = s for s ≥ 2.
-/
/-- R(s, 2) = s. -/
theorem ramsey_s_2 (s : ℕ) (hs : s ≥ 2) : RamseyNumber s 2 = s := by
  refine' le_antisymm ( Nat.sInf_le _ ) _;
  · intro G;
    by_cases h : ∃ k : Finset ( Fin s ), G.IsNClique s k <;> aesop;
    contrapose! h;
    use Finset.univ;
    simp_all +decide [ SimpleGraph.isNClique_iff ];
    intro x hx y hy hxy; specialize h { x, y } ; simp_all +decide [ SimpleGraph.isNIndepSet_iff ] ;
    simp_all +decide [ SimpleGraph.isIndepSet_iff, Set.Pairwise ];
    by_cases h' : G.Adj x y <;> simp_all +decide [ SimpleGraph.adj_comm ];
  · refine' le_csInf _ _;
    · exact Exists.elim ( ramsey_theorem_exists s 2 ) fun n hn => ⟨ n, hn ⟩;
    · intro n hn; contrapose! hn; aesop;
      have := a ( ⊤ ) ; aesop;
      · have := h.2;
        exact hn.not_le ( this ▸ le_trans ( Finset.card_le_univ _ ) ( by norm_num ) );
      · simp_all +decide [ SimpleGraph.isNIndepSet_iff, Finset.card_eq_two ];
        bound