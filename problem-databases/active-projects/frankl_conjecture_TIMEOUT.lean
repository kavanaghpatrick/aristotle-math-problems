/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9045e773-d2c5-436e-9fef-b365c20fe7f6

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A family of sets is union-closed if the union of any two sets in the family is also in the family.
-/
def IsUnionClosed {α : Type*} [DecidableEq α] (F : Finset (Finset α)) : Prop :=
  ∀ s ∈ F, ∀ t ∈ F, s ∪ t ∈ F

/-
The Frankl condition for a family F is that there exists an element x in the universe such that x belongs to at least half of the sets in F.
-/
def FranklCondition {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) : Prop :=
  ∃ x : α, 2 * (F.filter (x ∈ ·)).card ≥ F.card

/-
If a union-closed family F contains a singleton set {x}, then x appears in at least half of the sets in F.
-/
lemma frankl_of_singleton {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (h_closed : IsUnionClosed F) (x : α) (hx : {x} ∈ F) : 2 * (F.filter (x ∈ ·)).card ≥ F.card := by
  -- Consider the function $f: F \rightarrow F$ defined by $f(S) = S \cup \{x\}$.
  set f : Finset α → Finset α := fun S => S ∪ {x};
  -- This function $f$ is injective, and its image is contained in the set of sets in $F$ that contain $x$.
  have h_inj : Finset.card (Finset.image f (F.filter (fun S => x ∉ S))) = Finset.card (F.filter (fun S => x ∉ S)) ∧ Finset.image f (F.filter (fun S => x ∉ S)) ⊆ F.filter (fun S => x ∈ S) := by
    rw [ Finset.card_image_of_injOn ];
    · simp +contextual [ Finset.subset_iff ];
      aesop;
      convert h_closed _ a _ hx using 1;
      aesop;
    · intro S hS T hT; aesop;
      rw [ Finset.ext_iff ] at a ; aesop;
      grind;
  have := Finset.card_mono h_inj.2; simp_all +decide [ Finset.filter_not, Finset.card_sdiff ] ;
  rw [ Finset.inter_eq_left.mpr ( Finset.filter_subset _ _ ) ] at this ; linarith [ Nat.sub_add_cancel ( show ( Finset.card ( Finset.filter ( fun a => x ∈ a ) F ) ) ≤ F.card from Finset.card_filter_le _ _ ) ]

/-
The Frankl conjecture for a natural number n states that for any universe of size n, and any union-closed family F of sets in this universe (excluding the trivial family {∅}), there exists an element that appears in at least half of the sets in F.
-/
def FranklConjectureForN (n : ℕ) : Prop :=
  ∀ (α : Type) [DecidableEq α] [Fintype α] (h_card : Fintype.card α = n)
    (F : Finset (Finset α)) (h_closed : IsUnionClosed F) (h_nontrivial : F ≠ {∅}),
    FranklCondition F

/-
If there exists an element x that is contained in every non-empty set of a union-closed family F (where F is not just {∅}), then the Frankl condition holds for F.
-/
lemma frankl_of_mem_all_nonempty {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (h_nontrivial : F ≠ {∅}) (x : α) (hx : ∀ s ∈ F, s ≠ ∅ → x ∈ s) : FranklCondition F := by
  refine' ⟨ x, _ ⟩;
  by_cases h_empty : ∅ ∈ F;
  · have h_filter : {x_1 ∈ F | x ∈ x_1} = F \ {∅} := by
      ext s; by_cases hs : s = ∅ <;> aesop;
    rw [ h_filter, Finset.card_sdiff ] ; aesop;
    rcases n : F.card with ( _ | _ | n ) <;> simp_all +arith +decide;
    rw [ Finset.card_eq_one ] at n ; aesop;
  · rw [ Finset.filter_true_of_mem fun s hs => hx s hs ( by aesop ) ] ; linarith

/-
The Frankl conjecture holds for a universe of size 1.
-/
theorem Frankl_1 : FranklConjectureForN 1 := by
  intro α hα h_nontrivial;
  intro h_card
  intro F h_closed h_nontrivial
  obtain ⟨x, hx⟩ : ∃ x : α, ∀ s ∈ F, s ≠ ∅ → x ∈ s := by
    rw [ Fintype.card_eq_one_iff ] at h_card ; aesop;
    · exact ⟨ w ⟩;
    · exact h _ ▸ Classical.choose_spec ( Finset.nonempty_of_ne_empty a_1 );
  exact?

/-
The Frankl conjecture holds for a universe of size 2.
-/
theorem Frankl_2 : FranklConjectureForN 2 := by
  intro α;
  -- Since the universe has only two elements, let's denote them as a and b.
  intro hα
  intro F h_closed h_nontrivial
  obtain ⟨a, b, hab⟩ : ∃ a b : α, a ≠ b ∧ ∀ x : α, x = a ∨ x = b := by
    have := Finset.card_eq_two.mp h_closed;
    obtain ⟨ x, y, hxy, h ⟩ := this; exact ⟨ x, y, hxy, fun z => by simpa using Finset.ext_iff.mp h z ⟩ ;
  intro h_closed h_nontrivial'
  by_cases ha : {a} ∈ h_nontrivial;
  · exact ⟨ a, frankl_of_singleton _ h_closed _ ha ⟩;
  · by_cases hb : {b} ∈ h_nontrivial;
    · exact ⟨ b, by simpa using frankl_of_singleton _ h_closed _ hb ⟩;
    · -- Since {a} and {b} are not in F, every set in F must contain both a and b or neither.
      have h_cases : ∀ s ∈ h_nontrivial, s = ∅ ∨ s = {a, b} := by
        intro s hs; have := Finset.card_le_univ s; simp_all +decide ;
        interval_cases _ : s.card <;> simp_all +decide;
        · rw [ Finset.card_eq_one ] at * ; aesop;
          cases right w <;> aesop;
        · exact Or.inr ( Finset.eq_of_subset_of_card_le ( fun x hx => by cases hab.2 x <;> aesop ) ( by aesop ) );
      use a;
      rw [ show { x ∈ h_nontrivial | a ∈ x } = h_nontrivial \ { ∅ } from ?_ ];
      · by_cases h : ∅ ∈ h_nontrivial <;> simp_all +decide [ Finset.card_sdiff ];
        · rcases k : Finset.card h_nontrivial with ( _ | _ | k ) <;> simp_all +arith +decide;
          rw [ Finset.card_eq_one ] at k ; aesop;
        · linarith;
      · ext s; specialize h_cases s; aesop;

/-
The Frankl conjecture holds for a universe of size 3.
-/
theorem Frankl_3 : FranklConjectureForN 3 := by
  -- For the induction step, let's consider the case when the universe has 3 elements.
  intros α h_card F h_closed h_nontrivial;
  -- Let's enumerate all possible families of sets on a 3-element universe and check each one.
  have h_enum : ∀ F : Finset (Finset (Fin 3)), IsUnionClosed F → F ≠ {∅} → FranklCondition F := by
    unfold FranklCondition IsUnionClosed; simp +decide ;
  -- Since α is a finite type with cardinality 3, we can establish a bijection between α and Fin 3.
  obtain ⟨e, he⟩ : ∃ e : α ≃ Fin 3, True := by
    exact ⟨ Fintype.equivOfCardEq <| by simp +decide [ h_closed ], trivial ⟩;
  contrapose! h_enum;
  refine' ⟨ Finset.image ( fun s => Finset.image ( fun x => e x ) s ) h_nontrivial, _, _, _ ⟩ <;> simp_all +decide [ IsUnionClosed, FranklCondition ];
  · intro s hs t ht; use s ∪ t; aesop;
  · simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
  · intro x; specialize h_enum; have := h_enum.2.2 ( e.symm x ) ; simp_all +decide [ Finset.filter_image ] ;
    rw [ Finset.card_image_of_injective, Finset.card_image_of_injective ] <;> norm_num [ Function.Injective ];
    · convert h_enum.2.2 ( e.symm x ) using 1;
      congr! 2;
      ext; aesop;
    · intro s t h; ext x; replace h := Finset.ext_iff.mp h ( e x ) ; aesop;
    · intro s t h; ext x; replace h := Finset.ext_iff.mp h ( e x ) ; aesop;

/-
If the intersection of all non-empty sets in a family F is non-empty, then the Frankl condition holds for F.
-/
lemma frankl_of_inter_nonempty {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (h_nontrivial : F ≠ {∅}) (h_inter : (⋂₀ ((F.filter (· ≠ ∅)).image (fun s => (s : Set α)) : Set (Set α))).Nonempty) : FranklCondition F := by
  aesop;
  exact?

/-
The Frankl condition holds for the full power set of a non-empty universe.
-/
lemma frankl_of_univ {α : Type*} [DecidableEq α] [Fintype α] (h_nonempty : Nonempty α) : FranklCondition (Finset.univ : Finset (Finset α)) := by
  obtain ⟨ x ⟩ := h_nonempty;
  use x; simp +decide [ Finset.card_univ ] ;
  rw [ show ( Finset.univ.filter fun s => x ∈ s ) = Finset.image ( fun s => Insert.insert x s ) ( Finset.univ.filter fun s => x ∉ s ) from ?_, Finset.card_image_of_injOn ];
  · rw [ show ( Finset.univ.filter fun s => x ∉ s ) = Finset.powerset ( Finset.univ \ { x } ) by ext s; simp +decide [ Finset.subset_iff ], Finset.card_powerset, Finset.card_sdiff ] ; simp +decide;
    rw [ ← pow_succ', Nat.sub_add_cancel ( Fintype.card_pos_iff.mpr ⟨ x ⟩ ) ];
  · intro s hs t ht; aesop;
    rw [ Finset.ext_iff ] at a ; aesop;
    grind;
  · ext s; aesop;
    exact ⟨ s.erase x, by aesop ⟩

/-
The Frankl conjecture holds for a universe of size 4.
-/
theorem Frankl_4 : FranklConjectureForN 4 := by
  -- By checking all possible union-closed families on a 4-element set, we can verify that the Frankl condition holds.
  have h_check : ∀ (F : Finset (Finset (Fin 4))), F ≠ {∅} → (∀ s ∈ F, ∀ t ∈ F, s ∪ t ∈ F) → ∃ x : Fin 4, 2 * (F.filter (x ∈ ·)).card ≥ F.card := by
    native_decide +revert;
  intro α _ _ h_card F h_closed h_nontrivial;
  -- Since α has cardinality 4, there exists a bijection between α and Fin 4.
  obtain ⟨f, hf⟩ : ∃ f : α ≃ Fin 4, True := by
    exact ⟨ Fintype.equivOfCardEq h_card, trivial ⟩;
  -- Let's map the family F to a family G on Fin 4 using the bijection f.
  set G : Finset (Finset (Fin 4)) := Finset.image (fun s => Finset.image f s) F with hG_def
  have hG_closed : ∀ s ∈ G, ∀ t ∈ G, s ∪ t ∈ G := by
    simp +zetaDelta at *;
    exact fun s hs t ht => ⟨ s ∪ t, h_closed s hs t ht, by ext; aesop ⟩
  have hG_nontrivial : G ≠ {∅} := by
    contrapose! h_nontrivial;
    rw [ Finset.eq_singleton_iff_unique_mem ] at * ; aesop
  have hG_card : G.card = F.card := by
    exact Finset.card_image_of_injective _ fun s t h => by simpa [ Finset.ext_iff ] using Finset.image_injective f.injective h;
  have hG_filter : ∀ x : Fin 4, (G.filter (x ∈ ·)).card = (F.filter (fun s => f.symm x ∈ s)).card := by
    intro x; rw [ Finset.card_filter, Finset.card_filter ] ; rw [ Finset.sum_image ] ; aesop;
    · congr 1 with s ; aesop;
    · intro s hs t ht; aesop;
      rw [ Finset.image_injective ( f.injective ) a ];
  obtain ⟨ x, hx ⟩ := h_check G hG_nontrivial hG_closed; use f.symm x; aesop;

/-
If an element x is not in any set of the family F, then the Frankl condition for F is equivalent to the Frankl condition for the family obtained by removing x from the universe (which effectively does nothing to the sets).
-/
lemma frankl_reduction_unused {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (x : α) (hx : ∀ s ∈ F, x ∉ s) :
    FranklCondition F ↔ FranklCondition (F.image (fun s => s.erase x)) := by
      -- Since x is not in any set of F, the image of F under erasing x is just F itself.
      have h_image : Finset.image (fun s => s.erase x) F = F := by
        ext s; aesop;
      rw [ h_image ]

/-
If a union-closed family F contains a doubleton set {x, y}, then the Frankl condition holds for F.
-/
lemma frankl_of_doubleton {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (h_closed : IsUnionClosed F) (x y : α) (h_ne : x ≠ y) (h_mem : {x, y} ∈ F) : FranklCondition F := by
  by_contra h_contra;
  -- Let A be the set of sets in F that contain x but not y.
  set A := F.filter (fun s => x ∈ s ∧ y ∉ s);
  -- Let B be the set of sets in F that contain y but not x.
  set B := F.filter (fun s => y ∈ s ∧ x ∉ s);
  -- Let C be the set of sets in F that contain both x and y.
  set C := F.filter (fun s => x ∈ s ∧ y ∈ s);
  -- Since $F$ is union-closed, we have $|F| = |A| + |B| + |C| + |D|$, where $D$ is the set of sets in $F$ that contain neither $x$ nor $y$.
  set D := F.filter (fun s => x ∉ s ∧ y ∉ s)
  have hF_card : F.card = A.card + B.card + C.card + D.card := by
    rw [ Finset.card_filter, Finset.card_filter, Finset.card_filter, Finset.card_filter ];
    simpa only [ ← Finset.sum_add_distrib ] using Finset.card_eq_sum_ones F ▸ by congr; ext s; by_cases hx : x ∈ s <;> by_cases hy : y ∈ s <;> simp +decide [ hx, hy ] ;
  -- Since $F$ is union-closed, we have $|D| \leq |C|$.
  have hD_le_C : D.card ≤ C.card := by
    -- Since $F$ is union-closed, we have $|D| \leq |C|$ by definition of $D$.
    have hD_le_C : ∀ s ∈ D, s ∪ {x, y} ∈ C := by
      aesop;
      convert h_closed _ left _ h_mem using 1;
      ext; simp [Finset.mem_union, Finset.mem_insert];
    have hD_le_C : D.card ≤ (Finset.image (fun s => s ∪ {x, y}) D).card := by
      rw [ Finset.card_image_of_injOn ];
      intro s hs t ht; aesop;
      simp_all +decide [ Finset.ext_iff ];
      grind +ring;
    exact hD_le_C.trans ( Finset.card_le_card <| Finset.image_subset_iff.mpr ‹_› );
  -- Since $F$ is union-closed, we have $|F_x| = |A| + |C|$ and $|F_y| = |B| + |C|$.
  have hFx_card : (F.filter (x ∈ ·)).card = A.card + C.card := by
    rw [ ← Finset.card_union_of_disjoint ];
    · congr with s ; by_cases hx : x ∈ s <;> by_cases hy : y ∈ s <;> aesop;
    · exact Finset.disjoint_filter.mpr ( by aesop )
  have hFy_card : (F.filter (y ∈ ·)).card = B.card + C.card := by
    rw [ ← Finset.card_union_of_disjoint ];
    · congr with s ; by_cases hx : x ∈ s <;> by_cases hy : y ∈ s <;> aesop;
    · exact Finset.disjoint_filter.mpr ( by aesop );
  exact h_contra ⟨ if A.card + C.card ≥ B.card + C.card then x else y, by split_ifs <;> linarith ⟩

/-
If two distinct elements x and y are equivalent in a family F (meaning they appear in exactly the same sets), then the Frankl condition for F is equivalent to the Frankl condition for the family obtained by removing y from every set (and thus from the universe).
-/
lemma frankl_reduction_equivalent {α : Type*} [DecidableEq α] [Fintype α] (F : Finset (Finset α)) (x y : α) (h_ne : x ≠ y) (h_equiv : ∀ s ∈ F, x ∈ s ↔ y ∈ s) :
    FranklCondition F ↔ FranklCondition (F.image (fun s => s.erase y)) := by
      constructor;
      · rintro ⟨ z, hz ⟩;
        by_cases hz' : z = y <;> simp_all +decide [ Finset.filter_erase ];
        · refine' ⟨ x, _ ⟩;
          rw [ Finset.card_image_of_injOn ];
          · refine' le_trans hz _;
            rw [ Finset.card_filter, Finset.card_filter ];
            rw [ Finset.sum_image ] ; aesop;
            intro s hs t ht; aesop;
            ext y; by_cases hy : y = z <;> simp_all +decide [ Finset.ext_iff ] ;
            grind;
          · intro s hs t ht; aesop;
            ext y; by_cases hy : y = z <;> simp_all +decide [ Finset.ext_iff ] ;
            grind;
        · refine' ⟨ z, _ ⟩;
          rw [ Finset.card_image_of_injOn, Finset.card_filter ];
          · rw [ Finset.sum_image ];
            · simp_all +decide [ Finset.sum_ite ];
            · intro s hs t ht; aesop;
              ext z; by_cases hz : z = y <;> simp_all +decide [ Finset.ext_iff ] ;
              grind;
          · intro s hs t ht; aesop;
            ext z; by_cases hz : z = y <;> simp_all +decide [ Finset.ext_iff ] ;
            grind;
      · unfold FranklCondition; aesop;
        rw [ Finset.card_image_of_injOn ] at h;
        · use if w = y then x else w;
          rcases eq_or_ne w y with rfl | hw <;> simp_all +decide [ Finset.filter_image ];
          refine' le_trans h ( Nat.mul_le_mul_left _ ( Finset.card_image_le ) );
        · intro s hs t ht; aesop;
          ext z; by_cases hz : z = y <;> simp_all +decide [ Finset.ext_iff ] ;
          grind