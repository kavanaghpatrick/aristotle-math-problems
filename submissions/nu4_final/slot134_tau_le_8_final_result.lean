/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7fb85f6f-3741-4cf5-ab47-c0a36ac97883

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

/-- Triangle covering number: minimum edges to hit all triangles -/
noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  sInf { n | ∃ E : Finset (Sym2 V), E.card = n ∧ E ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E, e ∈ t.sym2 }

/-- M-edges incident to vertex v -/
def M_edges_at (M : Finset (Finset V)) (v : V) : Finset (Sym2 V) :=
  M.biUnion (fun X => X.sym2.filter (fun e => v ∈ e))

/-- Triangles that share an M-edge containing v -/
def trianglesSharingMEdgeAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => ∃ e ∈ M_edges_at M v, e ∈ t.sym2)

def externalTrianglesAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  trianglesSharingMEdgeAt G M v \ M

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A
  h_diag_AC : (A ∩ C).card ≤ 1
  h_diag_BD : (B ∩ D).card ≤ 1
  h_vab_ne_vbc : v_ab ≠ v_bc
  h_vbc_ne_vcd : v_bc ≠ v_cd
  h_vcd_ne_vda : v_cd ≠ v_da
  h_vda_ne_vab : v_da ≠ v_ab

variable (cycle4_all_triangles_contain_shared : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3),
    cfg.v_ab ∈ t ∨ cfg.v_bc ∈ t ∨ cfg.v_cd ∈ t ∨ cfg.v_da ∈ t)

variable (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t)

variable {G : SimpleGraph V} [DecidableRel G.Adj] {M : Finset (Finset V)}

#check external_share_common_vertex

#check @external_share_common_vertex
#check Sym2.mk

def s {α} (p : α × α) := Sym2.mk p

/-- The 4 edges covering M-elements -/
def M_cover_edges (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, cfg.v_da), s(cfg.v_ab, cfg.v_bc), s(cfg.v_bc, cfg.v_cd), s(cfg.v_cd, cfg.v_da)}

noncomputable def get_x_ab (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  Classical.choose (external_share_common_vertex G M hM cfg cfg.v_ab (Or.inl rfl))

#check get_x_ab

noncomputable def get_x_bc (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  Classical.choose (external_share_common_vertex G M hM cfg cfg.v_bc (Or.inr (Or.inl rfl)))

noncomputable def get_x_cd (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  Classical.choose (external_share_common_vertex G M hM cfg cfg.v_cd (Or.inr (Or.inr (Or.inl rfl))))

noncomputable def get_x_da (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  Classical.choose (external_share_common_vertex G M hM cfg cfg.v_da (Or.inr (Or.inr (Or.inr rfl))))

/-- The 4 edges covering external triangles -/
noncomputable def external_cover_edges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, get_x_ab external_share_common_vertex G M hM cfg),
   s(cfg.v_bc, get_x_bc external_share_common_vertex G M hM cfg),
   s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg),
   s(cfg.v_da, get_x_da external_share_common_vertex G M hM cfg)}

/-- The full 8-edge cover -/
noncomputable def full_cover (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  M_cover_edges cfg ∪ external_cover_edges external_share_common_vertex G M hM cfg

lemma triangle_card_eq_3 (G : SimpleGraph V) [DecidableRel G.Adj]
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) : t.card = 3 := by
      -- By definition of cliqueFinset, if t is in the cliqueFinset of 3, then t has exactly 3 elements.
      apply Finset.mem_filter.mp ht |>.2.2

lemma external_triangle_contains_v (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (t : Finset V)
    (ht : t ∈ externalTrianglesAt G M v) : v ∈ t := by
      -- By definition of `externalTrianglesAt`, if `t` is in `externalTrianglesAt G M v`, then `t` is in the set of triangles sharing an M-edge at `v`.
      have h_triangle_sharing : t ∈ trianglesSharingMEdgeAt G M v := by
        exact Finset.mem_sdiff.mp ht |>.1;
      -- By definition of `trianglesSharingMEdgeAt`, if `t` is in `trianglesSharingMEdgeAt G M v`, then there exists an edge `e` in `M_edges_at M v` such that `e` is in `t.sym2`.
      obtain ⟨e, he₁, he₂⟩ : ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
        unfold trianglesSharingMEdgeAt at h_triangle_sharing; aesop;
      unfold M_edges_at at he₁; aesop;

#check full_cover

/-- Full cover has at most 8 edges -/
theorem full_cover_card_le_8 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) :
    (full_cover external_share_common_vertex G M hM cfg).card ≤ 8 := by
      -- Since the union of two sets with cardinality at most 4 each will have a cardinality at most 4 + 4 = 8, we can conclude.
      have h_union_card : (M_cover_edges cfg).card ≤ 4 ∧ (external_cover_edges external_share_common_vertex G M hM cfg).card ≤ 4 := by
        constructor;
        · exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _;
        · exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _;
      -- Apply the fact that the cardinality of the union of two finite sets is at most the sum of their cardinalities.
      apply le_trans (Finset.card_union_le _ _) (add_le_add h_union_card.left h_union_card.right)

lemma full_cover_covers_M (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (X : Finset V) (hX : X ∈ M) :
    ∃ e ∈ full_cover external_share_common_vertex G M hM cfg, e ∈ X.sym2 := by
      by_cases hX_eq_A : X = cfg.A;
      · refine' ⟨ s ( cfg.v_ab, cfg.v_da ), _, _ ⟩ <;> simp +decide [ *, full_cover ];
        · exact Or.inl ( Finset.mem_insert_self _ _ );
        · simp +decide [ s, cfg.h_vab_A, cfg.h_vda_A ];
      · -- Since X is in M and not equal to A, it must be B, C, or D.
        have hX_cases : X = cfg.B ∨ X = cfg.C ∨ X = cfg.D := by
          have := cfg.hM_eq; aesop;
        rcases hX_cases with ( rfl | rfl | rfl ) <;> simp +decide [ *, M_cover_edges ];
        · -- Since cfg.B is in M, the edge (cfg.v_ab, cfg.v_bc) is in the full cover and both vertices are in cfg.B.
          use s (cfg.v_ab, cfg.v_bc)
          simp [full_cover, M_cover_edges];
          simp +decide [ s, Sym2.eq_swap ];
          exact ⟨ cfg.h_vab_B, cfg.h_vbc_B ⟩;
        · refine' ⟨ s(cfg.v_bc, cfg.v_cd), _, _ ⟩ <;> simp +decide [ *, M_cover_edges, full_cover ];
          exact ⟨ cfg.h_vbc_C, cfg.h_vcd_C ⟩;
        · unfold full_cover;
          unfold M_cover_edges; simp +decide [ *, Finset.mem_insert, Finset.mem_singleton ] ;
          exact Or.inr <| Or.inr <| Or.inr <| Or.inl ⟨ cfg.h_vcd_D, cfg.h_vda_D ⟩

/-- Full cover covers all external triangles -/
lemma full_cover_covers_external (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M v) :
    ∃ e ∈ full_cover external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- Since $t$ is in the external triangles at $v$, it must contain $v$ and $x$. Therefore, either $(v, x)$ or $(x, v)$ is in $t$'s sym2.
      have h_edge_in_t : (s (v, (Classical.choose (external_share_common_vertex G M hM cfg v h_shared))) ∈ t.sym2) ∨ (s ((Classical.choose (external_share_common_vertex G M hM cfg v h_shared)), v) ∈ t.sym2) := by
        have := Classical.choose_spec ( external_share_common_vertex G M hM cfg v h_shared ) |>.2 t ht;
        have h_edge_in_t : v ∈ t ∧ Classical.choose (external_share_common_vertex G M hM cfg v h_shared) ∈ t := by
          exact ⟨ external_triangle_contains_v G M v t ht, this ⟩;
        simp +decide [ *, Sym2.mem_iff ];
        exact Or.inl fun x hx => by rcases Sym2.mem_iff.mp hx with ( rfl | rfl ) <;> [ exact h_edge_in_t.1; exact h_edge_in_t.2 ] ;
      unfold full_cover;
      unfold M_cover_edges external_cover_edges; simp +decide [ h_edge_in_t ] ;
      -- Since $t$ is in the external triangles at $v$, it must contain $v$. Also, the chosen vertex $x$ is such that $x$ is in all external triangles at $v$.
      have h_v_in_t : v ∈ t := by
        exact?
      have h_x_in_t : Classical.choose (external_share_common_vertex G M hM cfg v h_shared) ∈ t := by
        exact Classical.choose_spec ( external_share_common_vertex G M hM cfg v h_shared ) |>.2 t ht;
      rcases h_shared with ( rfl | rfl | rfl | rfl ) <;> tauto

lemma exists_edge_intersection (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ X ∈ M, ∃ e ∈ X.sym2, e ∈ t.sym2 := by
      -- Since $M$ is a maximal packing, every triangle must share an edge with at least one triangle in $M$.
      have h_max_packing : ∀ t ∈ G.cliqueFinset 3, ∃ X ∈ M, (X ∩ t).card ≥ 2 := by
        intro t ht
        by_contra h_contra;
        have h_max_packing : isTrianglePacking G (insert t M) := by
          refine' ⟨ _, _ ⟩;
          · simp_all +decide [ Finset.subset_iff ];
            have := hM.1;
            exact fun x hx => by have := this.1 hx; aesop;
          · intro x hx y hy hxy;
            by_cases hx' : x = t <;> by_cases hy' : y = t <;> simp_all +decide;
            · simpa only [ Finset.inter_comm ] using Nat.le_of_lt_succ ( h_contra y hy );
            · exact Nat.le_of_lt_succ ( h_contra x hx );
            · have := hM.1;
              have := this.2 hx hy hxy; aesop;
        have h_max_packing : (insert t M).card > M.card := by
          by_cases h : t ∈ M <;> simp_all +decide;
          specialize h_contra t h; simp_all +decide [ ht.card_eq ] ;
        have h_max_packing : (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (Finset.powerset (G.cliqueFinset 3)))).max.getD 0 ≥ (insert t M).card := by
          have h_max_packing : (insert t M).card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (Finset.powerset (G.cliqueFinset 3))) := by
            simp_all +decide [ Finset.subset_iff ];
            -- Since $M$ is a subset of the cliqueFinset 3 and $t$ is in the cliqueFinset 3, their union is also a subset of the cliqueFinset 3.
            have h_subset : Insert.insert t M ⊆ G.cliqueFinset 3 := by
              unfold isTrianglePacking at *; aesop;
            exact ⟨ Insert.insert t M, ⟨ fun x hx => by have := h_subset hx; aesop, by assumption ⟩, rfl ⟩;
          have := Finset.le_max h_max_packing;
          cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
        linarith! [ hM.2 ];
      obtain ⟨ X, hX₁, hX₂ ⟩ := h_max_packing t ht;
      obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.1 hX₂;
      exact ⟨ X, hX₁, Sym2.mk ( x, y ), by aesop ⟩

#check cycle4_all_triangles_contain_shared
#check full_cover_covers_M

lemma shares_M_edge_at_shared_vertex (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (h_not_M : t ∉ M)
    (v : V) (hv : v ∈ t)
    (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da) :
    ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
      -- Since $v \in t$ and $t \in G.cliqueFinset 3$, $t$ must contain at least one edge from $M_edges_at M v$ by the definition of $M_edges_at$.
      have h_inter : ∃ X ∈ M, v ∈ X := by
        unfold isMaxPacking at hM; aesop;
        · -- Since $cfg$ is a Cycle4, we know that $cfg.v_ab$ is in both $A$ and $B$, which are elements of $M$.
          use cfg.A; exact ⟨cfg.hA, cfg.h_vab_A⟩;
        · exact ⟨ cfg.B, cfg.hB, cfg.h_vbc_B ⟩;
        · exact ⟨ cfg.C, cfg.hC, cfg.h_vcd_C ⟩;
        · exact ⟨ _, cfg.hD, cfg.h_vda_D ⟩;
      simp_all +decide [ M_edges_at ];
      obtain ⟨ X, hX₁, hX₂ ⟩ := h_inter;
      exact ⟨ Sym2.mk ( v, v ), ⟨ X, hX₁, by aesop ⟩, by aesop ⟩

#check full_cover_covers_M

#check shares_M_edge_at_shared_vertex
#check full_cover_covers_M

/-- Full cover covers ALL triangles -/
theorem full_cover_covers_all (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (cycle4_all_triangles_contain_shared : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3),
    cfg.v_ab ∈ t ∨ cfg.v_bc ∈ t ∨ cfg.v_cd ∈ t ∨ cfg.v_da ∈ t)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ e ∈ full_cover external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- By combining the results from `cycle4_all_triangles_contain_shared` and `shares_M_edge_at_shared_vertex`, we can conclude that there exists an edge in the full cover that intersects t.
      obtain ⟨v, hv⟩ : ∃ v ∈ t, v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da := by
        rcases cycle4_all_triangles_contain_shared G M hM cfg t ht with h | h | h | h <;> [ exact ⟨ _, h, Or.inl rfl ⟩ ; exact ⟨ _, h, Or.inr <| Or.inl rfl ⟩ ; exact ⟨ _, h, Or.inr <| Or.inr <| Or.inl rfl ⟩ ; exact ⟨ _, h, Or.inr <| Or.inr <| Or.inr rfl ⟩ ];
      -- If $t$ is in $M$, then by the definition of $M_cover_edges$, there must be an edge in $M_cover_edges$ that is in $t.sym2$.
      by_cases htM : t ∈ M;
      · exact?;
      · -- Since $t$ is not in $M$, it must be an external triangle with respect to $v$.
        have h_external : t ∈ externalTrianglesAt G M v := by
          have := shares_M_edge_at_shared_vertex G M hM cfg t ht htM v hv.1 hv.2;
          exact Finset.mem_sdiff.mpr ⟨ Finset.mem_filter.mpr ⟨ ht, this ⟩, htM ⟩;
        exact full_cover_covers_external external_share_common_vertex G M hM cfg v hv.2 t h_external

#check full_cover_covers_all

#check full_cover_card_le_8
#check full_cover_covers_all

#check full_cover_card_le_8

#check full_cover_card_le_8
#check full_cover_covers_all