/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d4760ed8-3a88-413d-bc1a-617611423323

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def FactorialSums : Set ℕ :=
  {m : ℕ | ∃ S : Finset ℕ, m = ∑ n ∈ S, n.factorial}

def IsPowerful (n : ℕ) : Prop :=
  ∀ p : ℕ, p.Prime → p ∣ n → p ^ 2 ∣ n

/-
For any natural number n >= 4, there exists a prime p such that n/2 < p <= n.
-/
lemma bertrand_interval (n : ℕ) (hn : 4 ≤ n) : ∃ p, p.Prime ∧ n / 2 < p ∧ p ≤ n := by
  exact Nat.exists_prime_lt_and_le_two_mul ( n / 2 ) ( by omega ) |> fun ⟨ p, hp₁, hp₂ ⟩ => ⟨ p, hp₁, by omega, by omega ⟩

/-
If p is a prime and p <= n < 2p, then the exponent of p in the prime factorization of n! is 1.
-/
lemma valuation_factorial_eq_one {p n : ℕ} (hp : p.Prime) (h1 : p ≤ n) (h2 : n < 2 * p) :
  Nat.factorization (n.factorial) p = 1 := by
    -- By Legendre's formula, the exponent of p in the prime factorization of n! is given by $\sum_{k=1}^{\infty} \left\lfloor \frac{n}{p^k} \right\rfloor$.
    have legendre : (n.factorial.factorization p) = ∑ k ∈ Finset.Ico 1 (Nat.log p n + 1), (n / p ^ k) := by
      rw [ Nat.factorization_def ];
      · haveI := Fact.mk hp; rw [ padicValNat_factorial ] ; aesop;
      · assumption;
    rw [ legendre, Finset.sum_eq_single 1 ] <;> norm_num;
    · nlinarith [ Nat.div_mul_le_self n p, Nat.div_add_mod n p, Nat.mod_lt n hp.pos ];
    · exact fun b hb₁ hb₂ hb₃ => Or.inr <| lt_of_lt_of_le h2 <| Nat.le_trans ( by nlinarith [ Nat.Prime.one_lt hp ] ) <| Nat.pow_le_pow_right hp.pos <| Nat.lt_of_le_of_ne hb₁ <| Ne.symm hb₃;
    · exact fun h => absurd ( h h1 ) hp.one_lt.not_le

/-
If p is a prime in (m/2, m] and there are no elements in S between m and 2p, then the p-adic valuation of the sum of factorials is 1.
-/
lemma gap_valuation (m : ℕ) (S : Finset ℕ) (p : ℕ) (hp : p.Prime) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_p_range : m / 2 < p ∧ p ≤ m) (h_gap : ∀ n ∈ S, n > m → n ≥ 2 * p) : Nat.factorization (∑ n ∈ S, n.factorial) p = 1 := by
  -- For any $n > m$, since $n \ge 2p$, we have that $v_p(n!) \ge 2$.
  have h_vp_gt_m : ∀ n ∈ S, n > m → (Nat.factorization (Nat.factorial n)) p ≥ 2 := by
    intros n hn hn_gt_m
    have h_vp_ge_two : (Nat.factorization (Nat.factorial n)) p ≥ Nat.floor (n / p) := by
      have h_vp_ge_two : (Nat.factorization (Nat.factorial n)) p = ∑ k ∈ Finset.Ico 1 (Nat.log p n + 1), (n / p ^ k) := by
        rw [ Nat.factorization_def ];
        · haveI := Fact.mk hp; rw [ padicValNat_factorial ] ; aesop;
        · assumption;
      exact h_vp_ge_two.symm ▸ le_trans ( by norm_num ) ( Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.left_mem_Ico.mpr ( Nat.succ_lt_succ ( Nat.log_pos hp.one_lt ( by linarith [ h_gap n hn hn_gt_m ] ) ) ) ) );
    exact le_trans ( Nat.le_div_iff_mul_le hp.pos |>.2 <| by linarith [ h_gap n hn hn_gt_m ] ) h_vp_ge_two;
  -- Since $p$ divides $m!$ and for all $n > m$, $p$ also divides $n!$, it follows that $p$ divides the sum $\sum_{n \in S} n!$ but $p^2$ does not.
  have h_div : p ∣ (∑ n ∈ S, n.factorial) ∧ ¬(p^2 ∣ (∑ n ∈ S, n.factorial)) := by
    constructor;
    · exact Finset.dvd_sum fun n hn => Nat.dvd_factorial ( Nat.pos_of_ne_zero hp.ne_zero ) ( by linarith [ h_min n hn ] );
    · rw [ Finset.sum_eq_add_sum_diff_singleton hm ];
      rw [ Nat.dvd_add_left ];
      · -- Since $p$ is a prime in $(m/2, m]$, we have $v_p(m!) = 1$.
        have h_vp_m : Nat.factorization (Nat.factorial m) p = 1 := by
          apply valuation_factorial_eq_one hp h_p_range.right (by
          omega);
        rw [ ← Nat.factorization_le_iff_dvd ] <;> aesop;
      · exact Finset.dvd_sum fun n hn => Nat.dvd_trans ( pow_dvd_pow p <| h_vp_gt_m n ( Finset.mem_sdiff.mp hn |>.1 ) <| lt_of_le_of_ne ( h_min n <| Finset.mem_sdiff.mp hn |>.1 ) <| by aesop ) <| Nat.ordProj_dvd _ _;
  exact le_antisymm ( Nat.le_of_not_lt fun h => h_div.2 <| Nat.dvd_trans ( pow_dvd_pow _ h ) <| Nat.ordProj_dvd _ _ ) ( Nat.pos_of_ne_zero <| Finsupp.mem_support_iff.mp <| by { exact Nat.mem_primeFactors.mpr ⟨ hp, by { exact Nat.dvd_trans ( by simpa ) h_div.1 }, by { exact Nat.ne_of_gt <| Finset.sum_pos ( fun x hx => Nat.factorial_pos _ ) ⟨ m, hm ⟩ } ⟩ } )

/-
If a factorial sum with minimum element m is powerful, then for every prime p in (m/2, m], there exists an element n in S such that m < n < 2p.
-/
lemma powerful_implies_dense (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) : ∀ p, p.Prime → m / 2 < p → p ≤ m → ∃ n ∈ S, m < n ∧ n < 2 * p := by
  intro p hp hmp hpm
  by_contra h_no_n
  have h_val : Nat.factorization (∑ n ∈ S, n.factorial) p = 1 := by
    convert gap_valuation m S p hp hm h_min ⟨ hmp, hpm ⟩ _ using 1 ; aesop;
  -- Since p divides S, p^2 must divide S, so v_p(S) >= 2.
  have h_div : p ^ 2 ∣ ∑ n ∈ S, n.factorial := by
    exact h_pow p hp ( dvd_trans ( Nat.dvd_factorial ( Nat.pos_of_ne_zero hp.ne_zero ) hpm ) ( Finset.dvd_sum fun n hn => Nat.factorial_dvd_factorial ( h_min n hn ) ) ) |> fun h => by simpa [ sq ] using h;
  rw [ ← Nat.factorization_le_iff_dvd ] at h_div <;> aesop_cat

/-
If a factorial sum with minimum m is powerful, then for any prime p in (m/2, m], the sum of n!/m! for m < n < 2p plus 1 is divisible by p.
-/
lemma powerful_implies_congruence (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) :
  ∀ p, p.Prime → m / 2 < p → p ≤ m → (1 + ∑ n ∈ S.filter (fun x => m < x ∧ x < 2 * p), (n.factorial / m.factorial)) % p = 0 := by
    intro p hp hmp hpm
    have h_div : p ∣ (∑ n ∈ S, Nat.factorial n) := by
      exact dvd_trans ( Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.dvd_factorial hp.pos hpm ) ) ( Finset.dvd_sum fun x hx => Nat.factorial_dvd_factorial ( h_min x hx ) );
    have h_div : p^2 ∣ (∑ n ∈ S, Nat.factorial n) := by
      exact h_pow p hp h_div;
    -- We can factor out $m!$ from the sum, giving us $m!(1 + \sum_{n > m} n!/m!)$.
    have h_factor : ∑ n ∈ S, Nat.factorial n = Nat.factorial m * (1 + ∑ n ∈ S.filter (fun n => m < n), Nat.factorial n / Nat.factorial m) := by
      rw [ Finset.sum_eq_add_sum_diff_singleton hm ];
      rw [ mul_add, mul_one, Finset.mul_sum _ _ _ ];
      rw [ show S \ { m } = Finset.filter ( fun n => m < n ) S from ?_ ];
      · exact congr rfl ( Finset.sum_congr rfl fun x hx => by rw [ Nat.mul_div_cancel' ( Nat.factorial_dvd_factorial ( by linarith [ Finset.mem_filter.mp hx ] ) ) ] );
      · grind;
    -- Since $p^2 \mid m! (1 + \sum_{n > m} n!/m!)$, and $p \mid m!$, it follows that $p \mid (1 + \sum_{n > m} n!/m!)$.
    have h_div_sum : p ∣ (1 + ∑ n ∈ S.filter (fun n => m < n), Nat.factorial n / Nat.factorial m) := by
      have h_div_sum : p ∣ Nat.factorial m ∧ ¬p^2 ∣ Nat.factorial m := by
        have h_div_sum : Nat.factorization (Nat.factorial m) p = 1 := by
          apply valuation_factorial_eq_one hp hpm;
          omega;
        exact ⟨ Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| hp.dvd_factorial.mpr <| by linarith ), fun h => absurd ( Nat.factorization_le_iff_dvd ( by aesop ) ( by positivity ) |>.2 h ) ( by aesop ) ⟩;
      obtain ⟨ k, hk ⟩ := h_div_sum.1;
      simp_all +decide [ sq, mul_assoc, Nat.mul_dvd_mul_iff_left hp.pos ];
      exact Or.resolve_left ( hp.dvd_mul.mp h_div ) h_div_sum;
    -- Since $p$ is a prime in $(m/2, m]$, we know that for any $n \in S$ such that $m < n < 2p$, $n!/m!$ is divisible by $p$.
    have h_div_terms : ∀ n ∈ S.filter (fun n => m < n ∧ n ≥ 2 * p), p ∣ Nat.factorial n / Nat.factorial m := by
      intros n hn
      have h_div_term : p ∣ Nat.factorial n / Nat.factorial m := by
        have h_div_term_aux : p ∣ (∏ k ∈ Finset.Icc (m + 1) n, k) := by
          have h_div_term_aux : p ∣ (∏ k ∈ Finset.Icc (m + 1) (2 * p), k) := by
            exact dvd_trans ( by norm_num ) ( Finset.dvd_prod_of_mem _ ( show 2 * p ∈ Finset.Icc ( m + 1 ) ( 2 * p ) from Finset.mem_Icc.mpr ⟨ by linarith [ Nat.div_add_mod m 2, Nat.mod_lt m two_pos ], by linarith ⟩ ) );
          exact dvd_trans h_div_term_aux ( by apply_rules [ Finset.prod_dvd_prod_of_subset, Finset.Icc_subset_Icc_right ] ; linarith [ Finset.mem_filter.mp hn ] )
        have h_div_term_aux : ∏ k ∈ Finset.Icc (m + 1) n, k = Nat.factorial n / Nat.factorial m := by
          rw [ Nat.div_eq_of_eq_mul_left ];
          · positivity;
          · erw [ Finset.prod_Ico_eq_prod_range ];
            rw [ ← Nat.add_sub_of_le ( show m ≤ n from h_min n ( Finset.filter_subset _ _ hn ) ) ];
            exact Nat.recOn ( n - m ) ( by norm_num ) fun n ihn => by simp +decide [ Finset.prod_range_succ, Nat.factorial ] at * ; nlinarith;
        aesop;
      exact h_div_term;
    -- Therefore, we can split the sum into two parts: one where $n < 2p$ and one where $n \geq 2p$.
    have h_split_sum : ∑ n ∈ S.filter (fun n => m < n), Nat.factorial n / Nat.factorial m = ∑ n ∈ S.filter (fun n => m < n ∧ n < 2 * p), Nat.factorial n / Nat.factorial m + ∑ n ∈ S.filter (fun n => m < n ∧ n ≥ 2 * p), Nat.factorial n / Nat.factorial m := by
      rw [ ← Finset.sum_union ];
      · rcongr n ; by_cases hn : n < 2 * p <;> aesop;
      · exact Finset.disjoint_filter.mpr fun _ _ _ _ => by linarith;
    simp_all +decide [ Nat.dvd_add_left, Finset.sum_nat_mod, Nat.mod_eq_zero_of_dvd ];
    rw [ Nat.mod_eq_zero_of_dvd ];
    convert Nat.dvd_sub' h_div_sum ( show p ∣ ∑ n ∈ S with m < n ∧ 2 * p ≤ n, n.factorial / m.factorial from Finset.dvd_sum fun x hx => h_div_terms x ( Finset.mem_filter.mp hx |>.1 ) ( Finset.mem_filter.mp hx |>.2.1 ) ( Finset.mem_filter.mp hx |>.2.2 ) ) using 1 ; rw [ Nat.sub_eq_of_eq_add ] ; ring

/-
If a factorial sum with minimum m is powerful, then no prime in (m/2, m] divides m+1.
-/
lemma powerful_implies_not_exists_prime_dvd_succ (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) :
  ¬ ∃ p, p.Prime ∧ m / 2 < p ∧ p ≤ m ∧ p ∣ (m + 1) := by
    by_contra h_contra;
    obtain ⟨ p, hp_prime, hp_gt, hp_le, hp_div ⟩ := h_contra;
    -- Since p divides m+1, and n!/m! = (m+1)...n for n > m, p divides n!/m! for all n > m.
    have h_div : ∀ n ∈ S, m < n → p ∣ n.factorial / m.factorial := by
      intro n hn hmn; rw [ Nat.dvd_div_iff_mul_dvd ];
      · refine' dvd_trans _ ( Nat.factorial_dvd_factorial hmn );
        exact Nat.dvd_trans ( mul_dvd_mul_left _ hp_div ) ( by simp +decide [ Nat.factorial_succ, mul_comm ] );
      · exact Nat.factorial_dvd_factorial hmn.le;
    -- So $1 + \sum_{n > m} n!/m!$ is divisible by $p$.
    have h_sum_div : p ∣ 1 + ∑ n ∈ S.filter (fun x => m < x ∧ x < 2 * p), (n.factorial / m.factorial) := by
      have := powerful_implies_congruence m S hm h_min h_pow p hp_prime hp_gt hp_le;
      exact Nat.dvd_of_mod_eq_zero this;
    rw [ Nat.dvd_add_left ( Finset.dvd_sum fun x hx => h_div x ( by aesop ) ( by aesop ) ) ] at h_sum_div ; aesop

/-
If m >= 4, a powerful factorial sum cannot consist of just the single element m.
-/
lemma powerful_implies_not_singleton (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) (h_large : m ≥ 4) : S ≠ {m} := by
  rintro rfl;
  -- By Bertrand's postulate (bertrand_interval), there exists a prime p in (m/2, m].
  obtain ⟨p, hp_prime, hp_range⟩ : ∃ p, p.Prime ∧ m / 2 < p ∧ p ≤ m := by
    exact?;
  -- By valuation_factorial_eq_one, v_p(m!) = 1.
  have h_val : Nat.factorization (m.factorial) p = 1 := by
    apply valuation_factorial_eq_one hp_prime hp_range.right;
    omega;
  have := h_pow p hp_prime ( by exact Nat.dvd_factorial hp_prime.pos hp_range.2 ) ; simp_all +decide [ Nat.factorization_eq_zero_iff ] ;
  rw [ ← Nat.factorization_le_iff_dvd ] at this <;> aesop

/-
If m >= 4 and S is a powerful factorial sum with minimum m, then S contains an element strictly between m and 2m.
-/
lemma exists_next_element (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) (h_large : m ≥ 4) : ∃ n ∈ S, m < n ∧ n < 2 * m := by
  -- By Bertrand's interval, there exists a prime $p$ such that $m/2 < p \leq m$.
  obtain ⟨p, hp_prime, hp_range⟩ : ∃ p, p.Prime ∧ m / 2 < p ∧ p ≤ m := by
    exact?;
  obtain ⟨ n, hn ⟩ := powerful_implies_dense m S hm h_min h_pow p hp_prime hp_range.1 hp_range.2;
  exact ⟨ n, hn.1, hn.2.1, by linarith ⟩

/-
If m >= 4 and S is a powerful factorial sum with minimum m, let n_0 be the smallest element of S greater than m. Then there are no primes in the interval (m/2, n_0/2].
-/
lemma no_primes_in_gap (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) (h_large : m ≥ 4) :
  let n_0 := S.filter (fun n => m < n) |>.min' (by
  exact Exists.elim ( exists_next_element m S hm h_min h_pow h_large ) fun x hx => ⟨ x, by aesop ⟩)
  ∀ p, p.Prime → m / 2 < p → p ≤ n_0 / 2 → False := by
    intro n_0 p hp hp' hp'';
    have h_congruence : (1 + ∑ n ∈ (S.filter (fun x => m < x ∧ x < 2 * p)), (n.factorial / m.factorial)) % p = 0 := by
      apply powerful_implies_congruence m S hm h_min h_pow p hp hp' (by
      have h_contra : n_0 ≤ 2 * m := by
        have := exists_next_element m S hm h_min h_pow h_large;
        exact le_trans ( Finset.min'_le _ _ <| Finset.mem_filter.mpr ⟨ this.choose_spec.1, this.choose_spec.2.1 ⟩ ) this.choose_spec.2.2.le;
      omega);
    -- Since $n_0$ is the smallest element in $S$ greater than $m$, and $n_0 \geq 2p$, there are no elements in the sum range.
    have h_empty_sum : S.filter (fun x => m < x ∧ x < 2 * p) = ∅ := by
      ext x
      simp [n_0];
      exact fun hx hx' => by linarith [ Nat.div_mul_le_self n_0 2, Finset.min'_le _ _ ( Finset.mem_filter.mpr ⟨ hx, hx' ⟩ ) ] ;
    simp_all +decide [ Finset.ext_iff ]

/-
If every prime in the interval (m/2, m] divides K, then the product of all primes in that interval divides K.
-/
lemma product_primes_interval_divides (m : ℕ) (K : ℕ) (h : ∀ p, p.Prime → m / 2 < p → p ≤ m → p ∣ K) : (∏ p ∈ Finset.filter (fun p => p.Prime ∧ m / 2 < p ∧ p ≤ m) (Finset.range (m + 1)), p) ∣ K := by
  have h_prod_primes : ∀ S : Finset ℕ, (∀ p ∈ S, Nat.Prime p) → (∀ p ∈ S, p ∣ K) → (∏ p ∈ S, p) ∣ K := by
    intros S hS_prime hS_div
    induction' S using Finset.induction with p S hS ih;
    · norm_num;
    · simp_all +decide [ Finset.prod_insert hS ];
      exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( Nat.Coprime.prod_right fun q hq => hS_prime.1.coprime_iff_not_dvd.mpr fun hq' => hS <| by have := Nat.prime_dvd_prime_iff_eq hS_prime.1 ( hS_prime.2 q hq ) ; aesop ) hS_div.1 ih;
  exact h_prod_primes _ ( fun p hp => by aesop ) ( fun p hp => h p ( by aesop ) ( by aesop ) ( by aesop ) )

/-
If S is a powerful factorial sum with elements between m and 2m, then every prime p in (max(S)/2, m] divides 1 + sum_{n > m} n!/m!.
-/
lemma sum_divisible_by_large_primes (m : ℕ) (S : Finset ℕ) (hm : m ∈ S) (h_min : ∀ n ∈ S, m ≤ n) (h_pow : IsPowerful (∑ n ∈ S, n.factorial)) (h_subset : ∀ n ∈ S, n < 2 * m) :
  let n_max := S.max' ⟨m, hm⟩
  ∀ p, p.Prime → n_max / 2 < p → p ≤ m → p ∣ (1 + ∑ n ∈ S.filter (fun x => m < x), (n.factorial / m.factorial)) := by
    intro n_max p hp hp1 hp2
    generalize_proofs at *;
    -- Apply the powerful_implies_congruence lemma with the given conditions.
    have h_cong : (1 + ∑ n ∈ S.filter (fun x => m < x ∧ x < 2 * p), (n.factorial / m.factorial)) % p = 0 := by
      apply powerful_implies_congruence m S hm h_min h_pow p hp (by
      exact lt_of_le_of_lt ( Nat.div_le_div_right <| Finset.le_max' _ _ hm ) hp1) (by
      exact?);
    convert Nat.dvd_of_mod_eq_zero h_cong using 1;
    congr! 1;
    refine' Finset.sum_subset _ _ <;> simp_all +decide [ Finset.subset_iff ];
    exact fun n hn hn' => by linarith [ h_subset n hn, Nat.div_add_mod n_max 2, Nat.mod_lt n_max two_pos, Finset.le_max' _ _ hn ] ;

/-
Given specific bounds on prime gaps and primorial growth, the divisibility condition leads to a contradiction for m >= 100.
-/
lemma singleton_contradiction_with_bounds (m : ℕ) (hm : m ≥ 100) (n0 : ℕ) (h_n0 : m < n0) (h_div : ∀ p, p.Prime → m / 2 < p → p ≤ m → p ∣ (1 + n0.factorial / m.factorial))
  (h_gap : ∃ q, q.Prime ∧ m / 2 < q ∧ q < m / 2 + m / 20)
  (h_prod : (∏ p ∈ Finset.filter (fun p => p.Prime ∧ m / 2 < p ∧ p ≤ m) (Finset.range (m + 1)), p) > m ^ (m / 5)) : False := by
    -- Then n0 < m + m / 10.
    have h_n0_bound : n0 < m + m / 10 := by
      obtain ⟨ q, hq₁, hq₂, hq₃ ⟩ := h_gap;
      -- If $n0 \geq 2q$, then $q \leq n0/2$. Since $q > m/2$, $q$ is in $(m/2, n0/2]$.
      by_cases h_n0_ge_2q : n0 ≥ 2 * q;
      · have h_q_divides_K : q ∣ (1 + (n0.factorial / m.factorial)) := by
          exact h_div q hq₁ hq₂ ( by omega );
        have h_q_divides_n0_factorial : q ∣ (n0.factorial / m.factorial) := by
          have h_factorial_div : m.factorial * (∏ i ∈ Finset.Icc (m + 1) n0, i) = n0.factorial := by
            erw [ Finset.prod_Ico_eq_prod_range ];
            rw [ ← Nat.add_sub_of_le h_n0.le ];
            exact Nat.recOn ( n0 - m ) ( by norm_num ) fun n hn => by simp +decide [ Finset.prod_range_succ, Nat.factorial ] at * ; nlinarith;
          rw [ ← h_factorial_div, Nat.mul_div_cancel_left _ ( Nat.factorial_pos _ ) ];
          exact dvd_trans ( by norm_num ) ( Finset.dvd_prod_of_mem _ ( show q + q ∈ Finset.Icc ( m + 1 ) n0 from Finset.mem_Icc.mpr ⟨ by omega, by omega ⟩ ) );
        simp_all +decide [ Nat.dvd_add_left ];
      · omega;
    -- Then K = 1 + n0! / m! < 1 + n0^(n0-m) < 1 + (1.1 m)^(m/10).
    have h_K_bound : 1 + n0.factorial / m.factorial < 1 + (11 * m / 10) ^ (m / 10) := by
      -- Then n0! / m! ≤ (m+1)(m+2)...n0 ≤ (1.1m)^(n0-m).
      have h_factorial_bound : n0.factorial / m.factorial ≤ (11 * m / 10) ^ (n0 - m) := by
        have h_factorial_bound : n0.factorial / m.factorial ≤ (∏ i ∈ Finset.Icc (m + 1) n0, i) := by
          have h_factorial_bound : n0.factorial = m.factorial * (∏ i ∈ Finset.Icc (m + 1) n0, i) := by
            erw [ Finset.prod_Ico_eq_prod_range ];
            rw [ ← Nat.add_sub_of_le h_n0.le ];
            exact Nat.recOn ( n0 - m ) ( by norm_num ) fun n hn => by simp_all +decide [ Nat.factorial, Finset.prod_range_succ ] ; linarith;
          rw [ h_factorial_bound, Nat.mul_div_cancel_left _ ( Nat.factorial_pos _ ) ];
        refine le_trans h_factorial_bound ?_;
        exact le_trans ( Finset.prod_le_prod' fun x hx => show x ≤ 11 * m / 10 by linarith [ Finset.mem_Icc.mp hx, Nat.div_add_mod ( 11 * m ) 10, Nat.mod_lt ( 11 * m ) ( by decide : 0 < 10 ), Nat.div_mul_le_self m 10 ] ) ( by simp +decide [ Nat.sub_add_cancel h_n0.le ] );
      exact add_lt_add_left ( lt_of_le_of_lt h_factorial_bound ( pow_lt_pow_right₀ ( by omega ) ( by omega ) ) ) _;
    -- But P | K implies P <= K. Contradiction.
    have h_contradiction : (∏ p ∈ Finset.filter (fun p => p.Prime ∧ m / 2 < p ∧ p ≤ m) (Finset.range (m + 1)), p) ∣ (1 + n0.factorial / m.factorial) := by
      convert product_primes_interval_divides m ( 1 + n0.factorial / m.factorial ) h_div using 1;
    -- But $m^{m/5} > (1.1 m)^{m/10}$ for $m \geq 100$.
    have h_exp_bound : m ^ (m / 5) > (11 * m / 10) ^ (m / 10) := by
      -- We can simplify the inequality to $m^{2m/10} > (11m/10)^{m/10}$, which further simplifies to $m^2 > 11m/10$.
      suffices h_simplified : m ^ 2 > 11 * m / 10 by
        refine' lt_of_lt_of_le ( Nat.pow_lt_pow_left h_simplified ( by omega ) ) _;
        rw [ ← pow_mul ] ; exact pow_le_pow_right₀ ( by linarith ) ( by omega ) ;
      exact Nat.div_lt_of_lt_mul <| by nlinarith only [ hm ] ;
    linarith [ Nat.le_of_dvd ( by positivity ) h_contradiction ]