/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7f5ad42c-5394-4dbe-815d-a5ae764ea4ed

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of higher congruence tower and structural results for the Feit-Thompson conjecture at p=3.
Key results include:
- Explicit congruences for k modulo 324 and 972 (extending the known mod 108).
- k ≡ 2 (mod 12q) and k ≡ 12q + 2 (mod 36q).
- k ≡ 4q^2 - 20q + 2 (mod 108q).
- Multiplicative order of 3 modulo A(q) is q.
- Power sum identities: Σ 3^{ji} ≡ 0 (mod A) and 3^(jq) ≡ 1 + jkA (mod A²).
- Fermat quotient relation linking q_3, k, and A.
- n_val properties and constraints on odd prime factors of k (≡ 1 mod q).
- Extended bounded verification showing 3^q ≢ 1 (mod A) for all valid q < 200,000.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions and context for Feit-Thompson p=3 analysis. A(q) = q^2+q+1. k(q) = (3^q-1)/A(q). Context includes primality of q and A, q > 3, q ≡ 2 mod 3, 3^q ≡ 1 mod A, and known congruences for k.
-/
open Nat

def A (q : ℕ) : ℕ := q^2 + q + 1

def k (q : ℕ) : ℕ := (3^q - 1) / (A q)

class FT_Context (q : ℕ) where
  prime_q : Fact q.Prime
  q_gt_3 : q > 3
  q_mod_3 : q ≡ 2 [MOD 3]
  prime_A : Fact (A q).Prime
  pow_3_q : 3^q ≡ 1 [MOD A q]
  k_mod_9 : k q ≡ 8 [MOD 9]
  k_mod_36 : k q ≡ 26 [MOD 36]
  k_mod_6q : k q ≡ 2 [MOD 6 * q]

lemma h_k_def (q : ℕ) [c : FT_Context q] : 3^q = 1 + k q * A q := by
  rw [ k, A ];
  rw [ Nat.div_mul_cancel, add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
  cases' c with hq hA hA' hA'' hA''' hA'''';
  simpa [ ← Int.natCast_dvd_natCast ] using hA'''.symm.dvd

/-
q is congruent to 8 modulo 9.
-/
theorem q_mod_9 (q : ℕ) [c : FT_Context q] : q ≡ 8 [MOD 9] := by
  -- From $3^q = 1 � +� kA$, we know that $1 + kA \equiv 0 \pmod{9}$. Thus, $kA \equiv -1 \pmod{9}$.
  have h_kA_mod_9 : k q * A q ≡ 8 [MOD 9] := by
    -- Since $3^q \equiv 0 \pmod{9}$ for $q > � �3$, we have $1 + k q * A q \equiv 0 \pmod �{�9}$.
    have h_mod_9 : 1 + k q * A q ≡ 0 [MOD 9] := by
      -- Since $3^q \equiv 0 \pmod{9}$ for $q > 3$, we have $1 + k q * A q \equiv  �0� \pmod{9}$.
      have h_mod_9 : 3^q ≡ 0 [MOD 9] := by
        exact Nat.modEq_zero_iff_dvd.mpr ( dvd_trans ( by decide ) ( pow_dvd_pow _ c.q_gt_3 ) );
      have h_mod_9 : 1 + k q * A q = 3^q := by
        have h_mod_9 : k q * A q = 3^q - 1 := by
          exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by simpa [ ← Int.natCast_dvd_natCast ] using c.pow_3_q.symm.dvd );
        rw [ h_mod_9, add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
      aesop;
    exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by rw [ Nat.modEq_zero_iff_dvd ] at *; omega );
  -- Given $k 8 \pmod{9}$, we have $8A 8 \pmod{9}$, so $A 1 \p �mod�{9}$.
  have hA_mod_9 : A q ≡ 1 [MOD 9] := by
    simp_all +decide [ Nat.ModEq, Nat.mul_mod ];
    rw [ c.k_mod_9 ] at h_kA_mod_9; have := Nat.mod_lt ( A q ) ( by decide : 0 < 9 ) ; interval_cases A q % 9 <;> trivial;
  unfold A at hA_mod_9;
  rw [ ← Nat.mod_add_div q 9 ] at *; have := Nat.mod_lt q ( by decide : 0 < 9 ) ; interval_cases q % 9 <;> norm_num [ Nat.ModEq, Nat.add_mod, Nat.pow_mod ] at *;
  have := c.q_mod_3; rw [ Nat.ModEq ] at this; omega;

/-
k + q is congruent to 79 modulo 81.
-/
theorem k_add_q_mod_81 (q : ℕ) [c : FT_Context q] : k q + q ≡ 79 [MOD 81] := by
  -- We know $k \equiv 8 \pmod{9}$ and $q \equiv 2 \pmod{3}$, so let's � write� $k = 9u + 8$ and $q = 9v + 8$ for some integers $ �u�$ and $v$.
  obtain ⟨u, hu⟩ : ∃ u, k q = 9 * u + 8 := by
    have := c.k_mod_9; rw [ Nat.ModEq ] at this; exact ⟨ k q / 9, by linarith [ Nat.mod_add_div ( k q ) 9 ] ⟩ ;
  obtain ⟨v, hv⟩ : ∃ v, q = 9 * v + 8 := by
    use (q - 8) / 9;
    have := @q_mod_9 q c; rw [ Nat.ModEq ] at this; omega;
  -- From the definition of $A(q)$, we have $A(q) = 81v^2 + 153 �v� + 73$.
  have hA : A q = 81 * v^2 + 153 * v + 73 := by
    simpa [ hv, A ] using by ring;
  -- From the definition of $k$, we have $k * A(q) = 3^q - 1$. Taking modulo 81, we get $(9u + 8) * (81v^2 + 153v + 73) \equiv 3^q - 1 \pmod{81}$.
  have h_mod : (9 * u + 8) * (81 * v^2 + 153 * v + 73) ≡ 3^q - 1 [MOD 81] := by
    have h_mod : k q * A q = 3^q - 1 := by
      exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
    rw [ ← h_mod, hu, hA ];
  rcases q with ( _ | _ | _ | _ | _ | q ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod, Nat.pow_mod ] at * ; simp_all +arith +decide [ Nat.ModEq ];
  grind +ring

/-
k + 2 is congruent to 80q modulo 324.
-/
theorem k_add_2_mod_324 (q : ℕ) [c : FT_Context q] : k q + 2 ≡ 80 * q [MOD 324] := by
  -- Combine k+q� � �79 (mod 81) and k 2 (mod 4).
  have h_k_mod_4 : k q ≡ 2 [MOD 4] := by
    exact c.k_mod_36.of_dvd <| by decide;
  have h_k_mod_81 : k q ≡ 79 - q [ZMOD 81] := by
    -- Using the definition of $k$, we have $k � q� = 81m + 79 - q$ for some $m$.
    obtain ⟨m, hm⟩ : ∃ m, k q = 81 * m + 79 - q := by
      have := @k_add_q_mod_81 q c;
      exact ⟨ ( k q + q ) / 81, by rw [ Nat.ModEq ] at this; omega ⟩;
    rw [ hm, Int.modEq_iff_dvd ];
    rw [ Nat.cast_sub ] <;> push_cast <;> ring_nf <;> norm_num;
    by_contra h_contra;
    rw [ Nat.sub_eq_zero_of_le ( by linarith ) ] at hm ; simp_all +decide [ Nat.ModEq ]
  have h_k_mod_324 : k q ≡ 80 * q - 2 [ZMOD 324] := by
    rw [ Int.ModEq ] at *;
    rw [ Nat.ModEq ] at *; omega;
  simpa [ ← Int.natCast_modEq_iff ] using h_k_mod_324.add_right 2

/-
k is congruent to 2 modulo 12q.
-/
theorem k_mod_12q (q : ℕ) [c : FT_Context q] : k q ≡ 2 [MOD 12 * q] := by
  -- From $k 2 [MOD 6q]$ and $k 2 [MOD 4]$, we conclude $k  �2� [MOD lcm(6q, 4)]$.
  have h_k_mod_lcm : k q ≡ 2 [MOD Nat.lcm (6 * q) 4] := by
    have h_k_mod_6q : k q ≡ 2 [MOD 6 * q] := by
      exact c.k_mod_6q
    have h_k_mod_4 : k q ≡ 2 [MOD 4] := by
      have := c.k_mod_36;
      exact this.of_dvd <| by decide;
    exact?;
  convert h_k_mod_lcm using 1 ; rw [ Nat.lcm ] ; ring;
  rw [ show q * 6 = 2 * ( q * 3 ) by ring, Nat.gcd_comm ] ; rw [ Nat.gcd_rec ] ; ( have := Nat.mod_lt q zero_lt_four; interval_cases _ : q % 4 <;> simp_all +decide [ Nat.add_mod, Nat.mul_mod ] ; );
  · have := Nat.Prime.eq_two_or_odd c.prime_q.1; omega;
  · norm_num [ Nat.mul_div_assoc ];
  · have := Nat.Prime.eq_two_or_odd c.prime_q.1; simp_all +decide [ ← Nat.mod_mod_of_dvd q ( by decide : 2 ∣ 4 ) ] ;
  · norm_num [ Nat.mul_div_assoc ]

/-
k is congruent to 12q + 2 modulo 36q.
-/
theorem k_mod_36q (q : ℕ) [c : FT_Context q] : k q ≡ 12 * q + 2 [MOD 36 * q] := by
  -- By the Chinese Remainder The �orem�, there exists a unique solution modulo 36q.
  have h_crt : ∃ x, x ≡ k q [MOD 12 * q] ∧ x ≡ 26 [MOD 36] ∧ x ≡ 12 * q + 2 [MOD 36 * q] := by
    use 12 * q + 2;
    have h_cong : k q ≡ 2 [MOD 12 * q] := by
      have := @k_mod_12q q c; aesop;
    simp_all +decide [ Nat.ModEq ];
    rw [ ← Nat.mod_add_div q 3, show q % 3 = 2 from c.q_mod_3 ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ;
  -- By the Chinese Remainder Theorem, since x �₡� k � q� (mod 12q) and x k q (mod 36), we have x ≡ k q (mod 36q).
  obtain ⟨x, hx⟩ := h_crt;
  have hx_mod : x ≡ k q [MOD 36 * q] := by
    -- Since $k q \ �equiv� 26 \pmod{36}$ and $x � \�equiv 26 \pmod{36}$, we have $x \equiv k q \pmod{36}$.
    have hx_mod_36 : x ≡ k q [MOD 36] := by
      exact hx.2.1.trans ( c.k_mod_36.symm );
    rw [ Nat.modEq_iff_dvd ] at *;
    convert Int.coe_lcm_dvd hx.1 hx_mod_36 using 1 ; norm_num [ Int.lcm ] ; ring;
    norm_cast ; norm_num [ Nat.lcm ];
    rw [ show q * 12 = 12 * q by ring, show 36 = 12 * 3 by norm_num, Nat.gcd_mul_left ] ; norm_num [ Nat.gcd_comm ];
    rw [ show Nat.gcd q 3 = 1 by exact Nat.Coprime.symm <| Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by have := Nat.mod_eq_zero_of_dvd h; have := c.q_mod_3; simp_all +decide [ Nat.ModEq, Nat.mod_eq_of_lt ] ] ; norm_num ; ring;
    exact Eq.symm ( Nat.div_eq_of_eq_mul_left ( by decide ) ( by ring ) );
  exact hx_mod.symm.trans hx.2.2

/-
k is congruent to 4q^2 - 20q + 2 modulo 108q.
-/
theorem k_mod_108q (q : ℕ) [c : FT_Context q] (h_k_mod_108 : k q ≡ 8 * q + 34 [MOD 108]) :
    k q ≡ 4 * q^2 - 20 * q + 2 [MOD 108 * q] := by
      -- We have k 12q + � �2 (mod 36q) and k 8q + 34 (mod 108). Let's write k as 36qm + 12q + 2 for some integer m.
      obtain ⟨m, hm⟩ : ∃ m, k q = 36 * q * m + 12 * q + 2 := by
        -- By definition of $k$, � we� know that $k q 12 * q + 2 [MOD 36 * q]$.
        have h_congr : k q % (36 * q) = (12 * q + 2) % (36 * q) := by
          have := @k_mod_36q q c;
          exact this;
        use (k q / (36 * q));
        linarith [ Nat.mod_add_div ( k q ) ( 36 * q ), Nat.mod_eq_of_lt ( show 12 * q + 2 < 36 * q by linarith [ c.q_gt_3 ] ) ];
      -- Since $q \equiv 8 \pmod{9}$, let $ �q = 9t + 8$ for some integer $t$.
      obtain ⟨t, rfl⟩ : ∃ t, q = 9 * t + 8 := by
        -- By definition of congruence modulo 9, there exists an integer t such that q = 9t + 8.
        use (q - 8) / 9;
        rw [ Nat.mul_div_cancel', Nat.sub_add_cancel ];
        · exact le_of_not_gt fun h => by interval_cases q <;> contradiction;
        · cases le_total q 8 <;> simp_all +decide [ Nat.ModEq ];
          grind;
      -- From the congruence $k \equiv 8q + 34 \pmod{108}$, � we� can derive that $m \equiv t \pmod{3}$.
      have h_m_mod_3 : m ≡ t [MOD 3] := by
        norm_num [ Nat.ModEq, Nat.mod_mod ] at *;
        grind;
      rw [ hm ];
      rw [ Nat.modEq_iff_dvd ];
      rw [ ← Nat.mod_add_div m 3, h_m_mod_3 ] ; push_cast ; ring_nf ;
      rw [ Nat.cast_sub ( by nlinarith only [ c.q_gt_3 ] ) ] ; push_cast ; ring_nf;
      exact ⟨ - ( m / 3 ) + t / 3, by nlinarith only [ Nat.mod_add_div t 3, show ( t : ℤ ) % 3 = t % 3 from rfl, show ( m : ℤ ) / 3 = m / 3 from rfl ] ⟩

/-
The multiplicative order of 3 modulo A(q) is q.
-/
theorem orderOf_3_mod_A_eq_q (q : ℕ) [c : FT_Context q] : orderOf (3 : ZMod (A q)) = q := by
  -- From 3^q ≡ 1 [MOD A], we know � that� the order of 3 modulo A divides q. Since q is prime, the order must be 1 � or� q.
  have h_order_div : (orderOf (3 : ZMod (A q))) ∣ q := by
    exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using c.pow_3_q )
  have h_order_prime : (orderOf (3 : ZMod (A q))) = 1 ∨ (orderOf (3 : ZMod (A q))) = q := by
    rwa [ Nat.dvd_prime c.prime_q.1 ] at h_order_div;
  -- If orderOf(3) = 1, then 3 ≡ 1 (mod A), so A | 2.
  have h_order_one : (orderOf (3 : ZMod (A q))) = 1 → (A q) ∣ 2 := by
    simp +contextual [ ← ZMod.natCast_eq_zero_iff ];
    exact fun h => by linear_combination' h;
  exact h_order_prime.resolve_left fun h => absurd ( h_order_one h ) ( Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by exact lt_add_of_lt_of_nonneg ( lt_add_of_lt_of_nonneg ( by nlinarith [ c.q_gt_3 ] ) ( Nat.zero_le _ ) ) ( Nat.zero_le _ ) ) )

/-
The sum of (3^j)^i for i from 0 to q-1 is 0 modulo A(q), for 1 <= j < q.
-/
theorem sum_pow_3_mod_A_eq_zero (q : ℕ) [c : FT_Context q] (j : ℕ) (hj : 1 ≤ j) (hj' : j < q) :
    ∑ i ∈ Finset.range q, (3 : ZMod (A q)) ^ (j * i) = 0 := by
      simp +decide [ pow_mul ];
      -- Since $3^j \not\equiv 1 \ �p�mod{A(q)}$, we have $(3^j)^q \equiv 1 \pmod{A(q)}$.
      have h_pow : (3 ^ j) ^ q ≡ 1 [MOD A q] := by
        simpa [ ← pow_mul, mul_comm ] using c.pow_3_q.pow j;
      have := geom_sum_mul ( 3 ^ j : ZMod ( A q ) ) q;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      -- Since $3^j \not\equiv 1 \pmod{A(q)}$, we have $(3^j - 1) \neq 0 \pmod{A(q)}$.
      have h_ne_zero : (3 ^ j - 1 : ZMod (A q)) ≠ 0 := by
        intro h; have := orderOf_dvd_iff_pow_eq_one.mpr ( show ( 3 : ZMod ( A q ) ) ^ j = 1 from sub_eq_zero.mp h ) ; simp_all +decide [ orderOf_dvd_iff_pow_eq_one ] ;
        have := orderOf_dvd_iff_pow_eq_one.mpr this; simp_all +decide [ orderOf_3_mod_A_eq_q ] ;
        linarith [ Nat.le_of_dvd ( by linarith ) this ];
      haveI := Fact.mk ( show Nat.Prime ( A q ) from c.prime_A.1 ) ; aesop;

/-
Relation between Fermat quotient of 3 and k: 3 * q_3 = ((k-2)/q) * A + 2q + 2.
-/
def fermatQuotient3 (q : ℕ) : ℕ := (3^(q-1) - 1) / q

theorem fermatQuotient3_relation (q : ℕ) [c : FT_Context q] :
    3 * fermatQuotient3 q = ((k q - 2) / q) * A q + 2 * q + 2 := by
      -- From 3^q = 3 * 3^(q-1) = 3(1 + q * q_3) = 3 + 3q * q_3.
      have h_expansion : 3 ^ q = 3 + 3 * q * fermatQuotient3 q := by
        unfold fermatQuotient3;
        rw [ ← Nat.mul_div_assoc, Nat.mul_comm ];
        · rcases q with ( _ | _ | q ) <;> simp_all +decide [ pow_succ', Nat.mul_div_assoc ];
          · exact Nat.not_prime_zero c.prime_q.1;
          · linarith [ Nat.sub_add_cancel ( show 1 ≤ 3 * 3 ^ q from Nat.one_le_iff_ne_zero.mpr ( by positivity ) ) ];
        · have := Nat.totient_prime c.prime_q.1;
          rw [ ← Nat.modEq_zero_iff_dvd ];
          simpa [ Nat.modEq_iff_dvd, this ] using Nat.ModEq.pow_totient ( Nat.coprime_comm.mp <| c.prime_q.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith ) h; linarith [ c.q_gt_3 ] );
      -- Substitute k = mq + 2 into the equation kA = 2 + 3q q_3.
      have h_subst : (k q - 2) / q * A q + 2 * q + 2 = 3 * fermatQuotient3 q := by
        have h_k : k q = ((k q - 2) / q) * q + 2 := by
          rw [ Nat.div_mul_cancel, tsub_add_cancel_of_le ];
          · have := c.k_mod_36; rw [ Nat.ModEq ] at this; omega;
          · -- Since $k \equiv 2 � \�pmod{q}$, we have $k = mq + 2$ for some integer $m$.
            have h_k_mod : k q ≡ 2 [MOD q] := by
              have := c.k_mod_6q; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
              -- Since $q$ divides $6q$, the congruence modulo $6q$ implies the congruence modulo $q$.
              have h_cong : (k q : ℕ) ≡ 2 [MOD 6 * q] → (k q : ℕ) ≡ 2 [MOD q] := by
                exact fun h => h.of_dvd <| dvd_mul_left _ _;
              simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
            rw [ ← Nat.mod_add_div ( k q ) q, h_k_mod ];
            rcases q with ( _ | _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ]
        have h_subst : k q * A q = 2 + 3 * q * fermatQuotient3 q := by
          have h_subst : k q * A q = 3 ^ q - 1 := by
            exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
          exact h_subst.trans ( Nat.sub_eq_of_eq_add <| by linarith );
        rw [ show A q = q ^ 2 + q + 1 from rfl ] at * ; nlinarith [ c.q_gt_3 ];
      exact h_subst.symm

/-
n_val satisfies 27 * n_val ≡ -8 modulo q.
-/
def n_val (q : ℕ) : ℕ := (k q - 8 * q - 34) / 108

theorem n_val_mod_q (q : ℕ) [c : FT_Context q] (h_k_mod_108 : k q ≡ 8 * q + 34 [MOD 108]) :
    27 * n_val q ≡ -8 [ZMOD q] := by
      -- Substitute h_k_mod_108 into the expression for n_val and simplify.
      have h_subst : 108 * (n_val q : ℤ) ≡ k q - 8 * q - 34 [ZMOD q] := by
        have h_subst : 108 * (n_val q : ℤ) = k q - 8 * q - 34 := by
          unfold n_val;
          rw_mod_cast [ Nat.mul_div_cancel' ];
          · rw [ Int.subNatNat_of_le ];
            · rw [ Nat.cast_sub ];
              · rfl;
              · refine Nat.le_sub_of_add_le' ?_;
                refine' Nat.le_div_iff_mul_le ( Nat.succ_pos _ ) |>.2 _;
                refine' Nat.le_induction _ _ q ( show q ≥ 11 by exact le_of_not_gt fun h => by interval_cases q <;> exact absurd h_k_mod_108 ( by native_decide ) ) <;> intros <;> norm_num [ Nat.pow_succ' ] at *;
                rw [ Nat.le_sub_iff_add_le ] at * <;> nlinarith [ Nat.pow_le_pow_right ( show 1 ≤ 3 by norm_num ) ‹11 ≤ _› ];
            · have h_k_ge_8q : k q * (q^2 + q + 1) = 3^q - 1 := by
                exact Nat.div_mul_cancel ( show q ^ 2 + q + 1 ∣ 3 ^ q - 1 from by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
              have h_k_ge_8q : 3^q - 1 ≥ 8 * q * (q^2 + q + 1) := by
                have h_k_ge_8q : ∀ q ≥ 11, 3^q - 1 ≥ 8 * q * (q^2 + q + 1) := by
                  exact fun q hq => Nat.le_sub_one_of_lt <| by induction hq <;> norm_num [ Nat.pow_succ' ] at * ; nlinarith;
                by_cases hq : q ≥ 11;
                · exact h_k_ge_8q q hq;
                · interval_cases q <;> simp_all +decide;
              nlinarith [ pow_pos ( show 0 < 3 by decide ) q ];
          · rw [ ← Nat.mod_add_div ( k q ) 108, h_k_mod_108 ] ; norm_num [ Nat.add_mod, Nat.mul_mod ];
            omega;
        aesop;
      -- From k 4q^2 - 20q + 2 (mod 108q), we have k = 108q � *� J + � (�4q^2 - 20q + 2) for some integer J.
      obtain ⟨J, hJ⟩ : ∃ J : ℤ, k q = 108 * q * J + (4 * q^2 - 20 * q + 2) := by
        -- By combining the congruences modulo 108 and � modulo� q, we can express k q as 108q*J + (4q^2 - 20q + 2) for some integer J.
        have h_combined : k q ≡ 4 * q^2 - 20 * q + 2 [ZMOD 108 * q] := by
          have := @k_mod_108q q c;
          norm_cast at *;
          rw [ Int.subNatNat_of_le ] <;> norm_cast;
          · exact this h_k_mod_108;
          · nlinarith [ show q ≥ 5 by exact le_of_not_gt fun h => by interval_cases q <;> exact absurd h_k_mod_108 ( by native_decide ) ];
        exact h_combined.symm.dvd.imp fun J hJ => by linarith;
      -- Substitute hJ into the expression for n_val and simplify modulo q.
      have h_mod_q : 108 * (n_val q : ℤ) ≡ 2 - 28 * q - 34 [ZMOD q] := by
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      have h_div : 4 * (27 * (n_val q : ℤ)) ≡ 4 * (-8) [ZMOD q] := by
        convert h_mod_q.trans ( Int.modEq_of_dvd _ ) using 1 ; ring_nf ; norm_num [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
      rw [ Int.modEq_iff_dvd ] at *;
      have h_coprime : Int.gcd (q :) 4 = 1 := by
        exact_mod_cast c.prime_q.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases q <;> trivial;
      exact ( Int.dvd_of_dvd_mul_right_of_gcd_one ( by convert h_div using 1; ring ) h_coprime )

/-
Any odd prime factor of k is congruent to 1 modulo q.
-/
theorem odd_prime_factor_k_mod_q (q : ℕ) [c : FT_Context q] (p : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) (h_dvd : p ∣ k q) :
    p ≡ 1 [MOD q] := by
      have h_order : orderOf (3 : ZMod p) = q := by
        -- Since $p$ divides $k$, we have $p � \mid� 3^q - 1$. Therefore, $3^q \equiv 1 \pmod{p}$.
        have h_mod : 3^q ≡ 1 [MOD p] := by
          -- Since $p$ � divides� $k$, we have $p \mid 3^q - 1$.
          have h_div : p ∣ 3^q - 1 := by
            refine dvd_trans h_dvd ?_;
            exact Nat.div_dvd_of_dvd ( by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
          exact Nat.ModEq.symm <| Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_div;
        -- Since $q$ is prime, the order of $3$ � modulo� $p$ must divide $q$.
        have h_div : orderOf (3 : ZMod p) ∣ q := by
          exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_mod );
        -- Since $q$ is prime, the order of $3$ modulo $p$ must be $1$ or $q$. However, if the order were $1$, then $3 \equiv 1 \pmod{p}$, which contradicts $p \neq 2$.
        have h_order_ne_one : orderOf (3 : ZMod p) ≠ 1 := by
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
          intro H; rcases p with ( _ | _ | _ | _ | p ) <;> cases H <;> simp_all +decide ;
        rw [ Nat.dvd_prime c.prime_q.1 ] at h_div ; aesop;
      -- By Fermat's Little Theorem, we know that $3^{p-1} \equiv 1 \pmod{p}$. Since the order of $3$ modulo $p$ is $q$, � it� follows that $q$ divides $p-1$.
      have h_div : q ∣ p - 1 := by
        rw [ ← h_order, orderOf_dvd_iff_pow_eq_one ];
        haveI := Fact.mk hp;
        rw [ ZMod.pow_card_sub_one_eq_one ];
        intro H; have := orderOf_dvd_iff_pow_eq_one.1 ( dvd_of_eq h_order ) ; simp_all +decide ;
        linarith [ c.q_gt_3 ];
      exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, hp.pos ] using h_div )

/-
Modular exponentiation and verification functions for Feit-Thompson p=3.
-/
def powMod (b e m : Nat) : Nat :=
  if m == 0 then 0 else
  if m == 1 then 0 else
  let rec go (b e acc : Nat) : Nat :=
    if h : e = 0 then acc
    else
      let acc := if e % 2 == 1 then (acc * b) % m else acc
      let b := (b * b) % m
      go b (e / 2) acc
    termination_by e
    decreasing_by
    exact Nat.div_lt_self ( Nat.pos_of_ne_zero h ) ( by decide )
  go (b % m) e 1

def check_q (q : ℕ) : Bool :=
  if q ≤ 3 then true
  else if !q.Prime then true
  else if q % 3 != 2 then true
  else
    let a := A q
    if !a.Prime then true
    else powMod 3 q a != 1

def verify_range (limit : ℕ) : Bool :=
  (List.range limit).all check_q

/-
Verification that for all q < 100, the Feit-Thompson conditions hold (specifically 3^q ≢ 1 mod A(q)).
-/
theorem verify_up_to_100 : verify_range 100 = true := by native_decide

/-
Verification up to 2000.
-/
theorem verify_up_to_2000 : verify_range 2000 = true := by native_decide

/-
Verification up to 10,000.
-/
theorem verify_up_to_10000 : verify_range 10000 = true := by native_decide

/-
Verification up to 50,000.
-/
theorem verify_up_to_50000 : verify_range 50000 = true := by native_decide

/-
Verification up to 100,000.
-/
theorem verify_up_to_100000 : verify_range 100000 = true := by native_decide

/-
Verification up to 200,000.
-/
theorem verify_up_to_200000 : verify_range 200000 = true := by native_decide

/-
n_val is positive.
-/
theorem n_val_pos (q : ℕ) [c : FT_Context q] : n_val q > 0 := by
  refine' Nat.div_pos _ ( by decide );
  -- Since $q \equiv 8 \pmod{9}$ and $q > 3$, we have $q \geq 17$.
  have hq_ge_17 : 17 ≤ q := by
    by_contra h_contra;
    interval_cases q <;> simp_all +decide;
    all_goals cases c ; simp_all +decide [ Nat.pow_succ ] ;
  rw [ Nat.sub_sub, le_tsub_iff_left ];
  · -- We'll use that $3^q > (8q + 142)(q^2 + q + 1)$ for $q \geq 17$.
    have h_exp_growth : ∀ q ≥ 17, 3^q > (8 * q + 142) * (q^2 + q + 1) := by
      exact fun q hq => by induction hq <;> norm_num [ Nat.pow_succ' ] at * ; nlinarith;
    have := h_exp_growth q hq_ge_17; ( rw [ show k q = ( 3 ^ q - 1 ) / ( q ^ 2 + q + 1 ) by rfl ] ; exact Nat.le_div_iff_mul_le ( by positivity ) |>.2 <| Nat.le_sub_one_of_lt <| by nlinarith; );
  · -- By definition of $k$, we know that $k q = (3^q - 1) / A q$.
    have hk_def : k q = (3^q - 1) / (q^2 + q + 1) := by
      exact?;
    rw [ hk_def, Nat.le_div_iff_mul_le ];
    · exact Nat.le_sub_one_of_lt ( by { exact Nat.le_induction ( by norm_num ) ( fun n hn ih ↦ by norm_num [ Nat.pow_succ' ] at * ; nlinarith only [ ih, hn ] ) q hq_ge_17 } );
    · positivity

/-
Definition of k modulo 243 using the extended Euclidean algorithm to find the inverse of A.
-/
def k_mod_243 (q : ℕ) : ℕ :=
  let a_val := (A q) % 243
  let a_inv := (Nat.gcdA a_val 243) % 243
  ((243 - a_inv) % 243).toNat

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_is_correct (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      -- By definition of $k_mod_243$, we know that $k q \equiv - (A q)^{-1} \pmod{243}$.
      have h_k_mod_243_def : k q * (A q) ≡ -1 [ZMOD 243] := by
        -- Since $3^q \equiv 0 \p �mod�{24 �3�}$ for $q \geq  �5�$, we have $1 + k �(q�)A(q) \equiv 0 \pmod{243}$.
        have h_mod_243 : (3 ^ q : ℤ) ≡ 0 [ZMOD 243] := by
          exact Int.modEq_zero_iff_dvd.mpr ( pow_dvd_pow _ ( show q ≥ 5 by exact le_of_not_gt fun h => by interval_cases q <;> cases c <;> trivial ) );
        -- From the definition of $k$, we know that $3^q = 1 + kq * Aq$.
        have h_k_eq : (3 ^ q : ℤ) = 1 + k q * (A q : ℤ) := by
          unfold k A;
          rw_mod_cast [ Nat.div_mul_cancel ];
          · rw [ add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
          · have := c.pow_3_q;
            simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( Nat.one_le_pow q 3 zero_lt_three ) ] using this.symm.dvd;
        exact Int.modEq_iff_dvd.mpr ⟨ -h_mod_243.symm.dvd.choose, by linarith [ h_mod_243.symm.dvd.choose_spec ] ⟩;
      -- Since $A q$ is invertible modulo $243$, we can multiply both sides of $k q * A q -1 [ZMOD 243]$ by � the� inverse of $A q$ modulo $243$.
      have h_inv : (A q) * (Nat.gcdA (A q % 243) 243 % 243) ≡ 1 [ZMOD 243] := by
        have h_inv : Nat.gcd (A q % 243) 243 = 1 := by
          have h_gcd : Nat.gcd (A q) 243 = 1 := by
            have h_coprime : Nat.gcd (A q) 3 = 1 := by
              have h_coprime : A q % 3 = 1 := by
                have := c.q_mod_3; ( rw [ Nat.ModEq ] at this; norm_num [ Nat.add_mod, Nat.pow_mod, Nat.mul_mod, A ] at *; have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> trivial; );
              rw [ ← Nat.mod_add_div ( A q ) 3, h_coprime ] ; norm_num
            exact Nat.Coprime.pow_right 5 h_coprime;
          rwa [ Nat.gcd_comm, Nat.gcd_rec ] at h_gcd;
        have h_inv : (A q % 243) * (Nat.gcdA (A q % 243) 243) ≡ 1 [ZMOD 243] := by
          rw [ Int.modEq_iff_dvd ];
          have := Nat.gcd_eq_gcd_ab ( A q % 243 ) 243; aesop;
        simpa [ Int.ModEq, Int.mul_emod ] using h_inv;
      -- By combining the congruences � $�k q * A q -1 [ZMOD 243]$ and $A q * (Nat.gcdA (A q % 243) 243 % 243) ≡ 1 [ZMOD 243]$, we get $k q ≡ - (Nat.gcdA (A q % 243) 243 % 243) [ZMOD 243]$.
      have h_k_mod_243_combined : k q ≡ - (Nat.gcdA (A q % 243) 243 % 243) [ZMOD 243] := by
        have := h_k_mod_243_def.mul_right ( Nat.gcdA ( A q % 243 ) 243 % 243 );
        simp_all +decide [ mul_assoc, Int.ModEq ];
        rw [ ← this, Int.mul_emod, h_inv ] ; norm_num;
      simp_all +decide [ ← Int.natCast_modEq_iff ];
      unfold k_mod_243; norm_num [ Int.ModEq ] at *; omega;

/-
A(q) is coprime to 243.
-/
theorem A_coprime_243 (q : ℕ) [c : FT_Context q] : Nat.gcd (A q) 243 = 1 := by
  -- Since $q \equiv 2 \pmod{3}$, we have $q^2 + q + 1 \equiv 2^2 + 2 + 1 \equiv 7 \equiv � �1 \pmod{3}$.
  have h_mod_3 : (q^2 + q + 1) % 3 = 1 := by
    rw [ ← Nat.mod_add_div q 3, c.q_mod_3 ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ;
  unfold A; exact Nat.Coprime.pow_right 5 <| Nat.Coprime.symm <| Nat.prime_three.coprime_iff_not_dvd.mpr <| by omega;

/-
3^q is congruent to 0 modulo 243.
-/
theorem pow_3_q_mod_243 (q : ℕ) [c : FT_Context q] : 3^q ≡ 0 [MOD 243] := by
  exact Nat.modEq_zero_iff_dvd.mpr ( pow_dvd_pow _ ( show q ≥ 5 by exact le_of_not_gt fun h => by interval_cases q <;> cases c <;> trivial ) )

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_correct (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      have := @k_mod_243_is_correct q c;
      exact this

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_proven (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      -- Since $A(q)$ is coprime to $243$, it has an inverse modulo $243$.
      have h_inv : ∃ x, A q * x ≡ 1 [MOD 243] := by
        have := Nat.exists_mul_emod_eq_one_of_coprime ( show Nat.Coprime ( q ^ 2 + q + 1 ) 243 from ?_ );
        · exact this ( by decide );
        · exact Nat.Coprime.symm ( Nat.Coprime.gcd_eq_one <| by rw [ show 243 = 3 ^ 5 by norm_num ] ; exact Nat.Coprime.pow_left _ <| by simpa [ ← Int.natCast_dvd_natCast ] using Nat.prime_three.coprime_iff_not_dvd.2 <| by rw [ Nat.dvd_iff_mod_eq_zero ] ; norm_num [ Nat.add_mod, Nat.pow_mod ] ; have := c.q_mod_3 ; rw [ ← Nat.mod_add_div q 3, show q % 3 = 2 from c.q_mod_3 ] ; norm_num );
      -- By multiplying both sides of the � congr�uence $k * A(q) ≡ 243 - 1$ (mod 243) by the inverse of $A(q)$, we get $k ≡ (243 - 1) * x$ (mod 243).
      obtain ⟨x, hx⟩ : ∃ x, A q * x ≡ 1 [MOD 243] := h_inv
      have h_k_mod_243 : k q * A q ≡ 243 - 1 [MOD 243] := by
        have h_k_mod_243 : k q * A q = 3^q - 1 := by
          exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
        rw [ h_k_mod_243, Nat.ModEq ];
        rcases q with ( _ | _ | _ | _ | _ | q ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod ] at *;
        all_goals have := c.q_gt_3; norm_num at this;
        · cases c ; contradiction;
        · zify ; norm_num [ Int.sub_emod, Int.mul_emod ]
      have h_k_mod_243_equiv : k q ≡ (243 - 1) * x [MOD 243] := by
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        linear_combination' h_k_mod_243 * x - hx * k q;
      refine h_k_mod_243_equiv.trans ?_;
      -- By definition of $k_mod_243$, we know that $k_mod_243 q \equiv (243 - 1) * x \pmod{243}$.
      have h_k_mod_243_def : k_mod_243 q ≡ (243 - 1) * x [MOD 243] := by
        have h_inv : (A q) % 243 * (Nat.gcdA ((A q) % 243) 243) ≡ 1 [ZMOD 243] := by
          have := Nat.gcd_eq_gcd_ab ( A q % 243 ) 243; simp_all +decide [ ← Int.natCast_modEq_iff ] ;
          rw [ Int.ModEq ] ; norm_cast at *; simp_all +decide [ Nat.gcd_rec 243 ] ;
          have h_gcd : Nat.gcd (A q % 243) 243 = 1 := by
            rw [ ← Nat.mod_add_div ( A q ) 243 ] at *; simp_all +decide [ Nat.ModEq, Nat.mul_mod ] ;
            exact Nat.Coprime.symm ( Nat.Coprime.coprime_dvd_right ( dvd_mul_right _ _ ) <| by rw [ ← Nat.mod_add_div ( A q % 243 * ( x % 243 % 243 ) ) 243 ] ; aesop );
          grind
        -- Since $A(q �)� * x \equiv 1 \pmod{243}$, we have $(A(q) % 243) * x \equiv 1 \pmod{243}$.
        have h_mod : (A q) % 243 * x ≡ 1 [ZMOD 243] := by
          norm_cast at *; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          simpa [ Nat.ModEq, Nat.mul_mod ] using hx;
        have h_mod : (Nat.gcdA ((A q) % 243) 243) ≡ x [ZMOD 243] := by
          have := h_inv.mul_left x; have := h_mod.mul_left ( Nat.gcdA ( A q % 243 ) 243 ) ; ring_nf at *; simp_all +decide [ Int.ModEq ] ;
        unfold k_mod_243; simp_all +decide [ ← Int.natCast_modEq_iff ] ;
        rw [ Int.ModEq ] at *; omega;
      exact h_k_mod_243_def.symm

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_final (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      haveI := Fact.mk c.prime_A.1; norm_num [ Nat.ModEq, Nat.pow_mod ] at *;
      rw [ ← ZMod.natCast_eq_natCast_iff' ] at *;
      -- Since $A(q) \equiv 0 \pmod{243}$, we have $k(q) \equiv k \pmod{243}$ where $k$ is the multiplicative inverse of $A(q)$ modulo $243$.
      have h_k_mod : (k q : ZMod 243) = - (A q : ZMod 243)⁻¹ := by
        have h_k_mod : (k q : ZMod 243) * (A q : ZMod 243) = -1 := by
          have h_k_mod : (3^q : ZMod 243) = 1 + (k q : ZMod 243) * (A q : ZMod 243) := by
            norm_cast at *;
            rw [ show k q * A q = 3 ^ q - 1 from ?_ ];
            · rw [ add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
            · exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
          have h_k_mod : (3^q : ZMod 243) = 0 := by
            have h_k_mod : q ≥ 5 := by
              exact le_of_not_gt fun h => by interval_cases q <;> cases c <;> contradiction;
            exact pow_eq_zero_of_le h_k_mod ( by decide );
          grind;
        have h_inv : (A q : ZMod 243) * (A q : ZMod 243)⁻¹ = 1 := by
          have h_inv : IsUnit (A q : ZMod 243) := by
            exact isUnit_iff_exists_inv.mpr ⟨ -k q, by linear_combination' h_k_mod.symm ⟩;
          exact?;
        grind;
      -- By definition of $k_mod_243$, we know that $(A q : ZMod 243)⁻¹ = Nat.gcdA (A q % 243) 243$.
      have h_inv : (A q : ZMod 243)⁻¹ = Nat.gcdA (A q % 243) 243 := by
        exact?;
      simp_all +decide [ k_mod_243 ];
      erw [ ← Int.emod_add_mul_ediv ( Nat.gcdA ( A q % 243 ) 243 ) 243 ] ; norm_num [ Int.toNat_of_nonneg, Int.emod_nonneg ];
      norm_cast;
      erw [ ZMod.intCast_eq_intCast_iff ] ; norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod ]

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_congr (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      rw [ Nat.modEq_iff_dvd ];
      have h_mod_243 : (A q) * (k q) ≡ -1 [ZMOD 243] := by
        have h_mod_243 : (A q) * (k q) = 3^q - 1 := by
          exact Nat.mul_div_cancel' ( by exact Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact by have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd ) );
        norm_cast;
        rw [ h_mod_243, Int.ModEq ];
        rcases q with ( _ | _ | _ | _ | _ | q ) <;> norm_num [ pow_succ, mul_assoc, Int.mul_emod ] at *;
        all_goals have := c.q_gt_3; simp_all +decide;
      -- Since $A(q)$ is coprime to $243$, we can find an integer $ �x�$ such that $A(q) \cdot x \equiv 1 \pmod{243}$.
      obtain ⟨x, hx⟩ : ∃ x : ℤ, (A q : ℤ) * x ≡ 1 [ZMOD 243] := by
        have h_coprime : Int.gcd (A q :) 243 = 1 := by
          exact_mod_cast c.prime_A.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; have := Nat.le_of_lt_succ ( show q < 45 by nlinarith [ show A q = q^2 + q + 1 from rfl ] ) ; interval_cases q <;> trivial;
        exact?;
      -- By definition of $k_mod_243$, we � know� that $ �k�_mod_243 q \equiv -x \pmod{243}$.
      have h_k_mod_243_def : (k_mod_243 q : ℤ) ≡ -x [ZMOD 243] := by
        -- By definition of $k_mod_243$, we know that $k_mod_243 q \equiv -x \pmod{243}$.
        simp [k_mod_243];
        -- By definition of gcdA, we know that gcdA(a, b) * a ≡ 1 [ZMOD b] when a and b are coprime.
        have h_gcdA : (Nat.gcdA (A q % 243) 243) * (A q % 243) ≡ 1 [ZMOD 243] := by
          have h_coprime : Nat.gcd (A q) 243 = 1 := by
            have h_coprime : Nat.gcd (A q) 243 = 1 := by
              have h_coprime : Nat.gcd (A q) 3 = 1 := by
                exact c.prime_A.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by norm_num ) h; rcases q with ( _ | _ | _ | _ | _ | q ) <;> simp_all +arith +decide [ A ] ;
              exact Nat.Coprime.pow_right 5 h_coprime;
            exact h_coprime;
          rw [ ← Nat.mod_add_div ( A q ) 243 ] at *; simp_all +decide [ Nat.gcd_comm ] ;
          have := Nat.gcd_eq_gcd_ab ( A q % 243 ) 243; simp_all +decide [ Nat.gcd_comm ] ;
          norm_num [ mul_comm, Int.ModEq ];
        have := h_gcdA.mul_left x; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        have := hx.mul_left ( Nat.gcdA ( A q % 243 ) 243 ) ; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, mul_assoc, mul_comm, mul_left_comm ] ;
        simp_all +decide [ ← mul_assoc, Int.ModEq ];
        simp_all +decide [ mul_assoc, Int.mul_emod ];
        grind;
      have := h_mod_243.sub ( hx.mul_left ( k q : ) ) ; ring_nf at *; simp_all +decide [ Int.ModEq ] ;
      norm_num [ Int.sub_emod, Int.mul_emod, h_mod_243, hx ] at this;
      exact Int.dvd_of_emod_eq_zero ( by omega )

/-
k is congruent to k_mod_243 modulo 243.
-/
theorem k_mod_243_final_v3 (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_243 q [MOD 243] := by
      have := @k_mod_243_is_correct q c ; aesop

/-
k_mod_243 * A is congruent to -1 modulo 243.
-/
theorem k_mod_243_mul_A (q : ℕ) [c : FT_Context q] :
    k_mod_243 q * A q ≡ 242 [MOD 243] := by
      have h_inv : (Nat.gcdA (A q % 243) 243 : ℤ) * A q ≡ 1 [ZMOD 243] := by
        have h_inv : Nat.gcd (A q) 243 = 1 := by
          have h_coprime : Nat.gcd (A q) 3 = 1 := by
            exact c.prime_A.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; nlinarith [ show q > 3 by exact c.q_gt_3, show A q = q^2 + q + 1 by rfl ] ;
          exact Nat.Coprime.pow_right 5 h_coprime;
        have := Nat.gcd_eq_gcd_ab ( A q % 243 ) 243;
        rw [ ← Nat.mod_add_div ( A q ) 243 ] at *; simp_all +decide [ Nat.ModEq, Int.ModEq ] ;
        grind;
      unfold k_mod_243;
      simp_all +decide [ ← Int.natCast_modEq_iff ];
      norm_num [ Int.ModEq, Int.mul_emod, Int.emod_nonneg ] at *;
      norm_num [ ← Int.mul_emod, h_inv ];
      rw [ neg_eq_neg_one_mul, Int.mul_emod ] ; norm_num [ Int.mul_emod, h_inv ];
      aesop

/-
Definition of k modulo 972 based on k modulo 243.
-/
def k_mod_972 (q : ℕ) : ℕ :=
  (244 * k_mod_243 q + 486) % 972

/-
k is congruent to k_mod_972 modulo 972.
-/
theorem k_mod_972_is_correct (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_972 q [MOD 972] := by
      -- By definition of $k_mod_972$, we � know� that $k \equiv k_mod_972 \pmod{972}$.
      have h_k_mod_972 : k q ≡ k_mod_972 q [MOD 243] ∧ k q ≡ k_mod_972 q [MOD 4] := by
        unfold k_mod_972;
        -- By definition of $k_mod_972$, � we� know that $k \equiv k_mod_972 \pmod{972}$.
        apply And.intro;
        · unfold k_mod_243;
          have := @k_mod_243_is_correct q c;
          unfold k_mod_243 at this; norm_num [ Nat.ModEq ] at *; omega;
        · norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
          have := c.k_mod_36;
          exact this.of_dvd <| by decide;
      exact Nat.modEq_of_dvd <| by simpa using lcm_dvd ( Nat.modEq_iff_dvd.mp h_k_mod_972.1 ) ( Nat.modEq_iff_dvd.mp h_k_mod_972.2 ) ;

/-
k is congruent to k_mod_972 modulo 972 (proven version).
-/
theorem k_mod_972_is_correct_proven (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_972 q [MOD 972] := by
      obtain ⟨q_prime, q_gt_3, q_mod_3, prime_A, pow_3_q, k_mod_9, k_mod_36, k_mod_6q⟩ := c;
      have := @k_mod_243_final_v3 q ⟨ q_prime, q_gt_3, q_mod_3, prime_A, pow_3_q, k_mod_9, k_mod_36, k_mod_6q ⟩ ; have := @k_mod_972_is_correct q ⟨ q_prime, q_gt_3, q_mod_3, prime_A, pow_3_q, k_mod_9, k_mod_36, k_mod_6q ⟩ ; omega;

/-
3^(jq) is congruent to 1 + j*k*A modulo A^2.
-/
theorem pow_3_mul_j_q_mod_A_sq (q : ℕ) [c : FT_Context q] (j : ℕ) :
    3^(j * q) ≡ 1 + j * k q * A q [MOD (A q)^2] := by
      -- Expand $(1 + kA)^j$ using the binomial theorem.
      have h_expand : (1 + k q * A q)^j ≡ 1 + j * k q * A q [MOD A q ^ 2] := by
        induction j <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_succ, mul_assoc ];
        ring_nf at *;
        norm_cast; simp +decide [ sq, mul_assoc ] ;
      -- Since $3^q \equiv 1 + kA \pmod{A^2}$, we can rewrite $3^{jq}$ as $(3 �^�q)^j \equiv (1 + kA)^j \pmod{A^2}$.
      have h_exp_mod : 3^(q) ≡ 1 + k q * A q [MOD A q ^ 2] := by
        unfold k;
        rw [ Nat.div_mul_cancel ];
        · rw [ add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
        · exact Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; have := c.pow_3_q; simpa [ ← Int.natCast_dvd_natCast ] using this.symm.dvd );
      simpa only [ pow_mul' ] using h_exp_mod.pow j |> Nat.ModEq.trans <| h_expand

/-
k is congruent to k_mod_972 modulo 972.
-/
theorem k_mod_972_final (q : ℕ) [c : FT_Context q] :
    k q ≡ k_mod_972 q [MOD 972] := by
      -- From the problem statement, we have $k q 2 [MOD 4]$
      have k_mod_4 : k q % 4 = 2 := by
        have := c.k_mod_36; norm_num [ Nat.ModEq ] at this; omega;
      have := @k_mod_243_congr q;
      simp_all +decide [ Nat.ModEq ];
      unfold k_mod_972; omega;