/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 56ab6ac5-e8d7-4d0a-82b6-6546988e944f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves that for any scattered graph with a maximum edge-disjoint triangle packing of size ν = 4, the triangle transversal number τ is at most 8. This confirms Tuza's conjecture (τ ≤ 2ν) for this specific class of graphs. The proof relies on analyzing the structure of external triangles relative to the packing elements, showing that local covers of size 2 exist for each packing element.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A triangle is a 3-clique in G
-/
def isTriangle {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (T : Finset V) : Prop :=
  T.card = 3 ∧ ∀ x ∈ T, ∀ y ∈ T, x ≠ y → G.Adj x y

/-
Two triangles are edge-disjoint if they share at most 1 vertex
-/
def edgeDisjoint {V : Type*} [Fintype V] [DecidableEq V] (T1 T2 : Finset V) : Prop :=
  (T1 ∩ T2).card ≤ 1

/-
M is an edge-disjoint triangle packing
-/
def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  (∀ T ∈ M, isTriangle G T) ∧
  (∀ T1 ∈ M, ∀ T2 ∈ M, T1 ≠ T2 → edgeDisjoint T1 T2)

/-
M is a MAXIMUM triangle packing
-/
def isMaxPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧
  ∀ T, isTriangle G T → (∀ A ∈ M, edgeDisjoint T A) → T ∈ M

/-
Scattered: M-elements are pairwise vertex-disjoint
-/
def isScattered {V : Type*} [Fintype V] [DecidableEq V] (M : Finset (Finset V)) : Prop :=
  ∀ A ∈ M, ∀ B ∈ M, A ≠ B → Disjoint A B

/-
Triangle T shares an edge with triangle A
-/
def sharesEdge {V : Type*} [Fintype V] [DecidableEq V] (T A : Finset V) : Prop :=
  (T ∩ A).card ≥ 2

/-
Triangles at A: triangles sharing an edge with A
-/
def trianglesAt {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (A : Finset V) : Finset (Finset V) :=
  (Finset.univ : Finset (Finset V)).filter (fun T => isTriangle G T ∧ sharesEdge T A)

/-
An edge (pair of vertices) is contained in triangle T
-/
def edgeInTriangle {V : Type*} [Fintype V] [DecidableEq V] (e : Finset V) (T : Finset V) : Prop :=
  e.card = 2 ∧ e ⊆ T

/-
Cover: set of edges that hit all triangles
-/
def isCover {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (E : Finset (Finset V)) (S : Finset (Finset V)) : Prop :=
  (∀ e ∈ E, e.card = 2) ∧
  (∀ T ∈ S, ∃ e ∈ E, edgeInTriangle e T)

/-
M is a maximum cardinality triangle packing
-/
def isMaximumPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ ∀ M', isTrianglePacking G M' → M'.card ≤ M.card

/-
A maximum cardinality packing is also a maximal (unextendable) packing
-/
lemma maximum_implies_maximal
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (h : isMaximumPacking G M) :
    isMaxPacking G M := by
  refine' ⟨ h.1, fun T hT hM => _ ⟩;
  convert h.2 ( Insert.insert T M ) ?_ using 1;
  · by_cases hT' : T ∈ M <;> simp +decide [ hT' ];
  · refine' ⟨ _, _ ⟩;
    · intro A hA; rcases Finset.mem_insert.mp hA with ( rfl | hA ) <;> [ exact hT; exact h.1.1 A hA ] ;
    · simp_all +decide [ edgeDisjoint ];
      exact fun A hA => ⟨ fun hA' => by simpa only [ Finset.inter_comm ] using hM A hA, fun B hB hAB => h.1.2 A hA B hB hAB ⟩

/-
A set of size 3 cannot share 2 or more elements with each of two disjoint sets
-/
lemma disjoint_sets_intersection_card
    {V : Type*} [Fintype V] [DecidableEq V]
    (T A B : Finset V)
    (hT : T.card = 3)
    (hDisjoint : Disjoint A B)
    (hTA : (T ∩ A).card ≥ 2)
    (hTB : (T ∩ B).card ≥ 2) :
    False := by
  have h_card : (T ∩ A).card + (T ∩ B).card ≤ T.card := by
    rw [ ← Finset.card_union_of_disjoint ];
    · exact Finset.card_le_card fun x hx => by aesop;
    · exact Disjoint.mono inf_le_right inf_le_right hDisjoint;
  linarith

/-
If T shares an edge with A in a scattered packing M, then T is edge-disjoint from any other B in M
-/
lemma external_disjoint_from_other_M
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M)
    (T : Finset V) (hT_shares : sharesEdge T A) (hT_tri : isTriangle G T) :
    ∀ B ∈ M, B ≠ A → edgeDisjoint T B := by
  -- Assume $T$ shares an edge with $B$. Then $|T \cap B| \geq 2$.
  intro B hB hB_ne_A
  by_contra h_contra
  have h_inter_B : (T ∩ B).card ≥ 2 := by
    unfold edgeDisjoint at h_contra; aesop;
  -- Since $M$ is scattered, $A$ and $B$ are disjoint, and $|T \cap A| \geq 2$. By disjoint_sets_intersection_card, this is impossible.
  have h_contradiction : Disjoint A B := by
    exact hS _ hA _ hB ( Ne.symm hB_ne_A );
  exact absurd ( disjoint_sets_intersection_card T A B ( hT_tri.1 ) h_contradiction hT_shares h_inter_B ) ( by aesop )

/-
In a maximum packing, no two externals at A can be edge-disjoint (otherwise we could replace A with {T1, T2})
-/
lemma no_disjoint_externals
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M) :
    ∀ T1 T2, T1 ∈ trianglesAt G A → T2 ∈ trianglesAt G A → T1 ≠ A → T2 ≠ A → ¬ edgeDisjoint T1 T2 := by
  intro T1 T2 hT1 hT2 hT1A hT2A h_disjoint;
  -- Since $T1$ and $T2$ are edge-disjoint and share an edge with $A$, they are edge-disjoint from all other elements in $M$.
  have h_disjoint_all : ∀ B ∈ M, B ≠ A → edgeDisjoint T1 B ∧ edgeDisjoint T2 B := by
    exact fun B hB hBA => ⟨ external_disjoint_from_other_M G M hS A hA T1 ( Finset.mem_filter.mp hT1 |>.2.2 ) ( Finset.mem_filter.mp hT1 |>.2.1 ) B hB hBA, external_disjoint_from_other_M G M hS A hA T2 ( Finset.mem_filter.mp hT2 |>.2.2 ) ( Finset.mem_filter.mp hT2 |>.2.1 ) B hB hBA ⟩;
  -- By replacing $A$ with $\{T1, T2\}$ in $M$, we obtain a new packing $M'$ with $|M'| = |M| + 1$, contradicting the maximality of $M$.
  have h_new_packing : isTrianglePacking G ((M.erase A) ∪ {T1, T2}) := by
    refine' ⟨ _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
    · exact ⟨ Finset.mem_filter.mp hT1 |>.2.1, Finset.mem_filter.mp hT2 |>.2.1, fun a ha ha' => hM.1.1 a ha' ⟩;
    · refine' ⟨ fun h => _, fun a ha1 ha2 => ⟨ fun ha3 => _, fun ha3 => _, fun b hb1 hb2 hab => _ ⟩ ⟩ <;> simp_all +decide [ edgeDisjoint ];
      · rwa [ Finset.inter_comm ];
      · simpa only [ Finset.inter_comm ] using h_disjoint_all a ha2 ha1 |>.1;
      · simpa only [ Finset.inter_comm ] using h_disjoint_all a ha2 ha1 |>.2;
      · have := hS a ha2 b hb2 hab; rw [ Finset.disjoint_iff_inter_eq_empty ] at this; aesop;
  have := hM.2 ( M.erase A ∪ { T1, T2 } ) h_new_packing; simp_all +decide ;
  rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] at this <;> simp_all +decide [ Finset.disjoint_left ];
  · rw [ Nat.sub_add_cancel ( Finset.card_pos.mpr ⟨ A, hA ⟩ ) ] at this ; linarith;
  · intro h; have := h_disjoint_all T2 h; simp_all +decide [ edgeDisjoint ] ;
    unfold trianglesAt at hT2; simp_all +decide [ isTriangle ] ;
  · constructor <;> intro h <;> simp_all +decide [ edgeDisjoint ];
    · have := h_new_packing.1 T2; simp_all +decide [ isTriangle ] ;
    · have := h_disjoint_all T1 h; simp_all +decide [ Finset.inter_comm ] ;
      unfold trianglesAt at hT1; simp_all +decide [ isTriangle ] ;

/-
Set of external triangles sharing edge e with A
-/
def externalsOn {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (A : Finset V) (e : Finset V) : Finset (Finset V) :=
  (trianglesAt G A).filter (fun T => T ≠ A ∧ edgeInTriangle e T)

/-
Two externals on different edges of A share a vertex outside A
-/
lemma externals_on_diff_edges_share_vertex
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M)
    (e1 e2 : Finset V) (he1 : e1 ⊆ A) (he2 : e2 ⊆ A) (he1_card : e1.card = 2) (he2_card : e2.card = 2) (hne : e1 ≠ e2)
    (T1 : Finset V) (hT1 : T1 ∈ externalsOn G A e1)
    (T2 : Finset V) (hT2 : T2 ∈ externalsOn G A e2) :
    ∃ x, x ∉ A ∧ x ∈ T1 ∧ x ∈ T2 := by
  -- T1 and T2 share an edge (by no_disjoint_externals).
  have h_edge : (T1 ∩ T2).card ≥ 2 := by
    -- By the lemma no_disjoint_externals, T1 and T2 cannot be edge-disjoint.
    have h_not_disjoint : ¬edgeDisjoint T1 T2 := by
      apply no_disjoint_externals G M hM hS A hA T1 T2;
      · exact Finset.mem_filter.mp hT1 |>.1;
      · exact Finset.mem_filter.mp hT2 |>.1;
      · exact Finset.mem_filter.mp hT1 |>.2.1;
      · exact Finset.mem_filter.mp hT2 |>.2.1;
    exact not_lt.1 fun contra => h_not_disjoint <| by exact Nat.le_of_lt_succ contra;
  -- Since T1 and T2 share an edge, there exists a vertex x such that x ∈ T1 ∩ T2 and x ∉ A.
  obtain ⟨x, hx₁, hx₂⟩ : ∃ x, x ∈ T1 ∧ x ∈ T2 ∧ x ∉ A := by
    contrapose! h_edge;
    -- Since $T1$ and $T2$ are both external triangles sharing an edge with $A$, and $A$ is a triangle, their intersection must be a subset of $A$ and have cardinality at most 1.
    have h_inter_card : (T1 ∩ T2).card ≤ 1 := by
      have h_inter_card : (T1 ∩ A).card = 2 ∧ (T2 ∩ A).card = 2 := by
        have h_inter_card : ∀ T ∈ trianglesAt G A, T ≠ A → (T ∩ A).card = 2 := by
          intros T hT hT_ne_A
          have hT_card : T.card = 3 := by
            exact Finset.mem_filter.mp hT |>.2.1.1
          have hA_card : A.card = 3 := by
            exact hM.1.1 A hA |>.1;
          have h_inter_card : (T ∩ A).card ≤ 2 := by
            have h_inter_card : (T ∩ A).card < 3 := by
              have h_inter_card : (T ∩ A).card ≤ T.card - 1 := by
                refine' Nat.le_sub_one_of_lt ( Finset.card_lt_card _ );
                simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
                exact Finset.not_subset.mp fun h => hT_ne_A <| Finset.eq_of_subset_of_card_le h <| by linarith;
              exact lt_of_le_of_lt h_inter_card ( by rw [ hT_card ] ; decide );
            grind
          have h_inter_card_ge_2 : 2 ≤ (T ∩ A).card := by
            exact Finset.mem_filter.mp hT |>.2.2
          exact le_antisymm h_inter_card h_inter_card_ge_2;
        exact ⟨ h_inter_card T1 ( Finset.mem_filter.mp hT1 |>.1 ) ( Finset.mem_filter.mp hT1 |>.2.1 ), h_inter_card T2 ( Finset.mem_filter.mp hT2 |>.1 ) ( Finset.mem_filter.mp hT2 |>.2.1 ) ⟩;
      have h_inter_card : (T1 ∩ A) ≠ (T2 ∩ A) := by
        intro h; simp_all +decide [ externalsOn ] ;
        have h_inter_card : e1 = T1 ∩ A ∧ e2 = T2 ∩ A := by
          exact ⟨ Finset.eq_of_subset_of_card_le ( Finset.subset_inter hT1.2.2.2 he1 ) ( by aesop ), Finset.eq_of_subset_of_card_le ( Finset.subset_inter hT2.2.2.2 he2 ) ( by aesop ) ⟩;
        grind +ring;
      have h_inter_card : (T1 ∩ A) ∩ (T2 ∩ A) ⊂ T1 ∩ A := by
        simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
        exact Exists.imp ( by aesop ) ( Finset.not_subset.mp ( show ¬T1 ∩ A ⊆ T2 ∩ A from fun h => h_inter_card <| Finset.eq_of_subset_of_card_le h <| by linarith ) );
      have := Finset.card_lt_card h_inter_card; simp_all +decide [ Finset.inter_assoc ] ;
      exact Nat.le_of_lt_succ ( lt_of_le_of_lt ( Finset.card_le_card fun x hx => by aesop ) this );
    linarith;
  exact ⟨ x, hx₂.2, hx₁, hx₂.1 ⟩

/-
An external triangle has exactly one vertex outside A
-/
lemma external_has_unique_vertex_outside_A
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (A : Finset V) (hA : A.card = 3)
    (T : Finset V) (hT : isTriangle G T) (hT_shares : sharesEdge T A) (hT_ne_A : T ≠ A) :
    ∃! x, x ∈ T ∧ x ∉ A := by
  -- Since T shares an edge with A, |T ∩ A| ≥ 2. Since T ≠ A and both are size 3, |T ∩ A| cannot be 3 (otherwise T=A). So |T ∩ A| = 2.
  have h_card_inter : (T ∩ A).card = 2 := by
    have h_card_inter : (T ∩ A).card ≥ 2 := by
      exact hT_shares;
    refine' le_antisymm ( Nat.le_of_lt_succ _ ) h_card_inter;
    refine' lt_of_le_of_ne ( Nat.le_trans ( Finset.card_le_card fun x hx => by aesop ) ( hT.1.le ) ) _;
    intro h; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : T ∩ A ⊆ T ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : T ∩ A ⊆ A ) ; simp_all +decide ;
    exact hT_ne_A ( Eq.symm ( ‹T.card ≤ 3 → A = T› ( by linarith [ hT.1 ] ) ) );
  -- Since T \ A is non-empty and has exactly one element, there exists a unique x in T \ A.
  have h_unique : ∃! x, x ∈ T \ A := by
    have h_nonempty : T \ A ≠ ∅ := by
      intro h; simp_all +decide [ Finset.card_sdiff ] ;
      exact h_card_inter.not_gt ( by rw [ Finset.inter_eq_left.mpr h ] ; linarith [ hT.1 ] )
    have h_card : (T \ A).card = 1 := by
      have := Finset.card_sdiff_add_card_inter T A; simp_all +decide ;
      linarith [ hT.1 ]
    exact Finset.card_eq_one.mp h_card |> fun ⟨ x, hx ⟩ => ⟨ x, by aesop ⟩;
  grind

/-
If T1 (on e1) and T2 (on e2) share x outside A, then ALL externals contain x
-/
lemma externals_share_same_vertex
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M)
    (e1 e2 : Finset V) (he1 : e1 ⊆ A) (he2 : e2 ⊆ A) (he1_card : e1.card = 2) (he2_card : e2.card = 2) (hne : e1 ≠ e2)
    (T1 : Finset V) (hT1 : T1 ∈ externalsOn G A e1)
    (T2 : Finset V) (hT2 : T2 ∈ externalsOn G A e2)
    (x : V) (hx : x ∉ A) (hxT1 : x ∈ T1) (hxT2 : x ∈ T2) :
    ∀ T, T ∈ trianglesAt G A → T ≠ A → x ∈ T := by
  intro T hT hTA_A
  by_cases hT_edge : ∃ e : Finset V, e ⊆ A ∧ e.card = 2 ∧ edgeInTriangle e T ∧ e ≠ e1 ∧ e ≠ e2;
  · obtain ⟨ e, he₁, he₂, he₃, he₄, he₅ ⟩ := hT_edge;
    -- By externals_on_diff_edges_share_vertex, T and T1 share a vertex w ∉ A.
    obtain ⟨ w, hw₁, hw₂ ⟩ : ∃ w, w ∉ A ∧ w ∈ T ∧ w ∈ T1 := by
      apply externals_on_diff_edges_share_vertex G M hM hS A hA e e1 he₁ he1 he₂ he1_card he₄ T (by
      unfold externalsOn; aesop;) T1 (by
      exact?);
    -- By external_has_unique_vertex_outside_A, T1 has exactly one vertex outside A.
    obtain ⟨ y, hy₁, hy₂ ⟩ : ∃! y, y ∈ T1 ∧ y ∉ A := by
      apply external_has_unique_vertex_outside_A G A (by
      have := hM.1.1 A hA; unfold isTriangle at this; aesop;) T1 (by
      exact Finset.mem_filter.mp hT1 |>.1 |> Finset.mem_filter.mp |>.2.1) (by
      exact Finset.mem_filter.mp hT1 |>.1 |> fun h => Finset.mem_filter.mp h |>.2.2) (by
      exact fun h => hx ( h ▸ hxT1 ));
    grind;
  · -- Since T is not on e1 or e2, it must be on either e1 or e2.
    have hT_edge_cases : T ∈ externalsOn G A e1 ∨ T ∈ externalsOn G A e2 := by
      simp_all +decide [ trianglesAt, externalsOn ];
      obtain ⟨e, he⟩ : ∃ e : Finset V, e ⊆ A ∧ e.card = 2 ∧ edgeInTriangle e T := by
        obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq hT.2;
        exact ⟨ e, Finset.Subset.trans he.1 ( Finset.inter_subset_right ), he.2, ⟨ he.2, Finset.Subset.trans he.1 ( Finset.inter_subset_left ) ⟩ ⟩;
      by_cases he1 : e = e1 <;> specialize hT_edge e he.1 he.2.1 he.2.2 <;> aesop;
    cases' hT_edge_cases with h h <;> simp_all +decide [ externalsOn ];
    · -- By Lemma~\ref{lem:externals_on_diff_edges_share_vertex}, T and T2 share a vertex y ∉ A.
      obtain ⟨y, hy⟩ : ∃ y, y ∉ A ∧ y ∈ T ∧ y ∈ T2 := by
        apply externals_on_diff_edges_share_vertex G M hM hS A hA e1 e2 he1 he2 he1_card he2_card hne T (by
        exact Finset.mem_filter.mpr ⟨ hT, hTA_A, h ⟩) T2 (by
        exact Finset.mem_filter.mpr ⟨ hT2.1, hT2.2.1, hT2.2.2 ⟩);
      -- By Lemma~\ref{lem:external_has_unique_vertex_outside_A}, T2 has exactly one vertex outside A.
      have hT2_unique : ∃! z, z ∈ T2 ∧ z ∉ A := by
        apply external_has_unique_vertex_outside_A G A (by
        have := hM.1.1 A hA; unfold isTriangle at this; aesop;) T2 (by
        exact Finset.mem_filter.mp hT2.1 |>.2.1) (by
        exact Finset.mem_filter.mp hT2.1 |>.2.2) (by
        tauto);
      cases hT2_unique ; aesop;
    · -- By external_has_unique_vertex_outside_A, T and T1 share a vertex y ∉ A.
      obtain ⟨y, hyT, hyT1⟩ : ∃ y, y ∉ A ∧ y ∈ T ∧ y ∈ T1 := by
        apply externals_on_diff_edges_share_vertex G M hM hS A hA e2 e1 he2 he1 he2_card he1_card (Ne.symm hne) T (by
        exact Finset.mem_filter.mpr ⟨ hT, hTA_A, h ⟩) T1 (by
        exact Finset.mem_filter.mpr ⟨ hT1.1, hT1.2.1, hT1.2.2 ⟩);
      have h_unique_vertex : ∀ T : Finset V, isTriangle G T → sharesEdge T A → T ≠ A → ∀ y z, y ∉ A → y ∈ T → z ∉ A → z ∈ T → y = z := by
        intros T hT hT_shares hT_ne_A y z hy hyT hz hzT
        have h_unique_vertex : ∃! x, x ∈ T ∧ x ∉ A := by
          apply external_has_unique_vertex_outside_A G A (by
          have := hM.1.1 A hA; unfold isTriangle at this; aesop;) T hT hT_shares hT_ne_A
          skip
        obtain ⟨x, hxT, hx_unique⟩ := h_unique_vertex
        aesop;
      exact h_unique_vertex T1 ( Finset.mem_filter.mp hT1.1 |>.2.1 ) ( Finset.mem_filter.mp hT1.1 |>.2.2 ) hT1.2.1 x y hx hxT1 hyT hyT1.2 ▸ hyT1.1

/-
True if there is at least one external triangle on edge e
-/
def hasExternalsOn {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (A : Finset V) (e : Finset V) : Prop :=
  ∃ T, T ∈ externalsOn G A e

/-
If externals exist on two edges, a cover of size 2 exists
-/
lemma tau_at_A_le_2_of_externals_on_two_edges
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M)
    (e1 e2 : Finset V) (he1 : e1 ⊆ A) (he2 : e2 ⊆ A) (he1_card : e1.card = 2) (he2_card : e2.card = 2) (hne : e1 ≠ e2)
    (T1 : Finset V) (hT1 : T1 ∈ externalsOn G A e1)
    (T2 : Finset V) (hT2 : T2 ∈ externalsOn G A e2) :
    ∃ E : Finset (Finset V), E.card ≤ 2 ∧ isCover G E (trianglesAt G A) := by
  -- By externals_on_diff_edges_share_vertex, T1 and T2 share a vertex x ∉ A.
  obtain ⟨x, hx1, hx2⟩ : ∃ x, x ∉ A ∧ x ∈ T1 ∧ x ∈ T2 := by
    apply externals_on_diff_edges_share_vertex G M hM hS A hA e1 e2 he1 he2 he1_card he2_card hne T1 hT1 T2 hT2;
  -- Let E = {{u, x}, {v, w}}.
  obtain ⟨u, v, w, hu, hv, hw, huvw⟩ : ∃ u v w, u ∈ A ∧ v ∈ A ∧ w ∈ A ∧ u ≠ v ∧ v ≠ w ∧ w ≠ u ∧ e1 = {u, v} ∧ e2 = {v, w} := by
    rcases Finset.card_eq_two.mp he1_card with ⟨ u, v, hu, hv, huv ⟩ ; rcases Finset.card_eq_two.mp he2_card with ⟨ w, x, hw, hx, hwx ⟩ ; simp_all +decide [ Finset.subset_iff ];
    by_cases huv : u = w ∨ u = x ∨ v = w ∨ v = x;
    · rcases huv with ( rfl | rfl | rfl | rfl ) <;> simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
      · grind;
      · grind;
      · grind;
      · exact ⟨ u, he1, v, he2.2, w, he2.1, by tauto ⟩;
    · have := hM.1.1 A hA; simp_all +decide [ isTriangle ] ;
      have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset he1.1 ( Finset.insert_subset he1.2 ( Finset.singleton_subset_iff.mpr he2.1 ) ) ) ; simp_all +decide ;
      grind;
  refine' ⟨ { { u, x }, { v, w } }, _, _ ⟩ <;> simp_all +decide [ isCover ];
  · exact Finset.card_insert_le _ _;
  · refine' ⟨ _, _ ⟩;
    · grind;
    · intro T hT
      by_cases hT_A : T = A;
      · simp_all +decide [ edgeInTriangle ];
      · -- By externals_share_same_vertex, since T ≠ A, T must contain x.
        have hT_x : x ∈ T := by
          apply externals_share_same_vertex G M hM hS A hA {u, v} {v, w} he1 he2 (by
          rw [ Finset.card_pair huvw.1 ]) (by
          grind) (by
          exact hne) T1 hT1 T2 hT2 x hx1 hx2.left hx2.right T hT hT_A;
        -- Since T is a triangle and shares an edge with A, it must contain at least one of the edges {u, v}, {v, w}, or {u, w}.
        have hT_edge : {u, v} ⊆ T ∨ {v, w} ⊆ T ∨ {u, w} ⊆ T := by
          have hT_edge : (T ∩ A).card ≥ 2 := by
            exact Finset.mem_filter.mp hT |>.2.2;
          have hT_edge : (T ∩ A) ⊆ {u, v, w} := by
            have := hM.1.1 A hA; simp_all +decide [ isTriangle ] ;
            rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ hu, Finset.insert_subset_iff.mpr ⟨ hv, Finset.singleton_subset_iff.mpr hw ⟩ ⟩ ) ] ; aesop;
            rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> aesop;
          have := Finset.card_le_card hT_edge; simp_all +decide ;
          rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] at this <;> simp_all +decide [ Finset.subset_iff ];
          · interval_cases _ : Finset.card ( T ∩ A ) <;> simp_all +decide [ Finset.card_eq_two ];
            · rcases ‹_› with ⟨ x, y, hxy, h ⟩ ; simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ] ;
              grind;
            · have := Finset.eq_of_subset_of_card_le ( show T ∩ A ⊆ { u, v, w } from fun x hx => by aesop ) ; simp_all +decide ;
              simp_all +decide [ Finset.ext_iff ];
              grind +ring;
          · grind +ring;
        rcases hT_edge with ( h | h | h ) <;> simp_all +decide [ Finset.subset_iff, edgeInTriangle ];
        · exact Or.inl ( Finset.card_pair ( by aesop ) );
        · grind

/-
The set {{u, x}, {v, w}} is a valid cover for triangles at A given the common vertex x
-/
lemma cover_properties
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (A : Finset V)
    (u v w x : V)
    (hA_eq : A = {u, v, w})
    (h_distinct : u ≠ v ∧ v ≠ w ∧ u ≠ w)
    (hx : x ∉ A)
    (h_all_externals_contain_x : ∀ T, T ∈ trianglesAt G A → T ≠ A → x ∈ T) :
    isCover G {{u, x}, {v, w}} (trianglesAt G A) := by
  constructor <;> intro T hT ; simp_all +decide [ Finset.subset_iff, isCover ];
  · grind;
  · by_cases hT_eq_A : T = A <;> simp_all +decide [ edgeInTriangle ];
    simp_all +decide [ Finset.subset_iff, trianglesAt ];
    rcases hT.2 with h ; rcases Finset.card_eq_three.mp hT.1.1 with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
    specialize h_all_externals_contain_x { a, b, c } hT h hT_eq_A ; simp_all +decide [ Finset.subset_iff, Finset.card_insert_of_notMem ] ;
    rcases h_all_externals_contain_x with ( rfl | rfl | rfl ) <;> simp_all +decide [ sharesEdge ];
    · grind;
    · grind;
    · grind

/-
τ(triangles at A) ≤ 2 for any A in maximum scattered packing
-/
lemma tau_at_A_le_2
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hS : isScattered M)
    (A : Finset V) (hA : A ∈ M) :
    ∃ E : Finset (Finset V), E.card ≤ 2 ∧ isCover G E (trianglesAt G A) := by
  by_cases h_cases : ∃ e1 e2 : Finset V, e1 ⊆ A ∧ e2 ⊆ A ∧ e1.card = 2 ∧ e2.card = 2 ∧ e1 ≠ e2 ∧ (hasExternalsOn G A e1) ∧ (hasExternalsOn G A e2);
  · obtain ⟨ e1, e2, he1, he2, he1_card, he2_card, hne, h1, h2 ⟩ := h_cases;
    exact tau_at_A_le_2_of_externals_on_two_edges G M hM hS A hA e1 e2 he1 he2 he1_card he2_card hne h1.choose h1.choose_spec h2.choose h2.choose_spec;
  · -- If there are no externals on two edges, then there are at most one edge with externals.
    obtain ⟨e, he⟩ : ∃ e : Finset V, e ⊆ A ∧ e.card = 2 ∧ ∀ e' : Finset V, e' ⊆ A → e'.card = 2 → e' ≠ e → ¬(hasExternalsOn G A e') := by
      by_cases h_cases : ∃ e : Finset V, e ⊆ A ∧ e.card = 2 ∧ (hasExternalsOn G A e);
      · grind +ring;
      · have := hM.1.1 A hA;
        rcases this with ⟨ hA₁, hA₂ ⟩;
        rcases Finset.card_eq_three.mp hA₁ with ⟨ x, y, z, hx, hy, hz, h ⟩ ; use { x, y } ; aesop;
    refine' ⟨ { e }, _, _ ⟩ <;> simp_all +decide [ isCover ];
    intro T hT
    by_cases hT_eq_A : T = A;
    · exact ⟨ he.2.1, hT_eq_A ▸ he.1 ⟩;
    · -- Since T is an external triangle at A, it must share an edge with A.
      obtain ⟨e', he'⟩ : ∃ e' : Finset V, e' ⊆ A ∧ e'.card = 2 ∧ edgeInTriangle e' T := by
        have hT_edge : (T ∩ A).card ≥ 2 := by
          exact Finset.mem_filter.mp hT |>.2.2;
        obtain ⟨ e', he' ⟩ := Finset.exists_subset_card_eq hT_edge;
        exact ⟨ e', Finset.Subset.trans he'.1 ( Finset.inter_subset_right ), he'.2, ⟨ he'.2, Finset.Subset.trans he'.1 ( Finset.inter_subset_left ) ⟩ ⟩;
      contrapose! he;
      exact fun _ _ => ⟨ e', he'.1, he'.2.1, by aesop_cat, ⟨ T, Finset.mem_filter.mpr ⟨ hT, hT_eq_A, he'.2.2 ⟩ ⟩ ⟩

/-
Every triangle shares an edge with some element of a maximum packing
-/
lemma every_triangle_shares_edge_with_M
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (T : Finset V) (hT : isTriangle G T) :
    ∃ A ∈ M, sharesEdge T A := by
  have h_exists : ∀ T, isTriangle G T → (∀ A ∈ M, ¬sharesEdge T A) → T ∈ M := by
    intro T hT hT_not_share
    have hT_edge_disjoint : ∀ A ∈ M, edgeDisjoint T A := by
      exact fun A hA => le_of_not_gt fun h => hT_not_share A hA <| by unfold sharesEdge; aesop;
    exact hM.2 T hT hT_edge_disjoint;
  contrapose! h_exists;
  refine' ⟨ T, hT, h_exists, _ ⟩;
  exact fun h => h_exists T h ( by unfold sharesEdge; exact le_trans ( by simp +decide [ hT.1 ] ) le_rfl )

/-
Main theorem: τ ≤ 8 for scattered ν = 4
-/
theorem scattered_tau_le_8
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hMcard : M.card = 4)
    (hS : isScattered M) :
    ∃ E : Finset (Finset V), E.card ≤ 8 ∧
      (∀ e ∈ E, e.card = 2) ∧
      (∀ T, isTriangle G T → ∃ e ∈ E, edgeInTriangle e T) := by
  -- By Lemma tau_at_A_le_2, for each A in M, there exists a cover E_A of size at most 2 for trianglesAt G A.
  obtain ⟨E_A, hE_A⟩ : ∃ E_A : Finset V → Finset (Finset V), (∀ A ∈ M, (E_A A).card ≤ 2 ∧ isCover G (E_A A) (trianglesAt G A)) := by
    have hE_A : ∀ A ∈ M, ∃ E_A : Finset (Finset V), (E_A.card ≤ 2 ∧ isCover G E_A (trianglesAt G A)) := by
      exact?;
    choose! E hE using hE_A ; tauto;
  refine' ⟨ Finset.biUnion M E_A, _, _, _ ⟩;
  · exact le_trans ( Finset.card_biUnion_le ) ( by exact le_trans ( Finset.sum_le_sum fun x hx => hE_A x hx |>.1 ) ( by simp +decide [ hMcard ] ) );
  · simp +zetaDelta at *;
    exact fun e x hx he => hE_A x hx |>.2.1 e he;
  · intro T hT
    obtain ⟨A, hA⟩ : ∃ A ∈ M, sharesEdge T A := by
      apply every_triangle_shares_edge_with_M G M (maximum_implies_maximal G M hM) T hT;
    rcases hE_A A hA.1 with ⟨ hE_A₁, hE_A₂ ⟩ ; rcases hE_A₂.2 T ( Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hT, hA.2 ⟩ ) with ⟨ e, he₁, he₂ ⟩ ; use e ; aesop;

/-
Corollary: Tuza's conjecture holds for scattered ν = 4
-/
theorem tuza_scattered_nu4
    {V : Type*} [Fintype V] [DecidableEq V]
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaximumPacking G M) (hMcard : M.card = 4)
    (hS : isScattered M) :
    ∃ E : Finset (Finset V), E.card ≤ 2 * M.card ∧
      (∀ e ∈ E, e.card = 2) ∧
      (∀ T, isTriangle G T → ∃ e ∈ E, edgeInTriangle e T) := by
  obtain ⟨E, hEcard, hEedge, hEcover⟩ := scattered_tau_le_8 G M hM hMcard hS
  exact ⟨E, by omega, hEedge, hEcover⟩