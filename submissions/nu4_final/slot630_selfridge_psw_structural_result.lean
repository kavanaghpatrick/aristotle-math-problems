/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9d8acfd8-a6f2-4923-ae1d-c617df06f85f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the Selfridge conditions: p is odd, p ≡ 2 or 3 mod 5, 2^(p-1) ≡ 1 mod p, and Fib(p+1) ≡ 0 mod p.
-/
structure IsSelfridge (p : ℕ) : Prop where
  is_odd : Odd p
  mod_5 : p ≡ 2 [MOD 5] ∨ p ≡ 3 [MOD 5]
  pow_2 : 2^(p-1) ≡ 1 [MOD p]
  fib : Nat.fib (p+1) ≡ 0 [MOD p]

/-
For every non-zero natural number n, there exists a positive index k such that n divides the k-th Fibonacci number.
-/
lemma exists_fib_dvd (n : ℕ) (hn : n ≠ 0) : ∃ k > 0, n ∣ Nat.fib k := by
  -- By the pigeonhole principle, since there are only $n^2$ possible pairs $(F_i \mod n, F_{i+1} \mod n)$, the sequence must eventually repeat.
  have h_repeat : ∃ i j, i < j ∧ (Nat.fib i % n = Nat.fib j % n) ∧ (Nat.fib (i + 1) % n = Nat.fib (j + 1) % n) := by
    by_contra! h;
    exact absurd ( Set.infinite_range_of_injective ( show Function.Injective ( fun x => ( Nat.fib x % n, Nat.fib ( x + 1 ) % n ) ) from fun x y hxy => le_antisymm ( not_lt.1 fun contra => h _ _ contra ( by aesop ) ( by aesop ) ) ( not_lt.1 fun contra => h _ _ contra ( by aesop ) ( by aesop ) ) ) ) ( Set.not_infinite.mpr <| Set.finite_iff_bddAbove.mpr ⟨ ( n, n ), by rintro x ⟨ y, rfl ⟩ ; exact ⟨ Nat.le_of_lt <| Nat.mod_lt _ <| Nat.pos_of_ne_zero hn, Nat.le_of_lt <| Nat.mod_lt _ <| Nat.pos_of_ne_zero hn ⟩ ⟩ );
  obtain ⟨ i, j, hij, hi, hj ⟩ := h_repeat;
  induction' i with i ih generalizing j;
  · exact ⟨ j, hij, Nat.dvd_of_mod_eq_zero ( by simpa using hi.symm ) ⟩;
  · contrapose! ih;
    use j - 1;
    rcases j <;> simp_all +decide [ Nat.fib_add_two, Nat.add_mod ];
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ]

/-
Definition of the Fibonacci rank of apparition (entry point). It is the smallest positive index k such that n divides Fib(k).
-/
noncomputable def fibRank (n : ℕ) : ℕ :=
  if h : n = 0 then 0 else Nat.find (exists_fib_dvd n h)

/-
The Fibonacci rank of apparition `fibRank n` is an index `k` such that `n` divides `Fib(k)`.
-/
lemma fibRank_dvd (n : ℕ) (hn : n ≠ 0) : n ∣ Nat.fib (fibRank n) := by
  convert Nat.find_spec ( exists_fib_dvd n hn ) |>.2 using 1;
  unfold fibRank; aesop;

/-
The Fibonacci rank of apparition `fibRank n` is strictly positive.
-/
lemma fibRank_pos (n : ℕ) (hn : n ≠ 0) : 0 < fibRank n := by
  unfold fibRank;
  aesop

/-
n divides Fib(m) if and only if the rank of apparition of n divides m.
-/
lemma fibRank_dvd_iff (n m : ℕ) (hn : n ≠ 0) : n ∣ Nat.fib m ↔ fibRank n ∣ m := by
  -- By definition of $fibRank n$, we know that $fibRank n$ is the smallest positive integer $k$ such that $n \mid F_k$.
  have h_fibRank_min : ∀ k > 0, n ∣ Nat.fib k → fibRank n ∣ k := by
    intro k hk hnk
    have h_fib_div : n ∣ Nat.fib (Nat.gcd k (fibRank n)) := by
      have h_fib_div : Nat.gcd (Nat.fib k) (Nat.fib (fibRank n)) = Nat.fib (Nat.gcd k (fibRank n)) := by
        exact?;
      exact h_fib_div ▸ Nat.dvd_gcd hnk ( fibRank_dvd n hn );
    -- Since $fibRank n$ is the smallest positive integer such that $n \mid F_{fibRank n}$, and $n \mid F_{gcd(k, fibRank n)}$, it must be that $gcd(k, fibRank n) = fibRank n$.
    have h_gcd_eq : Nat.gcd k (fibRank n) = fibRank n := by
      have h_gcd_le : Nat.gcd k (fibRank n) ≥ fibRank n := by
        unfold fibRank at *; aesop;
      exact le_antisymm (Nat.le_of_dvd (fibRank_pos n hn) (Nat.gcd_dvd_right _ _)) h_gcd_le;
    exact h_gcd_eq ▸ Nat.gcd_dvd_left _ _;
  -- By combining the results from the hypothesis `h_fibRank_min`, we can conclude the proof by applying `iff_of_imp_of_imp`.
  apply Iff.intro;
  · by_cases hm : 0 < m <;> aesop;
  · intro hm; rcases eq_or_ne m 0 with ( rfl | hm' ) <;> simp_all +decide [ Nat.fib_dvd ] ;
    exact dvd_trans ( fibRank_dvd n hn ) ( by simpa using Nat.fib_dvd _ _ hm )

/-
Definition of a Carmichael number: a composite number n such that a^(n-1) ≡ 1 (mod n) for all a coprime to n.
-/
def IsCarmichael (n : ℕ) : Prop :=
  ¬ n.Prime ∧ 1 < n ∧ ∀ a, n.Coprime a → a^(n-1) ≡ 1 [MOD n]

/-
If q is an odd prime and n is a multiple of the rank of apparition z(q) such that q does not divide n/z(q), then the q-adic valuation of Fib(n) equals the q-adic valuation of Fib(z(q)).
-/
lemma fib_valuation_dvd (q : ℕ) (hq : q.Prime) (hq2 : q ≠ 2) (n : ℕ) (h : fibRank q ∣ n) (h_ndvd : ¬ q ∣ (n / fibRank q)) : padicValNat q (Nat.fib n) = padicValNat q (Nat.fib (fibRank q)) := by
  obtain ⟨ k, hk ⟩ := h;
  -- This follows from the Lifting the Exponent Lemma for Fibonacci numbers.
  have h_lifting : ∀ {m : ℕ}, m ≠ 0 → ¬ q ∣ m → padicValNat q (Nat.fib (fibRank q * m)) = padicValNat q (Nat.fib (fibRank q)) := by
    intro m hm hm'; haveI := Fact.mk hq; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.fib_dvd ] ;
    have h_lifting : ∀ {m : ℕ}, m ≠ 0 → ¬ q ∣ m → padicValNat q (Nat.fib (fibRank q * m)) = padicValNat q (Nat.fib (fibRank q)) := by
      intro m hm hm'
      have h_lifting_lemma : ∀ {n : ℕ}, Nat.fib (n * fibRank q) ≡ Nat.fib (fibRank q) * n * Nat.fib (fibRank q - 1) ^ (n - 1) [MOD q ^ (padicValNat q (Nat.fib (fibRank q)) + 1)] := by
        intro n; induction' n with n ih <;> simp_all +decide [ Nat.succ_mul, Nat.fib_add ] ;
        · rfl;
        · have h_fib_add : Nat.fib (n * fibRank q + fibRank q) = Nat.fib (n * fibRank q) * Nat.fib (fibRank q - 1) + Nat.fib (n * fibRank q + 1) * Nat.fib (fibRank q) := by
            rcases k : fibRank q with ( _ | _ | k ) <;> simp_all +decide [ Nat.fib_add_two, Nat.fib_add ];
            rename_i k' hk';
            rename_i k'' hk''; have := Nat.fib_add ( n * ( k'' + 1 + 1 ) ) ( k'' + 1 + 1 ) ; simp_all +decide [ Nat.fib_add_two, Nat.mul_succ ] ; ring;
            convert Nat.fib_add ( n * 2 + n * hk'' ) ( 1 + hk'' ) using 1 <;> ring;
            norm_num [ add_comm 1, add_comm 2, Nat.fib_add_two ] ; ring;
          -- We'll use that $Nat.fib (n * fibRank q + 1) \equiv Nat.fib (fibRank q - 1) ^ n [MOD q]$.
          have h_fib_succ : Nat.fib (n * fibRank q + 1) ≡ Nat.fib (fibRank q - 1) ^ n [MOD q] := by
            have h_fib_succ : ∀ {n : ℕ}, Nat.fib (n * fibRank q + 1) ≡ Nat.fib (fibRank q - 1) ^ n [MOD q] := by
              intro n; induction' n with n ih <;> simp_all +decide [ Nat.succ_mul, Nat.fib_add ] ;
              · rfl;
              · have h_fib_succ : Nat.fib (fibRank q) ≡ 0 [MOD q] := by
                  exact Nat.modEq_zero_iff_dvd.mpr ( fibRank_dvd q hq.ne_zero );
                simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_succ ];
                rcases k : fibRank q with ( _ | _ | k ) <;> simp_all +decide [ Nat.fib_add_two ];
            apply h_fib_succ;
          -- Substitute the induction hypothesis and the congruence for $Nat.fib (n * fibRank q + 1)$ into the expression.
          have h_subst : Nat.fib (n * fibRank q) * Nat.fib (fibRank q - 1) + Nat.fib (n * fibRank q + 1) * Nat.fib (fibRank q) ≡ (Nat.fib (fibRank q) * n * Nat.fib (fibRank q - 1) ^ (n - 1)) * Nat.fib (fibRank q - 1) + (Nat.fib (fibRank q - 1) ^ n) * Nat.fib (fibRank q) [MOD q ^ (padicValNat q (Nat.fib (fibRank q)) + 1)] := by
            refine' Nat.ModEq.add _ _;
            · exact ih.mul_right _;
            · rw [ Nat.modEq_iff_dvd ] at *;
              convert mul_dvd_mul h_fib_succ ( show ( q : ℤ ) ^ padicValNat q ( Nat.fib ( fibRank q ) ) ∣ Nat.fib ( fibRank q ) from ?_ ) using 1 ; push_cast ; ring;
              · push_cast; ring;
              · norm_cast;
                exact?;
          convert h_subst using 1 ; ring;
          cases n <;> simp_all +decide [ pow_succ', mul_assoc ]
      -- Since $q \nmid m$, we have $Nat.fib (fibRank q * m) \equiv Nat.fib (fibRank q) * m * Nat.fib (fibRank q - 1) ^ (m - 1) \pmod{q^{padicValNat q (Nat.fib (fibRank q)) + 1}}$.
      have h_cong : Nat.fib (fibRank q * m) ≡ Nat.fib (fibRank q) * m * Nat.fib (fibRank q - 1) ^ (m - 1) [MOD q ^ (padicValNat q (Nat.fib (fibRank q)) + 1)] := by
        simpa only [ mul_comm ] using h_lifting_lemma;
      -- Since $q \nmid m$, we have $Nat.fib (fibRank q * m) \equiv Nat.fib (fibRank q) * m * Nat.fib (fibRank q - 1) ^ (m - 1) \pmod{q^{padicValNat q (Nat.fib (fibRank q)) + 1}}$, and thus $v_q(Nat.fib (fibRank q * m)) = v_q(Nat.fib (fibRank q))$.
      have h_val : ¬(q ^ (padicValNat q (Nat.fib (fibRank q)) + 1) ∣ Nat.fib (fibRank q * m)) := by
        rw [ Nat.dvd_iff_mod_eq_zero, h_cong ];
        intro H; have := Nat.dvd_of_mod_eq_zero H; simp_all +decide [ Nat.Prime.dvd_mul ] ;
        -- Since $q \nmid m$, we have $q \nmid Nat.fib (fibRank q - 1)$.
        have h_not_div : ¬(q ∣ Nat.fib (fibRank q - 1)) := by
          have h_not_div : Nat.gcd (Nat.fib (fibRank q)) (Nat.fib (fibRank q - 1)) = 1 := by
            rcases n : fibRank q with ( _ | _ | k ) <;> simp_all +decide [ Nat.fib_add_two, Nat.gcd_comm ];
            exact Nat.recOn k ( by norm_num ) fun n ih => by simp_all +decide [ Nat.fib_add_two, Nat.gcd_comm ] ;
          intro h; have := Nat.dvd_gcd ( show q ∣ Nat.fib ( fibRank q ) from ?_ ) h; simp_all +decide ;
          exact Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by simpa using fibRank_dvd q <| by aesop );
        -- Since $q \nmid m$ and $q \nmid Nat.fib (fibRank q - 1)$, it follows that $q^{padicValNat q (Nat.fib (fibRank q)) + 1} \mid Nat.fib (fibRank q) * m$.
        have h_div : q ^ (padicValNat q (Nat.fib (fibRank q)) + 1) ∣ Nat.fib (fibRank q) * m := by
          exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( q ^ ( padicValNat q ( Nat.fib ( fibRank q ) ) + 1 ) ) ( Nat.fib ( fibRank q - 1 ) ^ ( m - 1 ) ) from Nat.Coprime.pow_right _ <| Nat.Coprime.pow_left _ <| hq.coprime_iff_not_dvd.mpr h_not_div ) this );
        have h_div : q ^ (padicValNat q (Nat.fib (fibRank q)) + 1) ∣ Nat.fib (fibRank q) := by
          exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( q ^ ( padicValNat q ( Nat.fib ( fibRank q ) ) + 1 ) ) m from Nat.Coprime.pow_left _ <| hq.coprime_iff_not_dvd.mpr hm' ) h_div );
        have := Nat.factorization_le_iff_dvd ( by aesop ) ( by aesop ) |>.2 h_div; simp_all +decide [ Nat.factorization_pow ] ;
        replace := this q ; simp_all +decide [ Nat.factorization ] ;
      have h_val : q ^ (padicValNat q (Nat.fib (fibRank q))) ∣ Nat.fib (fibRank q * m) := by
        have h_val : q ^ (padicValNat q (Nat.fib (fibRank q))) ∣ Nat.fib (fibRank q) := by
          exact?;
        exact dvd_trans h_val ( by simpa [ mul_comm ] using Nat.fib_dvd ( fibRank q ) ( fibRank q * m ) );
      obtain ⟨ k, hk ⟩ := h_val;
      haveI := Fact.mk hq; rw [ hk, padicValNat.mul ] <;> simp_all +decide [ Nat.Prime.dvd_iff_not_coprime ] ;
      · exact Or.inr <| Or.inr <| hq.coprime_iff_not_dvd.mpr fun h => h_val <| mul_dvd_mul_left _ h;
      · rintro rfl; simp_all +decide [ Nat.fib_pos ];
    exact h_lifting hm ( by rw [ ← ZMod.natCast_eq_zero_iff ] ; aesop );
  by_cases hk0 : k = 0 <;> simp_all +decide;
  exact h_lifting hk0 fun h => h_ndvd <| mul_dvd_mul_left _ h

/-
If 2^(q^a - 1) ≡ 1 (mod q^a), then the q-adic valuation of 2^(q-1) - 1 is at least a.
-/
lemma lemma_fermat_val (q a : ℕ) (hq : q.Prime) (ha : a ≠ 0) (h_fermat : 2^(q^a - 1) ≡ 1 [MOD q^a]) :
    padicValNat q (2^(q-1) - 1) ≥ a := by
      -- The order of 2 modulo $q^a$ divides $\gcd(q^a - 1, q^{a-1}(q - 1)) = q - 1$.
      have h_order : orderOf (2 : ZMod (q ^ a)) ∣ q - 1 := by
        have h_order_div : orderOf (2 : ZMod (q ^ a)) ∣ q ^ a - 1 ∧ orderOf (2 : ZMod (q ^ a)) ∣ Nat.totient (q ^ a) := by
          rw [ orderOf_dvd_iff_pow_eq_one, orderOf_dvd_iff_pow_eq_one ];
          have h_euler : 2 ^ Nat.totient (q ^ a) ≡ 1 [MOD q ^ a] := by
            refine' Nat.ModEq.pow_totient _;
            refine' Nat.Coprime.pow_right _ _;
            have := h_fermat.of_dvd <| dvd_pow_self _ ha; simp_all +decide [ Nat.ModEq, Nat.pow_mod ] ;
            rcases q with ( _ | _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
            exact hq.odd_of_ne_two <| by linarith;
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        rw [ Nat.totient_prime_pow hq ( Nat.pos_of_ne_zero ha ) ] at h_order_div;
        have h_coprime : Nat.gcd (q ^ a - 1) (q ^ (a - 1)) = 1 := by
          refine' Nat.coprime_of_dvd' _;
          intro k hk hk₁ hk₂; haveI := Fact.mk hk; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( Nat.one_le_pow _ _ hq.pos ) ] ;
        exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( orderOf ( 2 : ZMod ( q ^ a ) ) ) ( q ^ ( a - 1 ) ) from Nat.Coprime.coprime_dvd_left h_order_div.1 h_coprime ) h_order_div.2 );
      -- So $2^{q-1} \equiv 1 \pmod{q^a}$.
      have h_mod : (q ^ a : ℕ) ∣ (2 ^ (q - 1) - 1) := by
        rw [ ← Nat.modEq_zero_iff_dvd ];
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, orderOf_dvd_iff_pow_eq_one ];
      obtain ⟨ k, hk ⟩ := h_mod;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.sub_eq_iff_eq_add <| Nat.one_le_pow _ _ two_pos ];
      · exact absurd hk ( Nat.sub_ne_zero_of_lt hq.one_lt );
      · haveI := Fact.mk hq; rw [ padicValNat.mul ] <;> aesop;

/-
If Fib(q^a + 1) ≡ 0 (mod q^a), then the q-adic valuation of Fib(z(q)) is at least a.
-/
lemma lemma_fib_val (q a : ℕ) (hq : q.Prime) (hq2 : q ≠ 2) (ha : a ≠ 0) (h_fib : Nat.fib (q^a + 1) ≡ 0 [MOD q^a]) :
    padicValNat q (Nat.fib (fibRank q)) ≥ a := by
      -- Using `fib_valuation_dvd`, since $q \nmid (q^a+1)/z(q)$ (as $q \nmid q^a+1$), we have $v_q(F_{q^a+1}) = v_q(F_{z(q)})$.
      have h_val_eq : padicValNat q (Nat.fib (q^a + 1)) = padicValNat q (Nat.fib (fibRank q)) := by
        apply fib_valuation_dvd;
        · assumption;
        · assumption;
        · apply fibRank_dvd_iff q ( q^a + 1 ) hq.ne_zero |>.1;
          exact dvd_trans ( dvd_pow_self _ ha ) ( Nat.dvd_of_mod_eq_zero h_fib );
        · -- Since $q$ is prime and $q \neq 2$, we know that $q$ does not divide $q^a + 1$.
          have h_not_div : ¬(q ∣ q^a + 1) := by
            rw [ Nat.dvd_add_right ( dvd_pow_self _ ha ) ] ; aesop;
          refine fun h => h_not_div <| dvd_trans h <| Nat.div_dvd_of_dvd <| ?_;
          rw [ Nat.modEq_zero_iff_dvd ] at h_fib;
          exact fibRank_dvd_iff q _ hq.ne_zero |>.1 ( dvd_trans ( dvd_pow_self _ ha ) h_fib );
      rw [ Nat.modEq_zero_iff_dvd ] at h_fib;
      obtain ⟨ k, hk ⟩ := h_fib;
      rcases k with ( _ | k ) <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
      · norm_num [ ← h_val_eq ] at *;
      · haveI := Fact.mk hq; rw [ ← h_val_eq, padicValNat.mul ] <;> aesop;

/-
If p = q^a satisfies IsSelfridge, then a is odd.
-/
lemma lemma_a_odd (q a : ℕ) (hq : q.Prime) (ha : a ≠ 0) (hp : IsSelfridge (q^a)) : Odd a := by
  -- Suppose $a$ is even. Then $q^a + 1 \equiv 2 \pmod{q+1}$.
  by_cases ha_even : Even a;
  · obtain ⟨ k, hk ⟩ := ha_even; simp_all +decide [ Nat.ModEq, Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
    obtain ⟨ m, hm ⟩ := hp;
    rcases hm with ( hm | hm ) <;> rw [ Nat.ModEq, Nat.mul_mod ] at hm <;> have := Nat.mod_lt ( q ^ k ) ( by decide : 5 > 0 ) <;> interval_cases _ : q ^ k % 5 <;> simp_all +decide [ Nat.ModEq, Nat.pow_mod ];
  · simpa using ha_even

/-
If p = 3^a satisfies IsSelfridge, then a = 1.
-/
lemma lemma_q_3_imp_a_1 (a : ℕ) (ha : a ≠ 0) (hp : IsSelfridge (3^a)) : a = 1 := by
  -- From `lemma_fermat_val`, $v_3(2^{3-1}-1) \ge a$.
  have h_fermat_val : padicValNat 3 (2^(3-1) - 1) ≥ a := by
    apply lemma_fermat_val 3 a (by norm_num) ha;
    exact hp.pow_2;
  exact le_antisymm ( h_fermat_val.trans ( by native_decide ) ) ( Nat.pos_of_ne_zero ha )

/-
For all p < 10000, if p satisfies the Selfridge conditions, then p is prime.
-/
theorem bounded_verification : ∀ p < 10000, IsSelfridge p → p.Prime := by
  intro p hp h;
  obtain ⟨ h₁, h₂, h₃, h₄ ⟩ := h;
  revert p; native_decide;

/-
For any prime factor q of a Selfridge number p, the order of 2 modulo q divides p-1.
-/
lemma lemma3_fermat_structure (p : ℕ) (hp : IsSelfridge p) (q : ℕ) (hq : q.Prime) (h_dvd : q ∣ p) :
    orderOf (2 : ZMod q) ∣ p - 1 := by
      -- By definition of $IsSelfridge$, we know that $2^{p-1} \equiv 1 \pmod p$.
      have h_selfridge : 2 ^ (p - 1) ≡ 1 [MOD p] := by
        exact hp.pow_2
      -- Since $q$ divides $p$, we have $2^{p-1} \equiv 1 \pmod q$.
      have h_q_res : 2 ^ (p - 1) ≡ 1 [ZMOD q] := by
        simpa [ ← Int.natCast_modEq_iff ] using h_selfridge.of_dvd h_dvd;
      exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.intCast_eq_intCast_iff ] using h_q_res )

/-
For any prime factor q of a Selfridge number p, the Fibonacci rank of apparition z(q) divides p+1.
-/
lemma lemma4_lucas_structure (p : ℕ) (hp : IsSelfridge p) (q : ℕ) (hq : q.Prime) (h_dvd : q ∣ p) :
    fibRank q ∣ p + 1 := by
      -- By definition of $IsSelfridge$, we know that $Fib(p+1) \equiv 0 \pmod p$.
      have h_fib_p1 : Nat.fib (p + 1) ≡ 0 [MOD p] := by
        exact hp.fib;
      exact fibRank_dvd_iff q ( p + 1 ) hq.ne_zero |>.1 ( Nat.dvd_trans h_dvd ( Nat.dvd_of_mod_eq_zero h_fib_p1 ) )

/-
For any prime factor q of a Selfridge number p, the gcd of the order of 2 modulo q and the Fibonacci rank of apparition z(q) divides 2.
-/
lemma lemma5_gcd_constraint (p : ℕ) (hp : IsSelfridge p) (q : ℕ) (hq : q.Prime) (h_dvd : q ∣ p) :
    Nat.gcd (orderOf (2 : ZMod q)) (fibRank q) ∣ 2 := by
      -- Since $p$ is odd, $\gcd(p-1, p+1) = \gcd(p-1, 2) = 2$.
      have h_gcd_odd : Nat.gcd (p - 1) (p + 1) = 2 := by
        rcases hp with ⟨ hp_odd, hp_mod, hp_pow, hp_fib ⟩;
        rcases hp_odd with ⟨ m, rfl ⟩ ; simp +arith +decide [ Nat.gcd_mul_left ] ;
        norm_num [ ( by ring : 2 * m + 1 + 1 = 2 * m + 2 ) ];
      exact h_gcd_odd ▸ Nat.dvd_gcd ( Nat.dvd_trans ( Nat.gcd_dvd_left _ _ ) ( lemma3_fermat_structure p hp q hq h_dvd ) ) ( Nat.dvd_trans ( Nat.gcd_dvd_right _ _ ) ( lemma4_lucas_structure p hp q hq h_dvd ) )

/-
If p = q^a is a Selfridge number, then either a = 1 (so p is prime) or q satisfies strong valuation constraints (Wieferich and Wall-Sun-Sun conditions).
-/
theorem prime_power_properties (p : ℕ) (hp : IsSelfridge p) (q : ℕ) (hq : q.Prime) (a : ℕ) (ha : p = q^a) :
    a = 1 ∨ (padicValNat q (2^(q-1)-1) ≥ a ∧ padicValNat q (Nat.fib (fibRank q)) ≥ a) := by
      by_cases ha : a = 0 <;> simp_all +decide;
      -- From lemma_fermat_val, we have padicValNat q (2^(q-1) - 1) ≥ a.
      have h_fermat : padicValNat q (2^(q-1) - 1) ≥ a := by
        apply lemma_fermat_val;
        · assumption;
        · assumption;
        · exact hp.pow_2;
      have h_fib : Nat.fib (q^a + 1) ≡ 0 [MOD q^a] := by
        exact hp.fib;
      by_cases hq2 : q = 2;
      · cases hp ; aesop;
      · exact Or.inr ⟨ h_fermat, lemma_fib_val q a hq hq2 ha h_fib ⟩

/-
For any prime factor q of a Selfridge number p, 5 does not divide the Fibonacci rank of apparition z(q).
-/
lemma lemma7_mod5 (p : ℕ) (hp : IsSelfridge p) (q : ℕ) (hq : q.Prime) (h_dvd : q ∣ p) :
    ¬ 5 ∣ fibRank q := by
      have h_fib_rank_dvd : fibRank q ∣ p + 1 := by
        -- Apply the lemma that states the Fibonacci rank of apparition z(q) divides p+1.
        apply lemma4_lucas_structure p hp q hq h_dvd;
      -- Since $p$ is a Selfridge number, $p \equiv 2$ or $3 \pmod{5}$.
      have h_mod_5 : p % 5 = 2 ∨ p % 5 = 3 := by
        cases hp ; aesop;
      exact fun h => by have := Nat.dvd_trans h h_fib_rank_dvd; omega;

/-
If p is a Selfridge number, then either p is squarefree or there exists a prime factor q of p which is both a Wieferich prime and a Wall-Sun-Sun prime.
-/
def IsWieferich (q : ℕ) : Prop :=
  q.Prime ∧ padicValNat q (2^(q-1) - 1) ≥ 2

def IsWallSunSun (q : ℕ) : Prop :=
  q.Prime ∧ padicValNat q (Nat.fib (fibRank q)) ≥ 2

theorem selfridge_structure_thm (p : ℕ) (hp : IsSelfridge p) :
    Squarefree p ∨ ∃ q, q ∣ p ∧ IsWieferich q ∧ IsWallSunSun q := by
      by_cases h : Squarefree p <;> simp_all +decide [ IsWieferich, IsWallSunSun ];
      -- Then there exists a prime $q$ such that $q^2 \mid p$.
      obtain ⟨q, hq_prime, hq_sq⟩ : ∃ q, Nat.Prime q ∧ q^2 ∣ p := by
        rw [ Nat.squarefree_iff_prime_squarefree ] at h;
        simpa [ sq ] using h;
      -- By Lemma 3, $q$ satisfies the conditions for being a Wieferich prime and a Wall-Sun-Sun prime.
      have h_wieferich : padicValNat q (2^(q-1)-1) ≥ 2 := by
        apply lemma_fermat_val q 2 hq_prime (by norm_num);
        obtain ⟨ k, hk ⟩ := hq_sq;
        have h_wieferich : 2^(p-1) ≡ 1 [MOD q^2] := by
          have := hp.pow_2;
          exact this.of_dvd <| hk.symm ▸ dvd_mul_right _ _;
        have h_order : orderOf (2 : ZMod (q^2)) ∣ p - 1 := by
          exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_wieferich );
        have h_order_div : orderOf (2 : ZMod (q^2)) ∣ Nat.totient (q^2) := by
          rw [ orderOf_dvd_iff_pow_eq_one ] at *;
          have h_order_div : Nat.gcd 2 (q^2) = 1 := by
            rcases Nat.even_or_odd' q with ⟨ c, rfl | rfl ⟩ <;> simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
            exact absurd ( hp.is_odd ) ( by norm_num [ parity_simps ] );
          simpa [ ← ZMod.natCast_eq_natCast_iff ] using Nat.ModEq.pow_totient h_order_div;
        have h_order_div : orderOf (2 : ZMod (q^2)) ∣ q * (q - 1) := by
          simp_all +decide [ Nat.totient_prime_pow ];
        have h_order_div : orderOf (2 : ZMod (q^2)) ∣ q - 1 := by
          have h_order_div : orderOf (2 : ZMod (q^2)) ∣ q - 1 := by
            have h_coprime : Nat.gcd (orderOf (2 : ZMod (q^2))) q = 1 := by
              refine' Nat.Coprime.symm ( hq_prime.coprime_iff_not_dvd.mpr _ );
              intro hq_div_order
              have hq_div_p_minus_1 : q ∣ p - 1 := by
                exact dvd_trans hq_div_order h_order;
              rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.dvd_add_right, dvd_mul_of_dvd_left ];
              · cases hp ; aesop;
              · haveI := Fact.mk hq_prime; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show 1 ≤ q ^ 2 * k from Nat.mul_pos ( pow_pos hq_prime.pos 2 ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ] ;
            exact ( Nat.Coprime.dvd_of_dvd_mul_left h_coprime h_order_div );
          assumption;
        have h_order_div : 2^(q - 1) ≡ 1 [MOD q^2] := by
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, orderOf_dvd_iff_pow_eq_one ];
        convert h_order_div.pow ( q + 1 ) using 1 ; rw [ ← pow_mul, show q ^ 2 - 1 = ( q - 1 ) * ( q + 1 ) by convert Nat.sq_sub_sq q 1 using 1; ring ];
        norm_num
      have h_wall_sunsun : padicValNat q (Nat.fib (fibRank q)) ≥ 2 := by
        have h_wall_sunsun : Nat.fib (p + 1) ≡ 0 [MOD q^2] := by
          have := hp.fib
          generalize_proofs at *; (
          exact this.of_dvd hq_sq |> Nat.ModEq.trans <| Nat.modEq_zero_iff_dvd.mpr <| by simpa;)
        generalize_proofs at *; (
        have h_wall_sunsun : padicValNat q (Nat.fib (p + 1)) ≥ 2 := by
          rw [ Nat.modEq_zero_iff_dvd ] at h_wall_sunsun
          generalize_proofs at *; (
          obtain ⟨ k, hk ⟩ := h_wall_sunsun; simp_all +decide [ Nat.factorization_pow ] ;
          haveI := Fact.mk hq_prime; rw [ padicValNat.mul ] <;> aesop;)
        generalize_proofs at *; (
        have h_wall_sunsun : fibRank q ∣ p + 1 := by
          apply lemma4_lucas_structure p hp q hq_prime ( dvd_of_mul_left_dvd hq_sq ) |> fun h => by simpa using h;
        generalize_proofs at *; (
        have h_wall_sunsun : padicValNat q (Nat.fib (p + 1)) = padicValNat q (Nat.fib (fibRank q)) := by
          apply fib_valuation_dvd q hq_prime (by
          rintro rfl; simp_all +decide [ ← even_iff_two_dvd, Nat.one_le_iff_ne_zero, parity_simps ] ;) (p + 1) h_wall_sunsun (by
          intro h_div
          have h_div_p : q ∣ p + 1 := by
            exact dvd_trans h_div ( Nat.div_dvd_of_dvd h_wall_sunsun )
          generalize_proofs at *; (
          have := Nat.dvd_sub' h_div_p ( dvd_of_mul_left_dvd hq_sq ) ; aesop;))
        generalize_proofs at *; (
        linarith))))
      use q, dvd_of_mul_left_dvd hq_sq, ⟨hq_prime, h_wieferich⟩, hq_prime, h_wall_sunsun

/-
If p is a squarefree Selfridge number, then p is a base-2 Carmichael number (meaning it is squarefree and for every prime factor q, the order of 2 mod q divides p-1).
-/
def IsBase2Carmichael (n : ℕ) : Prop :=
  Squarefree n ∧ ∀ p, p.Prime → p ∣ n → orderOf (2 : ZMod p) ∣ n - 1

theorem selfridge_implies_base2_carmichael_if_squarefree (p : ℕ) (hp : IsSelfridge p) (h_sq : Squarefree p) :
    IsBase2Carmichael p := by
      refine' And.intro _ _;
      · assumption;
      · exact?

/-
If p is a composite Selfridge number, then p is a Lucas pseudoprime (with parameters P=1, Q=-1).
-/
def IsLucasPseudoprime (n : ℕ) : Prop :=
  ¬ n.Prime ∧ 1 < n ∧ n % 2 = 1 ∧ Nat.fib (n + 1) ≡ 0 [MOD n]

theorem selfridge_implies_lucas_pseudoprime (p : ℕ) (hp : IsSelfridge p) (h_comp : ¬ p.Prime) :
    IsLucasPseudoprime p := by
      obtain ⟨ k, hk ⟩ := hp;
      rcases k with ⟨ m, rfl ⟩ ; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at * ; simp_all +decide [ IsLucasPseudoprime ] ;
      rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ Nat.ModEq ]

/-
Conditional Lemma 2: If p is a composite Selfridge number and has no prime factors that are both Wieferich and Wall-Sun-Sun, then p must have at least two distinct prime factors.
-/
theorem lemma2_two_factors_conditional (p : ℕ) (hp : IsSelfridge p) (h_comp : ¬ p.Prime)
    (h_no_wwss : ∀ q, q ∣ p → ¬(IsWieferich q ∧ IsWallSunSun q)) :
    ∃ q1 q2, q1.Prime ∧ q2.Prime ∧ q1 ≠ q2 ∧ q1 ∣ p ∧ q2 ∣ p := by
      -- Since p is composite and not squarefree, it must have at least one prime factor with multiplicity greater than 1. But since we're assuming that p is squarefree, all prime factors have multiplicity 1. Therefore, p must have at least two distinct prime factors.
      have h_squarefree : Squarefree p := by
        have := selfridge_structure_thm p hp; aesop;
      have h_two_distinct_primes : ∀ q, Nat.Prime q → q ∣ p → ∃ r, Nat.Prime r ∧ r ∣ p ∧ r ≠ q := by
        intros q hq hq_div
        by_contra h_contra
        push_neg at h_contra;
        -- If p has only one prime factor q, then p must be equal to q^a for some a.
        obtain ⟨a, ha⟩ : ∃ a, p = q^a := by
          exact ⟨ Nat.primeFactorsList p |> List.count q, by nth_rw 1 [ ← Nat.prod_primeFactorsList ( show p ≠ 0 from by rintro rfl; exact absurd hp.is_odd ( by simp +decide ) ) ] ; rw [ List.prod_eq_pow_single q ] ; aesop ⟩;
        rcases a with ( _ | _ | a ) <;> simp_all +decide [ Nat.squarefree_pow_iff ];
        rw [ Nat.squarefree_pow_iff ] at h_squarefree <;> aesop;
      obtain ⟨q, hq⟩ : ∃ q, Nat.Prime q ∧ q ∣ p := by
        exact Nat.exists_prime_and_dvd ( by rintro rfl; exact absurd hp.mod_5 ( by decide ) );
      obtain ⟨ r, hr₁, hr₂, hr₃ ⟩ := h_two_distinct_primes q hq.1 hq.2; exact ⟨ q, r, hq.1, hr₁, Ne.symm hr₃, hq.2, hr₂ ⟩ ;

/-
If n is a composite squarefree number (and not 1), it has at least two distinct prime factors.
-/
lemma composite_squarefree_has_two_factors (n : ℕ) (h_comp : ¬ n.Prime) (h_sq : Squarefree n) (h_n : n ≠ 1) :
    ∃ q1 q2, q1.Prime ∧ q2.Prime ∧ q1 ≠ q2 ∧ q1 ∣ n ∧ q2 ∣ n := by
      obtain ⟨ q1, hq1 ⟩ := Nat.exists_prime_and_dvd h_n;
      -- Let $q_2$ be a prime factor of $n$ such that $q_2 \neq q_1$.
      obtain ⟨ q2, hq2, hq2_ne_q1 ⟩ : ∃ q2, Nat.Prime q2 ∧ q2 ∣ n ∧ q2 ≠ q1 := by
        by_contra h_contra;
        -- If $q_1$ is the only prime factor of $n$, then $n = q_1^k$ for some $k$.
        obtain ⟨k, hk⟩ : ∃ k, n = q1^k := by
          exact ⟨ n.factorization q1, by nth_rw 1 [ ← Nat.factorization_prod_pow_eq_self ( by aesop : n ≠ 0 ) ] ; exact Finset.prod_eq_single q1 ( by aesop ) ( by aesop ) ⟩;
        rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.squarefree_pow_iff ];
      exact ⟨ q1, q2, hq1.1, hq2, hq2_ne_q1.2.symm, hq1.2, hq2_ne_q1.1 ⟩

/-
Computes the k-th Fibonacci number modulo n using an iterative approach.
-/
def fibMod (k n : ℕ) : ℕ :=
  (List.range k).foldl (fun (a, b) _ => (b, (a + b) % n)) (0, 1 % n) |>.1

/-
Computes the Fibonacci rank of apparition by searching for the first index k in [1, 2n+1] such that Fib(k) = 0 mod n. Returns 0 if not found (which shouldn't happen for n > 1).
-/
def fibRankComputable (n : ℕ) : ℕ :=
  (List.range (2 * n + 2)).find? (fun k => k > 0 ∧ fibMod k n = 0) |>.getD 0

/-
The function `fibMod` correctly computes the k-th Fibonacci number modulo n.
-/
lemma fibMod_eq_fib_mod (k n : ℕ) : fibMod k n = Nat.fib k % n := by
  -- By induction on $k$, we can show that the state $(a, b)$ after $k$ steps corresponds to $(Fib(k), Fib(k+1))$ modulo $n$.
  have h_ind : ∀ k, (List.range k).foldl (fun (a, b) _ => (b, (a + b) % n)) (0, 1 % n) = (Nat.fib k % n, Nat.fib (k + 1) % n) := by
    intro k; induction k <;> simp_all +decide [ Nat.fib_add_two, List.range_succ ] ;
  exact congr_arg Prod.fst ( h_ind k )

/-
k is the Fibonacci rank of apparition of n if k > 0, n divides Fib(k), and n does not divide Fib(j) for any 0 < j < k.
-/
def IsFibRank (n k : ℕ) : Prop :=
  k > 0 ∧ n ∣ Nat.fib k ∧ ∀ j < k, j > 0 → ¬ n ∣ Nat.fib j

/-
If k satisfies the IsFibRank predicate for n, then fibRank n is equal to k.
-/
lemma fibRank_eq_of_isFibRank (n k : ℕ) (h : IsFibRank n k) : fibRank n = k := by
  have h_fibRank_eq : ∀ j, j > 0 → j < k → ¬ (n ∣ Nat.fib j) := by
    exact fun j hj₁ hj₂ => h.2.2 j hj₂ hj₁;
  unfold fibRank;
  split_ifs <;> simp_all +decide [ Nat.find_eq_iff ];
  · cases h ; aesop;
  · exact ⟨ h.1, h.2.1 ⟩

/-
Computable version of Fibonacci rank searching up to n^2 + 1.
-/
def fibRankComputableSq (n : ℕ) : ℕ :=
  (List.range (n * n + 2)).find? (fun k => k > 0 ∧ fibMod k n = 0) |>.getD 0

/-
If q is an odd prime not equal to 5 and 5 is a quadratic residue modulo q, then q divides Fib(q-1).
-/
lemma fib_mod_q_eq_zero_of_jacobi_one (q : ℕ) (hq : q.Prime) (hq2 : q ≠ 2) (hq5 : q ≠ 5) (h : jacobiSym 5 q = 1) :
    q ∣ Nat.fib (q - 1) := by
      have h_congr : (∃ x : ZMod q, x ^ 2 = 5) → q ∣ Nat.fib (q - 1) := by
        intro h_congr
        obtain ⟨x, hx⟩ := h_congr;
        haveI := Fact.mk hq; norm_num [ ← ZMod.natCast_eq_zero_iff ] ;
        -- Using the roots of the characteristic polynomial, we can express the Fibonacci sequence in terms of these roots.
        have h_fib_expr : ∀ n : ℕ, Nat.fib n = ((1 + x) ^ n - (1 - x) ^ n) / (2 ^ n * x) := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ] ; ring;
          · by_cases hx' : x = 0 <;> simp_all +decide [ sq ];
            · rcases q with ( _ | _ | _ | _ | _ | _ | q ) <;> cases hx <;> trivial;
            · rw [ inv_mul_cancel₀ ] ; norm_num;
              erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases q <;> trivial;
          · rw [ ih n ( by linarith ) ] ; ring;
            rw [ show ( 4 : ZMod q ) = 2 * 2 by norm_num, mul_inv ] ; ring;
            by_cases h₂ : ( 2 : ZMod q ) = 0 <;> simp_all +decide [ sq, mul_assoc ] ; ring;
            · rcases q with ( _ | _ | _ | q ) <;> cases h₂ <;> trivial;
            · grind;
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
        rw [ ZMod.pow_card_sub_one_eq_one, ZMod.pow_card_sub_one_eq_one ] <;> norm_num;
        · rw [ sub_eq_zero ] ; intro H; simp_all +decide [ sq ];
          norm_num [ ← H ] at hx;
          rcases q with ( _ | _ | _ | _ | _ | _ | q ) <;> cases hx <;> contradiction;
        · intro H; rw [ show x = -1 by linear_combination' H ] at hx; norm_num at hx;
          rcases q with ( _ | _ | _ | _ | _ | _ | q ) <;> cases hx <;> contradiction;
      apply h_congr;
      haveI := Fact.mk hq; rw [ jacobiSym ] at h;
      norm_num [ Nat.primeFactorsList_prime hq ] at h;
      rw [ legendreSym.eq_one_iff ] at h;
      · exact Exists.elim h fun x hx => ⟨ x, by rw [ sq, ← hx ] ; norm_num ⟩;
      · simp +zetaDelta at *;
        erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases q <;> trivial