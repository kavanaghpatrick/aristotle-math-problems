/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eee40105-3743-49af-9fd4-8641776fc5e0

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A number n is powerful (or squarefull) if for every prime p dividing n, p^2 also divides n.
-/
def Powerful (n : ℕ) : Prop := ∀ p : ℕ, p.Prime → p ∣ n → p ^ 2 ∣ n

/-
The ABC conjecture states that for every ε > 0, there exists a constant K_ε such that for all coprime triples (a, b, c) with a + b = c, c < K_ε * rad(abc)^(1+ε).
-/
def AbcConjecture : Prop :=
  ∀ ε : ℝ, 0 < ε → ∃ K_ε : ℝ, 0 < K_ε ∧
  ∀ a b c : ℕ, 0 < a → 0 < b → 0 < c → a.Coprime b → a + b = c →
  (c : ℝ) < K_ε * (UniqueFactorizationMonoid.radical (a * b * c) : ℝ) ^ (1 + ε)

/-
If n is a non-zero powerful number and p is a prime factor of n, then the exponent of p in the prime factorization of n is at least 2.
-/
lemma factorization_ge_two_of_powerful {n : ℕ} (hn : n ≠ 0) (h : Powerful n) {p : ℕ} (hp : p ∈ n.primeFactors) :
  2 ≤ n.factorization p := by
    -- By definition of powerful, if $p$ divides $n$, then $p^2$ also divides $n$.
    have h_p2_div : p ^ 2 ∣ n := by
      exact h p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp );
    rw [ ← Nat.factorization_le_iff_dvd ] at h_p2_div <;> aesop

/-
For a non-zero powerful number n, its radical is at most its square root.
-/
lemma radical_le_sqrt_of_powerful {n : ℕ} (hn : n ≠ 0) (h : Powerful n) :
  (UniqueFactorizationMonoid.radical n : ℝ) ≤ Real.sqrt n := by
    unfold UniqueFactorizationMonoid.radical;
    simp_all +decide [ UniqueFactorizationMonoid.primeFactors ];
    erw [ Finset.prod_eq_one ] <;> norm_num;
    · exact Nat.pos_of_ne_zero hn;
    · simp +decide [ UniqueFactorizationMonoid.normalizedFactors ];
      simp +decide [ normalize ];
      simp +decide [ NormalizationMonoid.normUnit ];
      intro a ha; split_ifs <;> simp_all +decide [ Units.ext_iff ] ;
      have := UniqueFactorizationMonoid.irreducible_of_factor ( 0 : ℝ ) ha; norm_num at this;

/-
For a non-zero powerful number n, the square of its radical is less than or equal to n.
-/
lemma radical_sq_le_self_of_powerful {n : ℕ} (hn : n ≠ 0) (h : Powerful n) :
  (UniqueFactorizationMonoid.radical n) ^ 2 ≤ n := by
    -- Since $n$ is powerful, for every prime $p$ dividing $n$, $p^2$ also divides $n$. Therefore, $(\text{rad}(n))^2 \leq n$.
    have h_radical_sq_le_n : (UniqueFactorizationMonoid.radical n) ^ 2 ≤ n := by
      have h_radical_sq_le_prod : (UniqueFactorizationMonoid.radical n) ^ 2 = ∏ p ∈ n.primeFactors, p ^ 2 := by
        rw [ Finset.prod_pow, UniqueFactorizationMonoid.radical ];
        convert rfl;
        exact?
      -- Since $n$ is powerful, for every prime $p$ dividing $n$, $p^2$ also divides $n$. Therefore, $p^2 \leq p^{n.factorization p}$.
      have h_prime_power_le_n_factorization : ∀ p ∈ n.primeFactors, p ^ 2 ≤ p ^ (n.factorization p) := by
        exact fun p hp => Nat.pow_le_pow_right ( Nat.pos_of_mem_primeFactors hp ) ( factorization_ge_two_of_powerful hn h hp );
      convert Finset.prod_le_prod' h_prime_power_le_n_factorization using 1;
      exact Eq.symm ( Nat.factorization_prod_pow_eq_self hn );
    exact h_radical_sq_le_n

/-
The radical of a product is less than or equal to the product of the radicals.
-/
lemma radical_mul_le (a b : ℕ) : UniqueFactorizationMonoid.radical (a * b) ≤ UniqueFactorizationMonoid.radical a * UniqueFactorizationMonoid.radical b := by
  rw [ UniqueFactorizationMonoid.radical, UniqueFactorizationMonoid.radical ];
  by_cases ha : a = 0 <;> by_cases hb : b = 0 <;> simp_all +decide [ UniqueFactorizationMonoid.primeFactors ];
  · refine' Nat.pos_of_ne_zero _;
    exact?;
  · refine' Nat.one_le_iff_ne_zero.mpr _;
    simp_all +decide [ Finset.prod_eq_zero_iff ];
    exact fun h => absurd ( UniqueFactorizationMonoid.prime_of_normalized_factor 0 h ) ( by simp +decide );
  · unfold UniqueFactorizationMonoid.radical;
    rw [ Finset.prod_subset ];
    any_goals exact ( UniqueFactorizationMonoid.normalizedFactors a |> Multiset.toFinset ) ∪ ( UniqueFactorizationMonoid.normalizedFactors b |> Multiset.toFinset );
    · -- Since the product of primes in the union is less than or equal to the product of primes in each set, we can conclude the inequality.
      have h_union_le_prod : ∀ (s t : Finset ℕ), (∀ p ∈ s, Nat.Prime p) → (∀ p ∈ t, Nat.Prime p) → (∏ p ∈ s ∪ t, p) ≤ (∏ p ∈ s, p) * (∏ p ∈ t, p) := by
        intros s t hs ht; rw [ ← Finset.prod_union_inter ] ;
        exact le_mul_of_one_le_right ( Finset.prod_nonneg fun _ _ => Nat.zero_le _ ) ( Nat.one_le_iff_ne_zero.mpr <| Finset.prod_ne_zero_iff.mpr fun x hx => Nat.Prime.ne_zero <| by aesop );
      convert h_union_le_prod _ _ _ _ using 1;
      · simp +decide [ UniqueFactorizationMonoid.primeFactors ];
        convert rfl;
      · simp +zetaDelta at *;
        exact fun p hp => by have := UniqueFactorizationMonoid.prime_of_normalized_factor p hp; exact this.nat_prime;
      · simp +zetaDelta at *;
        exact fun p hp => by have := UniqueFactorizationMonoid.prime_of_normalized_factor p hp; exact this.nat_prime;
    · aesop_cat;
    · aesop

/-
The radical of a power is equal to the radical of the base, for non-zero exponent.
-/
lemma radical_pow_eq (a : ℕ) {k : ℕ} (hk : k ≠ 0) : UniqueFactorizationMonoid.radical (a ^ k) = UniqueFactorizationMonoid.radical a := by
  exact?

/-
The radical of n(n+2)(n+1)^2 is bounded by the product of the radicals of n, n+2, and n+1.
-/
lemma radical_triple_bound_nat (n : ℕ) :
  UniqueFactorizationMonoid.radical (n * (n + 2) * (n + 1) ^ 2) ≤
  UniqueFactorizationMonoid.radical n * UniqueFactorizationMonoid.radical (n + 2) * UniqueFactorizationMonoid.radical (n + 1) := by
    have h_radical_mul_le : ∀ a b : ℕ, UniqueFactorizationMonoid.radical (a * b) ≤ UniqueFactorizationMonoid.radical a * UniqueFactorizationMonoid.radical b := by
      exact?;
    refine le_trans ( h_radical_mul_le _ _ ) ?_;
    gcongr;
    · exact h_radical_mul_le _ _;
    · rw [ radical_pow_eq ] ; norm_num

/-
If the radicals of a, b, c are bounded by their square roots, then the product of the radicals is bounded by the square root of the product a*b*c.
-/
lemma prod_radical_le_prod_sqrt {a b c : ℕ}
  (ha : (UniqueFactorizationMonoid.radical a : ℝ) ≤ Real.sqrt a)
  (hb : (UniqueFactorizationMonoid.radical b : ℝ) ≤ Real.sqrt b)
  (hc : (UniqueFactorizationMonoid.radical c : ℝ) ≤ Real.sqrt c) :
  (UniqueFactorizationMonoid.radical a : ℝ) * (UniqueFactorizationMonoid.radical b : ℝ) * (UniqueFactorizationMonoid.radical c : ℝ) ≤ Real.sqrt (a * b * c) := by
    rw [ Real.sqrt_mul', Real.sqrt_mul' ] <;> try positivity;
    gcongr;
    · unfold UniqueFactorizationMonoid.radical;
      norm_num [ UniqueFactorizationMonoid.primeFactors ];
      norm_num [ UniqueFactorizationMonoid.normalizedFactors ];
      refine' Finset.prod_nonneg fun x hx => _;
      norm_num +zetaDelta at *;
      obtain ⟨ a, ha, rfl ⟩ := hx; unfold normalize; norm_num;
      simp +decide [ NormalizationMonoid.normUnit ];
      split_ifs <;> simp_all +decide [ Units.mk0 ];
    · unfold UniqueFactorizationMonoid.radical;
      norm_num [ UniqueFactorizationMonoid.primeFactors ];
      refine' Finset.prod_nonneg fun x hx => _;
      rw [ UniqueFactorizationMonoid.normalizedFactors ] at hx;
      norm_num [ normalize ] at hx;
      norm_num [ NormalizationMonoid.normUnit ] at hx;
      obtain ⟨ a, ha, rfl ⟩ := hx; split_ifs at * <;> simp_all +decide [ Units.ext_iff ] ;