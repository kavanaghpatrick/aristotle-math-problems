/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c8bf4a01-6745-4a1d-8dd5-174e9a7888ba

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Structural lemmas for Lehmer's Totient Problem.

We define a Lehmer counterexample as a composite number n > 1 such that φ(n) | (n-1).
We prove several necessary conditions for such a counterexample:
1. n must be odd.
2. n must be squarefree.
3. n must be a product of distinct odd primes.
4. For every prime factor p of n, (p-1) | (n-1).
5. n ≡ 1 [MOD (p-1)] for every prime factor p of n.
6. n must have at least 3 distinct prime factors.
7. 2^k | (n-1) where k is the number of prime factors of n.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a Lehmer counterexample: a composite number n > 1 such that φ(n) | (n-1).
-/
def IsLehmerCounterexample (n : ℕ) : Prop :=
  1 < n ∧ ¬ n.Prime ∧ Nat.totient n ∣ (n - 1)

/-
Lemma 1: n must be odd
-/
theorem lehmer_counterexample_odd (n : ℕ) (h : IsLehmerCounterexample n) : ¬ 2 ∣ n := by
  obtain ⟨ hn_gt1, hn_comp, h_div ⟩ := h; ( have := Nat.totient_even <| show n > 2 from not_le.mp fun contra ↦ by interval_cases n ; trivial; ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ; );
  exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => by have := Nat.dvd_trans ( even_iff_two_dvd.mp this ) h_div; rw [ Nat.dvd_iff_mod_eq_zero ] at this; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.add_mod, Nat.mul_mod ] )

/-
Lemma 2: n must be squarefree
-/
theorem lehmer_counterexample_squarefree (n : ℕ) (h : IsLehmerCounterexample n) : Squarefree n := by
  -- Assume there exists a prime $p$ such that $p^2 \mid n$.
  by_contra h_not_squarefree
  obtain ⟨p, hp_prime, hp_sq⟩ : ∃ p, Nat.Prime p ∧ p^2 ∣ n := by
    simpa only [ sq ] using by rw [ Nat.squarefree_iff_prime_squarefree ] at h_not_squarefree; aesop;
  -- Since $p^2 \mid n$, we have $p \mid \phi(n)$.
  have h_p_div_phi : p ∣ Nat.totient n := by
    refine' Nat.dvd_trans _ ( Nat.totient_dvd_of_dvd hp_sq );
    norm_num [ Nat.totient_prime_pow hp_prime ];
  -- Since $p \mid \phi(n)$ and $\phi(n) \mid (n - 1)$, we have $p \mid (n - 1)$.
  have h_p_div_n_minus_1 : p ∣ (n - 1) := by
    exact dvd_trans h_p_div_phi h.2.2;
  have := Nat.dvd_sub ( dvd_of_mul_left_dvd hp_sq ) h_p_div_n_minus_1; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.prime_dvd_prime_iff_eq ] ;
  cases h.1

/-
Lemma 3: n is a product of distinct odd primes
-/
theorem lehmer_counterexample_odd_squarefree (n : ℕ) (h : IsLehmerCounterexample n) :
  ∀ p ∈ n.primeFactors, Odd p := by
    -- Since $n$ is odd, any prime factor $p$ of $n$ must also be odd.
    intro p hp
    have h_odd_n : Odd n := by
      exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h₂ => by have := lehmer_counterexample_odd n h; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] );
    exact h_odd_n.of_dvd_nat <| Nat.dvd_of_mem_primeFactors hp

/-
Lemma 4: For each prime p | n, we have (p-1) | (n-1)
-/
theorem lehmer_each_prime_factor (n : ℕ) (h : IsLehmerCounterexample n) :
  ∀ p ∈ n.primeFactors, (p - 1) ∣ (n - 1) := by
    -- Since p | n, we have φ(p) | φ(n) by Nat.totient_dvd_of_dvd.
    intro p hp
    have h_phi_p : Nat.totient p ∣ Nat.totient n := by
      exact Nat.totient_dvd_of_dvd ( Nat.dvd_of_mem_primeFactors hp );
    exact dvd_trans ( by rw [ Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ] ) ( h_phi_p.trans h.2.2 )

/-
Lemma 5: n ≡ 1 [MOD (p - 1)] for each prime p | n
-/
theorem lehmer_congruence (n : ℕ) (h : IsLehmerCounterexample n) :
  ∀ p ∈ n.primeFactors, n ≡ 1 [MOD (p - 1)] := by
    intro p hp_mem; have := lehmer_each_prime_factor n h p hp_mem; exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub <| show 1 ≤ n from Nat.pos_of_ne_zero $ by aesop ] using this ) ;

/-
Lemma 6: n must have at least 3 distinct prime factors
-/
theorem lehmer_at_least_three_primes (n : ℕ) (h : IsLehmerCounterexample n) :
  3 ≤ n.primeFactors.card := by
    -- Suppose for contradiction that the number of distinct prime factors of n is less than 3.
    by_contra h_contra
    have h_card : n.primeFactors.card < 3 := by
      exact lt_of_not_ge h_contra;
    interval_cases _ : n.primeFactors.card <;> simp_all +decide [ Finset.card_eq_one ];
    · cases ‹_› <;> simp_all +decide [ IsLehmerCounterexample ];
    · rcases ‹_› with ⟨ p, hp ⟩ ; have := h.2.1 ; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
      -- Since $p$ is the only prime factor of $n$, we have $n = p^k$ for some integer $k$.
      obtain ⟨k, hk⟩ : ∃ k, n = p^k := by
        exact ⟨ n.factorization p, by nth_rw 1 [ ← Nat.factorization_prod_pow_eq_self hp.1.2.2 ] ; exact Finset.prod_eq_single p ( by aesop ) ( by aesop ) ⟩;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.totient_prime_pow ];
      · exact Nat.Prime.ne_one hp.1.1 hp.1.2;
      · exact absurd ( lehmer_counterexample_squarefree _ h ) ( by rw [ Nat.squarefree_pow_iff ] <;> aesop );
    · -- Let the prime factors of n be p and q with p ≠ q.
      obtain ⟨p, q, hpq, hneq⟩ : ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ n.primeFactors = {p, q} := by
        rw [ Finset.card_eq_two ] at *;
        obtain ⟨ p, q, hpq, h ⟩ := ‹_›; exact ⟨ p, q, Nat.prime_of_mem_primeFactors ( h.symm ▸ Finset.mem_insert_self _ _ ), Nat.prime_of_mem_primeFactors ( h.symm ▸ Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ), hpq, h ⟩ ;
      -- Since n is squarefree, n = p * q.
      have hn_eq_pq : n = p * q := by
        have hn_eq_pq : n = ∏ p ∈ n.primeFactors, p := by
          rw [ Nat.prod_primeFactors_of_squarefree ];
          exact lehmer_counterexample_squarefree n h;
        rw [ hn_eq_pq, hneq.2.2, Finset.prod_pair hneq.2.1 ];
      -- Then φ(n) = (p - 1)(q - 1).
      have hphi_eq : Nat.totient n = (p - 1) * (q - 1) := by
        rw [ hn_eq_pq, Nat.totient_mul, Nat.totient_prime hpq, Nat.totient_prime hneq.1 ];
        simpa [ hneq.2.1 ] using Nat.coprime_primes hpq hneq.1;
      -- We have φ(n) | (n - 1), so (p - 1)(q - 1) | (pq - 1).
      have hdiv : (p - 1) * (q - 1) ∣ (p * q - 1) := by
        exact hphi_eq ▸ hn_eq_pq ▸ h.2.2;
      rcases p with ( _ | _ | _ | p ) <;> rcases q with ( _ | _ | _ | q ) <;> norm_num at *;
      · rcases hdiv with ⟨ k, hk ⟩ ; rw [ tsub_eq_iff_eq_add_of_le ( by linarith ) ] at hk ; nlinarith [ show k = 2 by nlinarith ];
      · obtain ⟨ k, hk ⟩ := hdiv; rw [ tsub_eq_iff_eq_add_of_le ( by linarith ) ] at hk; nlinarith [ show k = 2 by nlinarith ] ;
      · rcases hdiv with ⟨ k, hk ⟩;
        rcases k with ( _ | _ | k ) <;> simp_all! +arith +decide [ Nat.mul_succ, Nat.add_mul ];
        grind

/-
Lemma 9: 2^k | (n-1) where k is the number of prime factors
-/
theorem lehmer_two_power_divides (n : ℕ) (h : IsLehmerCounterexample n) :
  2 ^ n.primeFactors.card ∣ (n - 1) := by
    -- By definition of Lehmer counterexample, we know that $\varphi(n) \mid (n - 1)$.
    have h_phi_div : Nat.totient n ∣ (n - 1) := by
      exact h.2.2;
    refine dvd_trans ?_ h_phi_div;
    -- Since $n$ is squarefree, we can use the multiplicative property of the totient function.
    have h_totient_mul : n.totient = ∏ p ∈ n.primeFactors, (p - 1) := by
      rw [ Nat.totient_eq_div_primeFactors_mul, mul_comm ];
      rw [ Nat.div_eq_of_eq_mul_left ];
      rw [ mul_one ];
      · exact Finset.prod_pos fun p hp => Nat.pos_of_mem_primeFactors hp;
      · rw [ one_mul, Nat.prod_primeFactors_of_squarefree ];
        exact lehmer_counterexample_squarefree n h;
    -- Since each $p_i$ is odd, we have $2 \mid (p_i - 1)$ for each $i$.
    have h_two_div : ∀ p ∈ n.primeFactors, 2 ∣ (p - 1) := by
      exact fun p hp => even_iff_two_dvd.mp ( Nat.Prime.even_sub_one ( Nat.prime_of_mem_primeFactors hp ) ( by rintro rfl; exact absurd ( lehmer_counterexample_odd n h ) ( by have := h.1; aesop ) ) );
    exact h_totient_mul.symm ▸ dvd_trans ( by norm_num ) ( Finset.prod_dvd_prod_of_dvd _ _ h_two_div )