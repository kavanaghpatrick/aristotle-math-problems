/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a93954c8-1e79-4553-a1bf-dd8ea9cf1a81

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized several known structural results about odd perfect numbers.
1. `no_odd_perfect_of_form_p_mul_q_sq`: There is no odd perfect number of the form p * q^2 where p, q are distinct odd primes with p ≡ 1 (mod 4).
2. `sigma_prime_pow_sum`: The sum of divisors of a prime power p^a is the geometric sum.
3. `odd_perfect_exists_unique_prime_odd_exponent`: Euler's form constraint: if n is odd perfect, exactly one prime factor has an odd exponent.
4. `odd_perfect_euler_form`: Full Euler's form: n = p^k * m^2 with p ≡ k ≡ 1 (mod 4) and p prime.
5. `odd_perfect_omega_ge_three`: An odd perfect number must have at least 3 distinct prime factors.
6. `odd_perfect_not_div_three_omega_ge_four`: If an odd perfect number is not divisible by 3, it must have at least 4 distinct prime factors.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
There is no odd perfect number of the form p * q^2 where p, q are distinct odd primes with p ≡ 1 (mod 4).
-/
theorem no_odd_perfect_of_form_p_mul_q_sq (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (hpq : p ≠ q) (hp_odd : Odd p) (hq_odd : Odd q) (hp_mod_4 : p ≡ 1 [MOD 4]) : ¬ Nat.Perfect (p * q ^ 2) := by
  -- Assume $p = qr - 1$, then substitute into the equation to get $r(q^2 + q + 1) = 2(qr-1)q$
  by_contra h
  obtain ⟨r, hr⟩ : ∃ r : ℕ, p + 1 = q * r := by
    -- The sum of the divisors of $pq^2$ is $(1 + p)(1 + q + q^2)$.
    have h_sigma : ∑ x ∈ Nat.divisors (p * q^2), x = (1 + p) * (1 + q + q^2) := by
      -- Let's calculate the sum of the divisors of $pq^2$.
      have h_divisors : Nat.divisors (p * q^2) = {1, p, q, q^2, p * q, p * q^2} := by
        rw [ Nat.divisors_mul, Nat.divisors_prime_pow hq, hp.divisors ];
        simp +decide [ Finset.range_add_one, Finset.mul_sum ];
        simpa [ Finset.ext_iff, Finset.mem_mul ] using by aesop;
      rw [ h_divisors, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert ] <;> norm_num [ hp.ne_zero, hq.ne_zero, hp.ne_one, hq.ne_one, hpq ] ; ring;
      · nlinarith only [ hq.two_le ];
      · rw [ sq ] ; aesop;
      · exact ⟨ by nlinarith only [ hq.two_le ], by nlinarith only [ hq.two_le, hp.two_le, mul_pos hp.pos hq.pos ] ⟩;
      · intro H; simp_all +decide [ Nat.prime_mul_iff, sq ] ;
      · exact ⟨ Ne.symm hp.ne_one, Ne.symm hq.ne_one, Ne.symm ( by nlinarith only [ hq.two_le ] ), Ne.symm ( by nlinarith only [ hp.two_le, hq.two_le ] ), Ne.symm ( by nlinarith only [ hp.two_le, hq.two_le, pow_pos hq.pos 2 ] ) ⟩;
    -- Since $p$ and $q$ are distinct odd primes, we have $q \mid (p + 1)(q^2 + q + 1)$.
    have h_div : q ∣ (p + 1) * (q^2 + q + 1) := by
      simp_all +decide [ Nat.Perfect, Nat.sum_divisors_eq_sum_properDivisors_add_self ];
      exact ⟨ p * q * 2, by linarith ⟩;
    exact Or.resolve_right ( hq.dvd_mul.mp h_div ) ( by rw [ Nat.dvd_add_right ( dvd_add ( dvd_pow_self _ two_ne_zero ) ( dvd_refl _ ) ) ] ; aesop );
  -- Simplify to obtain $r(q^2 + q + 1) = 2(qr - 1)q$
  have hr_simplified : r * (q^2 + q + 1) = 2 * (q * r - 1) * q := by
    -- From the definition of perfect numbers, we know that $σ(pq^2) = 2pq^2$.
    have h_sigma : (Nat.divisors (p * q^2)).sum id = 2 * p * q^2 := by
      simp_all +decide [ mul_assoc, Nat.sum_divisors_eq_sum_properDivisors_add_self, Nat.Perfect ];
      ring;
    -- Using the formula for the sum of divisors, we have $σ(pq^2) = (p + 1)(q^2 + q + 1)$.
    have h_sigma_formula : (Nat.divisors (p * q^2)).sum id = (p + 1) * (q^2 + q + 1) := by
      have h_sigma_formula : (Nat.divisors (p * q^2)).sum id = (Nat.divisors p).sum id * (Nat.divisors (q^2)).sum id := by
        have h_sigma_factored : ∀ {a b : ℕ}, Nat.gcd a b = 1 → (Nat.divisors (a * b)).sum id = (Nat.divisors a).sum id * (Nat.divisors b).sum id := by
          simp +zetaDelta at *;
          exact?;
        exact h_sigma_factored <| Nat.Coprime.pow_right _ <| hp.coprime_iff_not_dvd.mpr fun h => hpq <| by have := Nat.prime_dvd_prime_iff_eq hp hq; tauto;
      simp_all +decide [ Nat.divisors_prime_pow, Finset.sum_range_succ' ];
    cases r <;> cases q <;> simp_all +decide [ Nat.mul_succ, sq ] ; nlinarith;
  rcases r with ( _ | _ | r ) <;> rcases q with ( _ | _ | q ) <;> norm_num at *;
  · grind;
  · norm_num [ Nat.mul_succ ] at *;
    grind

/-
The sum of divisors of a prime power p^a is the sum of the geometric series 1 + p + ... + p^a.
-/
theorem sigma_prime_pow_sum (p : ℕ) (hp : p.Prime) (a : ℕ) :
    ArithmeticFunction.sigma 1 (p ^ a) = ∑ i ∈ Finset.range (a + 1), p ^ i := by
      simp +decide [ ArithmeticFunction.sigma_apply, Nat.divisors_prime_pow hp ]

/-
For an odd prime p, sigma(p^a) is even if and only if a is odd.
-/
lemma sigma_prime_pow_even_iff_odd_exponent {p a : ℕ} (hp : p.Prime) (hp_odd : Odd p) :
    Even (ArithmeticFunction.sigma 1 (p ^ a)) ↔ Odd a := by
      simp_all +decide [ Finset.sum_range_succ, parity_simps, ArithmeticFunction.sigma_apply ];
      cases a <;> simp_all +decide [ Nat.even_iff, Nat.add_mod, Nat.pow_mod, Finset.sum_nat_mod, Nat.odd_iff ]

/-
If n is an odd perfect number, then there is exactly one prime factor p of n such that the exponent of p in the prime factorization of n is odd.
-/
theorem odd_perfect_exists_unique_prime_odd_exponent (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) :
    ∃! p, p.Prime ∧ Odd (n.factorization p) := by
      -- Since $n$ is perfect, $\sigma(n) = 2n$. Also, $\sigma$ is multiplicative.
      have h_sigma_mul : ArithmeticFunction.sigma 1 n = 2 * n := by
        rw [ ArithmeticFunction.sigma_apply ];
        simp_all +decide [ Nat.sum_divisors_eq_sum_properDivisors_add_self, two_mul, Nat.Perfect ]
      have h_sigma_factorization : ArithmeticFunction.sigma 1 n = ∏ p ∈ Nat.primeFactors n, ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p)) := by
        convert ArithmeticFunction.sigma_one_apply n using 1;
        conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' ];
        -- Apply the multiplicativity of the sum of divisors function.
        have h_sigma_mult : ∀ {m n : ℕ}, Nat.gcd m n = 1 → (∑ d ∈ Nat.divisors (m * n), d) = (∑ d ∈ Nat.divisors m, d) * (∑ d ∈ Nat.divisors n, d) := by
          exact?;
        -- Apply the multiplicativity of the sum of divisors function to rewrite the product.
        have h_sigma_prod : ∀ {S : Finset ℕ} {f : ℕ → ℕ}, (∀ p ∈ S, Nat.Prime p) → (∏ p ∈ S, (∑ d ∈ Nat.divisors (p ^ (f p)), d)) = (∑ d ∈ Nat.divisors (∏ p ∈ S, p ^ (f p)), d) := by
          intros S f hf; induction S using Finset.induction <;> simp_all +decide ;
          rw [ h_sigma_mult ];
          · simp +decide [ *, Nat.divisors_prime_pow ];
          · exact Nat.Coprime.prod_right fun p hp => Nat.coprime_pow_primes _ _ hf.1 ( hf.2 p hp ) <| by aesop;
        convert h_sigma_prod fun p hp => Nat.prime_of_mem_primeFactors hp using 1;
        norm_num [ ArithmeticFunction.sigma ]
      have h_sigma_odd : ∀ p ∈ Nat.primeFactors n, Odd p := by
        exact fun p hp => hn_odd.of_dvd_nat <| Nat.dvd_of_mem_primeFactors hp
      have h_sigma_exp : ∀ p ∈ Nat.primeFactors n, (Odd (Nat.factorization n p)) ↔ Even (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) := by
        intros p hp; specialize h_sigma_odd p hp; simp_all +decide [ ArithmeticFunction.sigma_apply, parity_simps ] ;
        rw [ Nat.even_iff, Nat.odd_iff ] ; norm_num [ Nat.pow_mod, Finset.sum_nat_mod, Nat.odd_iff.mp h_sigma_odd ] ;
        grind
      have h_sigma_one : ∑ p ∈ Nat.primeFactors n, Nat.factorization (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 = 1 := by
        have h_sigma_one : Nat.factorization (∏ p ∈ Nat.primeFactors n, ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 = ∑ p ∈ Nat.primeFactors n, Nat.factorization (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 := by
          rw [ Nat.factorization_prod ] ; aesop;
          intro p hp; specialize h_sigma_exp p hp; aesop;
        simp_all +decide [ Nat.factorization_mul, hn_odd.pos.ne' ];
        rw [ ← h_sigma_one, Nat.factorization_eq_zero_of_not_dvd ] ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ]
      have h_sigma_unique : ∃! p : ℕ, p ∈ Nat.primeFactors n ∧ Odd (Nat.factorization n p) := by
        have h_sigma_unique : ∀ p ∈ Nat.primeFactors n, (Odd (Nat.factorization n p)) → Nat.factorization (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 ≥ 1 := by
          intros p hp h_odd_exp
          have h_sigma_even : Even (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) := by
            exact h_sigma_exp p hp |>.1 h_odd_exp;
          exact Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by exact Nat.mem_primeFactors.mpr ⟨ Nat.prime_two, Nat.dvd_of_mod_eq_zero ( Nat.even_iff.mp h_sigma_even ), by aesop ⟩ ) );
        have h_sigma_unique : ∀ p q : ℕ, p ∈ Nat.primeFactors n → q ∈ Nat.primeFactors n → p ≠ q → ¬(Odd (Nat.factorization n p) ∧ Odd (Nat.factorization n q)) := by
          intros p q hp hq hpq h_odd
          have h_sum : ∑ p ∈ Nat.primeFactors n, Nat.factorization (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 ≥ Nat.factorization (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p))) 2 + Nat.factorization (ArithmeticFunction.sigma 1 (q ^ (Nat.factorization n q))) 2 := by
            rw [ Finset.sum_eq_add_sum_diff_singleton hp ];
            exact add_le_add_left ( Finset.single_le_sum ( fun x hx => Nat.zero_le ( Nat.factorization ( ArithmeticFunction.sigma 1 ( x ^ ( n.factorization x ) ) ) 2 ) ) ( by aesop ) ) _;
          linarith [ h_sigma_unique p hp h_odd.1, h_sigma_unique q hq h_odd.2 ];
        obtain ⟨p, hp⟩ : ∃ p ∈ Nat.primeFactors n, Odd (Nat.factorization n p) := by
          contrapose! h_sigma_one;
          rw [ Finset.sum_eq_zero ] <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
          exact fun p pp dp hn => Or.inl <| Nat.odd_iff.mp <| h_sigma_exp p pp dp hn;
        exact ⟨ p, hp, fun q hq => Classical.not_not.1 fun hq' => h_sigma_unique q p hq.1 hp.1 hq' ⟨ hq.2, hp.2 ⟩ ⟩;
      exact ⟨ h_sigma_unique.exists.choose, ⟨ Nat.prime_of_mem_primeFactors h_sigma_unique.exists.choose_spec.1, h_sigma_unique.exists.choose_spec.2 ⟩, fun p hp => h_sigma_unique.unique ⟨ Nat.mem_primeFactors.mpr ⟨ hp.1, Nat.dvd_of_mod_eq_zero <| Nat.mod_eq_zero_of_dvd <| hp.1.dvd_iff_one_le_factorization ( by aesop ) |>.2 <| Nat.pos_of_ne_zero <| by aesop, by aesop ⟩, hp.2 ⟩ h_sigma_unique.exists.choose_spec ⟩

/-
An odd prime power p^a (with a >= 1) cannot be a perfect number.
-/
theorem odd_prime_pow_not_perfect {p a : ℕ} (hp : p.Prime) (hp_odd : Odd p) (ha : 1 ≤ a) : ¬ Nat.Perfect (p ^ a) := by
  rw [ Nat.Perfect ];
  norm_num [ Nat.properDivisors_prime_pow hp ];
  exact fun h => absurd h ( ne_of_lt ( Nat.geomSum_lt hp.one_lt ( by aesop ) ) )

/-
For a prime p and exponent a > 0, sigma(p^a)/p^a is strictly less than p/(p-1).
-/
lemma sigma_prime_pow_div_lt {p a : ℕ} (hp : p.Prime) (ha : a ≠ 0) :
    (ArithmeticFunction.sigma 1 (p ^ a) : ℚ) / (p ^ a) < (p : ℚ) / (p - 1) := by
      rw [ div_lt_div_iff₀ ];
      · norm_num [ ArithmeticFunction.sigma_apply, hp ];
        rw [ geom_sum_mul ] ; ring ; aesop;
      · exact_mod_cast pow_pos hp.pos _;
      · exact sub_pos_of_lt ( mod_cast hp.one_lt )

/-
An odd perfect number cannot have exactly 2 distinct prime factors.
-/
lemma odd_perfect_omega_ne_two (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) :
    (Nat.primeFactors n).card ≠ 2 := by
      -- Assume there are exactly two distinct primes $p$ and $q$.
      by_contra h_contra
      obtain ⟨p, q, hpq⟩ : ∃ p q, p ≠ q ∧ p.Prime ∧ q.Prime ∧ n.primeFactors = {p, q} := by
        rw [ Finset.card_eq_two ] at h_contra;
        obtain ⟨ p, q, hpq, h ⟩ := h_contra; exact ⟨ p, q, hpq, Nat.prime_of_mem_primeFactors ( h.symm ▸ Finset.mem_insert_self _ _ ), Nat.prime_of_mem_primeFactors ( h.symm ▸ Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ), h ⟩ ;
      -- Assume without loss of generality that $p < q$.
      suffices h_wlog : ∀ {p q : ℕ}, p.Prime → q.Prime → p < q → Odd p → Odd q → ¬Nat.Perfect (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) by
        -- Applying the hypothesis `h_wlog` to our assumption that $n$ is an odd perfect number with exactly two distinct prime factors $p$ and $q$.
        have h_factorization : n = p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q) := by
          conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' ];
          rw [ Finsupp.prod ] ; aesop;
        rcases lt_trichotomy p q with ( hpq_lt | rfl | hpq_gt ) <;> norm_num at *;
        · exact h_wlog hpq.2.1 hpq.2.2.1 hpq_lt ( hn_odd.of_dvd_nat <| h_factorization.symm ▸ dvd_mul_of_dvd_left ( dvd_pow_self _ <| Finsupp.mem_support_iff.mp <| by simp +decide [ hpq ] ) _ ) ( hn_odd.of_dvd_nat <| h_factorization.symm ▸ dvd_mul_of_dvd_right ( dvd_pow_self _ <| Finsupp.mem_support_iff.mp <| by simp +decide [ hpq ] ) _ ) ( h_factorization ▸ hn_perf );
        · exact h_wlog hpq.2.2.1 hpq.2.1 hpq_gt ( hn_odd.of_dvd_nat <| Nat.dvd_of_mem_primeFactors <| hpq.2.2.2.symm ▸ Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ) ( hn_odd.of_dvd_nat <| Nat.dvd_of_mem_primeFactors <| hpq.2.2.2.symm ▸ Finset.mem_insert_self _ _ ) <| by simpa only [ mul_comm ] using h_factorization ▸ hn_perf;
      intros p q hp hq hpq hp_odd hq_odd hn_perfect
      have h_sigma : (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) : ℚ) / (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) < (p : ℚ) / (p - 1) * (q : ℚ) / (q - 1) := by
        have h_sigma : (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p)) : ℚ) / (p ^ (Nat.factorization n p)) < (p : ℚ) / (p - 1) ∧ (ArithmeticFunction.sigma 1 (q ^ (Nat.factorization n q)) : ℚ) / (q ^ (Nat.factorization n q)) < (q : ℚ) / (q - 1) := by
          apply And.intro;
          · apply sigma_prime_pow_div_lt hp;
            intro h; simp_all +decide [ Nat.factorization_eq_zero_iff ] ;
            simp_all +decide [ Nat.Perfect, Nat.factorization_eq_zero_of_not_dvd ];
            exact absurd hn_perfect.1 ( ne_of_lt ( Nat.geomSum_lt hq.one_lt ( by aesop ) ) );
          · convert sigma_prime_pow_div_lt hq _ using 1;
            intro h; simp_all +decide [ Nat.Perfect ] ;
            rw [ Nat.geomSum_eq hp.one_lt ] at hn_perfect;
            exact absurd hn_perfect.1 ( Nat.ne_of_lt <| Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.sub_add_cancel <| Nat.one_le_pow ( Nat.factorization n p ) p hp.pos, Nat.sub_pos_of_lt hp.one_lt ] );
        have h_sigma_mul : ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) = ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p)) * ArithmeticFunction.sigma 1 (q ^ (Nat.factorization n q)) := by
          have h_sigma_mul : ∀ {a b : ℕ}, Nat.gcd a b = 1 → ArithmeticFunction.sigma 1 (a * b) = ArithmeticFunction.sigma 1 a * ArithmeticFunction.sigma 1 b := by
            simp +decide [ ArithmeticFunction.sigma ];
            exact?;
          exact h_sigma_mul <| Nat.coprime_pow_primes _ _ hp hq <| by linarith;
        convert mul_lt_mul'' h_sigma.1 h_sigma.2 ( by positivity ) ( by positivity ) using 1 <;> push_cast [ h_sigma_mul ] <;> ring;
      -- Since $n$ is perfect, we have $\sigma(n)/n = 2$.
      have h_sigma_eq_two : (ArithmeticFunction.sigma 1 (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) : ℚ) / (p ^ (Nat.factorization n p) * q ^ (Nat.factorization n q)) = 2 := by
        rw [ div_eq_iff ] <;> norm_cast <;> simp_all +decide [ Nat.Perfect, Nat.sum_divisors_eq_sum_properDivisors_add_self ];
        simp_all +decide [ ArithmeticFunction.sigma ];
        rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self, two_mul, hn_perfect.1 ];
      rcases p with ( _ | _ | _ | _ | p ) <;> rcases q with ( _ | _ | _ | _ | q ) <;> norm_num at *;
      · rw [ lt_div_iff₀ ] at h_sigma <;> nlinarith;
      · grind;
      · rw [ div_mul_eq_mul_div, div_div, lt_div_iff₀ ] at * <;> try positivity;
        rw [ h_sigma_eq_two ] at h_sigma ; nlinarith [ ( by norm_cast : ( p : ℚ ) < q ) ]

/-
An odd perfect number must have at least 3 distinct prime factors.
-/
theorem odd_perfect_omega_ge_three (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) :
    (Nat.primeFactors n).card ≥ 3 := by
      by_contra; interval_cases _ : n.primeFactors.card <;> simp_all +decide;
      · cases ‹_› <;> simp_all +decide [ Nat.Perfect ];
      · -- If n has exactly one prime factor p, then n = p^a for some integer a.
        obtain ⟨p, a, hp, ha⟩ : ∃ p a : ℕ, n = p^a ∧ p.Prime := by
          rw [ Finset.card_eq_one ] at *;
          simp +zetaDelta at *;
          obtain ⟨ p, hp ⟩ := ‹_›; exact ⟨ p, by rw [ ← Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' ] ; rw [ Finsupp.prod ] ; aesop, Nat.prime_of_mem_primeFactors <| hp.symm ▸ Finset.mem_singleton_self _ ⟩ ;
        simp_all +decide [ Nat.Perfect ];
        nlinarith [ ha.two_le, geom_sum_mul_neg ( p : ℤ ) a ];
      · exact absurd ‹_› ( odd_perfect_omega_ne_two n hn_odd hn_perf )

/-
For a prime p >= 5, p/(p-1) <= 5/4.
-/
lemma prime_div_pred_le_five_fourths {p : ℕ} (hp : p.Prime) (hp_ge_five : p ≥ 5) :
    (p : ℚ) / (p - 1) ≤ 5 / 4 := by
      rw [ div_le_div_iff₀ ] <;> linarith [ show ( p : ℚ ) ≥ 5 by norm_cast ]

/-
If n is an odd perfect number not divisible by 3, then n has at least 4 distinct prime factors.
-/
theorem odd_perfect_not_div_three_omega_ge_four (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) (h_not_div_three : ¬ 3 ∣ n) :
    (Nat.primeFactors n).card ≥ 4 := by
      by_contra h_contra;
      -- Since $n$ is an odd perfect number with exactly 3 distinct prime factors, we can write it as $n = p^a q^b r^c$ where $p, q, r$ are distinct primes and $a, b, c$ are positive integers.
      obtain ⟨p, q, r, a, b, c, hp, hq, hr, ha, hb, hc, hn⟩ : ∃ p q r a b c : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ Nat.Prime r ∧ p < q ∧ q < r ∧ a > 0 ∧ b > 0 ∧ c > 0 ∧ n = p^a * q^b * r^c := by
        have h_card : n.primeFactors.card = 3 := by
          have := odd_perfect_omega_ge_three n hn_odd hn_perf; interval_cases _ : n.primeFactors.card ; simp_all +decide ;
        obtain ⟨p, q, r, hp, hq, hr, hn⟩ : ∃ p q r : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ Nat.Prime r ∧ p < q ∧ q < r ∧ n.primeFactors = {p, q, r} := by
          obtain ⟨p, q, r, hp, hq, hr⟩ : ∃ p q r : ℕ, p ∈ n.primeFactors ∧ q ∈ n.primeFactors ∧ r ∈ n.primeFactors ∧ p < q ∧ q < r ∧ ∀ s ∈ n.primeFactors, s = p ∨ s = q ∨ s = r := by
            rcases Finset.card_eq_three.mp h_card with ⟨ p, q, r, hp, hq, hr ⟩ ; cases lt_trichotomy p q <;> cases lt_trichotomy q r <;> cases lt_trichotomy p r <;> aesop;
          exact ⟨ p, q, r, Nat.prime_of_mem_primeFactors hp, Nat.prime_of_mem_primeFactors hq, Nat.prime_of_mem_primeFactors hr.1, hr.2.1, hr.2.2.1, by ext s; aesop ⟩;
        use p, q, r, n.factorization p, n.factorization q, n.factorization r;
        rw [ ← Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' ];
        simp_all +decide [ Finsupp.prod ];
        rw [ Finset.prod_insert, Finset.prod_insert ] <;> simp_all +decide [ Nat.factorization_prod, hp.ne_zero, hq.ne_zero, hr.ne_zero ];
        · simp_all +decide [ Finsupp.single_apply, ne_of_lt ];
          exact ⟨ Or.inl ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by simp +decide [ hn ] ) ) ), Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by simp +decide [ hn ] ) ), Or.inr ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by simp +decide [ hn ] ) ) ), by rw [ if_neg ( by linarith ), if_neg ( by linarith ) ] ; ring ⟩;
        · linarith;
        · exact ⟨ by linarith, by linarith ⟩;
      -- Since $p$, $q$, and $r$ are distinct primes and $n$ is not divisible by 3, we have $p \geq 5$, $q \geq 7$, and $r \geq 11$.
      have hp_ge_5 : 5 ≤ p := by
        contrapose! h_not_div_three; interval_cases p <;> simp_all +decide ;
        · exact absurd ( hn_odd.of_dvd_nat ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( pow_dvd_pow _ hc ) _ ) _ ) ) ( by norm_num );
        · exact dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_pow_self _ hc.ne' ) _ ) _
      have hq_ge_7 : 7 ≤ q := by
        exact le_of_not_gt fun h => by interval_cases q <;> interval_cases p ; trivial;
      have hr_ge_11 : 11 ≤ r := by
        exact le_of_not_gt fun h => by interval_cases r <;> interval_cases q <;> interval_cases p <;> norm_num at *;
      -- Using the inequality $\frac{\sigma(p^a)}{p^a} < \frac{p}{p-1}$, we get $\frac{\sigma(n)}{n} < \frac{p}{p-1} \cdot \frac{q}{q-1} \cdot \frac{r}{r-1}$.
      have h_sigma_lt : (ArithmeticFunction.sigma 1 n : ℚ) / n < (p : ℚ) / (p - 1) * (q : ℚ) / (q - 1) * (r : ℚ) / (r - 1) := by
        have h_sigma_lt : (ArithmeticFunction.sigma 1 (p^a) : ℚ) / p^a < (p : ℚ) / (p - 1) ∧ (ArithmeticFunction.sigma 1 (q^b) : ℚ) / q^b < (q : ℚ) / (q - 1) ∧ (ArithmeticFunction.sigma 1 (r^c) : ℚ) / r^c < (r : ℚ) / (r - 1) := by
          exact ⟨ sigma_prime_pow_div_lt hp ( by linarith ), sigma_prime_pow_div_lt hq ( by linarith ), sigma_prime_pow_div_lt hr ( by linarith ) ⟩;
        -- Using the multiplicative property of the sum of divisors function, we have $\sigma(n) = \sigma(p^a) \cdot \sigma(q^b) \cdot \sigma(r^c)$.
        have h_sigma_mul : (ArithmeticFunction.sigma 1 n : ℚ) = (ArithmeticFunction.sigma 1 (p^a) : ℚ) * (ArithmeticFunction.sigma 1 (q^b) : ℚ) * (ArithmeticFunction.sigma 1 (r^c) : ℚ) := by
          have h_sigma_mul : ∀ {x y : ℕ}, Nat.gcd x y = 1 → (ArithmeticFunction.sigma 1 (x * y) : ℚ) = (ArithmeticFunction.sigma 1 x : ℚ) * (ArithmeticFunction.sigma 1 y : ℚ) := by
            intros x y h_coprime; norm_cast; simp +decide [ ArithmeticFunction.sigma ] ;
            exact?;
          rw [ hn.2.2, h_sigma_mul, h_sigma_mul ] <;> norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, hp.coprime_iff_not_dvd, hq.coprime_iff_not_dvd, hr.coprime_iff_not_dvd ];
          · exact Nat.coprime_pow_primes _ _ hp hq ( by linarith );
          · exact ⟨ Nat.coprime_pow_primes _ _ hp hr ( by linarith ), Nat.coprime_pow_primes _ _ hq hr ( by linarith ) ⟩;
        simp_all +decide [ mul_div_assoc ];
        convert mul_lt_mul'' ( mul_lt_mul'' h_sigma_lt.1 h_sigma_lt.2.1 ( by positivity ) ( by positivity ) ) h_sigma_lt.2.2 ( by positivity ) ( by positivity ) using 1 ; ring;
      -- Since $n$ is perfect, we have $\frac{\sigma(n)}{n} = 2$.
      have h_sigma_eq_two : (ArithmeticFunction.sigma 1 n : ℚ) / n = 2 := by
        rw [ div_eq_iff ] <;> norm_cast <;> simp_all +decide [ Nat.Perfect, ArithmeticFunction.sigma ];
        · rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self, two_mul, hn_perf.1 ];
        · exact ⟨ ⟨ fun h => absurd h hp.ne_zero, fun h => absurd h hq.ne_zero ⟩, fun h => absurd h hr.ne_zero ⟩;
      -- Substitute the inequality $\frac{p}{p-1} \cdot \frac{q}{q-1} \cdot \frac{r}{r-1} \leq \frac{5}{4} \cdot \frac{7}{6} \cdot \frac{11}{10}$ into the previous inequality.
      have h_subst : (p : ℚ) / (p - 1) * (q : ℚ) / (q - 1) * (r : ℚ) / (r - 1) ≤ (5 : ℚ) / 4 * (7 : ℚ) / 6 * (11 : ℚ) / 10 := by
        have h_subst : (p : ℚ) / (p - 1) ≤ 5 / 4 ∧ (q : ℚ) / (q - 1) ≤ 7 / 6 ∧ (r : ℚ) / (r - 1) ≤ 11 / 10 := by
          exact ⟨ by rw [ div_le_div_iff₀ ] <;> linarith [ show ( p : ℚ ) ≥ 5 by norm_cast ], by rw [ div_le_div_iff₀ ] <;> linarith [ show ( q : ℚ ) ≥ 7 by norm_cast ], by rw [ div_le_div_iff₀ ] <;> linarith [ show ( r : ℚ ) ≥ 11 by norm_cast ] ⟩;
        simpa only [ mul_div_assoc ] using mul_le_mul ( mul_le_mul h_subst.1 h_subst.2.1 ( by exact div_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr ( Nat.one_le_cast.mpr hq.pos ) ) ) ( by positivity ) ) h_subst.2.2 ( by exact div_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr ( Nat.one_le_cast.mpr hr.pos ) ) ) ( by positivity );
      linarith

/-
If n is an odd perfect number and p is the unique prime factor with an odd exponent, then p ≡ 1 (mod 4) and its exponent is ≡ 1 (mod 4).
-/
theorem odd_perfect_euler_form_prime_mod_4 (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) (p : ℕ) (hp : p ∈ n.primeFactors) (h_exponent_odd : Odd (n.factorization p)) :
    p ≡ 1 [MOD 4] ∧ n.factorization p ≡ 1 [MOD 4] := by
      -- Since $\sigma(n) = 2n$, we have $\sigma(p^{\alpha}) \cdot \prod_{q \neq p} \sigma(q^{\beta}) = 2n$. Therefore, $\sigma(p^{\alpha})$ must be even.
      have h_sigma_even : Even (ArithmeticFunction.sigma 1 (p ^ (n.factorization p))) := by
        convert sigma_prime_pow_even_iff_odd_exponent _ _ |>.2 h_exponent_odd using 1;
        · exact Nat.prime_of_mem_primeFactors hp;
        · exact hn_odd.of_dvd_nat ( Nat.dvd_of_mem_primeFactors hp );
      have h_alpha_odd : (ArithmeticFunction.sigma 1 (p ^ (n.factorization p))) % 4 = 2 := by
        have h_sigma_mod_four : (ArithmeticFunction.sigma 1 (p ^ (n.factorization p))) * (∏ q ∈ n.primeFactors.erase p, ArithmeticFunction.sigma 1 (q ^ (n.factorization q))) = 2 * n := by
          have h_sigma_prod : (∏ q ∈ n.primeFactors, ArithmeticFunction.sigma 1 (q ^ (n.factorization q))) = 2 * n := by
            have h_sigma_mod : (∏ q ∈ n.primeFactors, ArithmeticFunction.sigma 1 (q ^ (n.factorization q))) = ∑ d ∈ Nat.divisors n, d := by
              have h_sigma_mod : (∏ q ∈ n.primeFactors, (∑ i ∈ Finset.range (n.factorization q + 1), q ^ i)) = ∑ d ∈ Nat.divisors n, d := by
                have h_sigma_mod : ∀ {m : ℕ}, m ≠ 0 → (∏ q ∈ m.primeFactors, (∑ i ∈ Finset.range (m.factorization q + 1), q ^ i)) = ∑ d ∈ Nat.divisors m, d := by
                  exact?;
                exact h_sigma_mod hn_odd.pos.ne';
              convert h_sigma_mod using 2;
              simp +decide [ ArithmeticFunction.sigma ];
              rw [ Nat.divisors_prime_pow ( Nat.prime_of_mem_primeFactors ‹_› ) ] ; aesop;
            simp_all +decide [ Nat.Perfect, Nat.sum_divisors_eq_sum_properDivisors_add_self ];
            ring;
          rw [ ← h_sigma_prod, ← Finset.mul_prod_erase _ _ hp ];
        -- Since $\prod_{q \neq p} \sigma(q^{\beta})$ is odd, we have $\sigma(p^{\alpha}) \equiv 2 \pmod{4}$.
        have h_prod_odd : Odd (∏ q ∈ n.primeFactors.erase p, ArithmeticFunction.sigma 1 (q ^ (n.factorization q))) := by
          have h_prod_odd : ∀ q ∈ n.primeFactors.erase p, Odd (ArithmeticFunction.sigma 1 (q ^ (n.factorization q))) := by
            intros q hq
            have hq_odd : Odd (n.factorization q) → False := by
              have := odd_perfect_exists_unique_prime_odd_exponent n hn_odd hn_perf; cases this; aesop;
            simp_all +decide [ ArithmeticFunction.sigma ];
            rw [ Nat.odd_iff ] ; norm_num [ Nat.pow_mod, Finset.sum_nat_mod, Nat.even_iff.mp hq_odd ];
            cases Nat.Prime.eq_two_or_odd hq.2.1 <;> simp_all +decide [ Finset.sum_range_succ' ];
            norm_num [ Nat.add_mod, Nat.mod_mod, Nat.even_iff.mp hq_odd ];
          exact Nat.odd_iff.mpr ( by rw [ Finset.prod_nat_mod ] ; exact by rw [ Finset.prod_congr rfl fun x hx => Nat.odd_iff.mp ( h_prod_odd x hx ) ] ; norm_num );
        rcases h_sigma_even with ⟨ k, hk ⟩ ; rcases h_prod_odd with ⟨ m, hm ⟩ ; replace h_sigma_mod_four := congr_arg ( · % 4 ) h_sigma_mod_four ; rcases Nat.even_or_odd' k with ⟨ k₂, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' m with ⟨ m₂, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
        · rcases hn_odd with ⟨ k, rfl ⟩ ; norm_num [ Nat.add_mod, Nat.mul_mod, hk, hm ] at h_sigma_mod_four ⊢; have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> trivial;
        · rcases hn_odd with ⟨ k, rfl ⟩ ; norm_num [ Nat.add_mod, Nat.mul_mod, hk, hm ] at h_sigma_mod_four ⊢; have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> trivial;
        · grind;
        · norm_num [ Nat.add_mod, Nat.mul_mod, hk, hm ] at h_sigma_mod_four ⊢;
      -- Since $p \equiv 3 \pmod{4}$ would imply $\sigma(p^\alpha) \equiv 0 \pmod{4}$, we must have $p \equiv 1 \pmod{4}$.
      by_cases hp_mod : p % 4 = 3;
      · -- Since $p \equiv 3 \pmod{4}$, we have $\sum_{i=0}^{\alpha} p^i \equiv \sum_{i=0}^{\alpha} 3^i \equiv 0 \pmod{4}$ when $\alpha$ is odd.
        have h_sum_mod_four : (∑ i ∈ Finset.range (n.factorization p + 1), p ^ i) % 4 = 0 := by
          rw [ ← Nat.mod_add_div ( Nat.factorization n p ) 2 ] ; norm_num [ Nat.pow_add, Nat.pow_mul, Nat.odd_iff.mp h_exponent_odd, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Finset.sum_nat_mod, hp_mod ] ;
          induction ( n.factorization p / 2 ) <;> norm_num [ Nat.add_mod, Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at * ; simp_all +arith +decide;
          norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at * ; omega;
        simp_all +decide [ ArithmeticFunction.sigma ];
      · -- Since $p$ is a prime factor of $n$ and $n$ is odd, $p$ must also be odd.
        have hp_odd : p % 2 = 1 := by
          exact Nat.Prime.eq_two_or_odd ( Nat.prime_of_mem_primeFactors hp ) |> Or.resolve_left <| by rintro rfl; exact absurd ( hn_odd.of_dvd_nat <| Nat.dvd_of_mem_primeFactors hp ) ( by decide ) ;
        rw [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] at hp_odd; have := Nat.mod_lt p zero_lt_four; interval_cases _ : p % 4 <;> simp_all +decide [ Nat.ModEq ] ;
        -- Since $p \equiv 1 \pmod{4}$, we have $\sigma(p^\alpha) \equiv \alpha + 1 \pmod{4}$.
        have h_sigma_mod : (ArithmeticFunction.sigma 1 (p ^ (n.factorization p))) % 4 = (n.factorization p + 1) % 4 := by
          norm_num [ ArithmeticFunction.sigma_apply, *, Nat.pow_mod, Nat.add_mod ];
          norm_num [ Nat.pow_mod, Finset.sum_nat_mod, ‹_› ];
        rw [ Nat.odd_iff ] at h_exponent_odd; omega;

/-
Euler's form: If n is an odd perfect number, then n = p^k * m^2 where p is prime, p ≡ 1 (mod 4), k ≡ 1 (mod 4), and gcd(p, m) = 1.
-/
theorem odd_perfect_euler_form (n : ℕ) (hn_odd : Odd n) (hn_perf : Nat.Perfect n) :
    ∃ p k m, p.Prime ∧ p ≡ 1 [MOD 4] ∧ k ≡ 1 [MOD 4] ∧ n = p ^ k * m ^ 2 ∧ p.Coprime m := by
      -- Use `odd_perfect_exists_unique_prime_odd_exponent` to find the unique prime p with odd exponent k.
      obtain ⟨p, hp⟩ : ∃ p, p.Prime ∧ Odd (n.factorization p) ∧ ∀ q, q.Prime → q ≠ p → Even (n.factorization q) := by
        have := odd_perfect_exists_unique_prime_odd_exponent n hn_odd hn_perf;
        exact ⟨ this.exists.choose, this.exists.choose_spec.1, this.exists.choose_spec.2, fun q hq hq' => Nat.not_odd_iff_even.mp fun hq'' => hq' <| this.unique ⟨ hq, hq'' ⟩ this.exists.choose_spec ⟩;
      -- Use `odd_perfect_euler_form_prime_mod_4` to show p ≡ 1 (mod 4) and k ≡ 1 (mod 4).
      have h_mod : p ≡ 1 [MOD 4] ∧ n.factorization p ≡ 1 [MOD 4] := by
        have := odd_perfect_euler_form_prime_mod_4 n hn_odd hn_perf p;
        by_cases h : p ∣ n <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ];
        exact this hn_odd.pos.ne';
      refine ⟨ p, n.factorization p, ∏ q ∈ Nat.primeFactors n \ { p }, q ^ ( n.factorization q / 2 ), hp.left, h_mod.left, h_mod.right, ?_, ?_ ⟩;
      · conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' ];
        rw [ ← Finset.prod_pow ];
        rw [ Finsupp.prod_of_support_subset ];
        case s => exact { p } ∪ n.primeFactors \ { p };
        · rw [ Finset.prod_union ] <;> norm_num;
          exact Or.inl ( Finset.prod_congr rfl fun x hx => by rw [ ← pow_mul, Nat.div_mul_cancel ( even_iff_two_dvd.mp ( hp.2.2 x ( Nat.prime_of_mem_primeFactors ( Finset.mem_sdiff.mp hx |>.1 ) ) ( by aesop ) ) ) ] );
        · aesop_cat;
        · aesop;
      · exact Nat.Coprime.prod_right fun q hq => Nat.Coprime.pow_right _ <| hp.left.coprime_iff_not_dvd.mpr fun h => by have := Nat.prime_dvd_prime_iff_eq hp.left ( Nat.prime_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ; aesop;