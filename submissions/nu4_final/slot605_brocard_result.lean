/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b200f58b-ab9e-454b-b8c7-2a51856d4a92

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of Brocard's Problem (n! + 1 = m^2).
Includes verification of known solutions (n=4, 5, 7), bounded verification for n <= 20,
and structural results including modular obstructions, Wilson's theorem connection,
and growth bounds.

Main results:
- `brocard_solution_4`, `brocard_solution_5`, `brocard_solution_7`: Verification of known solutions.
- `brocard_bounded_20`: Proof that no other solutions exist for n <= 20.
- `brocard_non_solution`: Explicit statement that n! + 1 is not a square for n <= 20, n ∉ {4,5,7}.
- `brocard_mod_obstruction`: Modular constraints for primes p <= n.
- `brocard_wilson`: Connection to Wilson's theorem (p | m if n = p-1).
- `brocard_mod_8`: Parity constraint (m is odd for n >= 8).
- `brocard_primorial_dvd`: Divisibility by primorial n.
- `brocard_m_gt_n_sq`: Growth bound m > n^2 for n >= 7.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a Brocard solution and verification of the known solutions for n=4, 5, 7.
-/
def is_brocard_solution (n m : ℕ) : Prop := n.factorial + 1 = m ^ 2

theorem brocard_solution_4 : is_brocard_solution 4 5 := by
  exact?
theorem brocard_solution_5 : is_brocard_solution 5 11 := by
  -- By definition of $is_brocard_solution$, we need to show that $11^2 = 5! + 1$.
  unfold is_brocard_solution
  norm_num [Nat.factorial]
theorem brocard_solution_7 : is_brocard_solution 7 71 := by
  -- We can calculate $7! + 1$ directly.
  norm_num [is_brocard_solution]

/-
Bounded verification that for n <= 20, the only solutions are 4, 5, 7.
-/
def check_brocard (n : ℕ) : Bool :=
  if n ∈ [4, 5, 7] then true
  else let s := Nat.sqrt (n.factorial + 1)
       s * s ≠ n.factorial + 1

theorem brocard_bounded_20 : (List.range 21).all check_brocard = true := by
  native_decide +revert

/-
If n >= p for prime p, and n! + 1 = m^2, then m ≡ ±1 (mod p).
-/
theorem brocard_mod_obstruction {n m p : ℕ} (hp : p.Prime) (hn : p ≤ n) (h : is_brocard_solution n m) :
    m % p = 1 ∨ m % p = p - 1 := by
      -- Since $p$ divides $n �!�$, we have $m^2 \equiv 1 \pmod{p}$, so $m \equiv \pm 1 \pmod{p}$.
      have h_mod : m^2 % p = 1 % p := by
        rw [ ← h, Nat.add_mod, Nat.mod_eq_zero_of_dvd ( Nat.dvd_factorial hp.pos hn ) ] ; norm_num;
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ];
      rcases h_mod with h | h <;> rw [ ← ZMod.val_natCast, h ];
      · exact Or.inl ( by erw [ ZMod.val_one ] );
      · rcases p with ( _ | _ | p ) <;> norm_num at *

/-
If p is prime and (p-1)! + 1 = m^2, then p divides m.
-/
theorem brocard_wilson {p m : ℕ} (hp : p.Prime) (h : is_brocard_solution (p - 1) m) : p ∣ m := by
  haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
  haveI := Fact.mk hp; replace h := congr_arg ( fun x => x : ℕ → ZMod p ) h; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
  rw [ eq_comm ] at h ; aesop

/-
If n >= 8 and n! + 1 = m^2, then m is odd.
-/
theorem brocard_mod_8 {n m : ℕ} (hn : 8 ≤ n) (h : is_brocard_solution n m) : Odd m := by
  replace h := congr_arg Even h; simp_all +decide [ Nat.factorial_succ, parity_simps ] ;
  exact Classical.not_not.1 fun hm => absurd ( h.2 <| by simpa using hm ) ( by exact_mod_cast Nat.not_odd_iff_even.2 <| even_iff_two_dvd.2 <| Nat.dvd_factorial ( by decide ) <| by linarith )

/-
For n <= 20, if n is not 4, 5, or 7, then n! + 1 is not a perfect square.
-/
theorem brocard_non_solution (n : ℕ) (hn : n ≤ 20) (h_not_sol : n ∉ [4, 5, 7]) : ¬ ∃ m, is_brocard_solution n m := by
  interval_cases n <;> simp_all +decide [ is_brocard_solution ];
  all_goals intro x hx; norm_num [ Nat.factorial_succ ] at *; have := congr_arg Nat.sqrt hx; norm_num at this; nlinarith;

/-
If n! + 1 = m^2, then the primorial of n divides m^2 - 1.
-/
theorem brocard_primorial_dvd {n m : ℕ} (h : is_brocard_solution n m) : primorial n ∣ m ^ 2 - 1 := by
  rw [ ← h ];
  -- Since the product of all primes less than or equal to n divides the product of all integers from 1 to n, it follows that the primorial of n divides the factorial of n.
  have h_prime_prod_le_factorial : Finset.prod (Finset.filter Nat.Prime (Finset.Icc 1 n)) id ∣ Finset.prod (Finset.Icc 1 n) id := by
    apply_rules [ Finset.prod_dvd_prod_of_subset, Finset.filter_subset ];
  convert h_prime_prod_le_factorial using 1;
  · unfold primorial;
    congr 1 with ( _ | p ) <;> aesop;
  · exact Eq.symm ( Finset.prod_Ico_id_eq_factorial _ )

/-
If n >= 4 and n! + 1 = m^2, then m > n.
-/
theorem brocard_m_gt_n {n m : ℕ} (hn : 4 ≤ n) (h : is_brocard_solution n m) : n < m := by
  by_contra h_contra;
  -- Then $m^2 \leq n^2$.
  have h_square_le : m^2 ≤ n^2 := by
    gcongr ; linarith;
  -- For $n \geq 4$, we have $n! > n^2$, which implies $m^2 \leq n^2$.
  have h_factorial_gt_square : ∀ n ≥ 4, n.factorial > n^2 := by
    exact fun n hn => by induction hn <;> norm_num [ Nat.factorial_succ ] at * ; nlinarith;
  linarith [ h_factorial_gt_square n hn, h.symm ]

/-
If n! + 1 = m^2 and k divides n!, then m^2 ≡ 1 (mod k).
-/
theorem brocard_mod_general {n m k : ℕ} (h : is_brocard_solution n m) (hk : k ∣ n.factorial) : m ^ 2 % k = 1 % k := by
  rw [ ← h ];
  exact Nat.ModEq.add_right _ ( Nat.modEq_zero_iff_dvd.mpr hk )

/-
For n >= 7, if n! + 1 = m^2, then m > n^2.
-/
theorem brocard_m_gt_n_sq {n m : ℕ} (hn : 7 ≤ n) (h : is_brocard_solution n m) : n ^ 2 < m := by
  -- For n ≥ 7, we show that n! > n^4.
  have h_factorial_gt_n4 : n.factorial > n^4 := by
    exact Nat.le_induction ( by decide ) ( fun k hk ih => by rw [ Nat.factorial_succ, pow_succ' ] ; nlinarith [ Nat.mul_le_mul_left k hk ] ) n hn;
  nlinarith [ h.symm ]