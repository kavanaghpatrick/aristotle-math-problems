/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9ad82119-8077-465a-953f-e811983a7c3b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of IATA Rule 3015 (oneworld Explorer Round-the-World fare rules).
This module defines the necessary types (Continent, TCArea, CabinClass, FareBasis, City, Segment, Itinerary)
and the validity predicate `ValidRTW` which encodes the routing constraints.
It also includes proofs that any valid itinerary satisfies the ocean crossing, segment count, and continent count constraints,
and that the fare basis is uniquely determined for any valid itinerary and cabin class.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Continent and TCArea according to IATA Rule 3015.
Continents are: Europe-Middle East, Africa, Asia, South West Pacific, North America, South America.
TC Areas are:
TC1 = North America + South America
TC2 = Europe-Middle East + Africa
TC3 = Asia + South West Pacific
-/
inductive Continent
| EuropeMiddleEast
| Africa
| Asia
| SouthWestPacific
| NorthAmerica
| SouthAmerica
deriving Repr, DecidableEq, Inhabited

inductive TCArea
| TC1
| TC2
| TC3
deriving Repr, DecidableEq, Inhabited

def Continent.toTCArea : Continent → TCArea
| .NorthAmerica => .TC1
| .SouthAmerica => .TC1
| .EuropeMiddleEast => .TC2
| .Africa => .TC2
| .Asia => .TC3
| .SouthWestPacific => .TC3

/-
Define CabinClass and FareBasis.
Cabin classes: Economy, Business, First.
Fare bases: LONE3, IONE3, DONE3, AONE3, LONE4, DONE4, AONE4, LONE5, DONE5, AONE5, LONE6, DONE6, AONE6.
-/
inductive CabinClass
| Economy
| Business
| First
deriving Repr, DecidableEq, Inhabited

inductive FareBasis
| LONE3 | IONE3 | DONE3 | AONE3
| LONE4 | DONE4 | AONE4
| LONE5 | DONE5 | AONE5
| LONE6 | DONE6 | AONE6
deriving Repr, DecidableEq, Inhabited

/-
Define City, SegmentType, Segment, Itinerary, and Ocean.
A City has an id, a continent, and a country.
A SegmentType is either Flight or Surface.
A Segment has an origin, destination, type, and isStopover flag.
An Itinerary is a list of Segments.
Oceans are Atlantic and Pacific.
-/
structure City where
  id : String
  continent : Continent
  country : String
deriving Repr, DecidableEq, Inhabited

inductive SegmentType
| Flight
| Surface
deriving Repr, DecidableEq, Inhabited

structure Segment where
  origin : City
  destination : City
  type : SegmentType
  isStopover : Bool
deriving Repr, DecidableEq, Inhabited

def Itinerary := List Segment

inductive Ocean
| Atlantic
| Pacific
deriving Repr, DecidableEq, Inhabited

/-
Define helper functions:
- get_ocean: determines if a segment between two continents crosses an ocean.
- visited_continents: lists all unique continents visited, adding Asia if SWP-EME direct flight exists.
- continent_count: counts visited continents.
- ocean_crossings: lists all ocean crossings in the itinerary.
- fare_basis: determines the fare basis code from cabin class and continent count.
-/
def get_ocean (c1 c2 : Continent) : Option Ocean :=
  match c1.toTCArea, c2.toTCArea with
  | .TC1, .TC2 => some .Atlantic
  | .TC2, .TC1 => some .Atlantic
  | .TC1, .TC3 => some .Pacific
  | .TC3, .TC1 => some .Pacific
  | _, _ => none

def visited_continents (itin : Itinerary) : List Continent :=
  let origins := itin.map (fun s => s.origin.continent)
  let dests := itin.map (fun s => s.destination.continent)
  let all_points := origins ++ dests
  let unique := all_points.eraseDup
  let has_swp_eme := itin.any fun s =>
    (s.origin.continent == .SouthWestPacific && s.destination.continent == .EuropeMiddleEast) ||
    (s.origin.continent == .EuropeMiddleEast && s.destination.continent == .SouthWestPacific)
  if has_swp_eme && !unique.contains .Asia then .Asia :: unique else unique

def continent_count (itin : Itinerary) : Nat := (visited_continents itin).length

def ocean_crossings (itin : Itinerary) : List Ocean :=
  itin.filterMap fun s => get_ocean s.origin.continent s.destination.continent

def fare_basis (cabin : CabinClass) (itin : Itinerary) : Option FareBasis :=
  let cc := continent_count itin
  match cabin, cc with
  | .Economy, 3 => some .LONE3
  | .Business, 3 => some .DONE3
  | .First, 3 => some .AONE3
  | .Economy, 4 => some .LONE4
  | .Business, 4 => some .DONE4
  | .First, 4 => some .AONE4
  | .Economy, 5 => some .LONE5
  | .Business, 5 => some .DONE5
  | .First, 5 => some .AONE5
  | .Economy, 6 => some .LONE6
  | .Business, 6 => some .DONE6
  | .First, 6 => some .AONE6
  | _, _ => none

/-
Define is_continuous, is_loop, count_ocean, visited_tc_areas, and ValidRTW.
ValidRTW requires:
- Continuous itinerary
- Loop (start = end)
- 3 to 16 segments
- Exactly 1 Atlantic crossing
- Exactly 1 Pacific crossing
- Visits all 3 TC areas (implied by TC1-TC2-TC3 routing)
-/
def is_continuous (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | _ :: [] => True
  | s1 :: s2 :: rest => s1.destination = s2.origin ∧ is_continuous (s2 :: rest)

def is_loop (itin : Itinerary) : Prop :=
  match itin with
  | [] => False
  | s :: _ =>
    match itin.getLast? with
    | some last => s.origin = last.destination
    | none => False

def count_ocean (itin : Itinerary) (o : Ocean) : Nat :=
  (ocean_crossings itin).filter (· == o) |>.length

def visited_tc_areas (itin : Itinerary) : List TCArea :=
  (visited_continents itin).map Continent.toTCArea |>.eraseDup

structure ValidRTW (itin : Itinerary) : Prop where
  continuous : is_continuous itin
  loop : is_loop itin
  min_segments : itin.length ≥ 3
  max_segments : itin.length ≤ 16
  one_atlantic : count_ocean itin .Atlantic = 1
  one_pacific : count_ocean itin .Pacific = 1
  visits_all_tc : (visited_tc_areas itin).length = 3
  -- We assume the "continuous forward direction" and other constraints imply we visit them in order,
  -- but for the purpose of the requested proofs, visiting all 3 is the key structural property derived from the oceans + loop.
  -- Actually, let's just stick to what's needed for the proofs requested.
  -- The rule 4b says "Travel must be in a continuous forward direction between TC1 - TC2 - TC3".
  -- This implies we touch all three.

/-
Theorem: Any ValidRTW itinerary has exactly one Atlantic crossing and one Pacific crossing.
Proof: This follows directly from the definition of ValidRTW.
-/
theorem valid_rtw_ocean_crossings (itin : Itinerary) (h : ValidRTW itin) :
  count_ocean itin .Atlantic = 1 ∧ count_ocean itin .Pacific = 1 := by
  exact ⟨ h.one_atlantic, h.one_pacific ⟩

/-
Theorem: Any ValidRTW itinerary has between 3 and 16 segments.
Proof: This follows directly from the definition of ValidRTW.
-/
theorem valid_rtw_segment_count (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ itin.length ∧ itin.length ≤ 16 := by
  exact ⟨h.min_segments, h.max_segments⟩

/-
Theorem: The continent count for any valid RTW itinerary is between 3 and 6.
Proof:
1. Upper bound: There are only 6 continents defined. The `visited_continents` function returns a list of unique continents (potentially adding Asia if implied), so its length cannot exceed 6.
2. Lower bound: `ValidRTW` requires visiting all 3 TC areas. Since each TC area corresponds to a disjoint set of continents, visiting 3 distinct TC areas implies visiting at least 3 distinct continents.
-/
theorem valid_rtw_continent_count (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
  constructor;
  · -- Since the itinerary must visit all three TC areas, and each TC area corresponds to a disjoint set of continents, the itinerary must visit at least three distinct continents.
    have h_visited_continents : (visited_continents itin).length ≥ 3 := by
      have h_tc_areas : (visited_tc_areas itin).length = 3 := h.visits_all_tc
      unfold visited_tc_areas at h_tc_areas;
      -- Since `List.map` preserves the length of the list, we can conclude that the length of `visited_continents itin` is at least 3.
      have h_length : (List.map Continent.toTCArea (visited_continents itin)).length ≥ (List.map Continent.toTCArea (visited_continents itin)).eraseDup.length := by
        induction ( List.map Continent.toTCArea ( visited_continents itin ) ) <;> simp +decide [ * ];
        simp_all +decide [ List.eraseDup ];
        simp_all +decide [ List.pwFilter ];
        grind;
      aesop;
    exact h_visited_continents;
  · unfold continent_count;
    -- The list of continents is a subset of the set of all continents, which has 6 elements.
    have h_subset : (visited_continents itin).toFinset ⊆ {Continent.EuropeMiddleEast, Continent.Africa, Continent.Asia, Continent.SouthWestPacific, Continent.NorthAmerica, Continent.SouthAmerica} := by
      intro x hx;
      cases x <;> simp +decide;
    convert Finset.card_le_card h_subset using 1;
    rw [ List.toFinset_card_of_nodup ];
    -- The list of continents is a subset of the set of all continents, which has 6 elements. Therefore, the length of the list is at most 6.
    have h_nodup : ∀ (l : List Continent), List.Nodup (List.eraseDup l) := by
      intro l; induction l <;> simp_all +decide [ List.eraseDup ] ;
      simp_all +decide [ List.pwFilter ];
      grind;
    unfold visited_continents; aesop;

/-
Theorem: For any valid RTW itinerary and any cabin class, the fare basis is determined (i.e., not none).
Proof:
1. We know from `valid_rtw_continent_count` that the continent count is between 3 and 6.
2. The `fare_basis` function is defined for all cabin classes and continent counts from 3 to 6.
3. Therefore, `fare_basis` returns `some` value.
-/
theorem valid_rtw_fare_determined (itin : Itinerary) (cabin : CabinClass) (h : ValidRTW itin) :
  (fare_basis cabin itin).isSome := by
  have h_continent_count : 3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?;
  unfold fare_basis;
  rcases h_continent_count with ⟨ _, _ ⟩ ; interval_cases _ : continent_count itin <;> simp +decide [ * ] ;
  · cases cabin <;> trivial;
  · cases cabin <;> trivial;
  · cases cabin <;> trivial;
  · rcases cabin with ( _ | _ | _ ) <;> trivial