/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7fb78658-3076-48d2-ae81-88d06cc2e143

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Finset BigOperators Classical

variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧ Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

lemma triangle_shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_not_in_M : t ∉ M) :
    ∃ e ∈ M, (t ∩ e).card ≥ 2 := by
      by_contra h_contra;
      -- If $t$ does not intersect any edge of $M$ in at least two vertices, then $M \cup \{t\}$ is also a packing.
      have h_packing : M ∪ {t} ⊆ G.cliqueFinset 3 ∧ Set.Pairwise (M ∪ {t}) (fun t1 t2 => (t1 ∩ t2).card ≤ 1) := by
        simp_all +decide [ Finset.subset_iff, Set.Pairwise ];
        simp_all +decide [ Finset.inter_comm ];
        exact ⟨ fun x hx => by have := hM.1; exact (by
        have := this.1 hx; simp_all +decide [ SimpleGraph.isNClique_iff ] ;), fun x hx hx' => Nat.le_of_lt_succ ( h_contra x hx ), fun x hx => ⟨ fun hx' => Nat.le_of_lt_succ ( h_contra x hx ), fun y hy hxy => by have := hM.1; exact (by
        exact this.2 hx hy hxy |> le_trans <| by decide;) ⟩ ⟩;
      -- Since $M \cup \{t\}$ is a packing, its cardinality must be less than or equal to the packing number.
      have h_card_le_packing_number : (M ∪ {t}).card ≤ trianglePackingNumber G := by
        have h_card_le_packing_number : ∃ S ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset, S.card = (M ∪ {t}).card := by
          refine' ⟨ M ∪ { t }, _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
        have h_card_le_packing_number_max : ∀ S ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset, S.card ≤ (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max.getD 0 := by
          intro S hS;
          have := Finset.le_max ( Finset.mem_image_of_mem Finset.card hS );
          cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 ).powerset ) ) <;> aesop;
        exact h_card_le_packing_number.choose_spec.2 ▸ h_card_le_packing_number_max _ h_card_le_packing_number.choose_spec.1;
      have := hM.2; simp_all +decide [ Finset.card_union_add_card_inter ] ;

lemma extract_two_from_triple (T : Finset V) (v : V) (hv : v ∈ T) (hcard : T.card = 3) :
    ∃ u w, u ∈ T ∧ w ∈ T ∧ u ≠ v ∧ w ≠ v ∧ u ≠ w ∧ T = {v, u, w} := by
      rw [ Finset.card_eq_three ] at hcard; aesop;

lemma two_edges_hit_sharing (G : SimpleGraph V) [DecidableRel G.Adj]
    (T : Finset V) (hT : T ∈ G.cliqueFinset 3)
    (a b c : V) (hT_eq : T = {a, b, c}) (hab : a ≠ b) (hac : a ≠ c) (hbc : b ≠ c) :
    ∀ t ∈ trianglesSharingEdge G T, s(a, b) ∈ t.sym2 ∨ s(a, c) ∈ t.sym2 ∨ s(b, c) ∈ t.sym2 := by
      -- Since $T = \{a, b, c\}$, any triangle $t$ sharing an edge with $T$ must share at least one of the edges $(a, b)$, $(a, c)$, or $(b, c)$.
      intros t ht
      have h_inter : (t ∩ {a, b, c}).card ≥ 2 := by
        unfold trianglesSharingEdge at ht; aesop;
      have h_inter : ∃ x y : V, x ∈ t ∧ y ∈ t ∧ x ≠ y ∧ (x = a ∧ y = b ∨ x = a ∧ y = c ∨ x = b ∧ y = c ∨ x = b ∧ y = a ∨ x = c ∧ y = a ∨ x = c ∧ y = b) := by
        obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.mp h_inter; use x, y; aesop;
      -- By examining the cases from h_inter, we can conclude that one of the edges (a, b), (a, c), or (b, c) must be in the symmetric square of t.
      obtain ⟨x, y, hx, hy, hxy, h_cases⟩ := h_inter;
      aesop

lemma union_covers_union (A B : Finset (Finset V)) (XA XB : Finset (Sym2 V))
    (hA : ∀ t ∈ A, ∃ e ∈ XA, e ∈ t.sym2) (hB : ∀ t ∈ B, ∃ e ∈ XB, e ∈ t.sym2) :
    ∀ t ∈ A ∪ B, ∃ e ∈ XA ∪ XB, e ∈ t.sym2 := by
      grind

lemma card_union_le_four (A B : Finset (Sym2 V)) (hA : A.card ≤ 2) (hB : B.card ≤ 2) :
    (A ∪ B).card ≤ 4 := by
      -- The cardinality of the union of two finite sets is at most the sum of their cardinalities.
      apply le_trans (Finset.card_union_le A B) (add_le_add hA hB)

def isPath4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧ A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ A ≠ C ∧ A ≠ D ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧
  (A ∩ C).card = 0 ∧ (A ∩ D).card = 0 ∧ (B ∩ D).card = 0

def active_edges (G : SimpleGraph V) [DecidableRel G.Adj] (T : Finset V) : Finset (Sym2 V) :=
  T.sym2.filter (fun e => ∃ t ∈ trianglesSharingEdge G T, e ∈ t.sym2)

def private_neighbors (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (T : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G T).filter (fun t => ∀ T' ∈ M, T' ≠ T → t ∉ trianglesSharingEdge G T')

def bridge_neighbors (G : SimpleGraph V) [DecidableRel G.Adj] (T T' : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G T).filter (fun t => t ∈ trianglesSharingEdge G T')

def bridge_edges (G : SimpleGraph V) [DecidableRel G.Adj] (T T' : Finset V) : Finset (Sym2 V) :=
  T.sym2.filter (fun e => ∃ t ∈ bridge_neighbors G T T', e ∈ t.sym2)

def private_edges (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (T : Finset V) : Finset (Sym2 V) :=
  T.sym2.filter (fun e => ∃ t ∈ private_neighbors G M T, e ∈ t.sym2)

lemma active_eq_private_union_bridges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (T : Finset V) (hT : T ∈ M) :
    active_edges G T = private_edges G M T ∪ (M.erase T).biUnion (fun T' => bridge_edges G T T') := by
  ext e
  simp [active_edges, private_edges, bridge_edges];
  constructor <;> intro h;
  · by_cases h₂ : ∃ T' ∈ M.erase T, e ∈ T.sym2.filter (fun e => ∃ t ∈ trianglesSharingEdge G T, t ∈ trianglesSharingEdge G T' ∧ e ∈ t.sym2) <;> simp_all +decide [ private_neighbors, bridge_neighbors ];
    · exact Or.inr ⟨ h₂.choose, h₂.choose_spec.1, h₂.choose_spec.2.choose, ⟨ h₂.choose_spec.2.choose_spec.1, h₂.choose_spec.2.choose_spec.2.1 ⟩, h₂.choose_spec.2.choose_spec.2.2 ⟩;
    · grind +ring;
  · rcases h with ( ⟨ h₁, t, ht₁, ht₂ ⟩ | ⟨ a, ⟨ ha₁, ha₂ ⟩, h₁, t, ht₁, ht₂ ⟩ ) <;> refine' ⟨ h₁, t, _, _ ⟩ <;> simp_all +decide [ private_neighbors, bridge_neighbors ]

lemma private_neighbor_intersection_le_one (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (T : Finset V)
    (t : Finset V) (ht : t ∈ private_neighbors G M T)
    (T' : Finset V) (hT' : T' ∈ M) (hdiff : T' ≠ T) :
    (t ∩ T').card ≤ 1 := by
      -- Since $t$ is in the private neighbors of $T$, it must be in the triangles SharingEdge $G T$, but not in any other trianglesSharingEdge $G T'$ for $T' \in M$ and $T' \neq T$.
      have h_not_in_sharing : ¬∃ T' ∈ M, T' ≠ T ∧ t ∈ trianglesSharingEdge G T' := by
        unfold private_neighbors at ht; aesop;
      contrapose! h_not_in_sharing;
      unfold private_neighbors trianglesSharingEdge at *; aesop;