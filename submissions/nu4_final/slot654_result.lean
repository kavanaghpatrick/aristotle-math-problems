/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dc2c0dfa-d1ce-4ef1-a464-60d7bce69b60

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized a reduction of the open problem "complexity(2^n) = 2n" to two conjectures regarding the "weight" function (sum of complexities of prime factors).
Specifically, we defined `weight n` and proved that `weight (2^n) = 2n`.
We then proved `complexity_ge_weight_of_assumptions`, which states that if `weight` is subadditive (`weight (a+b) ≤ weight a + weight b`) and satisfies a successor bound (`weight (m+1) ≤ weight m + 1`), then `complexity n ≥ weight n` for all `n`.
Finally, we proved `complexity_two_pow_eq_two_mul_of_weight_conjectures`, showing that these conjectures imply the main theorem `complexity (2^n) = 2n`.
The conjectures themselves remain open, as expected for this problem.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1c4453f1-831e-4153-a035-7e111eee0d3a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- The inductively defined predicate that `m` is reachable in `n` steps. -/
inductive Reachable : ℕ → ℕ → Prop
  | one : Reachable 1 1
  | add {m n a b} : Reachable m a → Reachable n b → Reachable (m + n) (a + b)
  | mul {m n a b} : Reachable m a → Reachable n b → Reachable (m * n) (a + b)

theorem not_reachable_zero_fst (n : ℕ) : ¬ Reachable 0 n := by
  intro h; generalize hm : 0 = m at h; induction h with
  | one => exact absurd hm (by decide)
  | add h₁ h₂ => rw [eq_comm, add_eq_zero] at hm; aesop
  | mul h₁ h₂ => rw [eq_comm, mul_eq_zero] at hm; aesop

theorem not_reachable_zero_snd (m : ℕ) : ¬ Reachable m 0 := by
  intro h; generalize hn : 0 = n at h; induction h with
  | one => exact absurd hn (by decide)
  | add h₁ h₂ => rw [eq_comm, add_eq_zero] at hn; aesop
  | mul h₁ h₂ => rw [eq_comm, add_eq_zero] at hn; aesop

theorem Reachable.dec {m n : ℕ} (h : Reachable m n) :
    ∃ m' n', m' + 1 = m ∧ n' + 1 = n := by
  obtain _ | m := m
  · exact absurd h (not_reachable_zero_fst _)
  obtain _ | n := n
  · exact absurd h (not_reachable_zero_snd _)
  exact ⟨_, _, rfl, rfl⟩

theorem Reachable.le {m n₁ n₂ : ℕ} (hn : n₁ ≤ n₂) (hm : Reachable m n₁) : Reachable m n₂ := by
  induction hn with
  | refl => exact hm
  | step h ih => convert ih.mul .one; simp

theorem Reachable.self (n : ℕ) (hn : 0 < n) : Reachable n n :=
  Nat.le_induction .one (fun _ _ ih ↦ .add ih .one) n hn

theorem reachable_iff_of_two_le (m n : ℕ) (hm : 2 ≤ m) :
    Reachable m n ↔ ∃ m₁, ∃ _ : m₁ < m, ∃ m₂, ∃ _ : m₂ < m, ∃ n₁, ∃ _ : n₁ < n, ∃ n₂, ∃ _ : n₂ < n,
      n₁ + n₂ = n ∧ Reachable m₁ n₁ ∧ Reachable m₂ n₂ ∧ (m₁ + m₂ = m ∨ m₁ * m₂ = m) := by
  refine ⟨fun hmn ↦ ?_, fun ⟨m₁, hm₁, m₂, hm₂, n₁, hn₁, n₂, hn₂, h₁, h₂, h₃, h₄⟩ ↦
    h₁ ▸ h₄.casesOn (· ▸ .add h₂ h₃) (· ▸ .mul h₂ h₃)⟩
  induction hmn with
  | one => exact absurd hm (by decide)
  | @add m₃ m₄ n₃ n₄ h₁ h₂ ih₁ ih₂ =>
      obtain ⟨m₃, n₃, rfl, rfl⟩ := h₁.dec
      obtain ⟨m₄, n₄, rfl, rfl⟩ := h₂.dec
      refine ⟨m₃ + 1, ?_, m₄ + 1, ?_, n₃ + 1, ?_, n₄ + 1, ?_, rfl, h₁, h₂, .inl rfl⟩ <;> omega
  | @mul m₃ m₄ n₃ n₄ h₁ h₂ ih₁ ih₂ =>
      obtain ⟨m₃, n₃, rfl, rfl⟩ := h₁.dec
      obtain ⟨m₄, n₄, rfl, rfl⟩ := h₂.dec
      obtain _ | m₃ := m₃
      · obtain ⟨m₅, hm₅, m₆, hm₆, n₅, hn₅, n₆, hn₆, h₃, h₄, h₅, h₆⟩ := ih₂ (by omega)
        refine ⟨m₅, ?_, m₆, ?_, n₅+n₃+1, ?_, n₆, ?_, by rw [← h₃]; ring, h₄.le ?_, h₅, ?_⟩
        all_goals omega
      obtain _ | m₄ := m₄
      · obtain ⟨m₅, hm₅, m₆, hm₆, n₅, hn₅, n₆, hn₆, h₃, h₄, h₅, h₆⟩ := ih₁ (by omega)
        refine ⟨m₅, ?_, m₆, ?_, n₅, ?_, n₆+n₄+1, ?_, by rw [← h₃]; ring, h₄, h₅.le ?_, ?_⟩
        all_goals omega
      refine ⟨m₃+2, ?_, m₄+2, ?_, _, ?_, _, ?_, rfl, h₁, h₂, .inr rfl⟩
      · refine (Nat.lt_mul_iff_one_lt_right ?_).2 ?_ <;> omega
      · refine (Nat.lt_mul_iff_one_lt_left ?_).2 ?_ <;> omega
      all_goals omega

open Classical

/-- The complexity of n: minimum number of 1s to express n using + and ×. -/
noncomputable def complexity (n : ℕ) : ℕ :=
  if h : n = 0 then 0 else Nat.find ⟨n, Reachable.self n <| n.pos_of_ne_zero h⟩

theorem Reachable.complexity_le {m n : ℕ} (h : Reachable m n) : complexity m ≤ n := by
  unfold complexity
  split_ifs with h'
  · subst h'; exact absurd h (not_reachable_zero_fst n)
  exact Nat.find_min' _ h

theorem Reachable.complexity_eq {m n : ℕ} (h : Reachable m n)
    (min : ∀ n' < n, ¬ Reachable m n') : complexity m = n := by
  refine le_antisymm h.complexity_le ?_
  unfold complexity
  split_ifs with h'
  · subst h'; exact absurd h (not_reachable_zero_fst n)
  exact (Nat.le_find_iff _ _).2 min

theorem Reachable.complexity {n : ℕ} (hn : 0 < n) : Reachable n (complexity n) := by
  -- By definition of complexity, there exists some $m$ such that $Reachable n m$ and $m$ is the minimum such number.
  obtain ⟨m, hm⟩ : ∃ m, Reachable n m ∧ ∀ k < m, ¬Reachable n k := by
    exact ⟨ Nat.find ⟨ n, Reachable.self n hn ⟩, Nat.find_spec ( ⟨ n, Reachable.self n hn ⟩ : ∃ m, Reachable n m ), fun k hk => Nat.find_min ( ⟨ n, Reachable.self n hn ⟩ : ∃ m, Reachable n m ) hk ⟩;
  convert hm.1;
  exact Reachable.complexity_eq hm.1 hm.2

theorem Reachable.pow (m n : ℕ) (hm : 0 < m) (hn : 0 < n) : Reachable (m ^ n) (m * n) := by
  induction' n with n ih;
  · contradiction;
  · rcases n with ( _ | n ) <;> simp_all +decide [ pow_succ' ];
    · exact Reachable.self m hm;
    · convert Reachable.mul ( Reachable.self m hm ) ih using 1 ; ring

theorem complexity_two_pow_le (n : ℕ) (h : 0 < n) : complexity (2 ^ n) ≤ 2 * n := by
  have : Reachable (2 ^ n) (2 * n) := Reachable.pow 2 n (by decide) h
  exact Reachable.complexity_le this

theorem complexity_add_le (a b : ℕ) (ha : 0 < a) (hb : 0 < b) :
    complexity (a + b) ≤ complexity a + complexity b := by
  have ha' := Reachable.complexity ha
  have hb' := Reachable.complexity hb
  exact Reachable.complexity_le (Reachable.add ha' hb')

theorem complexity_mul_le (a b : ℕ) (ha : 0 < a) (hb : 0 < b) :
    complexity (a * b) ≤ complexity a + complexity b := by
  have ha' := Reachable.complexity ha
  have hb' := Reachable.complexity hb
  exact Reachable.complexity_le (Reachable.mul ha' hb')

lemma factors_of_two_pow (a b n : ℕ) (h : a * b = 2 ^ n) : ∃ i j, a = 2 ^ i ∧ b = 2 ^ j ∧ i + j = n := by
  -- Since $a$ and $b$ are factors of $2^n$, they must themselves be powers of $2$.
  have ha_pow : ∃ i, a = 2 ^ i := by
    -- Since $a$ divides $2^n$, and $2^n$ is a power of 2, $a$ must also be a power of 2.
    have h_div : a ∣ 2 ^ n := by
      exact h ▸ dvd_mul_right _ _;
    rw [ Nat.dvd_prime_pow ] at h_div <;> norm_num at * ; tauto
  have hb_pow : ∃ j, b = 2 ^ j := by
    -- Since $a * b = 2^n$ and $a = 2^i$, we can substitute $a$ into the equation to get $2^i * b = 2^n$.
    obtain ⟨i, hi⟩ := ha_pow
    have hb_eq : b = 2 ^ (n - i) := by
      cases le_total n i <;> simp_all +decide [ ← pow_add ];
      · nlinarith [ pow_pos ( by decide : 0 < 2 ) n, pow_le_pow_right₀ ( by decide : 1 ≤ 2 ) ‹_› ];
      · exact mul_left_cancel₀ ( pow_ne_zero i two_ne_zero ) ( by rw [ ← pow_add, Nat.add_sub_of_le ‹i ≤ n› ] ; linarith );
    use n - i;
  -- Substitute the expressions for a and b from ha_pow and hb_pow into the equation a * b = 2^n.
  obtain ⟨i, hi⟩ := ha_pow
  obtain ⟨j, hj⟩ := hb_pow
  have h_exp : 2 ^ (i + j) = 2 ^ n := by
    rw [ ← h, hi, hj, pow_add ];
  aesop

lemma factors_of_two_pow' (a b n : ℕ) (h : a * b = 2 ^ n) : ∃ i j, a = 2 ^ i ∧ b = 2 ^ j ∧ i + j = n := by
  have ha : a ∣ 2 ^ n := Dvd.intro b h
  have hb : b ∣ 2 ^ n := Dvd.intro_left a h
  obtain ⟨i, hi⟩ := (Nat.dvd_prime_pow (Nat.prime_two)).1 ha
  obtain ⟨j, hj⟩ := (Nat.dvd_prime_pow (Nat.prime_two)).1 hb
  refine ⟨i, j, hi.2, hj.2, ?_⟩
  rw [hi.2, hj.2, ← Nat.pow_add, Nat.pow_right_inj (by decide)] at h
  exact h

#check padicValNat

lemma valuation_eq_of_add_eq_two_pow (a b n : ℕ) (h : a + b = 2 ^ n) (ha : 0 < a) (hb : 0 < b) :
    padicValNat 2 a = padicValNat 2 b := by
      by_contra h_neq;
      -- Without loss of generality, assume that $v_2(a) < v_2(b)$.
      wlog h_wlog : padicValNat 2 a < padicValNat 2 b generalizing a b;
      · exact this b a ( by rw [ add_comm, h ] ) hb ha ( Ne.symm h_neq ) ( lt_of_le_of_ne ( le_of_not_gt h_wlog ) ( Ne.symm h_neq ) );
      · -- If $v_2(a) < v_2(b)$, then $a + b$ is divisible by $2^{v_2(a)}$ but not by $2^{v_2(a) + 1}$.
        have h_div : 2 ^ (padicValNat 2 a) ∣ a + b ∧ ¬(2 ^ (padicValNat 2 a + 1) ∣ a + b) := by
          have h_div : 2 ^ (padicValNat 2 a) ∣ a ∧ ¬(2 ^ (padicValNat 2 a + 1) ∣ a) ∧ 2 ^ (padicValNat 2 a) ∣ b ∧ 2 ^ (padicValNat 2 a + 1) ∣ b := by
            exact ⟨ Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd ha.ne' ( by decide ), Nat.dvd_trans ( pow_dvd_pow _ h_wlog.le ) ( Nat.ordProj_dvd _ _ ), Nat.dvd_trans ( pow_dvd_pow _ ( Nat.succ_le_of_lt h_wlog ) ) ( Nat.ordProj_dvd _ _ ) ⟩;
          exact ⟨ Nat.dvd_add h_div.1 h_div.2.2.1, by rw [ Nat.dvd_add_left h_div.2.2.2 ] ; aesop ⟩;
        simp_all +decide [ Nat.dvd_prime_pow ];
        -- Since $a$ is a positive integer, we have $padicValNat 2 a \leq \log_2(a)$.
        have h_padic_le_log : padicValNat 2 a ≤ Nat.log 2 a := by
          exact Nat.le_log_of_pow_le ( by decide ) ( Nat.le_of_dvd ha ( Nat.ordProj_dvd _ _ ) );
        linarith [ Nat.log_lt_of_lt_pow ( by linarith ) ( show a < 2 ^ n by linarith ) ]

theorem complexity_pos (n : ℕ) (h : 1 < n) : 0 < complexity n := by
  unfold complexity;
  -- Since $n > 1$, the complexity of $n$ cannot be $0$ because that would imply $Reachable n 0$, which contradicts the definition of `Reachable`.
  have h_complexity_pos : ∀ {n : ℕ}, 1 < n → ¬Reachable n 0 := by
    -- By definition of Reachable, if Reachable n 0 were true, then n would have to be 0, which contradicts n > 1.
    intros n hn
    apply not_reachable_zero_snd;
  grind

lemma complexity_mul_ge_two_mul_of_IH (n : ℕ) (IH : ∀ k < n, 0 < k → complexity (2^k) = 2*k)
    (a b : ℕ) (hmul : a * b = 2^n) (ha : 1 < a) (hb : 1 < b) :
    complexity a + complexity b ≥ 2 * n := by
      -- Since $a$ and $b$ are both greater than 1, we have $a = 2^i$ and $b = 2^j$ for some $i, j$ such that $i + j = n$.
      obtain ⟨i, hi⟩ : ∃ i, a = 2 ^ i := by
        have : a ∣ 2 ^ n := hmul ▸ dvd_mul_right _ _; rw [ Nat.dvd_prime_pow ( by decide ) ] at this; aesop;
      obtain ⟨j, hj⟩ : ∃ j, b = 2 ^ j := by
        have : b ∣ 2 ^ n := hmul ▸ dvd_mul_left _ _; rw [ Nat.dvd_prime_pow ( by decide ) ] at this; aesop;
      have h_ij : i + j = n := by
        simp_all +decide [ ← pow_add ];
      grind

/-
If a * b = 2^n and the complexity of smaller powers of 2 is known, then complexity(a) + complexity(b) >= 2n.
-/
lemma complexity_mul_case (n : ℕ) (IH : ∀ k < n, 0 < k → complexity (2^k) = 2*k)
    (a b : ℕ) (hmul : a * b = 2^n) (ha : 1 < a) (hb : 1 < b) :
    complexity a + complexity b ≥ 2 * n := by
      -- Since $a$ and $b$ are both positive and greater than 1, they must be powers of 2.
      obtain ⟨i, hi⟩ : ∃ i, a = 2^i := by
        have : a ∣ 2 ^ n := hmul ▸ dvd_mul_right _ _; ( rw [ Nat.dvd_prime_pow ( by decide ) ] at this; tauto; )
      obtain ⟨j, hj⟩ : ∃ j, b = 2^j := by
        have : b ∣ 2 ^ n := hmul ▸ dvd_mul_left _ _; rw [ Nat.dvd_prime_pow ( by decide ) ] at this; aesop;
      simp_all +decide [ ← pow_add ];
      rw [ IH i ( by linarith [ Nat.pos_of_ne_zero ha, Nat.pos_of_ne_zero hb ] ) ( Nat.pos_of_ne_zero ha ), IH j ( by linarith [ Nat.pos_of_ne_zero ha, Nat.pos_of_ne_zero hb ] ) ( Nat.pos_of_ne_zero hb ) ] ; linarith

/-
Property: If a + b = 2^n, then complexity(a) + complexity(b) >= 2n.
-/
def ComplexityAddLowerBound (n : ℕ) : Prop :=
  ∀ a b, a + b = 2 ^ n → 0 < a → 0 < b → complexity a + complexity b ≥ 2 * n

/-
If the addition lower bound holds for all k <= n, then complexity(2^n) = 2n.
-/
theorem complexity_two_pow_of_add_bound (n : ℕ) (h : 0 < n)
    (H : ∀ k, 0 < k → k ≤ n → ComplexityAddLowerBound k) : complexity (2 ^ n) = 2 * n := by
      -- Assume by induction on `n` that `complexity (2^k) = 2k` for all `k < n`.
      induction' n using Nat.strong_induction_on with n ih;
      -- By definition of complexity, we have `Reachable (2^n) (complexity (2^n))`.
      obtain ⟨hm, h_reachable⟩ : ∃ m, m = complexity (2 ^ n) ∧ Reachable (2 ^ n) m := by
        exact ⟨ _, rfl, Reachable.complexity ( by positivity ) ⟩;
      -- By `reachable_iff_of_two_le`, since `2^n ≥ 2` (for `n ≥ 1`), the last step was either addition or multiplication.
      obtain ⟨m₁, m₂, n₁, n₂, hm₁, hm₂, hn₁, hn₂, h_sum, h_mul⟩ : ∃ m₁ m₂ n₁ n₂, m₁ < 2 ^ n ∧ m₂ < 2 ^ n ∧ n₁ < hm ∧ n₂ < hm ∧ n₁ + n₂ = hm ∧ Reachable m₁ n₁ ∧ Reachable m₂ n₂ ∧ (m₁ + m₂ = 2 ^ n ∨ m₁ * m₂ = 2 ^ n) := by
        have := reachable_iff_of_two_le ( 2 ^ n ) hm ( Nat.le_self_pow ( by linarith ) _ );
        rcases this.mp h_reachable.2 with ⟨ m₁, hm₁, m₂, hm₂, n₁, hn₁, n₂, hn₂, h₁, h₂, h₃, h₄ ⟩ ; exact ⟨ m₁, m₂, n₁, n₂, hm₁, hm₂, hn₁, hn₂, h₁, h₂, h₃, h₄ ⟩ ;
      -- Case 1: Multiplication. $2^n = a * b$.
      by_cases h_mul_case : m₁ * m₂ = 2 ^ n;
      · -- By `factors_of_two_pow`, $m₁=2^i, m₂=2^j$ with $i+j=n$.
        obtain ⟨i, j, hi, hj, hij⟩ : ∃ i j, m₁ = 2 ^ i ∧ m₂ = 2 ^ j ∧ i + j = n := by
          exact?;
        -- By `IH`, `complexity m₁ = 2i`, `complexity m₂ = 2j`.
        have h_complexity_m₁ : complexity m₁ = 2 * i := by
          grind
        have h_complexity_m₂ : complexity m₂ = 2 * j := by
          grind;
        -- Thus `m = complexity m₁ + complexity m₂ = 2i + 2j = 2n`.
        have h_complexity_m : hm ≥ 2 * i + 2 * j := by
          linarith [ Reachable.complexity_le h_mul.1, Reachable.complexity_le h_mul.2.1 ];
        linarith [ complexity_two_pow_le n h ];
      · -- By `H n`, `complexity a + complexity b ≥ 2n`.
        have h_add_lower_bound : complexity m₁ + complexity m₂ ≥ 2 * n := by
          apply H n h (le_refl n) m₁ m₂ (h_mul.right.right.resolve_right h_mul_case) (by
          contrapose! h_mul_case; aesop) (by
          contrapose! h_mul_case; aesop);
        -- By `Reachable.complexity_le`, we have `complexity (2^n) ≤ 2n`.
        have h_complexity_le : complexity (2 ^ n) ≤ 2 * n := by
          exact?;
        linarith [ Reachable.complexity_le h_mul.1, Reachable.complexity_le h_mul.2.1 ]

/-
Definition of the lower bound property restricted to odd numbers.
-/
def ComplexityAddLowerBoundOdd (n : ℕ) : Prop :=
  ∀ a b, a + b = 2 ^ n → Odd a → Odd b → complexity a + complexity b ≥ 2 * n

/-
Definition of weight using prime factors and its multiplicativity.
-/
def weight (n : ℕ) : ℕ := (Nat.primeFactorsList n).map complexity |> List.sum

lemma weight_mul (a b : ℕ) (ha : 0 < a) (hb : 0 < b) : weight (a * b) = weight a + weight b := by
  unfold weight;
  have h_prime_factors_mul : (a * b).primeFactorsList.Perm (a.primeFactorsList ++ b.primeFactorsList) := by
    exact Nat.perm_primeFactorsList_mul ha.ne' hb.ne';
  grind

/-
If weight is subadditive, then complexity is at least weight.
-/
lemma complexity_ge_weight_of_assumptions (n : ℕ)
    (h_add : ∀ a b, 1 < a → 1 < b → weight (a + b) ≤ weight a + weight b)
    (h_succ : ∀ m, 1 < m → weight (m + 1) ≤ weight m + 1) :
    complexity n ≥ weight n := by
      -- By induction on $k = \text{complexity } n$, we can show that $\text{complexity } n \geq \text{weight } n$ for all $n$.
      have h_ind : ∀ k, ∀ n, Reachable n k → weight n ≤ k := by
        intro k n hk
        induction' k using Nat.strong_induction_on with k ih generalizing n
        induction' hk with a b ha hb;
        · simp +decide [ weight ];
        · by_cases ha1 : 1 < a <;> by_cases hb1 : 1 < b <;> simp_all +arith +decide;
          · exact le_trans ( h_add a b ha1 hb1 ) ( add_le_add ( ‹ ( ∀ m < ha, ∀ n : ℕ, Reachable n m → weight n ≤ m ) → weight a ≤ ha › fun m mn n hn => ih m ( by linarith ) n hn ) ( ‹ ( ∀ m < hb, ∀ n : ℕ, Reachable n m → weight n ≤ m ) → weight b ≤ hb › fun m mn n hn => ih m ( by linarith ) n hn ) );
          · interval_cases b <;> simp_all +arith +decide;
            · exact absurd ‹Reachable 0 hb› ( not_reachable_zero_fst _ );
            · -- Using the induction hypothesis and the fact that weight 1 is 1, we can conclude that weight (a + 1) ≤ ha + 1.
              have h_weight_a1 : weight (a + 1) ≤ weight a + 1 := by
                exact h_succ a ha1;
              linarith [ ‹ ( ∀ m < ha, ∀ n, Reachable n m → weight n ≤ m ) → weight a ≤ ha › fun m mn n hn => ih m ( by linarith ) n hn, show hb ≥ 1 from Nat.pos_of_ne_zero ( by rintro rfl; exact not_reachable_zero_snd _ ‹_› ) ];
          · interval_cases a <;> simp_all +arith +decide;
            · exact absurd ‹Reachable 0 ha› ( not_reachable_zero_fst _ );
            · have h_ha_ge_one : 1 ≤ ha := by
                exact Nat.pos_of_ne_zero ( by rintro rfl; exact not_reachable_zero_snd 1 ‹_› );
              grind;
          · interval_cases a <;> interval_cases b <;> simp_all +decide [ weight ];
            -- Since $ha$ and $hb$ are both at least 1, their sum is at least 2. Therefore, $complexity 2 \leq ha + hb$.
            have h_complexity_two : complexity 2 ≤ 2 := by
              exact Reachable.complexity_le ( Reachable.add ( Reachable.one ) ( Reachable.one ) );
            linarith [ show ha ≥ 1 from Nat.pos_of_ne_zero fun h => by subst h; exact not_reachable_zero_snd 1 ‹_›, show hb ≥ 1 from Nat.pos_of_ne_zero fun h => by subst h; exact not_reachable_zero_snd 1 ‹_› ];
        · -- By the properties of weight, we have weight (m * n) = weight m + weight n.
          have h_weight_mul : ∀ m n, 0 < m → 0 < n → weight (m * n) = weight m + weight n := by
            exact?;
          rename_i k l hk hl ihk ihl;
          rw [ h_weight_mul ];
          · exact add_le_add ( ihk fun m mn n hn => ih m ( by linarith ) n hn ) ( ihl fun m mn n hn => ih m ( by linarith ) n hn );
          · exact Nat.pos_of_ne_zero ( by rintro rfl; exact not_reachable_zero_fst _ hk );
          · exact Nat.pos_of_ne_zero ( by rintro rfl; exact not_reachable_zero_fst _ hl );
      by_cases hn : n = 0 <;> simp_all +decide [ complexity ];
      · -- The weight of 0 is defined as the sum of the complexities of its prime factors, which is the empty list.
        simp [weight];
      · exact fun m mn hm => mn.not_le <| h_ind m n hm

/-
The weight of 2^n is 2n.
-/
lemma weight_two_pow (n : ℕ) : weight (2 ^ n) = 2 * n := by
  -- We proceed by induction on $n$.
  induction' n with k ih;
  · -- The prime factors list of 1 is empty, so the weight is 0.
    simp [weight];
  · -- By definition of weight, we have weight (2 * 2^k) = weight 2 + weight (2^k).
    have h_weight_mul : weight (2 * 2 ^ k) = weight 2 + weight (2 ^ k) := by
      apply weight_mul; norm_num; norm_num;
    -- By definition of weight, we have weight 2 = complexity 2.
    have h_weight_two : weight 2 = complexity 2 := by
      unfold weight; norm_num;
    -- By definition of complexity, we have complexity 2 = 2.
    have h_complexity_two : complexity 2 = 2 := by
      rw [ Reachable.complexity_eq ];
      · exact Reachable.self 2 ( by decide );
      · rintro ( _ | _ | n ) hn <;> simp_all +arith +decide;
        · exact?;
        · intro h;
          obtain ⟨ m₁, hm₁, m₂, hm₂, n₁, hn₁, n₂, hn₂, h₁, h₂, h₃ ⟩ := reachable_iff_of_two_le 2 1 ( by decide ) |>.1 h;
          grind;
    grind

/-
Conditional proof of the main theorem assuming weight conjectures.
-/
theorem complexity_two_pow_eq_two_mul_of_weight_conjectures (n : ℕ) (hn : 0 < n)
    (h_add : ∀ a b, 1 < a → 1 < b → weight (a + b) ≤ weight a + weight b)
    (h_succ : ∀ m, 1 < m → weight (m + 1) ≤ weight m + 1) :
    complexity (2 ^ n) = 2 * n := by
      refine' le_antisymm ( complexity_two_pow_le n hn ) ( complexity_ge_weight_of_assumptions _ h_add h_succ |> fun h => h.trans' ( by rw [ weight_two_pow ] ) )