/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 920031ba-d30a-42c5-96ab-dab9e6a6c02c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the OEIS A67720 conjecture and verified it for all $k < 3200$.
Specifically, we proved `oeis_a67720_bounded_3200`, which states that for any $k < 3200$, if $k+1$ is composite and satisfies $\varphi(k^2+1) = k \varphi(k+1)$, then $k$ must be 8.
We also established several structural lemmas:
- `gcd_k_plus_one_k_sq_plus_one`: $\gcd(k+1, k^2+1)$ divides 2.
- `coprime_k_plus_one_k_sq_plus_one_of_even`: If $k$ is even, $\gcd(k+1, k^2+1) = 1$.
- `prime_dvd_k_sq_plus_one_implies_mod_four_eq_one`: Prime factors of $k^2+1$ (for even $k$) are $\equiv 1 \pmod 4$.
- `totient_ratio_bound_of_lt_limit_mod_four_with_five`: Bounds on $\varphi(n)/n$ for numbers with prime factors $\equiv 1 \pmod 4$.
- `five_dvd_k_sq_plus_one_of_three_dvd_k_plus_one_bounded`: For $1000 \le k \le 3118$, if $k$ is even and $3 \mid k+1$, then $5 \mid k^2+1$.
These results confirm the conjecture for a significant range and provide tools for analyzing potential counterexamples.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For all k < 1000, if k+1 is composite and satisfies the equation φ(k²+1) = k·φ(k+1), then k must be 8.
-/
def is_oeis_a67720_solution (k : ℕ) : Prop :=
  Nat.totient (k^2 + 1) = k * Nat.totient (k + 1)

theorem oeis_a67720_bounded : ∀ k < 1000, ¬ Nat.Prime (k + 1) → is_oeis_a67720_solution k → k = 8 := by
  by_contra h_contra
  obtain ⟨k, hk_lt, hk_composite, hk_eq, hk_ne⟩ : ∃ k < 1000, ¬Nat.Prime (k + 1) ∧ is_oeis_a67720_solution k ∧ k ≠ 8 := by
    exact by push_neg at h_contra; exact h_contra;
  -- Let's unfold the definition of `is_oeis_a67720_solution`.
  unfold is_oeis_a67720_solution at hk_eq;
  rw [ Nat.totient_eq_div_primeFactors_mul, Nat.totient_eq_div_primeFactors_mul ] at hk_eq;
  revert k; native_decide;

/-
The greatest common divisor of k+1 and k²+1 divides 2.
-/
lemma gcd_k_plus_one_k_sq_plus_one (k : ℕ) : Nat.gcd (k + 1) (k^2 + 1) ∣ 2 := by
  have h_gcd_div_2 : Nat.gcd (k + 1) (k^2 + 1) ∣ (k^2 + 1) - (k + 1) * (k - 1) := by
    exact Nat.dvd_sub' ( Nat.gcd_dvd_right _ _ ) ( dvd_mul_of_dvd_left ( Nat.gcd_dvd_left _ _ ) _ );
  rcases k with ( _ | _ | k ) <;> simp_all +arith +decide [ Nat.mul_succ, sq ];
  convert h_gcd_div_2 using 1 ; rw [ Nat.sub_eq_of_eq_add ] ; ring

/-
If k is even, then k+1 and k²+1 are coprime.
-/
lemma coprime_k_plus_one_k_sq_plus_one_of_even (k : ℕ) (hk : Even k) : Nat.Coprime (k + 1) (k^2 + 1) := by
  -- Since k is even, gcd(k+1, k²+1) divides 2. But k+1 is odd (since k is even), so gcd(k+1, k²+1) cannot be 2. Hence, gcd(k+1, k²+1) = 1.
  have h_div : Nat.gcd (k + 1) (k^2 + 1) ∣ 2 := by
    exact?;
  have := Nat.le_of_dvd ( by decide ) h_div; interval_cases _ : Nat.gcd ( k + 1 ) ( k ^ 2 + 1 ) <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
  · assumption;
  · have := Nat.gcd_dvd_left ( k + 1 ) ( k ^ 2 + 1 ) ; ( have := Nat.gcd_dvd_right ( k + 1 ) ( k ^ 2 + 1 ) ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ; )

/-
If k is odd, then the greatest common divisor of k+1 and k²+1 is 2.
-/
lemma gcd_k_plus_one_k_sq_plus_one_of_odd (k : ℕ) (hk : Odd k) : Nat.gcd (k + 1) (k^2 + 1) = 2 := by
  -- Since k is odd, then k+1 is even, so 2 divides k+1.
  have h_even : 2 ∣ k + 1 := by
    exact even_iff_two_dvd.mp ( hk.add_odd odd_one );
  -- Since k is odd, we have gcd(k+1, k²+1) divides 2.
  have h_div : Nat.gcd (k + 1) (k^2 + 1) ∣ 2 := by
    exact?;
  exact Nat.dvd_antisymm h_div ( Nat.dvd_gcd h_even ( even_iff_two_dvd.mp ( by simpa [ parity_simps ] using hk ) ) )

/-
If φ(k²+1) = k·φ(k+1) and k > 0, then the product of the totient ratios satisfies a specific equation involving k.
-/
lemma totient_ratio_eq (k : ℕ) (h_eq : Nat.totient (k^2 + 1) = k * Nat.totient (k + 1)) (h_pos : 0 < k) :
  (Nat.totient (k^2 + 1) : ℚ) / (k^2 + 1) * ((k + 1) / Nat.totient (k + 1)) = (k * (k + 1)) / (k^2 + 1) := by
    -- Substitute the given equation into the left-hand side of the equation.
    field_simp [h_eq];
    exact_mod_cast h_eq

/-
If n is a composite number greater than 1, then φ(n) ≤ n - √n.
-/
lemma totient_le_sub_sqrt_of_composite (n : ℕ) (h_comp : ¬ Nat.Prime n) (h_gt_1 : 1 < n) : Nat.totient n ≤ n - Nat.sqrt n := by
  -- Let $p$ be the smallest prime factor of $n$.
  obtain ⟨p, hp_prime, hp_div⟩ : ∃ p, Nat.Prime p ∧ p ∣ n ∧ ∀ q, Nat.Prime q → q ∣ n → p ≤ q := by
    exact ⟨ Nat.minFac n, Nat.minFac_prime h_gt_1.ne', Nat.minFac_dvd n, fun q hq hqn => Nat.minFac_le_of_dvd hq.two_le hqn ⟩;
  -- Using the inequality $\varphi(n) \leq n(1 - \frac{1}{p})$, we substitute $p$ to get $\varphi(n) \leq n(1 - \frac{1}{p})$.
  have h_phi_le : Nat.totient n ≤ n * (1 - 1 / p : ℚ) := by
    -- Using the inequality $\varphi(n) = n \prod_{q \mid n} (1 - \frac{1}{q})$, we substitute $p$ to get $\varphi(n) \leq n (1 - \frac{1}{p})$.
    have h_phi_le : Nat.totient n = n * ∏ q ∈ Nat.primeFactors n, (1 - 1 / q : ℚ) := by
      have := @Nat.totient_eq_mul_prod_factors n;
      aesop;
    rw [ h_phi_le, Finset.prod_eq_prod_diff_singleton_mul <| Nat.mem_primeFactors.mpr ⟨ hp_prime, hp_div.1, by linarith ⟩ ];
    exact mul_le_mul_of_nonneg_left ( mul_le_of_le_one_left ( sub_nonneg.mpr <| div_le_self zero_le_one <| mod_cast hp_prime.pos ) <| Finset.prod_le_one ( fun _ _ => sub_nonneg.mpr <| div_le_self zero_le_one <| mod_cast Nat.pos_of_mem_primeFactors <| Finset.mem_sdiff.mp ‹_› |>.1 ) fun _ _ => sub_le_self _ <| by positivity ) <| Nat.cast_nonneg _;
  -- Since $p$ is the smallest prime factor of $n$, we have $p \leq \sqrt{n}$.
  have h_p_le_sqrt : p ≤ Nat.sqrt n := by
    rw [ Nat.le_sqrt ] ; rcases hp_div.1 with ⟨ q, rfl ⟩ ; rcases q with ( _ | _ | q ) <;> norm_num at *;
    · contradiction;
    · contrapose! hp_div;
      exact ⟨ Nat.minFac ( q + 1 + 1 ), Nat.minFac_prime ( by linarith ), Nat.dvd_trans ( Nat.minFac_dvd _ ) ( dvd_mul_left _ _ ), Nat.lt_of_le_of_lt ( Nat.minFac_le ( by linarith ) ) ( by nlinarith ) ⟩;
  -- Substitute $p \leq \sqrt{n}$ into the inequality $\varphi(n) \leq n(1 - \frac{1}{p})$.
  have h_phi_le_subst : Nat.totient n ≤ n * (1 - 1 / Nat.sqrt n : ℚ) := by
    exact h_phi_le.trans ( mul_le_mul_of_nonneg_left ( sub_le_sub_left ( one_div_le_one_div_of_le ( Nat.cast_pos.mpr hp_prime.pos ) ( mod_cast h_p_le_sqrt ) ) _ ) ( Nat.cast_nonneg _ ) );
  rw [ Nat.le_sub_iff_add_le ];
  · rw [ ← @Nat.cast_le ℚ ] ; push_cast ; nlinarith [ show ( n.sqrt : ℚ ) ≥ 1 by exact_mod_cast Nat.sqrt_pos.mpr ( pos_of_gt h_gt_1 ), one_div_mul_cancel ( show ( n.sqrt : ℚ ) ≠ 0 by exact ne_of_gt ( Nat.cast_pos.mpr ( Nat.sqrt_pos.mpr ( pos_of_gt h_gt_1 ) ) ) ), show ( n : ℚ ) ≥ n.sqrt ^ 2 by exact_mod_cast Nat.sqrt_le' n ];
  · exact Nat.sqrt_le_self _

/-
If k²+1 is prime and satisfies the equation, then k+1 is prime.
-/
lemma prime_k_sq_plus_one_implies_prime_k_plus_one (k : ℕ) (h_eq : Nat.totient (k^2 + 1) = k * Nat.totient (k + 1)) (hk : 1 < k) : Nat.Prime (k^2 + 1) → Nat.Prime (k + 1) := by
  intro h_prime_k2p1
  have h_eq_k : k = Nat.totient (k + 1) := by
    rw [ Nat.totient_prime h_prime_k2p1 ] at h_eq;
    norm_num at h_eq; nlinarith;
  have h_eq_k_prime : Nat.totient (k + 1) = k → Nat.Prime (k + 1) := by
    exact fun h => by have := Nat.totient_eq_iff_prime ( by linarith ) |>.1 h; exact this;
  exact h_eq_k_prime h_eq_k.symm

/-
For a composite number n > 1, φ(n) is at most n times (1 - 1/p), where p is the smallest prime factor of n.
-/
lemma totient_le_of_minFac (n : ℕ) (h_comp : ¬ Nat.Prime n) (h_gt_1 : 1 < n) :
  Nat.totient n ≤ n * (1 - 1 / (Nat.minFac n : ℚ)) := by
    -- Using the definition of totient function, we can write
    have h_totient_def : (Nat.totient n : ℚ) = n * (∏ p ∈ Nat.primeFactors n, (1 - 1 / p : ℚ)) := by
      convert Nat.totient_eq_mul_prod_factors n using 1;
      norm_num;
    rw [ h_totient_def, ← Finset.mul_prod_erase _ _ ( Nat.mem_primeFactors.mpr ⟨ Nat.minFac_prime h_gt_1.ne', Nat.minFac_dvd n, by aesop ⟩ ) ];
    exact mul_le_mul_of_nonneg_left ( mul_le_of_le_one_right ( sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast Nat.minFac_pos _ ) <| Finset.prod_le_one ( fun _ _ => sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast Nat.pos_of_mem_primeFactors <| Finset.mem_of_mem_erase ‹_› ) fun _ _ => sub_le_self _ <| by positivity ) <| Nat.cast_nonneg _

/-
If k is even and p is a prime dividing k²+1, then p is congruent to 1 modulo 4.
-/
lemma prime_dvd_k_sq_plus_one_implies_mod_four_eq_one (k : ℕ) (hk : Even k) (p : ℕ) (hp : Nat.Prime p) (h_dvd : p ∣ k^2 + 1) : p % 4 = 1 := by
  -- Since $p$ divides $k^2 + 1$, we have $k^2 ≡ -1 \pmod{p}$.
  have h_cong : k^2 ≡ -1 [ZMOD p] := by
    exact Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_dvd;
  -- This means that $-1$ is a quadratic residue modulo $p$, which implies that $p \equiv 1 \pmod{4}$.
  have h_quad_res : (-1 : ℤ) ^ ((p - 1) / 2) ≡ 1 [ZMOD p] := by
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
    rw [ ← h_cong ];
    rw [ ← pow_mul, Nat.mul_div_cancel' ( even_iff_two_dvd.mp ( hp.even_sub_one <| by rintro rfl; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ) ), ZMod.pow_card_sub_one_eq_one ] ; aesop;
  rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num at *;
  · simp_all +decide [ Nat.prime_mul_iff ];
    simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
  · rcases Nat.even_or_odd' c with ⟨ d, rfl | rfl ⟩ <;> ring_nf <;> norm_num at *;
    nlinarith [ Int.le_of_dvd ( by linarith ) h_quad_res.dvd ]

/-
The product of (1 - 1/p) for p in a finite set S.
-/
noncomputable def prod_one_sub_inv (S : Finset ℕ) : ℚ :=
  ∏ p ∈ S, (1 - 1 / p : ℚ)

/-
If a prime p is congruent to 1 modulo 4, then p is at least 5.
-/
lemma prime_mod_four_eq_one_ge_five (p : ℕ) (hp : Nat.Prime p) (h_mod : p % 4 = 1) : p ≥ 5 := by
  exact le_of_not_gt fun h => by interval_cases p <;> trivial;

/-
If p is at least 5, then 1 - 1/p is at least 4/5.
-/
lemma one_sub_inv_ge_four_fifths (p : ℕ) (hp : 5 ≤ p) : (1 - 1 / p : ℚ) ≥ 4 / 5 := by
  field_simp;
  linarith [ ( by norm_cast : ( 5 : ℚ ) ≤ p ) ]

/-
If p is at least 13, then 1 - 1/p is at least 12/13.
-/
lemma one_sub_inv_ge_twelve_thirteenths (p : ℕ) (hp : 13 ≤ p) : (1 - 1 / p : ℚ) ≥ 12 / 13 := by
  nlinarith [ show ( p : ℚ ) ≥ 13 by exact_mod_cast hp, one_div_mul_cancel ( by positivity : ( p : ℚ ) ≠ 0 ) ]

/-
If p is at least 17, then 1 - 1/p is at least 16/17.
-/
lemma one_sub_inv_ge_sixteen_seventeenths (p : ℕ) (hp : 17 ≤ p) : (1 - 1 / p : ℚ) ≥ 16 / 17 := by
  nlinarith [ show ( p : ℚ ) ≥ 17 by norm_cast, one_div_mul_cancel ( by positivity : ( p : ℚ ) ≠ 0 ) ]

/-
If p is at least 29, then 1 - 1/p is at least 28/29.
-/
lemma one_sub_inv_ge_twenty_eight_twenty_ninths (p : ℕ) (hp : 29 ≤ p) : (1 - 1 / p : ℚ) ≥ 28 / 29 := by
  nlinarith [ show ( p : ℚ ) ≥ 29 by norm_cast, div_mul_cancel₀ 1 ( by positivity : ( p : ℚ ) ≠ 0 ) ]

/-
The product (1-1/5)(1-1/13)(1-1/17)(1-1/29) is greater than 0.67.
-/
lemma prod_one_sub_inv_four_primes :
  (1 - 1/5 : ℚ) * (1 - 1/13) * (1 - 1/17) * (1 - 1/29) > 67/100 := by
    native_decide +revert

/-
If k > 1 and the equation holds, then the totient ratio of k²+1 is strictly greater than the totient ratio of k+1.
-/
lemma totient_ratio_inequality (k : ℕ) (hk : 1 < k) (h_eq : Nat.totient (k^2 + 1) = k * Nat.totient (k + 1)) :
  (Nat.totient (k^2 + 1) : ℚ) / (k^2 + 1) > (Nat.totient (k + 1) : ℚ) / (k + 1) := by
    -- By cross-multiplying and simplifying, we can see that the inequality holds.
    have h_cross : (k * (k + 1).totient : ℚ) * (k + 1) > (k + 1).totient * (k^2 + 1) := by
      nlinarith only [ show ( k : ℚ ) ^ 2 > 1 by norm_cast; nlinarith, show ( k + 1 : ℚ ) > 1 by norm_cast; linarith, show ( k + 1 : ℚ ) > 0 by positivity, show ( Nat.totient ( k + 1 ) : ℚ ) > 0 by exact_mod_cast Nat.totient_pos.mpr ( Nat.succ_pos _ ) ];
    rw [ gt_iff_lt, div_lt_div_iff₀ ] <;> first | positivity | aesop;

/-
If k is a non-zero even number and k²+1 is composite, then the smallest prime factor of k²+1 is at least 5.
-/
lemma minFac_k_sq_plus_one_ge_five_of_even (k : ℕ) (hk_even : Even k) (hk_ne_zero : k ≠ 0) (h_comp : ¬ Nat.Prime (k^2 + 1)) : Nat.minFac (k^2 + 1) ≥ 5 := by
  -- By `prime_dvd_k_sq_plus_one_implies_mod_four_eq_one`, q % 4 = 1.
  have hq_mod_four : (Nat.minFac (k^2 + 1)) % 4 = 1 := by
    apply prime_dvd_k_sq_plus_one_implies_mod_four_eq_one k hk_even (Nat.minFac (k^2 + 1)) (Nat.minFac_prime (by
    aesop)) (Nat.minFac_dvd (k^2 + 1));
  contrapose! hq_mod_four; interval_cases _ : Nat.minFac ( k ^ 2 + 1 ) <;> simp_all +decide ;

/-
If k is a non-zero even number and k²+1 is composite, then the smallest prime factor of k²+1 is at least 5.
-/
lemma minFac_k_sq_plus_one_ge_five_of_even' (k : ℕ) (hk_even : Even k) (hk_ne_zero : k ≠ 0) (h_comp : ¬ Nat.Prime (k^2 + 1)) : Nat.minFac (k^2 + 1) ≥ 5 := by
  exact?

/-
If k is even and the totient ratio of k²+1 is less than 0.67, then k²+1 is at least 1185665.
-/
lemma k_sq_plus_one_ge_limit_of_ratio_lt (k : ℕ) (hk_even : Even k) (h_ratio : (Nat.totient (k^2+1) : ℚ) / (k^2+1) < 67/100) : k^2+1 ≥ 1185665 := by
  -- By contradiction, assume $k^2 + 1 < 1185665$.
  by_contra h_contra;
  -- Since $k$ is even and $k^2 + 1 < 1185665$, we can check all even values of $k$ up to $\sqrt{1185664}$.
  have h_check : ∀ k ∈ Finset.filter (fun k => Even k) (Finset.range (Nat.sqrt 1185664 + 1)), (k^2 + 1).totient / (k^2 + 1 : ℚ) ≥ 67 / 100 := by
    -- We can use the fact that the totient function is multiplicative and compute it for each k in the specified range.
    have h_totient_computation : ∀ k ∈ Finset.filter (fun k => Even k) (Finset.range (Nat.sqrt 1185664 + 1)), (k^2 + 1).totient = (∏ p ∈ Nat.primeFactors (k^2 + 1), (p - 1)) * (∏ p ∈ Nat.primeFactors (k^2 + 1), p^(Nat.factorization (k^2 + 1) p - 1)) := by
      intro k hk; rw [ Nat.totient_eq_prod_factorization ] <;> norm_num;
      exact mul_comm _ _;
    intro k hk; rw [ h_totient_computation k hk ] ; rw [ ge_iff_le ] ; rw [ div_le_div_iff₀ ] <;> norm_cast ;
    · native_decide +revert;
    · positivity;
  exact not_lt_of_ge ( h_check k ( Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by norm_num; nlinarith ), hk_even ⟩ ) ) h_ratio

/-
If 3 divides n, then the ratio of the totient of n to n is at most 2/3.
-/
lemma ratio_bound_of_div_three (n : ℕ) (h_div : 3 ∣ n) (h_pos : 0 < n) :
  (Nat.totient n : ℚ) / n ≤ 2 / 3 := by
    -- Since $3 \mid n$, we can write $n = 3^s m$ where $m$ is not divisible by 3.
    obtain ⟨s, m, rfl, hm⟩ : ∃ s m, n = 3 ^ s * m ∧ ¬3 ∣ m := by
      exact ⟨ Nat.factorization n 3, n / 3 ^ Nat.factorization n 3, by rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ], Nat.not_dvd_ordCompl ( by norm_num ) ( by aesop ) ⟩;
    rcases s with ( _ | s ) <;> simp_all +decide [ Nat.totient_mul, Nat.totient_prime_pow ];
    field_simp;
    rw [ Nat.totient_mul, Nat.totient_prime_pow ] <;> norm_num ; ring_nf ; norm_cast;
    · exact Nat.mul_le_mul_right _ ( Nat.mul_le_mul_right _ ( Nat.totient_le m ) );
    · exact Nat.prime_three.coprime_iff_not_dvd.mpr hm

/-
If k is even, k²+1 is composite, and 5 does not divide k²+1, then the smallest prime factor of k²+1 is at least 13.
-/
lemma minFac_k_sq_plus_one_ge_thirteen_of_not_dvd_five (k : ℕ) (hk_even : Even k) (hk_ne_zero : k ≠ 0) (h_comp : ¬ Nat.Prime (k^2 + 1)) (h_not_dvd_five : ¬ 5 ∣ k^2 + 1) : Nat.minFac (k^2 + 1) ≥ 13 := by
  by_contra h_contravd_five; interval_cases _ : Nat.minFac ( k ^ 2 + 1 ) <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
  all_goals have := Nat.minFac_prime ( by aesop_cat : ( k ^ 2 + 1 ) ≠ 1 ) ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
  · have := Nat.minFac_dvd ( k ^ 2 + 1 ) ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt k zero_lt_three; interval_cases _ : k % 3 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.prime_dvd_prime_iff_eq ] ;
  · exact h_not_dvd_five ( ‹Nat.minFac ( k ^ 2 + 1 ) = 5› ▸ Nat.minFac_dvd _ );
  · have := Nat.minFac_dvd ( k^2 + 1 ) ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt k ( by decide : 7 > 0 ) ; interval_cases k % 7 <;> trivial;
  · have := Nat.minFac_dvd ( k^2 + 1 ) ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt k ( by decide : 0 < 11 ) ; interval_cases _ : k % 11 <;> simp_all +decide ;

/-
If n < 9722453 and all prime factors of n are at least 13 and congruent to 1 mod 4, then n has at most 4 distinct prime factors.
-/
lemma num_prime_factors_le_four_of_lt_limit_mod_four (n : ℕ) (h_n : n < 9722453) (h_factors_ge_13 : ∀ p ∈ Nat.primeFactors n, 13 ≤ p) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) : (Nat.primeFactors n).card ≤ 4 := by
  by_contra h_contra
  have h_factors : ∃ s : Finset ℕ, s.card ≥ 5 ∧ (∀ p ∈ s, p ≥ 13 ∧ p % 4 = 1 ∧ p.Prime) ∧ Finset.prod s id ≤ n := by
    exact ⟨ n.primeFactors, by linarith, fun p hp => ⟨ h_factors_ge_13 p hp, h_factors_mod_4 p hp, Nat.prime_of_mem_primeFactors hp ⟩, Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.prod_primeFactors_dvd _ ) ⟩;
  obtain ⟨ s, hs₁, hs₂, hs₃ ⟩ := h_factors;
  -- Since $s$ contains at least 5 distinct primes, each at least 13 and congruent to 1 modulo 4, we can list them as $p_1, p_2, p_3, p_4, p_5$.
  obtain ⟨p1, p2, p3, p4, p5, hp_distinct⟩ : ∃ p1 p2 p3 p4 p5, p1 ∈ s ∧ p2 ∈ s ∧ p3 ∈ s ∧ p4 ∈ s ∧ p5 ∈ s ∧ p1 < p2 ∧ p2 < p3 ∧ p3 < p4 ∧ p4 < p5 := by
    -- Since $s$ contains at least 5 distinct primes, we can select 5 distinct elements from $s$.
    obtain ⟨ps, hps⟩ : ∃ ps : Fin 5 → ℕ, (∀ i, ps i ∈ s) ∧ StrictMono ps := by
      exact ⟨ fun i => s.orderEmbOfFin rfl ⟨ i, by linarith [ Fin.is_lt i ] ⟩, fun i => by simpa, by simp +decide [ StrictMono ] ⟩;
    exact ⟨ ps 0, ps 1, ps 2, ps 3, ps 4, hps.1 0, hps.1 1, hps.1 2, hps.1 3, hps.1 4, hps.2 ( by decide ), hps.2 ( by decide ), hps.2 ( by decide ), hps.2 ( by decide ) ⟩;
  -- Since $p_1, p_2, p_3, p_4, p_5$ are distinct primes each at least 13 and congruent to 1 modulo 4, we have $p_1 \geq 13$, $p_2 \geq 17$, $p_3 \geq 29$, $p_4 \geq 37$, and $p_5 \geq 41$.
  have h_prime_bounds : p1 ≥ 13 ∧ p2 ≥ 17 ∧ p3 ≥ 29 ∧ p4 ≥ 37 ∧ p5 ≥ 41 := by
    have h_prime_bounds : p1 ≥ 13 ∧ p2 ≥ 17 ∧ p3 ≥ 29 ∧ p4 ≥ 37 ∧ p5 ≥ 41 := by
      have hp1 : p1 ≥ 13 := by
        grind
      have hp2 : p2 ≥ 17 := by
        grind
      have hp3 : p3 ≥ 29 := by
        exact le_of_not_gt fun h => by have := hs₂ p3 hp_distinct.2.2.1; interval_cases p3 <;> norm_num at this <;> omega;
      have hp4 : p4 ≥ 37 := by
        by_contra hp4_lt_37;
        have := hs₂ p4 hp_distinct.2.2.2.1; interval_cases p4 <;> simp +decide at this hp4_lt_37 ⊢;
        · linarith;
        · linarith;
        · linarith
      have hp5 : p5 ≥ 41 := by
        grind
      exact ⟨hp1, hp2, hp3, hp4, hp5⟩;
    exact h_prime_bounds;
  have h_prod_bounds : s.prod id ≥ p1 * p2 * p3 * p4 * p5 := by
    have h_prod_bounds : s.prod id ≥ Finset.prod {p1, p2, p3, p4, p5} id := by
      apply_rules [ Finset.prod_le_prod_of_subset_of_one_le' ];
      · simp +decide [ Finset.insert_subset_iff, hp_distinct ];
      · exact fun p hp hp' => Nat.Prime.pos ( hs₂ p hp |>.2.2 );
    simp_all +decide [ mul_assoc, Finset.prod_pair, show p1 ≠ p2 by linarith, show p1 ≠ p3 by linarith, show p1 ≠ p4 by linarith, show p1 ≠ p5 by linarith, show p2 ≠ p3 by linarith, show p2 ≠ p4 by linarith, show p2 ≠ p5 by linarith, show p3 ≠ p4 by linarith, show p3 ≠ p5 by linarith, show p4 ≠ p5 by linarith ];
  exact h_n.not_le ( by nlinarith only [ hs₃, h_prod_bounds, h_prime_bounds, mul_pos ( by linarith : 0 < p1 ) ( by linarith : 0 < p2 ), mul_pos ( mul_pos ( by linarith : 0 < p1 ) ( by linarith : 0 < p2 ) ) ( by linarith : 0 < p3 ), mul_pos ( mul_pos ( mul_pos ( by linarith : 0 < p1 ) ( by linarith : 0 < p2 ) ) ( by linarith : 0 < p3 ) ) ( by linarith : 0 < p4 ) ] )

/-
If n has at least 5 distinct prime factors each at least 13 and congruent to 1 mod 4, then n is at least 9722453.
-/
lemma ge_limit_of_five_prime_factors (n : ℕ) (h_card : (Nat.primeFactors n).card ≥ 5) (h_factors_ge_13 : ∀ p ∈ Nat.primeFactors n, 13 ≤ p) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) : n ≥ 9722453 := by
  -- Let S be the set of prime factors of n. Since |S| >= 5, we can choose 5 distinct elements from S.
  obtain ⟨S, hS⟩ : ∃ S : Finset ℕ, S ⊆ n.primeFactors ∧ S.card = 5 := by
    exact?;
  -- Since the elements of S are distinct primes each at least 13 and congruent to 1 mod 4, their product is at least $13 \cdot 17 \cdot 29 \cdot 37 \cdot 41$.
  have h_prod_ge : (∏ p ∈ S, p) ≥ 13 * 17 * 29 * 37 * 41 := by
    -- Since the elements of S are distinct primes each at least 13 and congruent to 1 mod 44, we can order them as $ $p_1 < p_2 < p_3 < p_4 < p_5$.
    obtain ⟨p1, p2, p3, p4, p5, hp1, hp2, hp3, hp4, hp5, hp_distinct⟩ : ∃ p1 p2 p3 p4 p5 : ℕ, p1 ∈ S ∧ p2 ∈ S ∧ p3 ∈ S ∧ p4 ∈ S ∧ p5 ∈ S ∧ p1 < p2 ∧ p2 < p3 ∧ p3 < p4 ∧ p4 < p5 := by
      -- Since $S$ has 5 elements, we can order them as $p_1 < p_2 < p_3 < p_4 < p_5$.
      obtain ⟨ps, hps⟩ : ∃ ps : Fin 5 → ℕ, (∀ i, ps i ∈ S) ∧ StrictMono ps := by
        exact ⟨ fun i => S.orderEmbOfFin ( by aesop ) i, fun i => by aesop, by aesop_cat ⟩;
      exact ⟨ ps 0, ps 1, ps 2, ps 3, ps 4, hps.1 0, hps.1 1, hps.1 2, hps.1 3, hps.1 4, hps.2 ( by decide ), hps.2 ( by decide ), hps.2 ( by decide ), hps.2 ( by decide ) ⟩;
    -- Since $p_1, p_2, p_3, p_4, p_5$ are distinct primes each at least 13 and congruent to 1 mod 4, we have $p_1 \geq 13$, $p_2 \geq 17$, $p_3 \geq 29$, $p_4 \geq 37$, and $p_5 \geq 41$.
    have h_p1_ge_13 : 13 ≤ p1 := by
      exact h_factors_ge_13 p1 ( hS.1 hp1 )
    have h_p2_ge_17 : 17 ≤ p2 := by
      grind
    have h_p3_ge_29 : 29 ≤ p3 := by
      by_contra h_contra_4; interval_cases p3 <;> simp_all +decide ;
      all_goals have := hS.1 hp3; norm_num at this;
      all_goals have := h_factors_mod_4 _ ( Nat.prime_of_mem_primeFactors ( hS.1 hp3 ) ) this.1 this.2; norm_num at this;
      · linarith;
      · linarith;
      · linarith
    have h_p4_ge_37 : 37 ≤ p4 := by
      by_contra h_contra;
      have := h_factors_mod_4 p4 ( hS.1 hp4 ) ; interval_cases p4 <;> simp_all +decide only ;
      all_goals have := hS.1 hp4; simp_all +decide ; ;
      · linarith;
      · linarith;
      · grind;
      · linarith
    have h_p5_ge_41 : 41 ≤ p5 := by
      grind;
    have h_prod_ge : (∏ p ∈ {p1, p2, p3, p4, p5}, p) ≥ 13 * 17 * 29 * 37 * 41 := by
      rw [ Finset.prod_insert, Finset.prod_insert, Finset.prod_insert, Finset.prod_insert ] <;> simp +decide [ * ];
      · exact le_trans ( by decide ) ( Nat.mul_le_mul h_p1_ge_13 ( Nat.mul_le_mul h_p2_ge_17 ( Nat.mul_le_mul h_p3_ge_29 ( Nat.mul_le_mul h_p4_ge_37 h_p5_ge_41 ) ) ) );
      · linarith;
      · grind;
      · exact ⟨ by linarith, by linarith, by linarith ⟩;
      · grind;
    exact h_prod_ge.trans ( Finset.prod_le_prod_of_subset_of_one_le' ( by aesop_cat ) fun _ _ _ => Nat.one_le_iff_ne_zero.mpr <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors <| hS.1 <| by aesop_cat );
  exact le_trans h_prod_ge ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( Nat.prod_primeFactors_dvd _ |> dvd_trans ( by rw [ ← Finset.prod_sdiff hS.1 ] ; aesop_cat ) ) )

/-
The product (1-1/13)(1-1/17)(1-1/29)(1-1/37) is greater than 0.8.
-/
lemma prod_one_sub_inv_four_primes_ge_13 :
  (1 - 1/13 : ℚ) * (1 - 1/17) * (1 - 1/29) * (1 - 1/37) > 8/10 := by
    decide +kernel

/-
If p1 < p2 < p3 < p4 are primes >= 13 and congruent to 1 mod 4, then p1 >= 13, p2 >= 17, p3 >= 29, p4 >= 37.
-/
lemma sorted_primes_lower_bounds (p1 p2 p3 p4 : ℕ)
  (h_primes : Nat.Prime p1 ∧ Nat.Prime p2 ∧ Nat.Prime p3 ∧ Nat.Prime p4)
  (h_sorted : p1 < p2 ∧ p2 < p3 ∧ p3 < p4)
  (h_ge_13 : 13 ≤ p1)
  (h_mod_4 : p1 % 4 = 1 ∧ p2 % 4 = 1 ∧ p3 % 4 = 1 ∧ p4 % 4 = 1) :
  p1 ≥ 13 ∧ p2 ≥ 17 ∧ p3 ≥ 29 ∧ p4 ≥ 37 := by
    refine ⟨ h_ge_13, ?_, ?_, ?_ ⟩;
    · grind;
    · by_contra h_contra; interval_cases p3 <;> simp_all +decide ;
      · grind +ring;
      · linarith [ h_primes.1.two_le, h_primes.2.1.two_le, h_primes.2.2.two_le ];
      · rcases h_sorted with ⟨ h₁, h₂, h₃ ⟩ ; interval_cases p2 <;> interval_cases p1 <;> norm_num at *;
    · by_contra h_contra; interval_cases p4 <;> simp_all +decide ;
      · grind;
      · linarith;
      · omega;
      · rcases h_sorted with ⟨ h₁, h₂, h₃ ⟩ ; interval_cases p3 <;> interval_cases p2 <;> interval_cases p1 <;> norm_num at *;

/-
The product of (1 - 1/p) for a set of at most 4 primes (>= 13, = 1 mod 4) is greater than 0.8.
-/
lemma prod_one_sub_inv_bound_of_card_le_four (S : Finset ℕ) (h_card : S.card ≤ 4) (h_primes : ∀ p ∈ S, Nat.Prime p) (h_ge_13 : ∀ p ∈ S, 13 ≤ p) (h_mod_4 : ∀ p ∈ S, p % 4 = 1) :
  ∏ p ∈ S, (1 - 1 / (p : ℚ)) > 8/10 := by
    by_cases hS : S.card = 0;
    · norm_num [ Finset.card_eq_zero.mp hS ];
    · -- Since S is not empty and has at most 4 elements, we can order its elements as q1 < q2 < q3 < q4.
      obtain ⟨q1, q2, q3, q4, hq⟩ : ∃ q1 q2 q3 q4 : ℕ, q1 ∈ S ∧ q2 ∈ S ∧ q3 ∈ S ∧ q4 ∈ S ∧ q1 < q2 ∧ q2 < q3 ∧ q3 < q4 ∧ S = {q1, q2, q3, q4} ∨ q1 ∈ S ∧ q2 ∈ S ∧ q3 ∈ S ∧ q1 < q2 ∧ q2 < q3 ∧ S = {q1, q2, q3} ∨ q1 ∈ S ∧ q2 ∈ S ∧ q1 < q2 ∧ S = {q1, q2} ∨ q1 ∈ S ∧ S = {q1} := by
        interval_cases _ : S.card <;> simp_all +decide;
        · obtain ⟨ q, hq ⟩ := Finset.card_eq_one.mp ‹_›; use q; aesop;
        · obtain ⟨ q1, q2, hq ⟩ := Finset.card_eq_two.mp ‹_›; cases lt_trichotomy q1 q2 <;> simp_all +decide ;
          · exact ⟨ q1, q2, q2, q2, by aesop ⟩;
          · exact ⟨ q2, q1, q1, q1, by aesop ⟩;
        · obtain ⟨ q1, q2, q3, h ⟩ := Finset.card_eq_three.mp ‹_›;
          cases lt_or_gt_of_ne h.1 <;> cases lt_or_gt_of_ne h.2.1 <;> cases lt_or_gt_of_ne h.2.2.1 <;> simp +decide [ * ] at *;
          exact ⟨ q1, q2, q3, q1, by aesop ⟩;
          exact ⟨ q1, q3, q2, q2, by aesop ⟩;
          exact ⟨ q3, q1, q2, q2, by aesop ⟩;
          · exact ⟨ q3, q1, q2, q2, by aesop ⟩;
          · exact ⟨ q2, q1, q3, q3, by aesop ⟩;
          · grind;
          · exact ⟨ q2, q3, q1, q1, by aesop ⟩;
          · exact ⟨ q3, q2, q1, q1, by aesop ⟩;
        · -- Since S has 4 elements, we can order them as q1 < q2 < q3 < q4.
          obtain ⟨q1, q2, q3, q4, hq⟩ : ∃ q1 q2 q3 q4 : ℕ, q1 ∈ S ∧ q2 ∈ S ∧ q3 ∈ S ∧ q4 ∈ S ∧ q1 < q2 ∧ q2 < q3 ∧ q3 < q4 ∧ S = {q1, q2, q3, q4} := by
            -- Since S has 4 elements, we can order them as q1 < q2 < q3 < q4 by definition of finsets.
            obtain ⟨q, hq⟩ : ∃ q : Fin 4 → ℕ, (∀ i, q i ∈ S) ∧ StrictMono q := by
              exact ⟨ fun i => S.orderEmbOfFin ( by aesop ) i, fun i => by aesop, by aesop_cat ⟩;
            use q 0, q 1, q 2, q 3;
            have := Finset.eq_of_subset_of_card_le ( show Finset.image q Finset.univ ⊆ S from Finset.image_subset_iff.mpr fun i _ => hq.1 i ) ; simp_all +decide [ Finset.card_image_of_injective _ hq.2.injective ] ;
            exact ⟨ hq.2 ( by decide ), hq.2 ( by decide ), hq.2 ( by decide ), this ▸ by simp +decide [ Fin.univ_succ ] ⟩;
          exact ⟨ q1, q2, q3, q4, Or.inl hq ⟩;
      rcases hq with ( ⟨ hq1, hq2, hq3, hq4, hq5, hq6, hq7, rfl ⟩ | ⟨ hq1, hq2, hq3, hq4, hq5, rfl ⟩ | ⟨ hq1, hq2, hq3, rfl ⟩ | ⟨ hq1, rfl ⟩ ) <;> norm_num at *;
      · rw [ Finset.prod_insert, Finset.prod_insert, Finset.prod_insert ] <;> norm_num;
        · field_simp;
          have h_sorted_lower_bounds : q1 ≥ 13 ∧ q2 ≥ 17 ∧ q3 ≥ 29 ∧ q4 ≥ 37 := by
            exact sorted_primes_lower_bounds q1 q2 q3 q4 h_primes ⟨ hq5, hq6, hq7 ⟩ h_ge_13.left h_mod_4;
          have h_prod_lower_bounds : (1 - 1 / (q1 : ℚ)) * (1 - 1 / (q2 : ℚ)) * (1 - 1 / (q3 : ℚ)) * (1 - 1 / (q4 : ℚ)) ≥ (1 - 1 / 13 : ℚ) * (1 - 1 / 17 : ℚ) * (1 - 1 / 29 : ℚ) * (1 - 1 / 37 : ℚ) := by
            have h1 : (1 - 1 / (q1 : ℚ)) ≥ (1 - 1 / 13 : ℚ) := by
              exact sub_le_sub_left ( one_div_le_one_div_of_le ( by norm_num ) ( mod_cast h_sorted_lower_bounds.1 ) ) _
            have h2 : (1 - 1 / (q2 : ℚ)) ≥ (1 - 1 / 17 : ℚ) := by
              exact sub_le_sub_left ( one_div_le_one_div_of_le ( by norm_num ) ( mod_cast h_sorted_lower_bounds.2.1 ) ) _
            have h3 : (1 - 1 / (q3 : ℚ)) ≥ (1 - 1 / 29 : ℚ) := by
              exact sub_le_sub_left ( one_div_le_one_div_of_le ( by norm_num ) ( mod_cast h_sorted_lower_bounds.2.2.1 ) ) _
            have h4 : (1 - 1 / (q4 : ℚ)) ≥ (1 - 1 / 37 : ℚ) := by
              exact sub_le_sub_left ( one_div_le_one_div_of_le ( by norm_num ) ( mod_cast h_sorted_lower_bounds.2.2.2 ) ) _
            gcongr;
          linarith;
        · linarith;
        · exact ⟨ by linarith, by linarith ⟩;
        · exact ⟨ by linarith, by linarith, by linarith ⟩;
      · -- Since $q1$, $q2$, and $q3$ are primes greater than or equal to 13 and congruent to 1 modulo 4, we have $q1 \geq 13$, $q2 \geq 17$, and $q3 \geq 29$.
        have hq1_ge_13 : q1 ≥ 13 := by
          linarith
        have hq2_ge_17 : q2 ≥ 17 := by
          grind +ring
        have hq3_ge_29 : q3 ≥ 29 := by
          exact le_of_not_gt fun h => by interval_cases q3 <;> interval_cases q2 <;> simp_all +decide only ;
        rw [ Finset.prod_insert, Finset.prod_insert ] <;> norm_num;
        · -- Substitute the minimum values of q1, q2, and q3 into the product.
          have h_prod_min : (1 - (q1 : ℚ)⁻¹) * (1 - (q2 : ℚ)⁻¹) * (1 - (q3 : ℚ)⁻¹) ≥ (1 - (13 : ℚ)⁻¹) * (1 - (17 : ℚ)⁻¹) * (1 - (29 : ℚ)⁻¹) := by
            gcongr <;> norm_cast;
            · exact mul_nonneg ( sub_nonneg.2 <| inv_le_one_of_one_le₀ <| mod_cast hq1_ge_13.trans' <| by norm_num ) ( sub_nonneg.2 <| inv_le_one_of_one_le₀ <| mod_cast hq2_ge_17.trans' <| by norm_num );
            · exact sub_nonneg.2 <| inv_le_one_of_one_le₀ <| mod_cast hq1_ge_13.trans' <| by norm_num;
          norm_num at * ; linarith;
        · linarith;
        · exact ⟨ by linarith, by linarith ⟩;
      · rw [ Finset.prod_pair ] <;> try linarith;
        field_simp;
        nlinarith only [ show ( q1 : ℚ ) ≥ 13 by exact_mod_cast h_ge_13.1, show ( q2 : ℚ ) ≥ 13 by exact_mod_cast h_ge_13.2, one_div_mul_cancel ( show ( q1 : ℚ ) ≠ 0 by norm_cast; linarith ), one_div_mul_cancel ( show ( q2 : ℚ ) ≠ 0 by norm_cast; linarith ), mul_pos ( show ( 0 : ℚ ) < q1 by norm_cast; linarith ) ( show ( 0 : ℚ ) < q2 by norm_cast; linarith ) ];
      · nlinarith [ show ( q1 : ℚ ) ≥ 13 by norm_cast, inv_mul_cancel₀ ( by positivity : ( q1 : ℚ ) ≠ 0 ) ]

/-
If p1 >= 13, p2 >= 17, p3 >= 29, p4 >= 37, then the product (1-1/p1)...(1-1/p4) is > 0.8.
-/
lemma prod_four_primes_gt_point_eight (p1 p2 p3 p4 : ℕ)
  (h13 : 13 ≤ p1) (h17 : 17 ≤ p2) (h29 : 29 ≤ p3) (h37 : 37 ≤ p4) :
  (1 - 1 / (p1 : ℚ)) * (1 - 1 / (p2 : ℚ)) * (1 - 1 / (p3 : ℚ)) * (1 - 1 / (p4 : ℚ)) > 8/10 := by
    -- By multiplying the inequalities for each term, we get the desired result.
    have h_prod : (1 - 1 / (p1 : ℚ)) * (1 - 1 / (p2 : ℚ)) * (1 - 1 / (p3 : ℚ)) * (1 - 1 / (p4 : ℚ)) ≥ (1 - 1 / 13) * (1 - 1 / 17) * (1 - 1 / 29) * (1 - 1 / 37) := by
      gcongr <;> norm_cast;
      · exact mul_nonneg ( mul_nonneg ( sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith ) <| sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith ) <| sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith;
      · exact mul_nonneg ( sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith ) ( sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith );
      · exact sub_nonneg.2 <| div_le_self zero_le_one <| mod_cast by linarith;
    exact h_prod.trans_lt' ( by norm_num )

/-
If n is non-zero and has exactly 4 prime factors, all at least 13 and congruent to 1 mod 4, then φ(n)/n > 0.8.
-/
lemma totient_ratio_bound_of_card_eq_four (n : ℕ) (hn : n ≠ 0) (h_factors_ge_13 : ∀ p ∈ Nat.primeFactors n, 13 ≤ p) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) (h_card : (Nat.primeFactors n).card = 4) : (Nat.totient n : ℚ) / n > 8/10 := by
  field_simp;
  -- Applying the lemma that the product of (1 - 1/p) for a set of at most 4 primes (>= 13, = 1 mod 4) is greater than 0.8.
  have h_prod : ∏ p ∈ n.primeFactors, (1 - 1 / (p : ℚ)) > 8 / 10 := by
    convert prod_one_sub_inv_bound_of_card_le_four _ _ _ _ _ using 1;
    · linarith;
    · exact fun p hp => Nat.prime_of_mem_primeFactors hp;
    · assumption;
    · assumption;
  -- By definition of totient function, we know that $\varphi(n) = n \prod_{p \mid n} (1 - 1/p)$.
  have h_totient : (Nat.totient n : ℚ) = n * ∏ p ∈ n.primeFactors, (1 - 1 / (p : ℚ)) := by
    have := @Nat.totient_eq_mul_prod_factors n; aesop;
  nlinarith [ show ( n : ℚ ) > 0 by positivity ]

/-
If n is non-zero and has at most 4 prime factors, all at least 13 and congruent to 1 mod 4, then φ(n)/n > 0.8.
-/
lemma totient_ratio_bound_of_card_le_four (n : ℕ) (hn : n ≠ 0) (h_factors_ge_13 : ∀ p ∈ Nat.primeFactors n, 13 ≤ p) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) (h_card : (Nat.primeFactors n).card ≤ 4) : (Nat.totient n : ℚ) / n > 8/10 := by
  -- By definition of totient function, $\frac{\varphi(n)}{n} = \prod_{p \in \text{primeFactors}(n)} \left(1 - \frac{1}{p}\right)$.
  have h_ratio : (Nat.totient n : ℚ) / n = ∏ p ∈ n.primeFactors, (1 - 1 / p : ℚ) := by
    field_simp;
    convert Nat.totient_eq_mul_prod_factors n using 1;
    norm_num;
  exact h_ratio ▸ mod_cast prod_one_sub_inv_bound_of_card_le_four _ h_card ( fun p hp => Nat.prime_of_mem_primeFactors hp ) h_factors_ge_13 h_factors_mod_4

/-
If n < 1185665 is non-zero and all prime factors are 1 mod 4, then φ(n)/n > 0.67.
-/
lemma totient_ratio_bound_of_lt_limit_mod_four_with_five (n : ℕ) (hn : n ≠ 0) (h_n_lt : n < 1185665) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) : (Nat.totient n : ℚ) / n > 67/100 := by
  -- If n < 1185665 and all prime factors are 1 mod 4, then n has at most 4 distinct prime factors.
  have h_card : (n.primeFactors).card ≤ 4 := by
    -- Since $n < 1185665$, we can check all numbers less than 1185665 to see if they have more than 4 distinct prime factors that are 1 mod 4.
    have h_check : ∀ m ∈ Finset.Ico 1 1185665, (∀ p ∈ m.primeFactors, p % 4 = 1) → m.primeFactors.card ≤ 4 := by
      native_decide +revert;
    exact h_check n ( Finset.mem_Ico.mpr ⟨ Nat.pos_of_ne_zero hn, h_n_lt ⟩ ) h_factors_mod_4;
  -- The ratio φ(n)/n is minimized when n has the smallest possible prime factors.
  have h_min_ratio : (Nat.totient n : ℚ) / n ≥ ∏ p ∈ n.primeFactors, (1 - 1 / p : ℚ) := by
    have := @Nat.totient_eq_mul_prod_factors n; aesop;
  -- Since the prime factors of n are at least 5, 13, 17, and 29, the product of (1 - 1/p) for these primes is greater than 0.67.
  have h_prod_gt_67 : ∏ p ∈ n.primeFactors, (1 - 1 / p : ℚ) ≥ ∏ p ∈ Finset.image (fun i => if i = 0 then 5 else if i = 1 then 13 else if i = 2 then 17 else 29) (Finset.range (n.primeFactors.card)), (1 - 1 / p : ℚ) := by
    -- Since the prime factors of n are at least 5, 13, 17, and 29, we can order them as p1 < p2 < p3 < p4.
    obtain ⟨ps, hps⟩ : ∃ ps : Fin (n.primeFactors.card) → ℕ, StrictMono ps ∧ ∀ i, ps i ∈ n.primeFactors ∧ ps i % 4 = 1 := by
      exact ⟨ fun i => n.primeFactors.orderEmbOfFin rfl i, by simp +decide [ StrictMono ], fun i => ⟨ by simp +decide, h_factors_mod_4 _ <| by simp +decide ⟩ ⟩;
    -- Since $ps$ is strictly monotone, we have $ps i ≥ if i = 0 then 5 else if i = 1 then 13 else if i = 2 then 17 else 29$ for all $i$.
    have h_ps_ge : ∀ i, ps i ≥ if i.val = 0 then 5 else if i.val = 1 then 13 else if i.val = 2 then 17 else 29 := by
      intro i; rcases i with ⟨ _ | _ | _ | _ | i, hi ⟩ <;> norm_num ;
      · exact le_of_not_gt fun h => by have := hps.2 ⟨ 0, hi ⟩ ; interval_cases ps ⟨ 0, hi ⟩ <;> simp_all +decide ;
      · by_contra h_contra;
        have := hps.2 ⟨ 1, by linarith ⟩ ; ( have := hps.2 ⟨ 0, by linarith ⟩ ; ( have := hps.1 ( show ⟨ 0, by linarith ⟩ < ⟨ 1, by linarith ⟩ from Nat.lt_succ_self _ ) ; ( norm_num at * ; interval_cases _ : ps ⟨ 1, by linarith ⟩ <;> simp_all +decide ; ) ) );
        have := hps.2 ⟨ 0, by linarith ⟩ ; ( have := Nat.le_of_lt_succ ( show ps ⟨ 0, by linarith ⟩ < 5 by linarith ) ; interval_cases ps ⟨ 0, by linarith ⟩ <;> simp_all +decide ; );
      · by_contra h_contra;
        have := hps.2 ⟨ 2, by linarith ⟩ ; interval_cases _ : ps ⟨ 2, by linarith ⟩ <;> simp_all +decide only ;
        · norm_num [ Nat.mem_primeFactors ] at this;
        · have := hps.1 ( show ⟨ 0, by linarith ⟩ < ⟨ 1, by linarith ⟩ from Nat.zero_lt_one ) ; have := hps.1 ( show ⟨ 1, by linarith ⟩ < ⟨ 2, by linarith ⟩ from Nat.lt_succ_self _ ) ; simp_all +decide ;
          have := hps.2 ⟨ 0, by linarith ⟩ ; have := hps.2 ⟨ 1, by linarith ⟩ ; interval_cases ps ⟨ 1, by linarith ⟩ <;> simp_all +decide ;
        · exact absurd ( Nat.prime_of_mem_primeFactors this.1 ) ( by norm_num );
        · have := hps.1 ( show ⟨ 1, by linarith ⟩ < ⟨ 2, by linarith ⟩ from Nat.lt_succ_self _ ) ; simp_all +decide ;
          have := hps.2 ⟨ 1, by linarith ⟩ ; interval_cases _ : ps ⟨ 1, by linarith ⟩ <;> simp_all +decide ;
          have := hps.1 ( show ⟨ 0, by linarith ⟩ < ⟨ 1, by linarith ⟩ from Nat.lt_succ_self _ ) ; simp_all +decide ;
          have := hps.2 ⟨ 0, by linarith ⟩ ; interval_cases _ : ps ⟨ 0, by linarith ⟩ <;> simp_all +decide ;
      · by_contra h_contra;
        have := hps.2 ⟨ 0, by linarith ⟩ ; have := hps.2 ⟨ 1, by linarith ⟩ ; have := hps.2 ⟨ 2, by linarith ⟩ ; have := hps.2 ⟨ 3, by linarith ⟩ ; norm_num at *;
        have := hps.1 ( show ⟨ 0, by linarith ⟩ < ⟨ 1, by linarith ⟩ from Nat.lt_succ_self _ ) ; ( have := hps.1 ( show ⟨ 1, by linarith ⟩ < ⟨ 2, by linarith ⟩ from Nat.lt_succ_self _ ) ; ( have := hps.1 ( show ⟨ 2, by linarith ⟩ < ⟨ 3, by linarith ⟩ from Nat.lt_succ_self _ ) ; norm_num at * ; ) );
        have := Nat.le_of_lt_succ ( show ps ⟨ 3, by linarith ⟩ < 29 by linarith ) ; interval_cases ps ⟨ 3, by linarith ⟩ <;> simp_all +decide only ;
        · grind;
        · have := hps.2 ⟨ 0, by linarith ⟩ ; have := hps.2 ⟨ 1, by linarith ⟩ ; have := hps.2 ⟨ 2, by linarith ⟩ ; norm_num at * ; interval_cases ps ⟨ 2, by linarith ⟩ <;> simp_all +decide only ;
          grind;
        · have := hps.2 ⟨ 0, by linarith ⟩ ; have := hps.2 ⟨ 1, by linarith ⟩ ; have := hps.2 ⟨ 2, by linarith ⟩ ; norm_num at * ; interval_cases ps ⟨ 2, by linarith ⟩ <;> simp_all +decide only ;
          · grind;
          · have := hps.2 ⟨ 0, by linarith ⟩ ; have := hps.2 ⟨ 1, by linarith ⟩ ; norm_num at * ; interval_cases ps ⟨ 1, by linarith ⟩ <;> simp_all +decide only ;
            have := hps.2 ⟨ 0, by linarith ⟩ ; interval_cases ps ⟨ 0, by linarith ⟩ <;> simp_all +decide ;
      · grind;
    have h_prod_ge : ∏ p ∈ Finset.image ps Finset.univ, (1 - 1 / p : ℚ) ≥ ∏ p ∈ Finset.image (fun i => if i = 0 then 5 else if i = 1 then 13 else if i = 2 then 17 else 29) (Finset.range (n.primeFactors.card)), (1 - 1 / p : ℚ) := by
      rw [ Finset.prod_image, Finset.prod_image ];
      · rw [ Finset.prod_range ];
        exact Finset.prod_le_prod ( fun _ _ => sub_nonneg.mpr <| div_le_one_of_le₀ ( by split_ifs <;> norm_num ) <| by positivity ) fun i _ => sub_le_sub_left ( one_div_le_one_div_of_le ( by split_ifs <;> norm_num ) <| mod_cast h_ps_ge i ) _;
      · interval_cases n.primeFactors.card <;> simp +decide [ Set.InjOn ];
      · exact hps.1.injective.injOn;
    refine le_trans h_prod_ge ?_;
    rw [ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun i _ => hps.2 i |>.1 ) ( by rw [ Finset.card_image_of_injective _ hps.1.injective ] ; simpa ) ];
  exact h_min_ratio.trans_lt' ( h_prod_gt_67.trans_lt' ( by interval_cases ( n.primeFactors.card ) <;> native_decide ) )

/-
If n is non-zero and has at most 4 prime factors, all at least 13 and congruent to 1 mod 4, then φ(n)/n > 0.8.
-/
lemma totient_ratio_bound_of_card_le_four' (n : ℕ) (hn : n ≠ 0) (h_factors_ge_13 : ∀ p ∈ Nat.primeFactors n, 13 ≤ p) (h_factors_mod_4 : ∀ p ∈ Nat.primeFactors n, p % 4 = 1) (h_card : (Nat.primeFactors n).card ≤ 4) : (Nat.totient n : ℚ) / n > 8/10 := by
  convert totient_ratio_bound_of_card_le_four n hn h_factors_ge_13 h_factors_mod_4 h_card using 1

/-
For 1000 <= k <= 3118, if k is even and 3 divides k+1, then 5 divides k^2+1.
-/
lemma five_dvd_k_sq_plus_one_of_three_dvd_k_plus_one_bounded (k : ℕ) (hk_ge_1000 : 1000 ≤ k) (hk_le_3118 : k ≤ 3118) (hk_even : Even k) (h_div3 : 3 ∣ k + 1) (h_eq : Nat.totient (k^2 + 1) = k * Nat.totient (k + 1)) : 5 ∣ k^2 + 1 := by
  -- If 5 does not divide k^2+1, then all prime factors of k^2+1 are >= 13 (by minFac lemma).
  by_contra h_not_dvd_five
  have h_factors_ge_13 : ∀ p ∈ Nat.primeFactors (k^2 + 1), 13 ≤ p := by
    intro p hp; have := Nat.le_of_mem_primeFactors hp; contrapose! h_not_dvd_five; interval_cases p <;> norm_num at *;
    · simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
    · rw [ Nat.dvd_iff_mod_eq_zero ] at *; norm_num [ Nat.add_mod, Nat.pow_mod ] at *; have := Nat.mod_lt k zero_lt_three; interval_cases k % 3 <;> trivial;
    · assumption;
    · rw [ Nat.dvd_iff_mod_eq_zero ] at hp; norm_num [ Nat.add_mod, Nat.pow_mod ] at hp; have := Nat.mod_lt k ( by decide : 7 > 0 ) ; interval_cases k % 7 <;> trivial;
    · rw [ Nat.dvd_iff_mod_eq_zero ] at hp; norm_num [ Nat.add_mod, Nat.pow_mod ] at hp; have := Nat.mod_lt k ( by decide : 0 < 11 ) ; interval_cases k % 11 <;> trivial;
  -- Since $k \leq 3118$, we have $k^2 + 1 \leq 3118^2 + 1 = 9721925 < 9722453$.
  have h_bound : k^2 + 1 < 9722453 := by
    nlinarith only [ hk_le_3118 ];
  -- So k^2+1 has at most 4 prime factors (by num_prime_factors lemma).
  have h_card_le_four : (Nat.primeFactors (k^2 + 1)).card ≤ 4 := by
    apply num_prime_factors_le_four_of_lt_limit_mod_four;
    · exact?;
    · assumption;
    · exact fun p hp => prime_dvd_k_sq_plus_one_implies_mod_four_eq_one k hk_even p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp );
  -- Thus φ(k^2+1)/(k^2+1) > 0.8 (by totient_ratio_bound lemma).
  have h_totient_ratio_gt_0_8 : (Nat.totient (k^2 + 1) : ℚ) / (k^2 + 1) > 8 / 10 := by
    convert totient_ratio_bound_of_card_le_four' ( k ^ 2 + 1 ) ( by positivity ) h_factors_ge_13 _ h_card_le_four using 1;
    · norm_cast;
    · exact fun p hp => prime_dvd_k_sq_plus_one_implies_mod_four_eq_one k hk_even p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp );
  -- But 3 | k+1 implies φ(k+1)/(k+1) ≤ 2/3.
  have h_totient_ratio_le_2_3 : (Nat.totient (k + 1) : ℚ) / (k + 1) ≤ 2 / 3 := by
    convert ratio_bound_of_div_three ( k + 1 ) h_div3 ( Nat.succ_pos _ ) using 1;
    norm_cast;
  -- From the equation, φ(k^2+1)/(k^2+1) = k(k+1)/(k^2+1) * φ(k+1)/(k+1).
  have h_eq_ratio : (Nat.totient (k^2 + 1) : ℚ) / (k^2 + 1) = (k * (k + 1) : ℚ) / (k^2 + 1) * (Nat.totient (k + 1) : ℚ) / (k + 1) := by
    field_simp [h_eq] ; ring;
    exact mod_cast by simpa only [ add_comm ] using h_eq;
  -- RHS <= (k(k+1)/(k^2+1)) * 2/3.
  have h_rhs_le : (k * (k + 1) : ℚ) / (k^2 + 1) * (Nat.totient (k + 1) : ℚ) / (k + 1) ≤ (k * (k + 1) : ℚ) / (k^2 + 1) * (2 / 3) := by
    simpa only [ mul_div_assoc ] using mul_le_mul_of_nonneg_left h_totient_ratio_le_2_3 ( by positivity );
  exact h_totient_ratio_gt_0_8.not_le ( h_eq_ratio ▸ h_rhs_le.trans ( by rw [ div_mul_eq_mul_div, div_le_iff₀ ] <;> nlinarith only [ show ( k : ℚ ) ≥ 1000 by exact_mod_cast hk_ge_1000, show ( k : ℚ ) ≤ 3118 by exact_mod_cast hk_le_3118 ] ) )

/-
For all k < 3200, if k+1 is composite and satisfies the equation φ(k²+1) = k·φ(k+1), then k must be 8.
-/
theorem oeis_a67720_bounded_3200 : ∀ k < 3200, ¬ Nat.Prime (k + 1) → is_oeis_a67720_solution k → k = 8 := by
  intro k hk₁ hk₂₃;
  -- By checking each $k$ in the specified range, we can verify whether $k$ satisfies the given equation.
  by_contra h_contra;
  unfold is_oeis_a67720_solution at h_contra; norm_num [ Nat.totient_eq_div_primeFactors_mul ] at *; revert k; native_decide;