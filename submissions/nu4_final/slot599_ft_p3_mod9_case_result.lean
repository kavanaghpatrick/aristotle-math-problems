/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d1f8186d-4824-49b2-a8be-2f932ca9c627

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of A = q^2 + q + 1
-/
def A (q : ℕ) := q^2 + q + 1

/-
q^3 is congruent to 1 modulo A = q^2 + q + 1.
-/
lemma q_cubed_eq_one (q : ℕ) : (q : ZMod (A q)) ^ 3 = 1 := by
  have h_subst : (q : ZMod (A q))^3 - 1 = (q - 1) * (A q) := by
    unfold A; ring;
    norm_num ; ring;
  simp_all +decide [ sub_eq_iff_eq_add ]

/-
The modular inverse of q modulo A is -(q+1).
-/
lemma q_inverse (q : ℕ) : (q : ZMod (A q))⁻¹ = -((q : ZMod (A q)) + 1) := by
  rw [ ZMod.inv_eq_of_mul_eq_one ];
  ring_nf at *;
  -- Since $q^2 + q + 1 \equiv 0 \pmod{A}$, we have $-(q^2 + q) \equiv 1 \pmod{A}$.
  have h_cong : (q^2 + q + 1 : ZMod (A q)) = 0 := by
    norm_cast at *;
    exact?;
  linear_combination' -h_cong

/-
Function to check the Feit-Thompson condition for q = 8 mod 9 case.
-/
def check_ft_mod9_case (q : ℕ) : Bool :=
  if q.Prime ∧ 3 < q ∧ q % 9 == 8 then
    let a := A q
    if a.Prime then
      (3 : ZMod a) ^ q ≠ 1
    else true
  else true

/-
The Feit-Thompson condition holds for all q < 50000.
-/
theorem ft_mod9_bounded_50000 :
    (List.range 50000).all check_ft_mod9_case = true := by
      native_decide +revert

/-
If 3^q = 1 mod A, then 3 is not a q-th power residue mod A.
-/
lemma not_is_q_th_power_residue (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) (hq3 : q > 3) :
    ¬ ∃ x : ZMod (A q), x ^ q = 3 := by
      -- Assume there exists $x$ such that $x^q = 3$.
      by_contra h
      obtain ⟨x, hx⟩ := h
      have h3_eq_one : (3 : (ZMod (A q))) = 1 := by
        haveI := Fact.mk hA; have h3_eq_one : (3 : (ZMod (A q))) ^ (q + 1) = 1 := by
          -- Since $x^q = 3$, we have $x^{q(q+1)} = (x^q)^{q+1} = 3^{q+1}$.
          have hx_pow : x ^ (q * (q + 1)) = 3 ^ (q + 1) := by
            rw [ pow_mul, hx ];
          -- Since $x$ is a non-zero element of the multiplicative group modulo $A$, we have $x^{A-1} = 1$.
          have hx_order : x ^ (A q - 1) = 1 := by
            by_cases hx_zero : x = 0 <;> simp_all +decide [ ZMod.pow_card_sub_one_eq_one ];
            cases q <;> simp_all +decide [ pow_succ' ];
            grind;
          simp_all +decide [ show A q - 1 = q * ( q + 1 ) by rw [ Nat.sub_eq_of_eq_add ] ; unfold A; ring ];
        simp_all +decide [ pow_succ' ]
      skip
      skip
      skip
      skip
      skip
      skip
      exact absurd h3_eq_one (by
      rcases q with ( _ | _ | _ | _ | _ | q ) <;> cases h3_eq_one ; trivial)

/-
If 3^q = 1 mod A, then 3 is a (q+1)-th power residue mod A.
-/
lemma is_q_plus_one_th_power_residue (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    ∃ x : ZMod (A q), x ^ (q + 1) = 3 := by
      grind

/-
If q is 35 mod 36, then A is 1 mod 36.
-/
lemma A_mod_36 (q : ℕ) (hq : q % 36 = 35) : A q % 36 = 1 := by
  unfold A; norm_num [ Nat.add_mod, Nat.pow_mod, hq ] ;

/-
3 is not congruent to 1 modulo A for q > 1.
-/
lemma three_not_cong_one (q : ℕ) (hq : q > 1) : (3 : ZMod (A q)) ≠ 1 := by
  rcases q with ( _ | _ | _ | _ | _ | q ) <;> norm_num [ ZMod ] at *;
  · decide +revert;
  · decide +revert;
  · decide +revert;
  · rintro ⟨ ⟩

/-
If 3^q = 1 mod A, then the order of 3 mod A is q.
-/
lemma order_of_three_eq_q (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) (hq3 : q > 3) : orderOf (3 : ZMod (A q)) = q := by
  have h_order : orderOf (3 : ZMod (A q)) ∣ q := by
    exact orderOf_dvd_iff_pow_eq_one.mpr h3;
  rw [ Nat.dvd_prime hq ] at h_order;
  -- If the order were 1, then 3 would be congruent to 1 modulo A, which contradicts h3.
  have h_contra : (3 : ZMod (A q)) ≠ 1 := by
    -- By definition of $A$, we know that $A q = q^2 + q + 1$. Therefore, $3 \neq 1 \pmod{A q}$.
    apply three_not_cong_one; linarith;
  exact h_order.resolve_left fun h => h_contra <| by rw [ orderOf_eq_one_iff ] at h; aesop;

/-
If 3^q = 1 mod A, then 3^{q+1} = 3 mod A.
-/
lemma three_pow_q_plus_one_eq_three (q : ℕ) (h3 : (3 : ZMod (A q)) ^ q = 1) : (3 : ZMod (A q)) ^ (q + 1) = 3 := by
  convert congr_arg ( · * 3 ) h3 using 1 ; ring

/-
3^(q^2) is congruent to (3^-1)^q modulo A.
-/
lemma three_pow_q_sq_eq_three_inv_q (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) :
    (3 : ZMod (A q)) ^ (q^2) = ((3 : ZMod (A q))⁻¹) ^ q := by
      have h_order : (3 : ZMod (A q)) ^ (q ^ 2) = (3 : ZMod (A q))⁻¹ ^ q := by
        have : q^2 = q * (q + 1) - q := by
          exact Eq.symm ( Nat.sub_eq_of_eq_add <| by ring )
        have h_order : (3 : ZMod (A q)) ^ (q * (q + 1)) = 1 := by
          -- By Fermat's Little Theorem, we know that $3^{A-1} \equiv 1 \pmod{A}$.
          have h_fermat : (3 : ZMod (A q)) ^ (A q - 1) = 1 := by
            haveI := Fact.mk hA; exact ZMod.pow_card_sub_one_eq_one ( by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by nlinarith only [ hq.two_le, show A q > 3 by exact lt_add_of_le_of_pos ( by nlinarith only [ hq.two_le ] ) zero_lt_one ] ) ) ;
          -- Since $A q - 1 = q(q + 1)$, we can substitute this into Fermat's Little Theorem.
          have h_subst : A q - 1 = q * (q + 1) := by
            exact Nat.sub_eq_of_eq_add <| by unfold A; ring;
          rwa [ h_subst ] at h_fermat;
        have h_order : (3 : ZMod (A q)) ^ (q * (q + 1) - q) = (3 : ZMod (A q))⁻¹ ^ q := by
          have h_inv : (3 : ZMod (A q)) ^ (q * (q + 1) - q) * (3 : ZMod (A q)) ^ q = 1 := by
            rw [ ← pow_add, Nat.sub_add_cancel ( by nlinarith only [ hq.two_le ] ), h_order ]
          haveI := Fact.mk hA; rw [ inv_pow ] ; rw [ eq_comm ] ; rw [ inv_eq_of_mul_eq_one_left h_inv ] ;
        aesop;
      exact h_order

/-
If 3^q = 1 mod A, then 3^q = 1 + kA with k = 2 mod q.
-/
lemma k_congruence (q : ℕ) (hq : q.Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    ∃ k : ℕ, 3 ^ q = 1 + k * (A q) ∧ k % q = 2 := by
      -- Since $3^q = 1 + kA$ for some integer $k$, we have $3^q \equiv 1 \pmod{A}$.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, 3 ^ q = 1 + k * A q := by
        -- Since $3^q = 1 \pmod{A}$, we have $3^q - 1$ is divisible by $A$.
        have h_div : A q ∣ 3 ^ q - 1 := by
          simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
        exact Exists.elim h_div fun k hk => ⟨ k, by linarith [ Nat.sub_add_cancel ( Nat.one_le_pow q 3 zero_lt_three ) ] ⟩;
      -- Mod q: $3^q \equiv 3 \pmod{q}$ (Fermat) and $A \equiv 1 \pmod{q}$, so $3 \equiv 1 + k \pmod{q}$.
      have h_mod_q : 3 % q = (1 + k) % q := by
        have h_mod_q : (3 ^ q : ℕ) % q = (1 + k) % q := by
          norm_num [ hk, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, show A q = q ^ 2 + q + 1 from rfl ];
          simp +decide [ ← Nat.mul_mod ];
        haveI := Fact.mk hq; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ] ;
        replace hk := congr_arg ( ( ↑ ) : ℕ → ZMod q ) hk ; aesop;
      rcases q with ( _ | _ | _ | _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
      · grind;
      · exact ⟨ k, Or.inl rfl, by rw [ show k = ( k + 1 ) - 1 from by rw [ Nat.add_sub_cancel ] ] ; rw [ ← Nat.mod_add_div ( k + 1 ) ( q + 5 ) ] ; norm_num [ h_mod_q.symm ] ⟩

/-
If 3^q = 1 + kA and q = 2 mod 3, then k is 2 mod 3.
-/
lemma k_mod_3 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq_mod3 : q % 3 = 2) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 3 = 2 := by
  -- Reduce the equation modulo 3: $3^q \equiv 1 + kA \pmod{3}$.
  have h_mod : (3 : ℕ) ^ q % 3 = (1 + k * (A q)) % 3 := by
    rw [h_eq];
  norm_num [ Nat.zero_pow hq.pos, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, A ] at h_mod;
  have := Nat.mod_lt k zero_lt_three; interval_cases k % 3 <;> simp +decide only [hq_mod3] at h_mod ⊢;

/-
If 3^q = 1 + kA, then k is even.
-/
lemma k_mod_2 (q : ℕ) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 2 = 0 := by
  norm_num [ show A q = q^2 + q + 1 from rfl ] at *; replace h_eq := congr_arg ( fun n : ℕ => n % 2 ) h_eq ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at h_eq; ( have := Nat.mod_lt k zero_lt_two; interval_cases k % 2 <;> norm_num at *; );
  cases Nat.mod_two_eq_zero_or_one q <;> simp +decide [ *, Nat.add_mod, Nat.pow_mod ] at h_eq

/-
If 3^q = 1 + kA, then k is 2 mod 6q.
-/
lemma k_mod_6q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq_mod3 : q % 3 = 2) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % (6 * q) = 2 := by
  -- We know that $k$ is even (from $k_mod_2$) and $k \equiv 2 \pmod{q}$ (from $k_congruence$).
  have hk_mod_q : k % q = 2 := by
    have hk_congr : ∃ k', 3 ^ q = 1 + k' * A q ∧ k' % q = 2 := by
      apply k_congruence q hq (by
      norm_cast at *;
      aesop);
    aesop
  have hk_even : k % 2 = 0 := by
    exact?;
  -- Since $q$ is prime and greater than 3, $k$ must also be congruent to $2 \pmod{3}$.
  have hk_mod_3 : k % 3 = 2 := by
    exact?;
  -- Since $k$ is even and $k \equiv 2 \pmod{3}$, we can write $k = 6m + 2$ for some integer $m$.
  obtain ⟨m, hm⟩ : ∃ m, k = 6 * m + 2 := by
    exact ⟨ k / 6, by omega ⟩;
  -- Since $k \equiv 2 \pmod{q}$, we have $6m + 2 \equiv 2 \pmod{q}$, which simplifies to $6m \equiv 0 \pmod{q}$.
  have h_mod_q : 6 * m ≡ 0 [MOD q] := by
    exact Nat.modEq_zero_iff_dvd.mpr ⟨ k / q, by linarith [ Nat.mod_add_div k q ] ⟩;
  -- Since $q$ is prime and greater than 3, $q$ must divide $6m$.
  have h_div_q : q ∣ 6 * m := by
    exact Nat.dvd_of_mod_eq_zero h_mod_q;
  -- Since $q$ is prime and greater than 3, $q$ must divide $m$.
  have h_div_m : q ∣ m := by
    exact Or.resolve_left ( hq.dvd_mul.mp h_div_q ) ( by intro t; have := Nat.le_of_dvd ( by linarith ) t; interval_cases q <;> trivial );
  obtain ⟨ n, hn ⟩ := h_div_m; simp_all +decide [ Nat.add_mod, Nat.mul_mod_mul_left ] ;
  rw [ Nat.mod_eq_of_lt ( by linarith ) ]

/-
If 3^q = 1 mod A and q = 8 mod 9, then 3 is a cubic residue mod A.
-/
lemma three_is_cubic_residue (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) (hq9 : q % 9 = 8) :
    ∃ x : ZMod (A q), x ^ 3 = 3 := by
      -- Since $3$ is a $(q+1)$-th power residue mod $A$, we can write $3$ as a third power.
      obtain ⟨x, hx⟩ : ∃ x : ZMod (A q), x ^ (q + 1) = 3 := by
        convert is_q_plus_one_th_power_residue q hq hA h3 using 1;
      -- Since $q$ is a prime number greater than 3 and congruent to 8 modulo 9, $q$ must be odd and not divisible by 3. Therefore, $q+1$ is even and divisible by 3.
      have h_div : 3 ∣ (q + 1) := by
        omega;
      obtain ⟨ k, hk ⟩ := h_div; use x ^ k; rw [ ← hx, ← pow_mul, mul_comm, ← hk ] ;

/-
If 3^q = 1 + kA and q = 8 mod 9, then k is 8 mod 9.
-/
lemma k_mod_9 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 9 = 8 := by
  -- Since $3^q \equiv 0 \pmod{9}$ for $q \geq 2$, we have $0 \equiv 1 + k \cdot (q^2 + q + 1) \pmod{9}$.
  have h_mod9 : 0 ≡ 1 + k * (q^2 + q + 1) [MOD 9] := by
    -- Since $3^q \equiv 0 \pmod{9}$ for $q \geq 2$, we can substitute this into the equation $3^q = 1 + k * (q^2 + q + 1)$ to get $0 \equiv 1 + k * (q^2 + q + 1) \pmod{9}$.
    have h_mod9 : 3 ^ q ≡ 0 [MOD 9] := by
      exact Nat.modEq_zero_iff_dvd.mpr ( dvd_trans ( by decide ) ( pow_dvd_pow _ hq3 ) );
    exact h_mod9.symm.trans ( h_eq.symm ▸ rfl ) |> Nat.ModEq.trans ( by rfl ) ;
  norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq9 ] at h_mod9; ( have := Nat.mod_lt k ( by decide : 0 < 9 ) ; interval_cases k % 9 <;> trivial; )

/-
If 3^q = 1 + kA and q = 8 mod 9, then k is 12q + 2 mod 18q.
-/
lemma k_mod_18q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % (18 * q) = (12 * q + 2) % (18 * q) := by
  -- From k_mod_6q and k_mod_9, we have k = 6qn + 2 and k = 8 mod 9.
  obtain ⟨n, hn⟩ : ∃ n : ℕ, k = 6 * q * n + 2 := by
    have := k_mod_6q q hq hq3 ( by omega ) k h_eq;
    exact ⟨ k / ( 6 * q ), by rw [ ← this, Nat.div_add_mod ] ⟩
  have hn_mod : (6 * q * n + 2) % 9 = 8 := by
    rw [ ← hn ] ; exact k_mod_9 q hq hq3 hq9 k h_eq;
  have n_mod : n % 3 = 2 := by
    norm_num [ Nat.add_mod, Nat.mul_mod, hq9 ] at hn_mod; ( rw [ ← Nat.mod_mod_of_dvd n ( by decide : 3 ∣ 9 ) ] ; have := Nat.mod_lt n ( by decide : 0 < 9 ) ; interval_cases n % 9 <;> trivial; )
  obtain ⟨m, hm⟩ : ∃ m : ℕ, n = 3 * m + 2 := by
    exact ⟨ n / 3, by rw [ ← n_mod, Nat.div_add_mod ] ⟩
  use by
    rw [ hn, hm ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod_mul_left ] ;
    norm_num [ mul_assoc, Nat.mul_mod_mul_left ]

/-
If 3^q = 1 mod A and q = 8 mod 9, then 3 is a 9th power residue mod A.
-/
lemma three_is_ninth_power_residue (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) (hq9 : q % 9 = 8) :
    ∃ x : ZMod (A q), x ^ 9 = 3 := by
      -- By Lemma~\ref{lem:is_q_plus_one_th_power_residue}, 3 is a (q+1)-th power residue.
      obtain ⟨y, hy⟩ : ∃ y : ZMod (A q), y ^ (q + 1) = 3 := by
        apply is_q_plus_one_th_power_residue q hq hA h3;
      -- Since $q + 1 = 9m$, we can write $y^{q+1} = y^{9m} = (y^m)^9$.
      obtain ⟨m, hm⟩ : ∃ m, q + 1 = 9 * m := by
        exact Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, hq9 ] )
      generalize_proofs at *;
      use y ^ m; (
      rw [ ← pow_mul', ← hm, hy ]);

/-
If 3^q = 1 mod A and q = 35 mod 36, then 3 is a 36th power residue mod A.
-/
lemma three_is_36th_power_residue (q : ℕ) (hq : q.Prime) (hA : (A q).Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) (hq36 : q % 36 = 35) :
    ∃ x : ZMod (A q), x ^ 36 = 3 := by
      -- Since $3$ is a $(q+1)$-th power residue modulo $A$, we can write $3 = y^{q+1}$ for some $y$.
      obtain ⟨y, hy⟩ : ∃ y : ZMod (A q), y ^ (q + 1) = 3 := by
        convert is_q_plus_one_th_power_residue q hq hA h3 using 1;
      -- Since $q = 35 \mod 36$, we have $q + 1 = 36m$ for some integer $m$.
      obtain ⟨m, hm⟩ : ∃ m : ℕ, q + 1 = 36 * m := by
        exact ⟨ q / 36 + 1, by linarith [ Nat.mod_add_div q 36 ] ⟩;
      exact ⟨ y ^ m, by rw [ ← hy, hm, pow_mul' ] ⟩

/-
If 3^q = 1 + kA, then k is 2 mod 4.
-/
lemma k_mod_4 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 4 = 2 := by
  -- Since $q$ is odd, we have $3^q \equiv 3 \pmod{4}$.
  have hq_odd : q % 2 = 1 := by
    exact hq.eq_two_or_odd.resolve_left ( by linarith )
  have h3q_mod4 : (3^q) % 4 = 3 := by
    rw [ ← Nat.mod_add_div q 2, hq_odd ] ; norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
  unfold A at h_eq; replace h_eq := congr_arg ( fun t => t % 4 ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod, h3q_mod4 ] at h_eq; have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> norm_num at *;
  · rw [ ← Nat.mod_add_div q 4 ] at *; have := Nat.mod_lt q zero_lt_four; interval_cases q % 4 <;> norm_num [ Nat.add_mod, Nat.pow_mod ] at *;
  · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at h_eq; have := Nat.mod_lt q zero_lt_four; interval_cases q % 4 <;> contradiction;

/-
If 3^q = 1 + kA and q = 8 mod 9, then k is 26 mod 36.
-/
lemma k_mod_36 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 36 = 26 := by
  -- From Lemma k_mod_9, we have k ≡ 8 mod 9.
  have hk_mod_9 : k % 9 = 8 := by
    exact?;
  -- From Lemma k_mod_4, we have k ≡ 2 mod 4.
  have hk_mod_4 : k % 4 = 2 := by
    exact?;
  grind

/-
If 3^q = 1 + kA and q = 8 mod 9, then k + q is 25 mod 27.
-/
lemma k_plus_q_mod_27 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : (k + q) % 27 = 25 := by
  -- Since $3^q = 0 \mod 27$ for $q \geq 3$, we have $1 + k * A q = 0 \mod 27$, thus $k * A q = -1 \mod 27$.
  have h_mod27 : k * A q ≡ -1 [ZMOD 27] := by
    have h_mod27 : 3 ^ q ≡ 0 [ZMOD 27] := by
      exact Int.modEq_zero_iff_dvd.mpr ( dvd_trans ( by decide ) ( pow_dvd_pow _ hq3 ) );
    exact Int.modEq_iff_dvd.mpr ⟨ -h_mod27.symm.dvd.choose, by linarith [ h_mod27.symm.dvd.choose_spec ] ⟩;
  unfold A at *; norm_num [ Int.ModEq ] at *; norm_cast at *; simp_all +arith +decide;
  norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at *; ( rw [ ← Nat.mod_mod_of_dvd q ( by decide : 9 ∣ 27 ) ] at hq9; ( have := Nat.mod_lt k ( by decide : 0 < 27 ) ; ( have := Nat.mod_lt q ( by decide : 0 < 27 ) ; ( interval_cases k % 27 <;> norm_num1 at * <;> interval_cases q % 27 <;> simp +decide at h_mod27 ⊢; ) ) ) );
  all_goals contradiction;

/-
Definition of k_val as (3^q - 1) / A.
-/
noncomputable def k_val (q : ℕ) : ℕ := (3 ^ q - 1) / (A q)

/-
3^q = 1 + k_val * A.
-/
lemma k_val_spec (q : ℕ) (h3 : (3 : ZMod (A q)) ^ q = 1) : 3 ^ q = 1 + k_val q * (A q) := by
  -- By definition of $k_val$, we have $3^q = 1 + k_val * (A q)$.
  have h_def_k_val : (3 ^ q - 1) = k_val q * (A q) := by
    have h3_eq : A q ∣ 3 ^ q - 1 := by
      simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
    exact Eq.symm ( Nat.div_mul_cancel h3_eq );
  rw [ ← h_def_k_val, Nat.add_sub_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ]

/-
3^q is congruent to 1 + k_val * (1+q) modulo q^2.
-/
lemma k_val_spec_mod_q_sq (q : ℕ) (hq : q.Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    3 ^ q ≡ 1 + k_val q * (1 + q) [MOD q ^ 2] := by
      -- By definition of $k_val$, we have $3^q = 1 + k_val * (q^2 + q + 1)$.
      have h_eq : 3 ^ q = 1 + k_val q * (q^2 + q + 1) := by
        convert k_val_spec q h3 using 1;
      norm_num [ h_eq, mul_add, add_mul, add_comm, Nat.ModEq, Nat.add_mod, Nat.mul_mod ]

/-
k_val is positive.
-/
lemma k_val_pos (q : ℕ) (hq : q > 1) (h3 : (3 : ZMod (A q)) ^ q = 1) : k_val q > 0 := by
  refine' Nat.div_pos _ ( Nat.succ_pos _ );
  unfold A; rw [ Nat.le_sub_iff_add_le ];
  · rcases q with ( _ | _ | _ | _ | _ | q ) <;> norm_num [ Nat.pow_succ ] at *;
    exact Nat.recOn q ( by norm_num ) fun n ihn => by norm_num [ Nat.pow_succ' ] at * ; nlinarith;
  · exact Nat.one_le_pow _ _ ( by decide )

/-
k_val is less than 3^q.
-/
lemma k_val_lt_three_pow_q (q : ℕ) (hq : q > 1) : k_val q < 3 ^ q := by
  exact Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.sub_add_cancel <| Nat.one_le_pow q 3 zero_lt_three, show A q > 1 from by exact Nat.succ_lt_succ <| by nlinarith ] ;

/-
k_val is 2 mod q.
-/
lemma k_val_mod_q (q : ℕ) (hq : q.Prime) (h3 : (3 : ZMod (A q)) ^ q = 1) : k_val q % q = 2 := by
  -- From k_val_spec, we know 3^q = 1 + k_val q * A.
  have h_eq : 3 ^ q = 1 + k_val q * A q := by
    convert k_val_spec q h3 using 1;
  -- By k_congruence, there exists k such that 3^q = 1 + kA and k ≡ 2 mod q.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, 3 ^ q = 1 + k * A q ∧ k % q = 2 := by
    exact?;
  aesop

/-
The Feit-Thompson condition holds for q = 71, 107, 179.
-/
theorem feit_thompson_mod9_examples :
    check_ft_mod9_case 71 ∧ check_ft_mod9_case 107 ∧ check_ft_mod9_case 179 := by
      native_decide

/-
k is 8q + 34 mod 108.
-/
lemma k_mod_108 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 108 = (8 * q + 34) % 108 := by
  -- From the previous results, we have that $k = 27m + 25 - q$ for some integer $m$.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, k = 27 * m + 25 - q ∧ m % 4 = 3 * (1 + q) / 9 % 4 := by
    -- From the previous results, we have that $k = 27m + 25 - q$ for some integer $m$ and $m \equiv 3(1+q)/9 \pmod{4}$.
    have hm : ∃ m : ℕ, k = 27 * m + 25 - q := by
      have h_k_mod : k ≡ 25 - q [ZMOD 27] := by
        have h_k_mod : (k + q) % 27 = 25 := by
          convert k_plus_q_mod_27 q hq hq3 hq9 k h_eq using 1
        generalize_proofs at *; (
        exact Int.modEq_iff_dvd.mpr ⟨ - ( ( k + q ) / 27 ), by linarith [ Nat.mod_add_div ( k + q ) 27 ] ⟩ ;);
      obtain ⟨ m, hm ⟩ := h_k_mod.symm.dvd
      generalize_proofs at *; (
      exact ⟨ Int.toNat m, eq_tsub_of_add_eq <| by linarith [ Int.toNat_of_nonneg <| show ( 0 : ℤ ) ≤ m by linarith [ show ( k : ℤ ) ≥ 0 by positivity, show ( q : ℤ ) ≥ 0 by positivity ] ] ⟩)
    generalize_proofs at *; (
    obtain ⟨ m, hm ⟩ := hm; use m; have := k_mod_36 q hq hq3 hq9 k h_eq; simp_all +decide [ ← Nat.mod_mod_of_dvd _ ( show 9 ∣ 36 by decide ) ] ;
    grind +ring);
  contrapose! h_eq;
  -- If $27m + 25 < q$, then $k = 0$, which contradicts $k > 0$.
  have hk_zero : k = 0 := by
    omega;
  exact ne_of_gt ( by nlinarith [ Nat.pow_le_pow_right three_pos hq.two_le ] )

/-
Odd prime factors of k are 1 mod q.
-/
lemma k_prime_factors_mod_q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) (p : ℕ) (hp : p.Prime) (hpk : p ∣ k) (hp2 : p ≠ 2) : p % q = 1 := by
  -- Since p divides A q, we have p = q^2 + q + 1.
  have hp_eq_Aq : p ∣ 3 ^ q - 1 := by
    exact dvd_trans hpk ( by use A q; rw [ h_eq ] ; rw [ Nat.sub_eq_of_eq_add ] ; ring );
  -- So $3^q \equiv 1 \pmod{p}$.
  have h_cong : 3 ^ q ≡ 1 [MOD p] := by
    exact Nat.ModEq.symm <| Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using hp_eq_Aq;
  -- So $ord_p(3) \mid q$. Since $q$ is prime, $ord_p(3) = 1$ or $q$.
  have h_ord : orderOf (3 : ZMod p) ∣ q := by
    exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_cong )
  have h_ord_cases : orderOf (3 : ZMod p) = 1 ∨ orderOf (3 : ZMod p) = q := by
    rwa [ Nat.dvd_prime hq ] at h_ord;
  -- If $ord_p(3) = 1$, then $3 \equiv 1 \pmod{p}$, which implies $p \mid 2$, contradicting $p \neq 2$.
  by_cases h_ord_one : orderOf (3 : ZMod p) = 1;
  · haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
    rcases p with ( _ | _ | _ | _ | p ) <;> cases h_ord_one <;> trivial;
  · -- If $ord_p(3) = q$, then $q \mid p-1$.
    have h_div : q ∣ p - 1 := by
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      exact h_ord_cases ▸ orderOf_dvd_iff_pow_eq_one.mpr ( by rw [ ZMod.pow_card_sub_one_eq_one ] ; aesop );
    obtain ⟨ m, hm ⟩ := h_div; rw [ tsub_eq_iff_eq_add_of_le hp.one_lt.le ] at hm; norm_num [ Nat.add_mod, Nat.mod_eq_of_lt hq.one_lt, hm ] ;

/-
k is 2 mod 4q.
-/
lemma k_mod_4q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % (4 * q) = 2 := by
  -- By the Chinese Remainder Theorem, there exists a unique solution modulo $4q$ to the system of congruences $k \equiv 2 \pmod{q}$ and $k \equiv 2 \pmod{4}$.
  obtain ⟨N, hN⟩ : ∃ N : ℕ, k = N * q + 2 := by
    have := k_congruence q hq ( show ( 3 : ZMod ( A q ) ) ^ q = 1 from ?_ );
    · obtain ⟨ N, hN ⟩ := this; use k / q; linarith [ Nat.mod_add_div k q, show k % q = 2 from by { have := congr_arg ( · % q ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq.ne_zero ] at *; aesop } ] ;
    · replace h_eq := congr_arg ( ( ↑ ) : ℕ → ZMod ( A q ) ) h_eq ; aesop;
  -- Since $k \equiv 2 \pmod{4}$, we have $N * q + 2 \equiv 2 \pmod{4}$, which simplifies to $N * q \equiv 0 \pmod{4}$.
  have hNq_mod_4 : N * q % 4 = 0 := by
    have hNq_mod_4 : (N * q + 2) % 4 = 2 := by
      have := k_mod_4 q hq hq3 k h_eq; aesop;
    exact Nat.mod_eq_zero_of_dvd ( by omega );
  -- Since $q$ is odd, $N$ must be divisible by 4.
  have hN_div_4 : 4 ∣ N := by
    exact Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime 4 q from Nat.Coprime.pow_left 2 <| Nat.prime_two.coprime_iff_not_dvd.2 <| by simpa [ ← even_iff_two_dvd, parity_simps ] using hq.eq_two_or_odd'.resolve_left <| by linarith ) <| Nat.dvd_of_mod_eq_zero hNq_mod_4;
  obtain ⟨ m, rfl ⟩ := hN_div_4; norm_num [ Nat.add_mod, Nat.mul_mod, hN ] ; ring_nf; norm_num;
  norm_num [ mul_assoc, mul_comm, mul_left_comm, Nat.add_mod, Nat.mul_mod_mul_left ];
  rw [ Nat.mod_eq_of_lt ( by linarith ) ]

/-
If all prime factors of m are 1 mod q, then m is 1 mod q.
-/
lemma nat_mod_q_of_prime_factors_mod_q (m q : ℕ) (hm : m > 0) (hq : q > 1)
    (h : ∀ p, p.Prime → p ∣ m → p % q = 1) : m % q = 1 := by
      -- By definition of prime factorization, we can write m as a product of its prime factors.
      have h_factorization : m = ∏ p ∈ Nat.primeFactors m, p ^ (Nat.factorization m p) := by
        exact Eq.symm ( Nat.factorization_prod_pow_eq_self hm.ne' );
      conv_lhs => rw [ h_factorization ];
      rw [ Finset.prod_nat_mod, Finset.prod_eq_one ] <;> norm_num [ h ];
      · exact Nat.mod_eq_of_lt hq;
      · exact fun p pp dp _ => by rw [ Nat.pow_mod, h p pp dp ] ; norm_num [ Nat.mod_eq_of_lt hq ] ;

/-
Definition of m_val as k_val / 2.
-/
noncomputable def m_val (q : ℕ) : ℕ := k_val q / 2

/-
m_val is odd.
-/
lemma m_val_odd (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h3 : (3 : ZMod (A q)) ^ q = 1) : m_val q % 2 = 1 := by
  -- By definition of $k_val$, we know that $k_val q = 2$ mod $4$.
  have hk_val_mod_4 : k_val q % 4 = 2 := by
    -- Apply the lemma that states k_val q % 4 = 2.
    apply k_mod_4 q hq hq3 (k_val q) (k_val_spec q h3);
  unfold m_val; omega;

/-
m_val is 1 mod q.
-/
lemma m_val_mod_q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h3 : (3 : ZMod (A q)) ^ q = 1) : m_val q % q = 1 := by
  -- By definition of $m_val$, we have $k_val q = 2 * m_val q$.
  have hk_val_eq : k_val q = 2 * m_val q := by
    have hk_val_eq : k_val q % 2 = 0 := by
      convert k_mod_2 q _ _ using 1;
      convert k_val_spec q h3 using 1;
    exact Eq.symm ( Nat.mul_div_cancel' ( Nat.dvd_of_mod_eq_zero hk_val_eq ) );
  have := k_val_mod_q q hq h3; simp_all +decide [ Nat.mul_mod ];
  rcases q with ( _ | _ | _ | _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
  -- Since $q + 5$ is prime and greater than 2, it is coprime with 2.
  have h_coprime : Nat.gcd 2 (q + 5) = 1 := by
    exact Nat.coprime_comm.mp ( hq.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by norm_num ) h; interval_cases _ : q + 5 <;> simp_all +decide );
  have h_div : 2 * m_val (q + 5) ≡ 2 [MOD (q + 5)] → m_val (q + 5) ≡ 1 [MOD (q + 5)] := by
    have h_div : ∃ x, 2 * x ≡ 1 [MOD (q + 5)] := by
      have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime; aesop;
    obtain ⟨ x, hx ⟩ := h_div; intro h; have := hx.mul_left ( m_val ( q + 5 ) ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    linear_combination' h * x - hx * m_val ( q + 5 ) + hx * 1;
  exact h_div this ▸ Nat.mod_eq_of_lt ( by linarith )

/-
m_val is 4q + 17 mod 54.
-/
lemma m_val_mod_54 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) : m_val q % 54 = (4 * q + 17) % 54 := by
  -- By definition of $k_val$, we know that $k_val q = 8 * q + 34$ modulo 108.
  have h_k_val_mod_108 : k_val q % 108 = (8 * q + 34) % 108 := by
    convert k_mod_108 q hq hq3 hq9 ( k_val q ) ( k_val_spec q ( mod_cast h3 ) ) using 1;
  unfold m_val; omega;

/-
m_val is 4q + 17 mod 54.
-/
lemma m_val_mod_54_new (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) : m_val q % 54 = (4 * q + 17) % 54 := by
  -- By definition of $k_val$, we know that $k_val q = 8 * q + 34$ modulo 108.
  have h_k_val_mod_108 : k_val q % 108 = (8 * q + 34) % 108 := by
    convert k_mod_108 q hq hq3 hq9 ( k_val q ) ( k_val_spec q ( mod_cast h3 ) ) using 1;
  unfold m_val; omega;

/-
k is 8q + 34 mod 108.
-/
lemma k_mod_108_val (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (k : ℕ) (h_eq : 3 ^ q = 1 + k * (A q)) : k % 108 = (8 * q + 34) % 108 := by
  -- From the previous results, we have that $k = 27m + 25 - q$ for some integer $m$.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, k = 27 * m + 25 - q ∧ m % 4 = 3 * (1 + q) / 9 % 4 := by
    -- From the previous results, we have that $k = 27m + 25 - q$ for some integer $m$ and $m \equiv 3(1+q)/9 \pmod{4}$.
    have hm : ∃ m : ℕ, k = 27 * m + 25 - q := by
      have h_k_mod : k ≡ 25 - q [ZMOD 27] := by
        have h_k_mod : (k + q) % 27 = 25 := by
          convert k_plus_q_mod_27 q hq hq3 hq9 k h_eq using 1
        generalize_proofs at *; (
        exact Int.modEq_iff_dvd.mpr ⟨ - ( ( k + q ) / 27 ), by linarith [ Nat.mod_add_div ( k + q ) 27 ] ⟩ ;);
      obtain ⟨ m, hm ⟩ := h_k_mod.symm.dvd
      generalize_proofs at *; (
      exact ⟨ Int.toNat m, eq_tsub_of_add_eq <| by linarith [ Int.toNat_of_nonneg <| show ( 0 : ℤ ) ≤ m by linarith [ show ( k : ℤ ) ≥ 0 by positivity, show ( q : ℤ ) ≥ 0 by positivity ] ] ⟩)
    generalize_proofs at *; (
    obtain ⟨ m, hm ⟩ := hm; use m; have := k_mod_36 q hq hq3 hq9 k h_eq; simp_all +decide [ ← Nat.mod_mod_of_dvd _ ( show 9 ∣ 36 by decide ) ] ;
    grind +ring);
  contrapose! h_eq;
  -- If $27m + 25 < q$, then $k = 0$, which contradicts $k > 0$.
  have hk_zero : k = 0 := by
    omega;
  exact ne_of_gt ( by nlinarith [ Nat.pow_le_pow_right three_pos hq.two_le ] )

/-
Definition of n_val.
-/
noncomputable def n_val (q : ℕ) : ℕ := (k_val q - (8 * q + 34)) / 108

/-
k_val is 108 * n_val + 8q + 34.
-/
lemma n_val_spec (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    k_val q = 108 * n_val q + 8 * q + 34 := by
      -- By definition of $k_val$, we know that $k_val q \equiv 8q + 34 \pmod{108}$.
      have hk_val_mod : k_val q % 108 = (8 * q + 34) % 108 := by
        convert k_mod_108 q hq hq3 hq9 ( k_val q ) _ using 1;
        convert k_val_spec q _;
        convert h3 using 1;
      -- By definition of $n_val$, we know that $k_val q = 108 * n_val q + 8q + 34$.
      have hn_val : k_val q ≥ 8 * q + 34 := by
        have hn_val : k_val q > 0 := by
          exact k_val_pos q ( by linarith ) ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h3 );
        contrapose! hn_val;
        have h_contra : 3 ^ q ≤ 1 + (8 * q + 34) * (q ^ 2 + q + 1) := by
          have h_contra : 3 ^ q = 1 + k_val q * (q ^ 2 + q + 1) := by
            convert k_val_spec q h3 using 1;
          exact h_contra.le.trans ( by gcongr );
        rcases q with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | q ) <;> norm_num [ Nat.pow_succ' ] at *;
        exact absurd h_contra ( by { exact Nat.recOn q ( by norm_num ) fun n ihn => by norm_num [ Nat.pow_succ' ] at * ; nlinarith only [ ihn, pow_pos ( show 0 < 3 by norm_num ) n ] } );
      unfold n_val; omega;

/-
27 * n_val = -8 mod q.
-/
lemma n_val_mod_q (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    (27 : ZMod q) * n_val q = -8 := by
      -- From Lemma 2, we know that $k_val q = 108 * n_val q + 8q + 34$.
      have h_k_val : k_val q = 108 * n_val q + 8 * q + 34 := by
        exact?;
      -- From Lemma 1, we know that $k_val q \equiv 2 \pmod{q}$.
      have h_k_val_mod_q : k_val q ≡ 2 [ZMOD q] := by
        have h_k_val_mod_q : k_val q % q = 2 := by
          convert k_val_mod_q q hq h3 using 1;
        exact Int.ModEq.symm <| Int.modEq_of_dvd <| by use k_val q / q; linarith [ Nat.mod_add_div ( k_val q ) q ] ;
      haveI := Fact.mk hq; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      exact mul_left_cancel₀ ( show ( 4 : ZMod q ) ≠ 0 from by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases q ; trivial ) ( by linear_combination' h_k_val_mod_q )

/-
n_val is not zero.
-/
lemma n_val_ne_zero (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) : n_val q ≠ 0 := by
  -- If $n_val q = 0$, then $8 = 0$ in $ZMod q$, which implies $q \mid 8$.
  by_contra h_contra
  have h_div : q ∣ 8 := by
    have h_div : (27 * n_val q : ZMod q) = -8 := by
      -- Apply the lemma n_val_mod_q to conclude the proof.
      apply n_val_mod_q q hq hq3 hq9 h3;
    haveI := Fact.mk hq; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
  have := Nat.le_of_dvd ( by decide ) h_div; interval_cases q <;> contradiction;

/-
Definition and property of Fermat quotient.
-/
def fermatQuotient (p a : ℕ) : ℕ := (a ^ (p - 1) - 1) / p

lemma fermatQuotient_spec (p a : ℕ) (hp : p.Prime) (ha : ¬ p ∣ a) :
    a ^ (p - 1) = 1 + p * fermatQuotient p a := by
      rw [ fermatQuotient ]; ring;
      rw [ Nat.mul_div_cancel' ];
      · rw [ Nat.add_sub_cancel' ( Nat.one_le_pow _ _ ( Nat.pos_of_ne_zero ( by aesop ) ) ) ];
      · haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( Nat.one_le_pow _ _ ( Nat.pos_of_ne_zero ( by aesop : a ≠ 0 ) ) ) ] ;
        rw [ sub_eq_zero, ZMod.pow_card_sub_one_eq_one ha ]

/-
27 * n_val + 8 = j_val * q.
-/
noncomputable def j_val (q : ℕ) : ℕ := (27 * n_val q + 8) / q

lemma j_val_spec (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) :
    27 * n_val q + 8 = j_val q * q := by
      -- By definition of $j_val$, we have $j_val q = (27 * n_val q + 8) / q$.
      have hj_val_def : j_val q = (27 * n_val q + 8) / q := by
        exact?;
      rw [ hj_val_def, Nat.div_mul_cancel ];
      have h_div : 27 * n_val q + 8 ≡ 0 [ZMOD q] := by
        have h_div : (27 : ZMod q) * n_val q = -8 := by
          exact?;
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      exact_mod_cast Int.dvd_of_emod_eq_zero h_div

/-
n_val is positive for q >= 17.
-/
lemma n_val_pos (q : ℕ) (hq : q.Prime) (hq9 : q % 9 = 8) (h3 : (3 : ZMod (A q)) ^ q = 1) : n_val q > 0 := by
  by_cases h17 : q ≥ 17;
  · -- Since $q \geq 17$, we have $3^q > (142 + 8q) * (q^2 + q + 1)$.
    have h_exp_growth : 3 ^ q > (142 + 8 * q) * (q ^ 2 + q + 1) := by
      exact Nat.le_induction ( by norm_num ) ( fun k hk ih ↦ by norm_num [ Nat.pow_succ' ] at * ; nlinarith ) q h17;
    refine' Nat.div_pos _ ( by decide );
    refine' Nat.le_sub_of_add_le' _;
    rw [ show k_val q = ( 3 ^ q - 1 ) / ( q ^ 2 + q + 1 ) from rfl ];
    exact Nat.le_div_iff_mul_le ( by positivity ) |>.2 ( Nat.le_sub_one_of_lt ( by nlinarith only [ h_exp_growth ] ) );
  · interval_cases q <;> norm_num at *