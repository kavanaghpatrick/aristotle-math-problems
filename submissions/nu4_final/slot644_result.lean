/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 164c4fe4-f634-41f5-92f0-e7ef4df95462

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The radical of a number n is the product of its distinct prime factors.
-/
def radical (n : ℕ) : ℕ := ∏ p ∈ n.primeFactors, p

/-
A number n is powerful (or squarefull) if for every prime p dividing n, p^2 also divides n.
-/
def IsPowerful (n : ℕ) : Prop := ∀ p, p.Prime → p ∣ n → p ^ 2 ∣ n

/-
The ABC conjecture states that for every ε > 0, there exists a constant K_ε such that for all coprime positive integers a, b, c with a + b = c, we have c < K_ε * rad(abc)^(1+ε).
-/
def ABC_conjecture : Prop :=
  ∀ ε > 0, ∃ K_ε > 0, ∀ a b c : ℕ,
    0 < a → 0 < b → 0 < c →
    Nat.Coprime a b → a + b = c →
    (c : ℝ) < K_ε * (radical (a * b * c) : ℝ) ^ (1 + ε)

/-
If n is a powerful number, then the exponent of every prime factor p of n is at least 2.
-/
lemma powerful_implies_factorization_ge_2 {n : ℕ} (h : IsPowerful n) {p : ℕ} (hp : p ∈ n.primeFactors) : 2 ≤ n.factorization p := by
  have := h p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp );
  rw [ ← Nat.factorization_le_iff_dvd ] at this <;> aesop

/-
For a non-zero powerful number n, the square of its radical is less than or equal to n.
-/
lemma radical_sq_le_self_of_powerful {n : ℕ} (h0 : n ≠ 0) (h : IsPowerful n) : (radical n) ^ 2 ≤ n := by
  -- By definition of radical, we have that radical n = ∏ p ∈ n.primeFactors, p.
  have h_radical_def : radical n = ∏ p ∈ n.primeFactors, p := by
    rfl;
  -- Since n is powerful, for every prime p|n, p^2 | n. This means the exponent of p in the prime factorization of n is at least 2.
  have h_exponent_ge_2 : ∀ p ∈ n.primeFactors, 2 ≤ n.factorization p := by
    exact?;
  conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self h0 ];
  rw [ h_radical_def, ← Finset.prod_pow ];
  exact Finset.prod_le_prod' fun p hp => Nat.pow_le_pow_right ( Nat.pos_of_mem_primeFactors hp ) ( h_exponent_ge_2 p hp )

/-
If n and n+2 are both powerful numbers, then n must be odd.
-/
lemma odd_of_powerful_n_n_plus_2 {n : ℕ} (hn : IsPowerful n) (hn2 : IsPowerful (n + 2)) : Odd n := by
  -- If n is even, then 2 divides n.
  by_cases h_even : Even n
  obtain ⟨k, hk⟩ : ∃ k, n = 2 * k := by
    exact even_iff_two_dvd.mp h_even
  have h₂_even : Even (n + 2) := by
    simp +arith +decide [ *, parity_simps ]
  have h₂_div : 4 ∣ (n + 2) := by
    exact hn2 2 Nat.prime_two ( even_iff_two_dvd.mp h₂_even ) |> fun x => dvd_trans ( by decide ) x;
  have h₂_mod : (n + 2) % 4 = 2 := by
    rcases h₂_div with ⟨ m, hm ⟩ ; replace hn := hn 2 Nat.prime_two ; simp_all +decide [ Nat.pow_succ', ← even_iff_two_dvd, parity_simps ] ;
    omega
  contrapose! h₂_div
  skip;
  · norm_num [ Nat.dvd_iff_mod_eq_zero, h₂_mod ];
  · simpa using h_even

/-
For a non-zero powerful number n, its radical is at most its square root.
-/
lemma radical_le_sqrt {n : ℕ} (h0 : n ≠ 0) (h : IsPowerful n) : radical n ≤ Real.sqrt n := by
  exact Real.le_sqrt_of_sq_le ( mod_cast radical_sq_le_self_of_powerful h0 h )

/-
If n, n+1, n+2 are powerful, then the radical of n(n+2)(n+1)^2 is bounded by sqrt(n(n+2)) * sqrt(n+1).
-/
lemma radical_bound_triple {n : ℕ} (hn : IsPowerful n) (hn1 : IsPowerful (n + 1)) (hn2 : IsPowerful (n + 2)) :
  (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) ≤ Real.sqrt (n * (n + 2)) * Real.sqrt (n + 1) := by
    -- Since n and n+2 are powerful, n is odd (by odd_of_powerful_n_n_plus_2).
    have h_odd : Odd n := by
      exact?;
    -- Thus gcd(n, n+2) = gcd(n, 2) = 1.
    have h_coprime : Nat.gcd n (n + 2) = 1 := by
      cases h_odd ; aesop
    have h_coprime_sq : Nat.gcd (n * (n + 2)) ((n + 1) ^ 2) = 1 := by
      simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ];
    -- So the radical of the product is the product of the radicals.
    have h_radical : radical (n * (n + 2) * (n + 1) ^ 2) = radical n * radical (n + 2) * radical (n + 1) := by
      have h_radical : radical (n * (n + 2) * (n + 1) ^ 2) = (∏ p ∈ (n * (n + 2) * (n + 1) ^ 2).primeFactors, p) := by
        rfl;
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.primeFactors_mul, Finset.prod_union ];
      · exact absurd ( hn2 3 Nat.prime_three ) ( by decide );
      · simp_all +decide [ radical, Nat.primeFactors_pow ];
        rw [ Finset.prod_union ( Nat.Coprime.disjoint_primeFactors <| by { exact Nat.Coprime.coprime_dvd_left ( by norm_num ) h_coprime_sq } ) ] ; ring;
    -- Using radical_le_sqrt for each:
    have h_radical_le_sqrt : radical n ≤ Real.sqrt n ∧ radical (n + 2) ≤ Real.sqrt (n + 2) ∧ radical (n + 1) ≤ Real.sqrt (n + 1) := by
      exact ⟨ radical_le_sqrt ( by aesop ) hn, mod_cast radical_le_sqrt ( by aesop ) hn2, mod_cast radical_le_sqrt ( by aesop ) hn1 ⟩;
    rw [ Real.sqrt_mul <| by positivity ] ; push_cast [ * ] ; exact mul_le_mul ( mul_le_mul h_radical_le_sqrt.1 h_radical_le_sqrt.2.1 ( by positivity ) <| by positivity ) h_radical_le_sqrt.2.2 ( by positivity ) <| by positivity;

/-
For any natural number n, n(n+2) and (n+1)^2 are coprime.
-/
lemma coprime_n_mul_n_plus_two_sq_n_plus_one (n : ℕ) : Nat.Coprime (n * (n + 2)) ((n + 1) ^ 2) := by
  norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
  norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ]

/-
The number 2 is not a powerful number.
-/
lemma not_powerful_two : ¬ IsPowerful 2 := by
  exact fun h => absurd ( h 2 Nat.prime_two ( by decide ) ) ( by decide )

/-
If n, n+1, n+2 are powerful numbers, then n must be positive.
-/
lemma n_pos_of_powerful_triple {n : ℕ} (hn : IsPowerful n) (hn1 : IsPowerful (n + 1)) (hn2 : IsPowerful (n + 2)) : 0 < n := by
  -- If $n = 0$, then $n + 2 = 2$, which is not powerful (by not_powerful_two).
  by_contra h_contra
  have h_contra2 : ¬IsPowerful 2 := by
    exact?
  aesop

/-
If n, n+1, n+2 are powerful, the radical of their product is strictly less than (n+1)^(3/2).
-/
lemma radical_bound_simplified {n : ℕ} (hn : IsPowerful n) (hn1 : IsPowerful (n + 1)) (hn2 : IsPowerful (n + 2)) :
  (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) < (n + 1 : ℝ) ^ (3 / 2 : ℝ) := by
    -- From radical_bound_triple, we have rad <= sqrt(n(n+2)) * sqrt(n+1).
    have h_rad_le : (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) ≤ Real.sqrt (n * (n + 2)) * Real.sqrt (n + 1) := by
      convert radical_bound_triple hn hn1 hn2 using 1;
    -- We know that $n(n+2) < (n+1)^2$, so $\sqrt{n(n+2)} < \sqrt{(n+1)^2} = n+1$.
    have h_sqrt_lt : Real.sqrt (n * (n + 2)) < n + 1 := by
      rw [ Real.sqrt_lt' ] <;> nlinarith only [ show ( n : ℝ ) > 0 from Nat.cast_pos.mpr ( n_pos_of_powerful_triple hn hn1 hn2 ) ];
    convert lt_of_le_of_lt h_rad_le ( mul_lt_mul_of_pos_right h_sqrt_lt ( Real.sqrt_pos.mpr ( by positivity : 0 < ( n:ℝ ) + 1 ) ) ) using 1 ; rw [ show ( ( n:ℝ ) + 1 ) ^ ( 3/2:ℝ ) = ( ( n:ℝ ) + 1 ) * Real.sqrt ( ( n:ℝ ) + 1 ) by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ; positivity ]

/-
If x^2 < K * x^(7/4) for positive x and K, then x < K^4.
-/
lemma real_bound_of_inequality {x K : ℝ} (hx : 0 < x) (hK : 0 < K) (h : x ^ 2 < K * x ^ (7 / 4 : ℝ)) : x < K ^ 4 := by
  -- Divide both sides by $x^{7/4}$ to get $x^{2 - 7/4} < K$, which simplifies to $x^{1/4} < K$.
  have h_div : x ^ (1 / 4 : ℝ) < K := by
    contrapose! h;
    exact le_trans ( mul_le_mul_of_nonneg_right h ( by positivity ) ) ( by rw [ ← Real.rpow_natCast, ← Real.rpow_add hx ] ; norm_num );
  exact lt_of_le_of_lt ( by norm_num [ ← Real.rpow_natCast, ← Real.rpow_mul hx.le ] ) ( pow_lt_pow_left₀ h_div ( by positivity ) ( by norm_num ) )