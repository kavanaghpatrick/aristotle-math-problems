/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ec96692a-4350-4662-b37a-6bcee1004e5c
-/

/-
We have successfully formalized and proved the `cycle4_disjoint_partition` theorem, which states that given a 4-cycle structure in a maximal triangle packing, the set of all triangles can be partitioned into four disjoint sets `T1`, `T2`, `T3`, `T4` based on which shared vertex they contain (using a priority ordering).

Key components:
1.  **Definitions**: `isTrianglePacking`, `trianglePackingNumber`, `isMaxPacking`, `isCycle4`, `sharedVertices`, and the partition sets `T1`, `T2`, `T3`, `T4`.
2.  **Helper Lemmas**:
    *   `triangle_shares_edge_with_packing`: Every triangle shares at least 2 vertices with some triangle in the packing.
    *   `pigeonhole_triangle`: If a triangle shares 2 vertices with another triangle, it must contain at least one of two specific vertices.
    *   `cycle4_all_triangles_contain_shared`: Every triangle contains at least one shared vertex from the cycle.
    *   `T*_T*_disjoint`: The partition sets are pairwise disjoint by construction.
    *   `disjoint_partition_covers_all`: The union of the partition sets covers all triangles.
3.  **Main Theorem**: `cycle4_disjoint_partition` combines the disjointness and covering properties to prove the partition is valid.

All proofs were completed by the ATP.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

-- ══════════════════════════════════════════════════════════════════════════════
-- CYCLE_4 STRUCTURE
-- ══════════════════════════════════════════════════════════════════════════════

/-- CYCLE_4: A—B—C—D—A forms a 4-cycle in the sharing graph -/
def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ A ≠ C ∧ A ≠ D ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧  -- A shares vertex with B (call it v_ab)
  (B ∩ C).card = 1 ∧  -- B shares vertex with C (call it v_bc)
  (C ∩ D).card = 1 ∧  -- C shares vertex with D (call it v_cd)
  (D ∩ A).card = 1 ∧  -- D shares vertex with A (call it v_da)
  (A ∩ C).card = 0 ∧  -- A and C are opposite (disjoint)
  (B ∩ D).card = 0    -- B and D are opposite (disjoint)

/-- Extract shared vertices from cycle_4 -/
def sharedVertices (A B C D : Finset V)
    (hab : (A ∩ B).card = 1) (hbc : (B ∩ C).card = 1)
    (hcd : (C ∩ D).card = 1) (hda : (D ∩ A).card = 1) : Finset V :=
  (A ∩ B) ∪ (B ∩ C) ∪ (C ∩ D) ∪ (D ∩ A)

/-- PROVEN: Every triangle in G shares an edge with some packing element -/
lemma triangle_shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ X ∈ M, (t ∩ X).card ≥ 2 := by
  -- By maximality: if t shares no edge with any X ∈ M, then M ∪ {t} is a larger packing
  -- Assume that the new triangle $t$ can be added to the packing $M$ without violating the triangle packing condition.
  by_contra h_contra;
  -- If no such $X$ exists, then $M \cup \{t\}$ would be a larger packing, contradicting the maximality of $M$.
  have h_larger_packing : isTrianglePacking G (M ∪ {t}) := by
    refine' ⟨ _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
    · simp_all +decide [ Finset.subset_iff, SimpleGraph.cliqueFinset ];
      exact fun x hx => by have := hM.1.1 hx; aesop;
    · intro x hx y hy hxy; by_cases hx' : x = t <;> by_cases hy' : y = t <;> simp_all +decide ;
      · exact Nat.le_of_lt_succ ( h_contra y hy );
      · simpa only [ Finset.inter_comm ] using Nat.le_of_lt_succ ( h_contra x hx );
      · have := hM.1.2; aesop;
  have h_card : (M ∪ {t}).card > M.card := by
    -- Since $t$ is not in $M$, adding $t$ to $M$ increases the cardinality by 1.
    have h_t_not_in_M : t ∉ M := by
      rintro h; specialize h_contra; simp_all +decide [ Finset.inter_comm ] ;
      exact absurd ( h_contra t h ) ( by rw [ Finset.inter_self ] ; exact not_lt_of_ge ( by simpa [ ht.card_eq ] ) );
    rw [ Finset.card_union ] ; aesop;
  have h_contradiction : (Finset.image Finset.card (Finset.powerset (G.cliqueFinset 3) |>.filter (isTrianglePacking G))).max.getD 0 ≥ (M ∪ {t}).card := by
    have h_contradiction : (M ∪ {t}) ∈ Finset.filter (isTrianglePacking G) (Finset.powerset (G.cliqueFinset 3)) := by
      simp_all +decide [ Finset.subset_iff ];
      exact fun x hx => Finset.mem_filter.mp ( h_larger_packing.1 ( Finset.mem_insert_of_mem hx ) ) |>.2;
    have := Finset.le_max ( Finset.mem_image_of_mem Finset.card h_contradiction );
    cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
  exact h_card.not_le ( hM.2 ▸ h_contradiction ) -- This is proven in prior Aristotle runs

/-
If a triangle `t` shares at least 2 vertices with a triangle `A` of size 3, and `A` contains two distinct vertices `v1, v2`, then `t` must contain at least one of `v1` or `v2`.
-/
lemma pigeonhole_triangle (A : Finset V) (t : Finset V) (v1 v2 : V)
    (hA : A.card = 3) (h_inter : (t ∩ A).card ≥ 2)
    (hv1 : v1 ∈ A) (hv2 : v2 ∈ A) (h_diff : v1 ≠ v2) :
    v1 ∈ t ∨ v2 ∈ t := by
  -- If neither v1 nor v2 is in t, then t ∩ A must be contained in A \ {v1, v2}
  -- But A \ {v1, v2} has size 1 (since |A|=3), while |t ∩ A| >= 2. Contradiction.
  by_contra h_contra; push_neg at h_contra; exact (by
  -- Since $v1$ and $v2$ are not in $t$, the intersection $t \cap A$ must be a subset of $A \setminus \{v1, v2\}$.
  have h_inter_subset : t ∩ A ⊆ A \ {v1, v2} := by
    aesop_cat;
  have := Finset.card_mono h_inter_subset; simp_all +decide [ Finset.card_sdiff ] ;
  linarith)

/-- PROVEN: In cycle_4, every triangle contains at least one shared vertex -/
lemma cycle4_all_triangles_contain_shared (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hcycle : isCycle4 M A B C D) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ v ∈ sharedVertices A B C D hcycle.2.2.2.2.2.2.2.1 hcycle.2.2.2.2.2.2.2.2.1
      hcycle.2.2.2.2.2.2.2.2.2.1 hcycle.2.2.2.2.2.2.2.2.2.2.1, v ∈ t := by
  -- Uses triangle_shares_edge_with_packing plus cycle_4 structure
  obtain ⟨X, hX₁, hX₂⟩ : ∃ X ∈ M, (t ∩ X).card ≥ 2 := triangle_shares_edge_with_packing G M hM t ht;
  rcases hcycle with ⟨ rfl, h ⟩;
  simp_all +decide [ Finset.ext_iff ];
  rcases hX₁ with ( hX₁ | hX₁ | hX₁ | hX₁ );
  · -- Since $A$ contains $v_ab$ (from $A \cap B$) and $v_da$ (from $D \cap A$), and $v_ab \neq v_da$ because $B \cap D = \emptyset$, we can apply `pigeonhole_triangle`.
    obtain ⟨v_ab, hv_ab⟩ : ∃ v_ab, v_ab ∈ A ∩ B := by
      exact Finset.card_pos.mp ( by linarith )
    obtain ⟨v_da, hv_da⟩ : ∃ v_da, v_da ∈ D ∩ A := by
      exact Finset.card_pos.mp ( by linarith )
    have hv_ab_ne_hv_da : v_ab ≠ v_da := by
      intro h_eq; simp_all +decide [ Finset.ext_iff ] ;
    have := pigeonhole_triangle A t v_ab v_da ?_ ?_ ?_ ?_ ?_ <;> simp_all +decide [ Finset.inter_comm ];
    · exact this.elim ( fun h => ⟨ v_ab, by unfold sharedVertices; aesop ⟩ ) fun h => ⟨ v_da, by unfold sharedVertices; aesop ⟩;
    · have := hM.1.1; simp_all +decide [ Finset.subset_iff ] ;
      exact this.1.2;
    · convert hX₂ using 1;
      exact congr_arg Finset.card ( by ext; aesop );
  · -- Since $B$ contains $v_{ab}$ and $v_{bc}$, and $v_{ab} \neq v_{bc}$, we can apply `pigeonhole_triangle`.
    obtain ⟨v_ab, hv_ab⟩ : ∃ v_ab ∈ B, v_ab ∈ A := by
      exact Exists.elim ( Finset.card_pos.mp ( by linarith ) ) fun x hx => ⟨ x, Finset.mem_of_mem_inter_right hx, Finset.mem_of_mem_inter_left hx ⟩
    obtain ⟨v_bc, hv_bc⟩ : ∃ v_bc ∈ B, v_bc ∈ C := by
      exact Exists.elim ( Finset.card_pos.mp ( by linarith ) ) fun x hx => ⟨ x, Finset.mem_of_mem_inter_left hx, Finset.mem_of_mem_inter_right hx ⟩
    have h_diff : v_ab ≠ v_bc := by
      intro h; simp_all +decide [ Finset.ext_iff ] ;
    have h_pigeonhole : v_ab ∈ t ∨ v_bc ∈ t := by
      apply pigeonhole_triangle B t v_ab v_bc;
      · have := hM.1; simp_all +decide [ isTrianglePacking ] ;
        simp_all +decide [ Finset.subset_iff, SimpleGraph.isNClique_iff ];
      · exact hX₂.trans ( Finset.card_mono fun x hx => by aesop );
      · tauto;
      · tauto;
      · exact h_diff;
    unfold sharedVertices; aesop;
  · -- Let $v1$ and $v2$ be the shared vertices of $C$.
    obtain ⟨v1, hv1⟩ : ∃ v1, v1 ∈ B ∩ C := by
      exact Finset.card_pos.mp ( by linarith )
    obtain ⟨v2, hv2⟩ : ∃ v2, v2 ∈ C ∩ D := by
      exact Finset.card_pos.mp ( by linarith );
    -- By the pigeonhole principle, since $t$ shares at least 2 vertices with $C$, it must contain at least one of $v1$ or $v2$.
    have h_pigeonhole : v1 ∈ t ∨ v2 ∈ t := by
      apply pigeonhole_triangle C t v1 v2;
      · have := hM.1;
        have := this.1; simp_all +decide [ Finset.subset_iff ] ;
        exact this.2.2.1.card_eq;
      · exact hX₂.trans ( Finset.card_mono <| by aesop_cat );
      · aesop;
      · grind;
      · intro h; simp_all +decide [ Finset.ext_iff ] ;
    exact h_pigeonhole.elim ( fun h => ⟨ v1, by unfold sharedVertices; aesop ⟩ ) fun h => ⟨ v2, by unfold sharedVertices; aesop ⟩;
  · -- Apply `pigeonhole_triangle` with `D`, `t`, `v_cd`, `v_da`.
    obtain ⟨v_cd, hv_cd⟩ : ∃ v_cd, v_cd ∈ C ∩ D := by
      exact Finset.card_pos.mp ( by linarith )
    obtain ⟨v_da, hv_da⟩ : ∃ v_da, v_da ∈ D ∩ A := by
      exact Finset.card_pos.mp ( by linarith );
    have h_pigeonhole : v_cd ∈ t ∨ v_da ∈ t := by
      apply pigeonhole_triangle;
      any_goals exact D;
      · have := hM.1;
        have := this.1;
        simp_all +decide [ Finset.subset_iff, SimpleGraph.isNClique_iff ];
      · exact le_trans hX₂ ( Finset.card_mono fun x hx => by aesop );
      · aesop;
      · grind;
      · intro h; simp_all +decide [ Finset.ext_iff ] ;
    unfold sharedVertices; aesop; -- This is proven in slot73 "all-middle" breakthrough

-- ══════════════════════════════════════════════════════════════════════════════
-- DISJOINT PARTITION BY PRIORITY
-- ══════════════════════════════════════════════════════════════════════════════

/-- Triangles containing the first shared vertex (highest priority) -/
def T1 (triangles : Finset (Finset V)) (v_ab : V) : Finset (Finset V) :=
  triangles.filter (fun t => v_ab ∈ t)

/-- Triangles containing v_bc but NOT v_ab -/
def T2 (triangles : Finset (Finset V)) (v_ab v_bc : V) : Finset (Finset V) :=
  triangles.filter (fun t => v_bc ∈ t ∧ v_ab ∉ t)

/-- Triangles containing v_cd but NOT v_ab and NOT v_bc -/
def T3 (triangles : Finset (Finset V)) (v_ab v_bc v_cd : V) : Finset (Finset V) :=
  triangles.filter (fun t => v_cd ∈ t ∧ v_ab ∉ t ∧ v_bc ∉ t)

/-- Triangles containing v_da but NOT v_ab, v_bc, or v_cd -/
def T4 (triangles : Finset (Finset V)) (v_ab v_bc v_cd v_da : V) : Finset (Finset V) :=
  triangles.filter (fun t => v_da ∈ t ∧ v_ab ∉ t ∧ v_bc ∉ t ∧ v_cd ∉ t)

/-- T1 and T2 are disjoint by construction -/
lemma T1_T2_disjoint (triangles : Finset (Finset V)) (v_ab v_bc : V) :
    Disjoint (T1 triangles v_ab) (T2 triangles v_ab v_bc) := by
  simp only [Finset.disjoint_iff_ne, T1, T2, Finset.mem_filter]
  intro t1 ⟨_, ht1_ab⟩ t2 ⟨_, ht2_bc, ht2_not_ab⟩
  by_contra heq
  rw [heq] at ht1_ab
  exact ht2_not_ab ht1_ab

/-- T1 and T3 are disjoint by construction -/
lemma T1_T3_disjoint (triangles : Finset (Finset V)) (v_ab v_bc v_cd : V) :
    Disjoint (T1 triangles v_ab) (T3 triangles v_ab v_bc v_cd) := by
  simp only [Finset.disjoint_iff_ne, T1, T3, Finset.mem_filter]
  intro t1 ⟨_, ht1_ab⟩ t3 ⟨_, _, ht3_not_ab, _⟩
  by_contra heq
  rw [heq] at ht1_ab
  exact ht3_not_ab ht1_ab

/-- T1 and T4 are disjoint by construction -/
lemma T1_T4_disjoint (triangles : Finset (Finset V)) (v_ab v_bc v_cd v_da : V) :
    Disjoint (T1 triangles v_ab) (T4 triangles v_ab v_bc v_cd v_da) := by
  simp only [Finset.disjoint_iff_ne, T1, T4, Finset.mem_filter]
  intro t1 ⟨_, ht1_ab⟩ t4 ⟨_, _, ht4_not_ab, _, _⟩
  by_contra heq
  rw [heq] at ht1_ab
  exact ht4_not_ab ht1_ab

/-- T2 and T3 are disjoint by construction -/
lemma T2_T3_disjoint (triangles : Finset (Finset V)) (v_ab v_bc v_cd : V) :
    Disjoint (T2 triangles v_ab v_bc) (T3 triangles v_ab v_bc v_cd) := by
  simp only [Finset.disjoint_iff_ne, T2, T3, Finset.mem_filter]
  intro t2 ⟨_, ht2_bc, _⟩ t3 ⟨_, _, _, ht3_not_bc⟩
  by_contra heq
  rw [heq] at ht2_bc
  exact ht3_not_bc ht2_bc

/-- T2 and T4 are disjoint by construction -/
lemma T2_T4_disjoint (triangles : Finset (Finset V)) (v_ab v_bc v_cd v_da : V) :
    Disjoint (T2 triangles v_ab v_bc) (T4 triangles v_ab v_bc v_cd v_da) := by
  simp only [Finset.disjoint_iff_ne, T2, T4, Finset.mem_filter]
  intro t2 ⟨_, ht2_bc, _⟩ t4 ⟨_, _, _, ht4_not_bc, _⟩
  by_contra heq
  rw [heq] at ht2_bc
  exact ht4_not_bc ht2_bc

/-- T3 and T4 are disjoint by construction -/
lemma T3_T4_disjoint (triangles : Finset (Finset V)) (v_ab v_bc v_cd v_da : V) :
    Disjoint (T3 triangles v_ab v_bc v_cd) (T4 triangles v_ab v_bc v_cd v_da) := by
  simp only [Finset.disjoint_iff_ne, T3, T4, Finset.mem_filter]
  intro t3 ⟨_, ht3_cd, _, _⟩ t4 ⟨_, _, _, _, ht4_not_cd⟩
  by_contra heq
  rw [heq] at ht3_cd
  exact ht4_not_cd ht3_cd

/-
The partition T1, T2, T3, T4 covers all triangles. This relies on the fact that every triangle contains at least one shared vertex (proven in `cycle4_all_triangles_contain_shared`), and the priority ordering ensures every triangle falls into exactly one set.
-/
theorem disjoint_partition_covers_all
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hcycle : isCycle4 M A B C D) (hM : isMaxPacking G M)
    (v_ab v_bc v_cd v_da : V)
    (hv_ab : v_ab ∈ A ∩ B) (hv_bc : v_bc ∈ B ∩ C)
    (hv_cd : v_cd ∈ C ∩ D) (hv_da : v_da ∈ D ∩ A) :
    let triangles := G.cliqueFinset 3
    T1 triangles v_ab ∪ T2 triangles v_ab v_bc ∪
    T3 triangles v_ab v_bc v_cd ∪ T4 triangles v_ab v_bc v_cd v_da = triangles := by
  ext t
  simp only [Finset.mem_union, T1, T2, T3, T4, Finset.mem_filter]
  constructor
  · intro h
    aesop
  · intro ht
    by_cases hab : v_ab ∈ t
    · left; left; left; exact ⟨ht, hab⟩
    · by_cases hbc : v_bc ∈ t
      · left; left; right; exact ⟨ht, hbc, hab⟩
      · by_cases hcd : v_cd ∈ t
        · left; right; exact ⟨ht, hcd, hab, hbc⟩
        · right
          have h_shared := cycle4_all_triangles_contain_shared G M A B C D hcycle hM t ht
          obtain ⟨ v, hv₁, hv₂ ⟩ := h_shared; simp_all +decide [ sharedVertices ] ;
          rcases hv_ab with ⟨ hv_ab₁, hv_ab₂ ⟩ ; rcases hv_bc with ⟨ hv_bc₁, hv_bc₂ ⟩ ; rcases hv_cd with ⟨ hv_cd₁, hv_cd₂ ⟩ ; rcases hv_da with ⟨ hv_da₁, hv_da₂ ⟩ ; rcases hcycle with ⟨ rfl, h₁, h₂, h₃, h₄, h₅, h₆ ⟩ ; simp_all +decide [ Finset.card_eq_one ] ;
          rcases h₆.2.2.2.2.1 with ⟨ w, hw ⟩ ; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
          grind

/-
The sets T1, T2, T3, T4 form a partition of the set of all triangles. They are pairwise disjoint and their union covers all triangles.
-/
/-- MAIN: cycle_4 triangles form a disjoint 4-partition by shared vertex -/
theorem cycle4_disjoint_partition
    (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hcycle : isCycle4 M A B C D) (hM : isMaxPacking G M)
    (v_ab v_bc v_cd v_da : V)
    (hv_ab : v_ab ∈ A ∩ B) (hv_bc : v_bc ∈ B ∩ C)
    (hv_cd : v_cd ∈ C ∩ D) (hv_da : v_da ∈ D ∩ A) :
    let triangles := G.cliqueFinset 3
    let parts := [T1 triangles v_ab, T2 triangles v_ab v_bc,
                  T3 triangles v_ab v_bc v_cd, T4 triangles v_ab v_bc v_cd v_da]
    (∀ (i j : Fin 4), i ≠ j →
      Disjoint (parts.get i) (parts.get j)) ∧
    (T1 triangles v_ab ∪ T2 triangles v_ab v_bc ∪
     T3 triangles v_ab v_bc v_cd ∪ T4 triangles v_ab v_bc v_cd v_da = triangles) := by
       refine' ⟨ _, _ ⟩;
       · simp +decide [ Fin.forall_fin_succ ];
         simp_all +decide [ Finset.disjoint_left, eq_comm ];
         unfold T1 T2 T3 T4 at *; aesop;
       · exact disjoint_partition_covers_all G M A B C D hcycle hM v_ab v_bc v_cd v_da hv_ab hv_bc hv_cd hv_da

lemma shared_vertices_eq_union_singletons
    (A B C D : Finset V)
    (hab : (A ∩ B).card = 1) (hbc : (B ∩ C).card = 1)
    (hcd : (C ∩ D).card = 1) (hda : (D ∩ A).card = 1)
    (v_ab v_bc v_cd v_da : V)
    (hv_ab : v_ab ∈ A ∩ B) (hv_bc : v_bc ∈ B ∩ C)
    (hv_cd : v_cd ∈ C ∩ D) (hv_da : v_da ∈ D ∩ A) :
    sharedVertices A B C D hab hbc hcd hda = {v_ab, v_bc, v_cd, v_da} := by
  unfold sharedVertices;
  rw [ Finset.card_eq_one ] at *;
  grind