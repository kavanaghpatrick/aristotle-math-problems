/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 954d343a-b94a-48bc-b598-fec7b6a9380b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We formalized the statement of the Jacobian Conjecture for polynomial maps over a field of characteristic zero. We defined regular functions, their composition, and the Jacobian matrix. We proved the easy direction of the conjecture: if a polynomial map has a polynomial inverse, then its Jacobian determinant is a unit. We also proved the conjecture for the special case of triangular maps, showing that they always have polynomial inverses. The full Jacobian Conjecture remains an open problem, as indicated by the `sorry` in the main theorem statement.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A regular function from k^Dom to k^Cod is a map from Cod to MvPolynomial Dom k.
-/
abbrev RegularFunction (k : Type*) (Dom Cod : Type*) [CommSemiring k] := Cod → MvPolynomial Dom k

/-
The composition of two regular functions G and F is defined by evaluating G at F.
-/
def RegularFunction.comp {k : Type*} [CommRing k] {σ τ ρ : Type*} (G : RegularFunction k σ τ) (F : RegularFunction k ρ σ) : RegularFunction k ρ τ :=
  fun i => MvPolynomial.aeval F (G i)

/-
The Jacobian of a regular function F is the matrix of partial derivatives of F.
-/
def RegularFunction.Jacobian {k : Type*} [CommRing k] {σ : Type*} [Fintype σ] [DecidableEq σ] (F : RegularFunction k σ σ) : Matrix σ σ (MvPolynomial σ k) :=
  fun i j => MvPolynomial.pderiv j (F i)

/-
The identity regular function maps each variable to itself.
-/
def RegularFunction.id (k : Type*) (σ : Type*) [CommRing k] : RegularFunction k σ σ :=
  fun i => MvPolynomial.X i

/-
The Jacobian Conjecture holds in dimension 1.
-/
theorem jacobian_conjecture_dim_one {k : Type*} [Field k] [CharZero k] {σ : Type*} [Fintype σ] [DecidableEq σ]
    (hσ : Fintype.card σ = 1)
    (F : RegularFunction k σ σ)
    (H : IsUnit F.Jacobian.det) :
    ∃ (G : RegularFunction k σ σ), G.comp F = RegularFunction.id k σ ∧ F.comp G = RegularFunction.id k σ := by
      have := Fintype.card_eq_one_iff.mp hσ;
      -- Since σ has only one element, we can write F as a polynomial in that single variable.
      obtain ⟨x, hx⟩ := this
      have hF : ∃ p : Polynomial k, F x = MvPolynomial.C (p.coeff 0) + ∑ i ∈ Finset.range (p.natDegree), MvPolynomial.C (p.coeff (i + 1)) * MvPolynomial.X x ^ (i + 1) := by
        use MvPolynomial.eval₂ Polynomial.C (fun i => if i = x then Polynomial.X else 0) (F x);
        conv_lhs => rw [ MvPolynomial.as_sum ( F x ) ];
        rw [ Finset.sum_subset ( show ( F x |> MvPolynomial.support ) ⊆ Finset.image ( fun i => Finsupp.single x i ) ( Finset.range ( Polynomial.natDegree ( MvPolynomial.eval₂ Polynomial.C ( fun i => if i = x then Polynomial.X else 0 ) ( F x ) ) + 1 ) ) from ?_ ) ];
        · rw [ Finset.sum_image ] <;> simp +decide [ MvPolynomial.monomial_eq, Finsupp.single_apply ];
          · rw [ Finset.sum_range_succ' ];
            simp +decide [ add_comm, MvPolynomial.eval₂_eq' ];
            congr! 1;
            · rw [ Finset.sum_eq_single 0 ] <;> simp +contextual [ hx ];
              intro b hb hb'; rw [ ← pow_mul ] ; simp +decide [ hb', hx ] ;
              exact ⟨ fun h => hb' <| Finsupp.ext fun y => by rw [ hx y ] ; exact h, by linarith ⟩;
            · refine' Finset.sum_congr rfl fun i hi => _;
              rw [ Finset.sum_eq_single ( Finsupp.single x ( i + 1 ) ) ] <;> simp +decide [ Finsupp.single_apply, hx ];
              · simp +decide [ ← pow_mul, hσ ];
              · intro b hb hb'; right; rw [ ← pow_mul ] ;
                rw [ Polynomial.coeff_X_pow, if_neg ] ; contrapose! hb' ; aesop;
              · aesop;
          · intro i hi j hj hij; replace hij := congr_arg ( fun f => f x ) hij; aesop;
        · aesop;
        · intro i hi; simp_all +decide [ Finsupp.ext_iff ] ;
          refine' ⟨ i x, _, _ ⟩;
          · refine' Nat.lt_succ_of_le ( Polynomial.le_natDegree_of_ne_zero _ );
            rw [ MvPolynomial.eval₂_eq' ];
            rw [ Polynomial.finset_sum_coeff ];
            rw [ Finset.sum_eq_single i ] <;> simp_all +decide [ Polynomial.coeff_C, Polynomial.coeff_X_pow, Finset.prod_eq_zero_iff ];
            intro j hj hij; contrapose! hij; ext y; aesop;
          · exact fun _ => rfl;
      -- Since the Jacobian determinant is a unit, the derivative of p must be a unit. In a field of characteristic zero, the only polynomials with a unit derivative are linear polynomials.
      obtain ⟨p, hp⟩ := hF
      have h_deriv_unit : IsUnit (Polynomial.derivative p) := by
        have h_deriv_unit : IsUnit (MvPolynomial.pderiv x (F x)) := by
          convert H using 1;
          exact?;
        rw [ Polynomial.derivative ];
        simp_all +decide [ Polynomial.sum_over_range ];
        simp_all +decide [ Finset.sum_range_succ', Polynomial.X_pow_eq_monomial ];
        convert h_deriv_unit using 1;
        constructor <;> intro h <;> rw [ isUnit_iff_dvd_one ] at *;
        · convert h_deriv_unit using 1;
        · obtain ⟨ q, hq ⟩ := h;
          refine' ⟨ MvPolynomial.eval₂ Polynomial.C ( fun _ => Polynomial.X ) q, _ ⟩;
          convert congr_arg ( MvPolynomial.eval₂ Polynomial.C ( fun _ => Polynomial.X ) ) hq using 1 <;> simp +decide [ mul_assoc, Polynomial.X_pow_eq_monomial ];
      -- Since the derivative of p is a unit, p must be a linear polynomial.
      have h_linear : ∃ a b : k, p = Polynomial.C a * Polynomial.X + Polynomial.C b := by
        have h_linear : Polynomial.natDegree p ≤ 1 := by
          have := Polynomial.natDegree_eq_zero_of_isUnit h_deriv_unit;
          contrapose! this;
          rw [ Polynomial.natDegree_eq_of_degree_eq_some ];
          exact Nat.cast_ne_zero.mpr ( Nat.sub_ne_zero_of_lt this );
          cases n : Polynomial.natDegree p <;> aesop;
        exact ⟨ p.coeff 1, p.coeff 0, Polynomial.eq_X_add_C_of_natDegree_le_one h_linear ⟩;
      obtain ⟨ a, b, rfl ⟩ := h_linear;
      by_cases ha : a = 0 <;> simp_all +decide [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
      refine' ⟨ fun _ => MvPolynomial.C ( -b / a ) + MvPolynomial.C ( 1 / a ) * MvPolynomial.X x, _, _ ⟩ <;> simp +decide [ RegularFunction.comp, hp, ha, mul_div_cancel₀ ];
      · ext y; simp +decide [ RegularFunction.comp, hp, ha, hx y ] ; ring;
        simp +decide [ RegularFunction.id, ha ];
        split_ifs <;> simp_all +decide [ mul_comm ];
      · ext y; simp +decide [ hx y, hp, RegularFunction.comp, RegularFunction.id ] ;
        split_ifs <;> simp_all +decide [ mul_add, add_mul, mul_assoc, mul_left_comm, div_eq_mul_inv ];
        simp +decide [ mul_left_comm a, ha ]

/-
The Jacobian of a regular function F : k^σ → k^τ is the matrix of partial derivatives of F.
-/
def RegularFunction.Jacobian_general {k : Type*} [CommRing k] {σ τ : Type*} [Fintype σ] [DecidableEq σ] [Fintype τ] [DecidableEq τ] (F : RegularFunction k σ τ) : Matrix τ σ (MvPolynomial σ k) :=
  fun i j => MvPolynomial.pderiv j (F i)

/-
The Jacobian of the composition of two regular functions is the product of their Jacobians (Chain Rule).
-/
theorem jacobian_comp {k : Type*} [CommRing k] {σ τ ρ : Type*} [Fintype σ] [DecidableEq σ] [Fintype τ] [DecidableEq τ] [Fintype ρ] [DecidableEq ρ]
    (G : RegularFunction k σ τ) (F : RegularFunction k ρ σ) :
    (G.comp F).Jacobian_general = Matrix.map G.Jacobian_general (MvPolynomial.aeval F) * F.Jacobian_general := by
      -- By definition of the Jacobian, we have:
      ext i j;
      -- By definition of $MvPolynomial.pderiv$, we can expand the left-hand side.
      have h_expand : (MvPolynomial.pderiv j ((MvPolynomial.bind₁ F) (G i))) = ∑ k, (MvPolynomial.aeval F (MvPolynomial.pderiv k (G i))) * (MvPolynomial.pderiv j (F k)) := by
        induction' G i using MvPolynomial.induction_on with i p q hp hq;
        · simp +decide [ MvPolynomial.aeval_def ];
        · simp +decide [ hp, hq, Finset.sum_add_distrib, add_mul ];
        · simp_all +decide [ MvPolynomial.pderiv_mul ];
          simp +decide [ add_mul, mul_add, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_add_distrib, Pi.single_apply ];
      exact?

/-
If a polynomial map F has a polynomial inverse G, then the Jacobian determinant of F is a unit.
-/
theorem jacobian_easy_direction {k : Type*} [CommRing k] {σ : Type*} [Fintype σ] [DecidableEq σ]
    (F G : RegularFunction k σ σ)
    (hFG : F.comp G = RegularFunction.id k σ)
    (hGF : G.comp F = RegularFunction.id k σ) :
    IsUnit F.Jacobian_general.det := by
      -- By the chain rule, the Jacobian of the composition $F \circ G$ is the product of the Jacobians of $F$ and $G$.
      have h_chain : (F.comp G).Jacobian_general = Matrix.map F.Jacobian_general (MvPolynomial.aeval G) * G.Jacobian_general := by
        exact?;
      -- Since $F \circ G = \text{id}$, their Jacobians are equal to the identity matrix.
      have h_id : Matrix.map F.Jacobian_general (MvPolynomial.aeval G) * G.Jacobian_general = 1 := by
        rw [ ← h_chain, hFG ];
        ext i j; by_cases hij : i = j <;> simp +decide [ hij, RegularFunction.Jacobian_general ] ;
        · simp +decide [ RegularFunction.id, hij, MvPolynomial.pderiv_X ];
          erw [ Matrix.one_apply ] ; aesop;
        · simp +decide [ RegularFunction.id, hij ];
      -- By the chain rule, the Jacobian of the composition $G \circ F$ is the product of the Jacobians of $G$ and $F$.
      have h_chain' : (G.comp F).Jacobian_general = Matrix.map G.Jacobian_general (MvPolynomial.aeval F) * F.Jacobian_general := by
        exact?;
      -- Since $G \circ F = \text{id}$, their Jacobians are equal to the identity matrix.
      have h_id' : Matrix.map G.Jacobian_general (MvPolynomial.aeval F) * F.Jacobian_general = 1 := by
        grind;
      exact?

/-
A regular function F is triangular if each component F_i is of the form x_i + p_i(x_1, ..., x_{i-1}).
-/
def is_triangular {k : Type*} [CommRing k] {n : ℕ} (F : RegularFunction k (Fin n) (Fin n)) : Prop :=
  ∀ i : Fin n, ∃ p : MvPolynomial (Fin i) k, F i = MvPolynomial.X i + MvPolynomial.rename (Fin.castLE (Nat.le_of_lt i.is_lt)) p

/-
Extract the polynomials defining a triangular map.
-/
noncomputable def triangular_polys {k : Type*} [CommRing k] {n : ℕ} (F : RegularFunction k (Fin n) (Fin n)) (hF : is_triangular F) (i : Fin n) : MvPolynomial (Fin i) k :=
  Classical.choose (hF i)

theorem triangular_eq {k : Type*} [CommRing k] {n : ℕ} (F : RegularFunction k (Fin n) (Fin n)) (hF : is_triangular F) (i : Fin n) :
    F i = MvPolynomial.X i + MvPolynomial.rename (Fin.castLE (Nat.le_of_lt i.is_lt)) (triangular_polys F hF i) :=
  Classical.choose_spec (hF i)

/-
Inductive step for the inverse of a triangular map: if previous variables are invertible, so is the current one.
-/
lemma triangular_inverse_step {k : Type*} [CommRing k] {n : ℕ} (F : RegularFunction k (Fin n) (Fin n)) (hF : is_triangular F) (i : Fin n)
    (h_prev : ∀ j : Fin i, ∃ G_j : MvPolynomial (Fin n) k, MvPolynomial.aeval F G_j = MvPolynomial.X (Fin.castLE (Nat.le_of_lt i.is_lt) j)) :
    ∃ G_i : MvPolynomial (Fin n) k, MvPolynomial.aeval F G_i = MvPolynomial.X i := by
      obtain ⟨ p, hp ⟩ := hF i;
      -- By replacing each occurrence of the variables in `p` with their respective inverses from `h_prev`, we can construct the polynomial `G_i`.
      have h_subst : ∃ (G_i : MvPolynomial (Fin n) k), MvPolynomial.aeval F G_i = MvPolynomial.eval₂ MvPolynomial.C (fun j => MvPolynomial.X (Fin.castLE (Nat.le_of_lt i.is_lt) j)) p := by
        refine' ⟨ MvPolynomial.eval₂ MvPolynomial.C ( fun j => Classical.choose ( h_prev j ) ) p, _ ⟩;
        simp +decide [ MvPolynomial.eval₂_eq' ];
        exact Finset.sum_congr rfl fun _ _ => by congr; ext j; have := Classical.choose_spec ( h_prev j ) ; aesop;
      obtain ⟨ G_i, hG_i ⟩ := h_subst; use MvPolynomial.X i - G_i; simp_all +decide [ MvPolynomial.aeval_def ] ;
      exact?

/-
The Jacobian determinant of a triangular map is 1.
-/
theorem triangular_jacobian_det {k : Type*} [CommRing k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    F.Jacobian_general.det = 1 := by
      -- By definition of triangularity, the Jacobian matrix of $F$ is upper triangular with 1's on the diagonal.
      have h_jacobian_upper_triangular : ∀ i j : Fin n, i < j → F.Jacobian_general i j = 0 := by
        intro i j hij
        have h_partial : MvPolynomial.pderiv j (F i) = 0 := by
          rw [ triangular_eq F hF i ];
          simp +decide [ MvPolynomial.pderiv_X, hij.ne' ];
          induction' triangular_polys F hF i using MvPolynomial.induction_on with i p q hp hq generalizing j;
          · simp +decide [ MvPolynomial.pderiv_C ];
          · simp +decide [ hp j hij, hq j hij ];
          · simp_all +decide [ MvPolynomial.pderiv_mul ];
            simp +decide [ Pi.single_apply, hij.ne' ];
            exact fun h => False.elim <| hij.not_le <| h.symm ▸ Fin.le_iff_val_le_val.mpr ( Nat.le_of_lt <| by simp );
        exact h_partial;
      -- Since the Jacobian matrix is upper triangular with 1's on the diagonal, its determinant is 1.
      have h_jacobian_diagonal : ∀ i : Fin n, F.Jacobian_general i i = 1 := by
        intro i
        have h_jacobian_entry : F.Jacobian_general i i = MvPolynomial.pderiv i (MvPolynomial.X i + MvPolynomial.rename (Fin.castLE (Nat.le_of_lt i.is_lt)) (triangular_polys F hF i)) := by
          exact congr_arg _ ( triangular_eq F hF i );
        simp +decide [ h_jacobian_entry, MvPolynomial.pderiv_X ];
        induction' ( triangular_polys F hF i ) using MvPolynomial.induction_on with i p q hp hq <;> simp_all +decide [ MvPolynomial.pderiv_X ];
        simp +decide [ Pi.single_apply, Fin.castLE ];
        exact fun h => absurd h ( ne_of_lt ( Fin.castSucc_lt_last _ ) );
      rw [ ← Matrix.det_transpose, Matrix.det_of_upperTriangular ];
      · aesop;
      · intro i j hij; aesop;

/-
Triangular maps in dimension 0 have an inverse (trivial).
-/
theorem triangular_has_inverse_zero {k : Type*} [Field k] [CharZero k]
    (F : RegularFunction k (Fin 0) (Fin 0))
    (hF : is_triangular F) :
    ∃ (G : RegularFunction k (Fin 0) (Fin 0)), G.comp F = RegularFunction.id k (Fin 0) ∧ F.comp G = RegularFunction.id k (Fin 0) := by
      aesop_cat

/-
For a triangular map, each variable can be expressed as a polynomial in the components of F.
-/
lemma triangular_inverse_exists_componentwise {k : Type*} [CommRing k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    ∀ i : Fin n, ∃ G_i : MvPolynomial (Fin n) k, MvPolynomial.aeval F G_i = MvPolynomial.X i := by
      intro i
      induction' i with i ih;
      induction' i using Nat.strong_induction_on with i ih generalizing F;
      apply triangular_inverse_step F hF ⟨i, ih⟩;
      aesop

/-
The evaluation map of a triangular regular function is surjective.
-/
def RegularFunction.eval {k : Type*} [CommRing k] {σ τ : Type*} [Fintype σ] (F : RegularFunction k σ τ) (x : σ → k) : τ → k :=
  fun j => MvPolynomial.eval x (F j)

theorem triangular_surjective_eval {k : Type*} [Field k] [CharZero k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    Function.Surjective (F.eval) := by
      -- By definition of triangular map, each component F_i is of the form x_i + p_i(x_1, ..., x_{i-1}).
      have h_triangular : ∀ i : Fin n, ∃ p : MvPolynomial (Fin i) k, F i = MvPolynomial.X i + MvPolynomial.rename (Fin.castLE (Nat.le_of_lt i.is_lt)) p := by
        exact hF;
      choose p hp using h_triangular;
      -- By definition of triangular map, we can construct the inverse function $G$ component-wise.
      have h_inverse : ∀ (y : Fin n → k), ∃ x : Fin n → k, ∀ i : Fin n, x i + MvPolynomial.eval (fun j : Fin i => x (Fin.castLE (Nat.le_of_lt i.is_lt) j)) (p i) = y i := by
        intro y
        induction' n with n ih;
        · simp +decide;
        · obtain ⟨x, hx⟩ : ∃ x : Fin n → k, ∀ i : Fin n, x i + MvPolynomial.eval (fun j : Fin i => x (Fin.castLE (Nat.le_of_lt i.is_lt) j)) (p (Fin.castSucc i)) = y (Fin.castSucc i) := by
            apply ih;
            rotate_right;
            exact fun i => MvPolynomial.X i + MvPolynomial.rename ( Fin.castLE ( Nat.le_of_lt i.is_lt ) ) ( p ( Fin.castSucc i ) );
            · intro i;
              use p (Fin.castSucc i);
            · exact fun _ => rfl;
          refine' ⟨ Fin.snoc x ( y ( Fin.last n ) - MvPolynomial.eval ( fun j : Fin n => x j ) ( p ( Fin.last n ) ) ), fun i => _ ⟩ ; induction i using Fin.lastCases <;> simp_all +decide [ Fin.snoc ];
          · simp +decide [ Fin.castLE ];
          · convert hx _ using 3;
            congr! 1;
            ext j; simp +decide [ Fin.castLE, Fin.castLT ] ;
            grind;
      intro y;
      obtain ⟨ x, hx ⟩ := h_inverse y;
      use x;
      ext i; specialize hx i; simp_all +decide [ RegularFunction.eval ] ;
      convert hx using 1;
      simp +decide [ MvPolynomial.eval_rename ];
      rfl

/-
The evaluation map of a triangular regular function is injective.
-/
theorem triangular_injective_eval {k : Type*} [CommRing k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    Function.Injective (F.eval) := by
      intro x y hxy
      have h_eq : ∀ i : Fin n, MvPolynomial.eval x (F i) = MvPolynomial.eval y (F i) := by
        exact fun i => congr_fun hxy i
      have h_ind : ∀ i : Fin n, x i = y i := by
        intro i
        induction' i with i ih
        generalize_proofs at *;
        induction' i using Nat.strong_induction_on with i ih;
        obtain ⟨ p, hp ⟩ := hF ⟨ i, ih ⟩;
        specialize h_eq ⟨ i, ih ⟩ ; simp_all +decide [ MvPolynomial.eval_rename ] ;
        rw [ show x ∘ Fin.castLE ( Nat.le_of_lt ih ) = y ∘ Fin.castLE ( Nat.le_of_lt ih ) from funext fun j => by aesop ] at h_eq ; aesop
      exact funext fun i => h_ind ⟨i, by
        exact i.2⟩
      skip

/-
Define the inverse of a triangular map and prove it is a left inverse.
-/
noncomputable def triangular_inverse {k : Type*} [CommRing k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) : RegularFunction k (Fin n) (Fin n) :=
  fun i => Classical.choose (triangular_inverse_exists_componentwise F hF i)

lemma triangular_inverse_comp_left {k : Type*} [CommRing k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    (triangular_inverse F hF).comp F = RegularFunction.id k (Fin n) := by
      funext i;
      convert Classical.choose_spec ( triangular_inverse_exists_componentwise F hF i ) using 1

/-
The inverse of a triangular map is also a right inverse.
-/
lemma triangular_inverse_comp_right {k : Type*} [Field k] [CharZero k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    F.comp (triangular_inverse F hF) = RegularFunction.id k (Fin n) := by
      funext i;
      -- By definition of triangular_inverse, we know that F.eval (triangular_inverse F hF) i = i.
      have h_eval : ∀ x : Fin n → k, F.eval (triangular_inverse F hF |> fun G => fun j => MvPolynomial.eval x (G j)) = x := by
        intro x;
        have h_surj : ∃ y : Fin n → k, F.eval y = x := by
          apply triangular_surjective_eval F hF;
        obtain ⟨ y, rfl ⟩ := h_surj;
        have h_inv : ∀ i : Fin n, MvPolynomial.eval (F.eval y) (triangular_inverse F hF i) = y i := by
          intro i
          have h_eval : MvPolynomial.aeval F (triangular_inverse F hF i) = MvPolynomial.X i := by
            exact Classical.choose_spec ( triangular_inverse_exists_componentwise F hF i );
          convert congr_arg ( MvPolynomial.eval y ) h_eval using 1;
          · induction' ( triangular_inverse F hF i ) using MvPolynomial.induction_on with i p q hp hq <;> simp +decide [ *, MvPolynomial.eval₂_add, MvPolynomial.eval₂_mul, MvPolynomial.eval₂_X ];
            exact Or.inl rfl;
          · simp +decide;
        ext j; simp +decide [ h_inv ] ;
      refine' MvPolynomial.funext fun x => _;
      convert congr_fun ( h_eval x ) i using 1;
      · simp +decide [ RegularFunction.comp, RegularFunction.eval ];
        induction' ( F i ) using MvPolynomial.induction_on with i p q hp hq ; aesop;
        · simp +decide [ hp, hq ];
        · simp_all +decide [ MvPolynomial.eval₂_mul, MvPolynomial.eval₂_X ];
      · simp +decide [ RegularFunction.id ]

/-
Triangular maps have polynomial inverses.
-/
theorem triangular_has_inverse {k : Type*} [Field k] [CharZero k] {n : ℕ}
    (F : RegularFunction k (Fin n) (Fin n))
    (hF : is_triangular F) :
    ∃ (G : RegularFunction k (Fin n) (Fin n)), G.comp F = RegularFunction.id k (Fin n) ∧ F.comp G = RegularFunction.id k (Fin n) := by
  use triangular_inverse F hF
  constructor
  · apply triangular_inverse_comp_left
  · apply triangular_inverse_comp_right