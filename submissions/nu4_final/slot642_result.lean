/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6cc4330f-e572-4809-85b9-c0f971987980

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If two coprime numbers have a powerful product, then both numbers are powerful.
-/
def Powerful (n : ℕ) : Prop :=
  ∀ p, Nat.Prime p → p ∣ n → p^2 ∣ n

lemma powerful_of_coprime_mul {a b : ℕ} (h_coprime : a.Coprime b) (h_pow : Powerful (a * b)) : Powerful a ∧ Powerful b := by
  refine ⟨ ?_, ?_ ⟩;
  · intro p hp;
    intro hpa
    have hpb : ¬p ∣ b := by
      exact fun hpb => hp.not_dvd_one <| h_coprime.gcd_eq_one ▸ Nat.dvd_gcd hpa hpb;
    have := h_pow p;
    exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( p ^ 2 ) b from hp.coprime_iff_not_dvd.mpr hpb |> Nat.Coprime.pow_left 2 ) <| this hp <| dvd_mul_of_dvd_left hpa _ );
  · intro p hp; have := h_pow p; simp_all +decide [ Nat.Prime.dvd_mul ] ;
    -- If $p$ divides $b$, then since $a$ and $b$ are coprime, $p$ cannot divide $a$.
    intro hpb
    have hp_not_div_a : ¬p ∣ a := by
      exact fun h => hp.not_dvd_one <| h_coprime.gcd_eq_one ▸ Nat.dvd_gcd h hpb;
    exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( p ^ 2 ) a from by simpa using hp.coprime_iff_not_dvd.mpr hp_not_div_a ) ( this ( Or.inr hpb ) ) )

/-
If n, n+1, n+2 are powerful, then n is 3 mod 4.
-/
lemma powerful_triple_mod_4 (n : ℕ)
    (h1 : Powerful n) (h2 : Powerful (n+1)) (h3 : Powerful (n+2)) :
    n % 4 = 3 := by
  by_contra; ( rw [ ← Nat.mod_mod_of_dvd n ( by decide : 4 ∣ 4 ), ] at *; have := Nat.mod_lt n zero_lt_four; interval_cases h4 : n % 4 <;> simp_all +arith +decide; );
  · specialize h3 2 Nat.prime_two ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod ];
    omega;
  · have := h2 2 Nat.prime_two; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, h4 ] at this;
    norm_num [ ← Nat.mod_mod_of_dvd n ( by decide : 2 ∣ 4 ), h4 ] at this;
  · have h5 := @h1 2 Nat.prime_two; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
    omega

/-
The GCD of m-1 and m^2+m+1 is 1 or 3.
-/
lemma gcd_m_minus_1_m_sq_plus_m_plus_1 (m : ℕ) :
    Nat.gcd (m - 1) (m^2 + m + 1) = 1 ∨ Nat.gcd (m - 1) (m^2 + m + 1) = 3 := by
  rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ Nat.gcd_comm ];
  norm_num [ ( by ring : m + ( m + 2 ) ^ 2 + 3 = ( m + 1 ) * ( m + 4 ) + 3 ) ];
  have := Nat.gcd_dvd_right ( m + 1 ) 3; ( have := Nat.le_of_dvd ( by norm_num ) this; interval_cases Nat.gcd ( m + 1 ) 3 <;> trivial; )

/-
The GCD of m+1 and m^2-m+1 is 1 or 3.
-/
lemma gcd_m_plus_1_m_sq_minus_m_plus_1 (m : ℕ) :
    Nat.gcd (m + 1) (m^2 - m + 1) = 1 ∨ Nat.gcd (m + 1) (m^2 - m + 1) = 3 := by
  -- We can use the fact that $(m+1)(m-2)+3 = m^2-m-2+3 = m^2-m+1$ to show that any common divisor of $m+1$ and $m^2-m+1$ must also divide 3.
  have h_div : Nat.gcd (m + 1) (m ^ 2 - m + 1) ∣ 3 := by
    rw [ show m ^ 2 - m = m * ( m - 1 ) by rw [ Nat.pow_two, Nat.mul_sub_left_distrib, Nat.mul_one ] ];
    rcases m with ( _ | _ | m ) <;> simp +arith +decide [ Nat.succ_eq_add_one ];
    norm_num [ ( by ring : ( m + 2 ) * ( m + 1 ) + 1 = ( m + 3 ) * ( m + 0 ) + 3 ) ];
    exact Nat.gcd_dvd_right _ _;
  rwa [ Nat.dvd_prime Nat.prime_three ] at h_div

/-
If n, n+1, n+2 are powerful and n+1 is a cube m^3, then m is even.
-/
lemma m_even (n m : ℕ) (h1 : Powerful n) (h2 : Powerful (n+1)) (h3 : Powerful (n+2)) (hm : n+1 = m^3) : 2 ∣ m := by
  -- Since $n + 1$ is divisible by 4, we have $4 \mid m^3$.
  have h4_div_m3 : 4 ∣ m^3 := by
    -- Since $n$ is powerful and $n \equiv 3 \pmod{4}$, we have $n + 1 \equiv 0 \pmod{4}$.
    have h_mod_4 : n % 4 = 3 := by
      exact?;
    omega;
  exact Nat.prime_two.dvd_of_dvd_pow ( dvd_trans ( by norm_num ) h4_div_m3 )

/-
Powerful numbers are 0, 1, 2, 4, 5, 7, or 8 mod 9.
-/
lemma powerful_mod_9 (k : ℕ) (h : Powerful k) :
    k % 9 ∈ ({0, 1, 2, 4, 5, 7, 8} : Set ℕ) := by
  by_cases h3 : 3 ∣ k;
  · exact Or.inl ( Nat.mod_eq_zero_of_dvd <| dvd_trans ( by decide ) ( h 3 Nat.prime_three h3 ) );
  · rw [ Nat.dvd_iff_mod_eq_zero ] at h3; rw [ ← Nat.mod_mod_of_dvd k ( by decide : 3 ∣ 9 ) ] at h3; have := Nat.mod_lt k ( by decide : 0 < 9 ) ; interval_cases _ : k % 9 <;> simp_all +decide ;

/-
If n, n+1, n+2 are powerful, then n mod 36 is 7, 27, or 35.
-/
lemma n_mod_36_in_set (n : ℕ) (h1 : Powerful n) (h2 : Powerful (n+1)) (h3 : Powerful (n+2)) :
    n % 36 ∈ ({7, 27, 35} : Set ℕ) := by
  -- Therefore, $n ≡ 3 \pmod{4}$ and $n \pmod{9} \in \{0, 1, 2, 4, 5, 7, 8\}$.
  have h_mod_4 : n % 4 = 3 := by
    exact?
  have h_mod_9 : n % 9 ∈ ({0, 1, 2, 4, 5, 7, 8} : Set ℕ) := by
    exact?
  have h_mod_9_plus_1 : (n + 1) % 9 ∈ ({0, 1, 2, 4, 5, 7, 8} : Set ℕ) := by
    exact?
  have h_mod_9_plus_2 : (n + 2) % 9 ∈ ({0, 1, 2, 4, 5, 7, 8} : Set ℕ) := by
    exact?;
  norm_num [ Nat.add_mod ] at *; ( rw [ ← Nat.mod_mod_of_dvd n ( by decide : 4 ∣ 36 ) ] at h_mod_4; ( rw [ ← Nat.mod_mod_of_dvd n ( by decide : 9 ∣ 36 ) ] at *; ( have := Nat.mod_lt n ( by decide : 0 < 36 ) ; interval_cases n % 36 <;> simp +decide at h_mod_4 h_mod_9 h_mod_9_plus_1 h_mod_9_plus_2 ⊢; ) ) ) ;

/-
If m is 1 mod 3 and m^3+1 is powerful, then m^2-m+1 is powerful.
-/
lemma powerful_m_sq_minus_m_plus_1_of_mod_3_eq_1 (m : ℕ) (h : Powerful (m^3+1)) (hm : m % 3 = 1) : Powerful (m^2 - m + 1) := by
  -- Since $m \equiv 1 \pmod{3}$, $\gcd(m+1, m^2-m+1) = 1$.
  have h_coprime : Nat.gcd (m + 1) (m^2 - m + 1) = 1 := by
    rcases m with ( _ | _ | m ) <;> simp_all +decide [ Nat.pow_succ', Nat.mul_succ ];
    norm_num [ ( by ring : ( m + 1 + 1 ) * m + ( m + 1 + 1 ) + 1 = ( m + 1 + 1 + 1 ) * m + 3 ) ];
    exact Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by omega );
  -- Since $m^3 + 1 = (m + 1)(m^2 - m + 1)$ and $m^3 + 1$ is powerful, $m^2 - m + 1$ must also be powerful.
  have h_factor : m^3 + 1 = (m + 1) * (m^2 - m + 1) := by
    nlinarith only [ Nat.sub_add_cancel ( show m ≤ m^2 by nlinarith ) ];
  exact powerful_of_coprime_mul ( by aesop ) ( by aesop ) |>.2

/-
If m is 2 mod 3 and m^3-1 is powerful, then m^2+m+1 is powerful.
-/
lemma powerful_m_sq_plus_m_plus_1_of_mod_3_eq_2 (m : ℕ) (h : Powerful (m^3-1)) (hm : m % 3 = 2) : Powerful (m^2 + m + 1) := by
  -- By definition of $Powerful$, we know that $m^2 + m + 1$ is coprime with $m - 1$.
  have h_coprime : Nat.Coprime (m ^ 2 + m + 1) (m - 1) := by
    rcases m with ( _ | _ | m ) <;> simp_all +decide [ Nat.succ_eq_add_one, pow_succ' ];
    norm_num [ ( by ring : ( m + 1 + 1 ) * ( m + 1 + 1 ) + ( m + 1 + 1 ) + 1 = ( m + 1 ) * ( m + 1 + 3 ) + 3 ) ];
    exact Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by omega;
  convert powerful_of_coprime_mul h_coprime _ |>.1 using 1;
  convert h using 1 ; zify ; cases m <;> norm_num ; ring

/-
If m is 1 mod 3 and m^3+1 is powerful, then m+1 is powerful.
-/
lemma powerful_m_plus_1_of_mod_3_eq_1 (m : ℕ) (h : Powerful (m^3+1)) (hm : m % 3 = 1) : Powerful (m + 1) := by
  -- Since $m \equiv 1 \pmod{3}$, $\gcd(m+1, m^2-m+1) = 1$.
  have h_coprime : Nat.gcd (m + 1) (m^2 - m + 1) = 1 := by
    -- By the lemma gcd_m_plus_1_m_sq_minus_m_plus_1, we know that the gcd is either 1 or 3.
    have h_gcd : Nat.gcd (m + 1) (m^2 - m + 1) = 1 ∨ Nat.gcd (m + 1) (m^2 - m + 1) = 3 := by
      exact?;
    -- If the gcd were 3, then 3 would divide both m+1 and m^2-m+1. But since m ≡ 1 mod 3, m+1 ≡ 2 mod 3, which can't be divisible by 3. Hence, the gcd must be 1.
    by_contra h_contra
    have h_div3 : 3 ∣ m + 1 := by
      exact h_gcd.resolve_left h_contra ▸ Nat.gcd_dvd_left _ _;
    omega;
  convert powerful_of_coprime_mul h_coprime _ |>.1 using 1;
  convert h using 1 ; nlinarith [ Nat.sub_add_cancel ( show m ≤ m^2 by nlinarith ) ]

/-
If m is 2 mod 3 and m^3-1 is powerful, then m-1 is powerful.
-/
lemma powerful_m_minus_1_of_mod_3_eq_2 (m : ℕ) (h : Powerful (m^3-1)) (hm : m % 3 = 2) : Powerful (m - 1) := by
  -- Since $m \equiv 2 \pmod 3$, $\gcd(m-1, m^2+m+1) = 1$.
  have h_coprime : Nat.gcd (m - 1) (m^2 + m + 1) = 1 := by
    rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ Nat.gcd_comm ];
    norm_num [ ( by ring : m + ( m + 2 ) ^ 2 + 3 = ( m + 1 ) * ( m + 4 ) + 3 ) ];
    exact Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by omega );
  convert powerful_of_coprime_mul h_coprime _ |>.1 using 1;
  convert h using 1 ; zify ; cases m <;> norm_num ; ring

/-
If p divides m^2+m+1 and m is 2 mod 3, then p is 1 mod 3.
-/
lemma prime_factor_mod_3_of_dvd_m_sq_plus_m_plus_1 (m p : ℕ) (hp : Nat.Prime p) (h : p ∣ m^2 + m + 1) (hm : m % 3 = 2) :
    p % 3 = 1 := by
  -- If $p \mid m^2 + m + 1$, then $m^3 \equiv 1 \pmod{p}$.
  have h_order : m ^ 3 ≡ 1 [MOD p] := by
    refine Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
    convert Int.natCast_dvd_natCast.mpr ( h.mul_left ( m - 1 ) ) using 1 ; cases m <;> norm_num at * ; ring;
  -- The order of $m$ modulo $p$ divides 3. If the order is 1, then $m \equiv 1 \pmod{p}$, so $m-1 \equiv 0 \pmod{p}$. Then $p | m-1$ and $p | m^2+m+1$, so $p | (m^2+m+1) - (m-1)(m+2) = 3$. So $p=3$.
  by_cases h_order_one : m ≡ 1 [MOD p];
  · simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ];
    rcases p with ( _ | _ | _ | _ | p ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
  · -- If the order of $m$ modulo $p$ is 3, then by Fermat's Little Theorem, $3$ divides $p-1$, so $p \equiv 1 \pmod{3}$.
    have h_fermat : 3 ∣ p - 1 := by
      have h_fermat : orderOf (m : ZMod p) = 3 := by
        have h_order_three : orderOf (m : ZMod p) ∣ 3 := by
          exact orderOf_dvd_iff_pow_eq_one.mpr ( by simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_order );
        simp_all +decide [ Nat.dvd_prime ];
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      rw [ ← h_fermat, orderOf_dvd_iff_pow_eq_one ];
      haveI := Fact.mk hp; simpa [ ← ZMod.natCast_eq_natCast_iff ] using ZMod.pow_card_sub_one_eq_one ( by rw [ ← ZMod.natCast_eq_natCast_iff ] at *; aesop ) ;
    obtain ⟨ k, hk ⟩ := h_fermat; rw [ tsub_eq_iff_eq_add_of_le hp.one_lt.le ] at hk; norm_num [ Nat.add_mod, hk ] ;

/-
If p divides m^2-m+1 and m is 1 mod 3, then p is 1 mod 3.
-/
lemma prime_factor_mod_3_of_dvd_m_sq_minus_m_plus_1 (m p : ℕ) (hp : Nat.Prime p) (h : p ∣ m^2 - m + 1) (hm : m % 3 = 1) :
    p % 3 = 1 := by
  -- If $p$ divides $m^2 - m + 1$, then $m^3 + 1 = (m + 1)(m^2 - m + 1) \equiv 0 \pmod{p}$, so $m^3 \equiv -1 \pmod{p}$.
  have h_m_cubed : m^3 ≡ -1 [ZMOD p] := by
    rw [ Int.modEq_comm, Int.modEq_iff_dvd ];
    have := Int.natCast_dvd_natCast.mpr h; convert this.mul_left ( m + 1 ) using 1; cases m <;> norm_num [ Nat.succ_mul, sq ] at * ; linarith;
  -- Thus $m^6 \equiv 1 \pmod{p}$. The order of $m$ modulo $p$ is 6 (since $m^3 \equiv -1 \not\equiv 1$ and $m^2 \equiv m-1 \not\equiv 1$ for $m \ge 2$).
  have h_order : orderOf (m : ZMod p) = 6 := by
    refine' orderOf_eq_of_pow_and_pow_div_prime _ _ _;
    · norm_num;
    · simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      linear_combination' h_m_cubed * h_m_cubed;
    · intro q hq hq' hq''; have := Nat.le_of_dvd ( by decide ) hq'; interval_cases q <;> simp_all +decide [ pow_succ, ← ZMod.intCast_eq_intCast_iff ] ;
      · rw [ neg_eq_iff_add_eq_zero ] at hq'';
        rcases p with ( _ | _ | _ | p ) <;> cases hq'' <;> simp_all +decide;
        rw [ ← even_iff_two_dvd ] at h; simp_all +decide [ Nat.even_add, Nat.even_sub ( show m ≤ m * m from Nat.le_mul_self _ ), parity_simps ] ;
      · haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show m ≤ m * m from Nat.le_mul_self _ ) ] ;
        rcases p with ( _ | _ | _ | _ | p ) <;> cases h <;> simp_all +decide;
        erw [ ZMod.natCast_eq_natCast_iff ] at h_m_cubed ; norm_num [ Nat.ModEq, hm ] at h_m_cubed;
  -- By Fermat's Little Theorem, order divides $p-1$.
  have h_div : 6 ∣ p - 1 := by
    rw [ ← h_order, orderOf_dvd_iff_pow_eq_one ];
    haveI := Fact.mk hp; simpa [ ← ZMod.intCast_eq_intCast_iff ] using ZMod.pow_card_sub_one_eq_one ( by intro H; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ) ;
  obtain ⟨ k, hk ⟩ := h_div; rw [ tsub_eq_iff_eq_add_of_le hp.one_lt.le ] at hk; norm_num [ Nat.add_mod, Nat.mul_mod, hk ] ;