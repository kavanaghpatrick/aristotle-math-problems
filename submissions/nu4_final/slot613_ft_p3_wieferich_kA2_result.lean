/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 16006bd6-7473-4312-987c-40ec5b3b75bf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Wieferich-like analysis for the Feit-Thompson conjecture case p=3.
Key results include:
- Theorem 1: The Fermat quotient Q_A(3) is divisible by A iff A divides k. Also Q_A(3) ≡ (q+1)k (mod A).
- Theorem 2: Size bound k > A for q > 12, and gcd(A, 12q) = 1.
- Theorem 3: Power sums lifting S_j * (3^j - 1) ≡ j * k * A (mod A²), and specifically 4 * (S_2 / A) ≡ k (mod A).
- Theorem 4: The derivative value q*3^(q-1) is congruent to q*3^(-1) mod A.
- Theorem 5: The value of the q-th cyclotomic polynomial at 3 is k*A/2.
- Theorem 6: Constraints on prime factors of k: odd factors are 1 mod q, v_2(k) = 1, gcd(k, q) = 1. Also k ≥ 4q + 2 if k > 2.
- Theorem 8: Verification for q=71 showing A(71) is prime and 3^71 ≢ 1 (mod A(71)).
- Theorem 9: If q ≡ 8 (mod 9), then k ≡ 8 (mod 9) and v_3(k) = 0.
- Theorem k_mod_12q: k ≡ 2 (mod 12q).

These results establish strong structural constraints on k = (3^q - 1)/A under the assumption 3^q ≡ 1 (mod A).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of A, k, and Fermat quotient.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

def k (q : ℕ) : ℕ := (3^q - 1) / A q

def fermatQuotient (a p : ℕ) : ℕ := (a^(p-1) - 1) / p

/-
Theorem 1: The Fermat quotient Q_A(3) is divisible by A iff A divides k.
-/
theorem theorem_1_fermat_quotient (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) :
  fermatQuotient 3 (A q) % (A q) = 0 ↔ (A q) ∣ k q := by
    -- By definition of Fermat quotient, we know that $Q_A(3) = \frac{3^{A-1} - 1}{A}$.
    have h_fermat_def : fermatQuotient 3 (A q) = (3 ^ (A q - 1) - 1) / A q := by
      rfl;
    -- Since $3^q \equiv 1 \pmod{A q}$, we can write $3^{A q - 1} - 1 = (3^q)^{(A q - 1)/q} - 1$.
    have h_factor : 3 ^ (A q - 1) - 1 = (3 ^ q - 1) * (∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q)) := by
      zify [ pow_mul' ];
      norm_num [ mul_geom_sum ];
      rw [ ← pow_mul, Nat.mul_div_cancel' ];
      exact ⟨ q + 1, Nat.sub_eq_of_eq_add <| by unfold A; ring ⟩;
    -- Since $A q$ is prime and $3^q \equiv 1 \pmod{A q}$, we can simplify the sum $\sum_{i=0}^{(A q - 1)/q - 1} 3^{i q}$ modulo $A q$.
    have h_sum_mod : ∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q) ≡ (A q - 1) / q [MOD A q] := by
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_mul' ];
    -- Since $A q$ is prime and $3^q \equiv 1 \pmod{A q}$, we can simplify the expression $(3^q - 1) * (∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q)) / A q$ modulo $A q$.
    have h_simplify : ((3 ^ q - 1) * (∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q))) / A q ≡ ((3 ^ q - 1) / A q) * ((A q - 1) / q) [MOD A q] := by
      have h_simplify : ((3 ^ q - 1) * (∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q))) / A q = ((3 ^ q - 1) / A q) * (∑ i ∈ Finset.range ((A q - 1) / q), 3 ^ (i * q)) := by
        rw [ Nat.div_eq_of_eq_mul_left ];
        · exact Nat.succ_pos _;
        · rw [ mul_right_comm, Nat.div_mul_cancel ];
          simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd;
      exact h_simplify.symm ▸ Nat.ModEq.mul_left _ h_sum_mod;
    simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
    -- Since $A q$ is prime and $q$ is prime, $(A q - 1) / q$ is not divisible by $A q$.
    have h_not_div : ¬(A q ∣ ((A q - 1) / q)) := by
      refine Nat.not_dvd_of_pos_of_lt ?_ ?_;
      · exact Nat.div_pos ( Nat.le_sub_one_of_lt ( by rw [ show A q = q ^ 2 + q + 1 from rfl ] ; nlinarith only [ hq_gt_3 ] ) ) hq_prime.pos;
      · exact Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.sub_add_cancel hA_prime.pos, show A q > q from by { exact lt_add_of_le_of_pos ( Nat.le_add_left _ _ ) zero_lt_one } ] ;
    exact ⟨ fun h => Nat.mod_eq_zero_of_dvd <| by exact Or.resolve_right ( hA_prime.dvd_mul.mp <| Nat.dvd_of_mod_eq_zero h ) h_not_div, fun h => Nat.mod_eq_zero_of_dvd <| by exact dvd_mul_of_dvd_left ( Nat.dvd_of_mod_eq_zero h ) _ ⟩

/-
Theorem 2 (Size bound): For q > 12, k > A.
-/
theorem theorem_2_size_bound (q : ℕ) (hq : q > 12) : k q > A q := by
  refine Nat.le_div_iff_mul_le ( Nat.succ_pos _ ) |>.2 ?_;
  refine Nat.le_sub_one_of_lt ?_;
  induction hq <;> norm_num [ Nat.pow_succ', A ] at *;
  nlinarith [ Nat.pow_le_pow_left ‹13 ≤ _› 3 ]

/-
Theorem 2 (GCD): gcd(A, 12q) = 1 given q = 2 mod 3.
-/
theorem theorem_2_gcd (q : ℕ) (hq_mod : q % 3 = 2) : Nat.gcd (A q) (12 * q) = 1 := by
  -- Since $A$ is a prime number, it is sufficient to show that $12$ and $q$ are coprime.
  suffices h_coprime : Nat.gcd (A q) q = 1 ∧ Nat.gcd (A q) 12 = 1 by
    exact Nat.Coprime.mul_right h_coprime.2 h_coprime.1;
  unfold A;
  norm_num [ show q ^ 2 + q + 1 = q * ( q + 1 ) + 1 by ring ];
  rw [ ← Nat.mod_add_div q 12 ] at *; have := Nat.mod_lt q ( by decide : 0 < 12 ) ; interval_cases q % 12 <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.gcd_comm, Nat.gcd_rec ] at *;

/-
Theorem 3: Power sums lifting. S_j * (3^j - 1) ≡ j * k * A (mod A²).
-/
def S (j q : ℕ) : ℕ := ∑ i ∈ Finset.range q, 3^(j*i)

theorem theorem_3_power_sums (q j : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) (hj : 1 ≤ j ∧ j < q) :
  (S j q) * (3^j - 1) ≡ j * (k q) * (A q) [MOD (A q)^2] := by
    -- By definition of $k$, we know that $3^q = kA + 1$.
    obtain ⟨k', hk'⟩ : ∃ k', 3^q = k' * A q + 1 := by
      exact ⟨ ( 3 ^ q - 1 ) / A q, by linarith [ Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd ), Nat.sub_add_cancel ( show 1 ≤ 3 ^ q from Nat.one_le_pow _ _ ( by decide ) ) ] ⟩;
    -- Expanding $(k'A + 1)^j$ using the binomial theorem, we get $(k'A)^j + \binom{j}{1}(k'A)^{j-1} + \cdots + \binom{j}{j-1}(k'A) + 1$.
    have h_expand : (k' * A q + 1)^j ≡ 1 + j * k' * A q [MOD A q ^ 2] := by
      -- Expanding $(k'A + 1)^j$ using the binomial theorem, we get $(k'A)^j + \binom{j}{1}(k'A)^{j-1} + \cdots + \binom{j}{j-1}(k'A) + 1$. All terms except the last two are divisible by $A^2$.
      have h_expand : (k' * A q + 1) ^ j ≡ (∑ i ∈ Finset.range 2, Nat.choose j i * (k' * A q) ^ i) [MOD A q ^ 2] := by
        norm_num [ add_pow, mul_comm ];
        rw [ ← Finset.sum_range_add_sum_Ico _ ( show 2 ≤ j + 1 from by linarith ) ];
        norm_num [ Nat.modEq_iff_dvd ];
        exact Finset.dvd_sum fun x hx => dvd_mul_of_dvd_left ( dvd_trans ( by ring_nf; norm_num ) ( pow_dvd_pow _ <| Finset.mem_Ico.mp hx |>.1 ) ) _;
      simpa [ Finset.sum_range_succ, mul_assoc ] using h_expand;
    -- Since $S_j = \sum_{i=0}^{q-1} 3^{ij}$, we have $S_j (3^j - 1) = 3^{qj} - 1$.
    have h_sum : S j q * (3 ^ j - 1) = 3 ^ (q * j) - 1 := by
      rw [ S ];
      zify [ pow_mul' ];
      norm_num [ ← geom_sum_mul ] ; ring;
      exact Or.inl <| Finset.sum_congr rfl fun _ _ => by ring;
    simp_all +decide [ pow_mul ];
    -- Since $k' = k$, we can substitute $k'$ with $k$ in the congruence.
    have h_k_eq_k' : k' = k q := by
      exact Eq.symm ( Nat.div_eq_of_eq_mul_left ( Nat.succ_pos _ ) ( by linarith! [ Nat.sub_add_cancel ( Nat.one_le_pow q 3 zero_lt_three ) ] ) );
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

/-
Theorem 5: The value of the q-th cyclotomic polynomial at 3 is k*A/2, under the assumption 3^q ≡ 1 (mod A).
-/
theorem theorem_5_cyclotomic (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) :
  (Polynomial.cyclotomic q ℤ).eval 3 = (k q * A q) / 2 := by
    -- Since $q$ is prime, we have $\Phi_q(3) = \frac{3^q - 1}{2}$.
    have h_cyclotomic : Polynomial.eval 3 (Polynomial.cyclotomic q ℤ) = (3^q - 1) / 2 := by
      haveI := Fact.mk hq_prime; rw [ Polynomial.cyclotomic_prime ] ; norm_num;
      norm_num [ ← geom_sum_mul ];
    -- Since $A$ is prime and $3^q ≡ 1 \ (\text{mod} \ A)$, it follows that $k * A = 3^q - 1$.
    have h_kA : (k q) * (A q) = 3^q - 1 := by
      exact Nat.div_mul_cancel <| Nat.dvd_of_mod_eq_zero <| by rw [ ← Nat.mod_add_div ( 3 ^ q ) ( A q ), h_cong ] ; norm_num [ Nat.mod_eq_of_lt hA_prime.one_lt ] ;
    norm_cast ; aesop

/-
Theorem 6: Constraints on prime factors of k.
1. Odd prime factors are 1 mod q.
2. v_2(k) = 1.
3. gcd(k, q) = 1.
-/
theorem theorem_6_constraints (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q])
  (hk_mod_12q : k q % (12 * q) = 2) :
  (∀ p, p.Prime → p ∣ k q → p = 2 ∨ p % q = 1) ∧
  (Nat.factorization (k q) 2 = 1) ∧
  (Nat.gcd (k q) q = 1) := by
    -- Let's first show that any prime divisor $p$ of $k$ must satisfy $p \equiv 1 \pmod{q}$ or $p = 2$.
    have h_divisors : ∀ p, Nat.Prime p → p ∣ k q → p = 2 ∨ p % q = 1 := by
      intro p pp dp
      have hp_order : orderOf (3 : ZMod p) ∣ q := by
        -- Since $p$ divides $k$, we have $p \mid 3^q - 1$.
        have hp_div_3q_minus_1 : p ∣ 3^q - 1 := by
          refine dvd_trans dp ?_;
          exact Nat.div_dvd_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd;
        rw [ orderOf_dvd_iff_pow_eq_one ];
        simp_all +decide [ ← ZMod.natCast_eq_zero_iff, sub_eq_iff_eq_add ];
      -- If the order of 3 modulo p is 1, then 3 ≡ 1 (mod p), which implies p divides 2. Hence, p = 2.
      by_cases hp_order_one : orderOf (3 : ZMod p) = 1;
      · haveI := Fact.mk pp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, pow_succ' ] ;
        rcases p with ( _ | _ | _ | _ | p ) <;> cases hp_order_one <;> simp_all +decide;
      · -- If the order of 3 modulo p is q, then by Fermat's Little Theorem, we have q ∣ p - 1.
        have hp_div_p_minus_one : q ∣ p - 1 := by
          have hp_div_p_minus_one : orderOf (3 : ZMod p) ∣ p - 1 := by
            rw [ orderOf_dvd_iff_pow_eq_one ] at *;
            haveI := Fact.mk pp; rw [ ZMod.pow_card_sub_one_eq_one ] ; cases q <;> aesop;
          rw [ Nat.dvd_prime hq_prime ] at hp_order ; aesop;
        exact Or.inr ( by obtain ⟨ k, hk ⟩ := hp_div_p_minus_one; rw [ tsub_eq_iff_eq_add_of_le pp.one_lt.le ] at hk; norm_num [ Nat.add_mod, hk ] ; have := Nat.mod_eq_of_lt hq_prime.two_le; aesop );
    refine' ⟨ h_divisors, _, _ ⟩;
    · -- Since $k$ is even and $k \equiv 2 \pmod{12q}$, we have $v_2(k) = 1$.
      have h_val2 : (k q) % 4 = 2 := by
        exact Eq.symm ( by rw [ ← Nat.mod_mod_of_dvd _ ( show 4 ∣ 12 * q from dvd_mul_of_dvd_left ( by decide ) _ ) ] ; simp +decide [ hk_mod_12q ] );
      rw [ ← Nat.mod_add_div ( k q ) 4, h_val2 ];
      norm_num [ show 2 + 4 * ( k q / 4 ) = 2 * ( 1 + 2 * ( k q / 4 ) ) by ring, Nat.factorization_eq_zero_of_not_dvd, Nat.prime_two.dvd_mul ];
    · refine' Nat.Coprime.symm ( hq_prime.coprime_iff_not_dvd.mpr _ );
      intro h; have := Nat.mod_eq_zero_of_dvd h; simp_all +decide [ Nat.mod_eq_of_lt ] ;
      rw [ ← Nat.mod_mod_of_dvd _ ( dvd_mul_left q 12 ), hk_mod_12q ] at this ; rcases q with ( _ | _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ]

/-
Theorem 4: The derivative value q*3^(q-1) is congruent to q*3^(-1) mod A.
-/
theorem theorem_4_derivative (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) :
  (q : ZMod (A q)) * (3 : ZMod (A q))^(q-1) = (q : ZMod (A q)) * (3 : ZMod (A q))⁻¹ := by
    -- Since $3$ is a unit in the field $ZMod (A q)$, we have $3^{q-1} = 3^{-1}$.
    have h_unit : (3 : ZMod (A q)) ^ (q - 1) = 3⁻¹ := by
      haveI := Fact.mk hA_prime; norm_num [ ← ZMod.natCast_eq_natCast_iff ] at *;
      exact eq_inv_of_mul_eq_one_right ( by rw [ ← pow_succ', Nat.sub_add_cancel hq_prime.pos, h_cong ] );
    rw [h_unit]

/-
Theorem 9: If q ≡ 8 (mod 9) and 3^q ≡ 1 (mod A), then k ≡ 8 (mod 9) and v_3(k) = 0.
-/
theorem theorem_9_val_3 (q : ℕ) (hq_mod : q % 9 = 8) (h_cong : 3^q ≡ 1 [MOD A q]) :
  k q % 9 = 8 ∧ Nat.factorization (k q) 3 = 0 := by
    -- First, let's establish that $k \equiv 8 \pmod{9}$.
    have h_mod_9 : k q % 9 = 8 := by
      rw [ Nat.ModEq.symm ];
      exact Nat.mod_eq_of_lt ( by decide : 8 < 9 );
      -- By definition of $k$, we know that $k q * A q = 3^q - 1$.
      have h_kq_Aq : k q * A q = 3^q - 1 := by
        exact Nat.div_mul_cancel ( by simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd );
      -- Since $A q = q^2 + q + 1$, we have $A q \equiv 1 \pmod{9}$.
      have h_Aq_mod_9 : A q ≡ 1 [MOD 9] := by
        unfold A; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq_mod ] ;
      -- Since $3^q \equiv 0 \pmod{9}$ for $q \geq 2$, we have $3^q - 1 \equiv -1 \equiv 8 \pmod{9}$.
      have h_3q_mod_9 : 3^q ≡ 0 [MOD 9] := by
        exact Nat.modEq_zero_iff_dvd.mpr ( dvd_trans ( by decide ) ( pow_dvd_pow _ ( show q ≥ 2 by contrapose! hq_mod; interval_cases q <;> trivial ) ) );
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      replace h_kq_Aq := congr_arg ( ( ↑ ) : ℕ → ZMod 9 ) h_kq_Aq ; aesop;
    exact ⟨ h_mod_9, Nat.factorization_eq_zero_of_not_dvd fun h => by have := Nat.mod_mod_of_dvd ( k q ) ( by decide : 3 ∣ 9 ) ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ⟩

/-
Theorem 6 (Lower Bound): If k > 2, then k ≥ 4q + 2.
-/
theorem theorem_6_lower_bound (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q])
  (hk_mod_12q : k q % (12 * q) = 2)
  (hk_gt_2 : k q > 2) :
  k q ≥ 4 * q + 2 := by
    -- Since $k \equiv 2 \pmod{12q}$ and $k > 2$, we have $k = 12q * m + 2$ for some integer $m \geq 1$.
    obtain ⟨m, hm⟩ : ∃ m, k q = 12 * q * m + 2 := by
      exact ⟨ k q / ( 12 * q ), by linarith [ Nat.mod_add_div ( k q ) ( 12 * q ) ] ⟩;
    nlinarith [ show m > 0 by nlinarith ]

/-
Theorem: k ≡ 2 (mod 12q) under the assumption 3^q ≡ 1 (mod A).
-/
theorem theorem_k_mod_12q (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (h_cong : 3^q ≡ 1 [MOD A q]) :
  k q % (12 * q) = 2 := by
    -- Since $k q$ is even, we can write $k q = 2m$ for some integer $m$.
    obtain ⟨m, hm⟩ : ∃ m, k q = 2 * m := by
      refine' Nat.dvd_div_of_mul_dvd _;
      -- Since $3^q \equiv 1 \pmod{A q}$, we have $3^q - 1 \equiv 0 \pmod{A q}$. Also, since $3^q$ is odd, $3^q - 1$ is even, so $2$ divides $3^q - 1$.
      have h_div : A q ∣ 3 ^ q - 1 ∧ 2 ∣ 3 ^ q - 1 := by
        exact ⟨ by simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd, by simp [ ← even_iff_two_dvd, Nat.one_le_iff_ne_zero, parity_simps ] ⟩;
      convert Nat.lcm_dvd h_div.1 h_div.2 using 1;
      rw [ Nat.Coprime.lcm_eq_mul ];
      exact Nat.Coprime.symm ( Nat.prime_two.coprime_iff_not_dvd.mpr <| by rw [ show A q = q^2 + q + 1 from rfl ] ; norm_num [ ← even_iff_two_dvd, parity_simps ] );
    -- Since $m$ is odd, we can write $m = 6qn + 1$ for some integer $n$.
    obtain ⟨n, hn⟩ : ∃ n, m = 6 * q * n + 1 := by
      -- Since $m$ is odd, we can write $m = 6qn + 1$ for some integer $n$ by definition of modular equivalence.
      have hm_odd : m % 6 = 1 := by
        -- Since $k q = 2m$, we have $3^q - 1 = A q * 2m$.
        have h_eq : 3^q - 1 = (q^2 + q + 1) * 2 * m := by
          unfold k at hm;
          rw [ Nat.div_eq_iff_eq_mul_left ] at hm;
          · exact hm.trans ( by rw [ show A q = q ^ 2 + q + 1 by rfl ] ; ring );
          · exact Nat.succ_pos _;
          · simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd;
        -- Since $3^q - 1 \equiv 2 \pmod{3}$ and $(q^2 + q + 1) * 2 * m \equiv 2 \pmod{3}$, we have $2 * m \equiv 2 \pmod{3}$, which implies $m \equiv 1 \pmod{3}$.
        have hm_mod_3 : m % 3 = 1 := by
          have hm_mod_3 : (3^q - 1) % 9 = (q^2 + q + 1) * 2 * m % 9 := by
            rw [h_eq];
          rw [ ← Nat.mod_add_div q 3, hq_mod ] at hm_mod_3; ring_nf at hm_mod_3; norm_num [ Nat.add_mod, Nat.mul_mod ] at hm_mod_3;
          rw [ ← Nat.mod_mod_of_dvd m ( by decide : 3 ∣ 9 ) ] ; have := Nat.mod_lt m ( by decide : 0 < 9 ) ; interval_cases m % 9 <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mul', Nat.pow_mod ] at hm_mod_3 ⊢;
          all_goals zify at hm_mod_3; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ] at hm_mod_3;
          · have := Int.emod_nonneg ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) > 0 ) ; interval_cases ( ( q : ℤ ) / 3 ) % 9 <;> contradiction;
          · have := Int.emod_nonneg ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) > 0 ) ; interval_cases ( ( q : ℤ ) / 3 ) % 9 <;> contradiction;
          · have := Int.emod_nonneg ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) > 0 ) ; interval_cases ( ( q : ℤ ) / 3 ) % 9 <;> contradiction;
          · have := Int.emod_nonneg ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) > 0 ) ; interval_cases ( ( q : ℤ ) / 3 ) % 9 <;> contradiction;
          · have := Int.emod_nonneg ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos ( ( q : ℤ ) / 3 ) ( by decide : ( 9 : ℤ ) > 0 ) ; interval_cases ( ( q : ℤ ) / 3 ) % 9 <;> contradiction;
        -- Since $m$ is odd, we have $m \equiv 1 \pmod{2}$.
        have hm_mod_2 : m % 2 = 1 := by
          rcases Nat.even_or_odd' m with ⟨ c, rfl | rfl ⟩ <;> replace h_eq := congr_arg ( · % 4 ) h_eq <;> rcases Nat.even_or_odd' q with ⟨ d, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at *;
          · simp_all +decide [ Nat.prime_mul_iff ];
          · rw [ ← Nat.mod_add_div ( 3 ^ ( d * 2 ) * 3 ) 4 ] at h_eq; norm_num [ Nat.pow_mul', Nat.mul_mod, Nat.pow_mod ] at h_eq;
        exact Eq.symm ( by omega );
      have hm_div : q ∣ m - 1 := by
        -- Since $k q = 2m$, we have $3^q - 1 = 2m * A q$.
        have h_eq : 3^q - 1 = 2 * m * (q^2 + q + 1) := by
          rw [ ← hm, show k q = ( 3 ^ q - 1 ) / ( q ^ 2 + q + 1 ) from rfl, Nat.div_mul_cancel ];
          simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd;
        -- Since $q$ is prime and $q \mid 3^q - 1$, we have $q \mid 2m(q^2 + q + 1) - 2$.
        have h_div : q ∣ 2 * m * (q^2 + q + 1) - 2 := by
          have h_div : q ∣ 3^q - 3 := by
            haveI := Fact.mk hq_prime; norm_num [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show 3 ≤ 3 ^ q by exact le_trans ( by decide ) ( pow_le_pow_right₀ ( by decide ) hq_gt_3.le ) ) ] ;
          convert h_div using 1 ; rw [ ← h_eq ] ; omega;
        haveI := Fact.mk hq_prime; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show 2 ≤ 2 * m * ( q ^ 2 + q + 1 ) from by nlinarith only [ hq_gt_3, show m > 0 from Nat.pos_of_ne_zero ( by aesop_cat ) ] ) ] ;
        cases m <;> simp_all +decide [ sub_eq_iff_eq_add ];
        exact mul_left_cancel₀ ( show ( 2 : ZMod q ) ≠ 0 from by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by positivity ) ( by linarith ) ) ( by linear_combination' h_div );
      -- Since $q$ divides $m - 1$ and $m \equiv 1 \pmod{6}$, we can write $m - 1 = 6qn$ for some integer $n$.
      obtain ⟨n, hn⟩ : ∃ n, m - 1 = 6 * q * n := by
        exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( show Nat.Coprime 6 q from Nat.Coprime.symm <| hq_prime.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases q <;> trivial ) ( show 6 ∣ m - 1 from Nat.dvd_of_mod_eq_zero <| by rw [ ← Nat.mod_add_div m 6, hm_odd ] ; norm_num ) hm_div;
      exact ⟨ n, by rw [ ← hn, Nat.sub_add_cancel ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ] ⟩;
    norm_num [ hm, hn, mul_add, mul_assoc, Nat.add_mod, Nat.mul_mod_mul_left ];
    norm_num [ show 2 * ( 6 * ( q * n ) ) = 12 * q * n by ring, Nat.mul_mod_mul_left ];
    rw [ Nat.mod_eq_of_lt ( by linarith ) ]

/-
Theorem 3 (S2): 4 * (S_2 / A) ≡ k (mod A).
-/
theorem theorem_3_S2_mod_A (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) :
  4 * ((S 2 q) / (A q)) ≡ k q [MOD A q] := by
    -- Using the power sums lifting formula from Theorem 3, we have $S_2 \cdot (3^2 - 1) \equiv 2 \cdot k \cdot A \pmod{A^2}$.
    have h_power_sums : S 2 q * (3^2 - 1) ≡ 2 * k q * A q [MOD (A q)^2] := by
      apply theorem_3_power_sums q 2 hq_prime hq_gt_3 hq_mod hA_prime h_cong ⟨by linarith, by linarith⟩;
    -- Dividing both sides of the congruence by $A$, we get $8 \cdot (S_2 / A) \equiv 2 \cdot k \pmod{A}$.
    have h_divide : 8 * (S 2 q / A q) ≡ 2 * k q [MOD (A q)] := by
      -- Since $A q$ divides $S 2 q$, we can write $S 2 q = A q * (S 2 q / A q)$.
      have h_div : S 2 q = A q * (S 2 q / A q) := by
        rw [ Nat.mul_div_cancel' ];
        -- Using the power sums lifting formula from Theorem 3, we have $S_2 \cdot (3^2 - 1) \equiv 2 \cdot k \cdot A \pmod{A^2}$. Since $A q$ divides $S 2 q$, we can write $S 2 q = A q * m$ for some integer $m$.
        have h_div : A q ∣ S 2 q * (3^2 - 1) := by
          exact Nat.dvd_of_mod_eq_zero ( h_power_sums.of_dvd ( dvd_pow_self _ two_ne_zero ) ▸ by norm_num );
        convert Nat.Coprime.dvd_of_dvd_mul_right _ h_div using 1;
        exact hA_prime.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; norm_num [ A ] at this; nlinarith;
      rw [ Nat.modEq_iff_dvd ] at *;
      norm_num [ sq, mul_assoc, mul_comm, mul_left_comm ] at *;
      exact h_power_sums.imp fun x hx => by nlinarith [ hA_prime.two_le, h_div.symm ▸ show ( S 2 q : ℤ ) = A q * ( S 2 q / A q ) from mod_cast h_div ] ;
    haveI := Fact.mk hA_prime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    exact mul_left_cancel₀ ( show ( 2 : ZMod ( A q ) ) ≠ 0 from by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt Nat.zero_lt_two <| by { exact lt_of_le_of_ne ( Nat.Prime.two_le hA_prime ) <| Ne.symm <| by { unfold A; exact ne_of_apply_ne ( fun x => x % 3 ) <| by norm_num [ Nat.add_mod, Nat.pow_mod, hq_mod ] } } ) <| by linear_combination' h_divide;

/-
Theorem 8 (Verification for q=71): A(71) is prime and 3^71 ≢ 1 (mod A(71)).
-/
theorem theorem_8_verification_q71 :
  let q := 71
  Nat.Prime (A q) ∧ 3^q % (A q) ≠ 1 := by
    native_decide

/-
Theorem 1 (Value): Q_A(3) ≡ (q+1)k (mod A).
-/
theorem theorem_1_fermat_quotient_value (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 3 = 2)
  (hA_prime : (A q).Prime) (h_cong : 3^q ≡ 1 [MOD A q]) :
  fermatQuotient 3 (A q) ≡ (q + 1) * k q [MOD A q] := by
    -- By definition of $A$, we know that $3^q ≡ 1 \pmod{A}$ implies $3^{A-1} ≡ 1 \pmod{A}$.
    have h_exp : 3^(A q - 1) ≡ (3^q)^((q + 1)) [MOD A q] := by
      rw [ ← pow_mul, show A q - 1 = q * ( q + 1 ) from Nat.sub_eq_of_eq_add <| by unfold A; ring ];
    -- Using the fact that $3^q ≡ 1 \pmod{A}$, we can simplify $3^{A-1} ≡ 1 \pmod{A}$.
    have h_simplified : 3^(A q - 1) ≡ 1 + (q + 1) * (3^q - 1) [MOD (A q)^2] := by
      -- Since $3^q \equiv 1 \pmod{A}$, we can write $3^q = 1 + A * m$ for some integer $m$.
      obtain ⟨m, hm⟩ : ∃ m, 3^q = 1 + A q * m := by
        exact ⟨ ( 3 ^ q - 1 ) / A q, by rw [ Nat.mul_div_cancel' ( by simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( Nat.one_le_pow q 3 zero_lt_three ) ] using h_cong.symm.dvd ) ] ; rw [ add_tsub_cancel_of_le ( Nat.one_le_pow q 3 zero_lt_three ) ] ⟩;
      -- Substitute $3^q = 1 + A * m$ into the expression $(3^q)^{q+1}$.
      have h_subst : (1 + A q * m)^(q + 1) ≡ 1 + (q + 1) * (A q * m) [MOD (A q)^2] := by
        have h_subst : (1 + A q * m)^(q + 1) ≡ 1 + (q + 1) * (A q * m) + (∑ i ∈ Finset.Icc 2 (q + 1), Nat.choose (q + 1) i * (A q * m)^i) [MOD (A q)^2] := by
          rw [ add_comm, add_pow ];
          erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, add_assoc, Finset.sum_range_succ' ] ; ring; aesop;
        refine h_subst.trans <| Nat.ModEq.add_left _ <| Nat.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun i hi => dvd_mul_of_dvd_right ( dvd_trans ( by ring_nf; norm_num ) <| pow_dvd_pow _ <| Finset.mem_Icc.mp hi |>.1 ) _;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      convert h_subst using 1;
      rw_mod_cast [ ← hm, show A q - 1 = q * ( q + 1 ) by rw [ Nat.sub_eq_of_eq_add ] ; unfold A; ring ] ; ring;
    -- Using the fact that $3^{A-1} ≡ 1 + (q + 1) * (3^q - 1) \pmod{A^2}$, we can derive that $Q_A(3) ≡ (q + 1) * k \pmod{A}$.
    have h_fermat_quotient : fermatQuotient 3 (A q) * A q ≡ (q + 1) * (3^q - 1) [MOD (A q)^2] := by
      have h_fermat_quotient : 3^(A q - 1) - 1 ≡ fermatQuotient 3 (A q) * A q [MOD (A q)^2] := by
        unfold fermatQuotient;
        rw [ Nat.div_mul_cancel ];
        haveI := Fact.mk hA_prime; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, ← ZMod.natCast_eq_natCast_iff ] ;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
    -- Using the fact that $3^q - 1 = k * A$, we can substitute this into the congruence.
    have h_substitute : fermatQuotient 3 (A q) * A q ≡ (q + 1) * (k q * A q) [MOD (A q)^2] := by
      convert h_fermat_quotient using 1;
      rw [ show k q * A q = 3 ^ q - 1 from Nat.div_mul_cancel <| show A q ∣ 3 ^ q - 1 from by simpa [ ← Int.natCast_dvd_natCast ] using h_cong.symm.dvd ];
    rw [ Nat.modEq_iff_dvd ] at *;
    exact h_substitute.imp fun x hx => by push_cast at *; nlinarith [ hA_prime.two_le ] ;