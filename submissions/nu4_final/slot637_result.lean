/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 02cb1ed0-fbe4-4ac9-a792-5b15ddff1c12

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Eisenstein integers as the ring of integers of the 3rd cyclotomic field, and ω as a primitive 3rd root of unity.
-/
abbrev EisensteinInteger := CyclotomicRing 3 ℤ ℚ

noncomputable def ω : EisensteinInteger := IsCyclotomicExtension.zeta 3 ℤ EisensteinInteger

/-
Define the norm of an Eisenstein integer as its algebra norm over Z.
-/
noncomputable def eisensteinNorm (x : EisensteinInteger) : ℤ := Algebra.norm ℤ x

/-
ω satisfies the equation ω² + ω + 1 = 0.
-/
lemma omega_sq_add_omega_add_one : ω^2 + ω + 1 = 0 := by
  -- By definition of ω, we know that ω^3 = 1 and ω ≠ 1.
  have h_omega_prop : ω^3 = 1 ∧ ω ≠ 1 := by
    refine' ⟨ _, _ ⟩;
    · exact IsCyclotomicExtension.zeta_pow 3 ℤ _;
    · -- By definition of ω, we know that ω is a primitive third root of unity, so ω ≠ 1.
      have h_ω_ne_one : IsPrimitiveRoot ω 3 := by
        convert IsCyclotomicExtension.zeta_spec 3 ℤ (CyclotomicRing 3 ℤ ℚ);
      exact h_ω_ne_one.ne_one ( by decide );
  exact mul_left_cancel₀ ( sub_ne_zero_of_ne h_omega_prop.2 ) ( by linear_combination' h_omega_prop.1 )

/-
The product of a+bω and a+bω² is a² - ab + b².
-/
lemma eisenstein_mul_conj (a b : ℤ) :
    ((a : EisensteinInteger) + (b : EisensteinInteger) * ω) * ((a : EisensteinInteger) + (b : EisensteinInteger) * ω^2) =
    (a^2 - a * b + b^2 : ℤ) := by
      ring_nf;
      rw [ show ω ^ 3 = 1 by
            exact IsCyclotomicExtension.zeta_pow _ _ _ ] ; ring;
      rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; push_cast ; ring

/-
The norm of an Eisenstein integer x is the determinant of the multiplication map by x.
-/
lemma norm_eq_det_mul (x : EisensteinInteger) :
    eisensteinNorm x = LinearMap.det (Algebra.lmul ℤ EisensteinInteger x) := by
      exact?

/-
Print the definition of CyclotomicRing to understand its structure.
-/
#print CyclotomicRing

/-
Define a basis for the Eisenstein integers as {1, ω}.
-/
noncomputable def eisensteinBasis : Module.Basis (Fin 2) ℤ EisensteinInteger :=
  Module.Basis.mk (v := fun i => ω ^ (i : ℕ)) (by
  -- Since ω is a root of the polynomial x² + x + 1, which is irreducible over ℤ, the set {1, ω} is linearly independent over ℤ.
  have h_irred : Irreducible (Polynomial.X ^ 2 + Polynomial.X + 1 : Polynomial ℤ) := by
    simpa using Polynomial.cyclotomic.irreducible three_pos;
  have h_min_poly : minpoly ℤ ω = Polynomial.X ^ 2 + Polynomial.X + 1 := by
    -- Since ω is a root of X² + X + 1 and the polynomial is irreducible, the minimal polynomial must be X² + X + 1.
    have h_min_poly : minpoly ℤ ω ∣ Polynomial.X ^ 2 + Polynomial.X + 1 := by
      refine minpoly.isIntegrallyClosed_dvd ?_ ?_;
      · refine' ⟨ Polynomial.X ^ 2 + Polynomial.X + 1, _, _ ⟩ <;> norm_num;
        · erw [ Polynomial.Monic, Polynomial.leadingCoeff ];
          norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
        · exact?;
      · convert omega_sq_add_omega_add_one using 1;
        norm_num [ Polynomial.aeval_def ];
    refine' ( Polynomial.eq_of_monic_of_associated _ _ <| associated_of_dvd_dvd h_min_poly _ );
    · apply minpoly.monic;
      use Polynomial.X ^ 2 + Polynomial.X + 1;
      exact ⟨ by erw [ Polynomial.Monic, Polynomial.leadingCoeff ] ; erw [ Polynomial.natDegree_add_C ] ; erw [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ], by simpa using omega_sq_add_omega_add_one ⟩;
    · erw [ Polynomial.Monic, Polynomial.leadingCoeff ];
      norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
    · have := minpoly.irreducible ( show IsIntegral ℤ ω from ?_ );
      · exact?;
      · refine' ⟨ Polynomial.X ^ 2 + Polynomial.X + 1, _, _ ⟩ <;> norm_num;
        · erw [ Polynomial.Monic, Polynomial.leadingCoeff ];
          norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
        · exact?;
  have h_lin_ind : ∀ (a b : ℤ), a + b * ω = 0 → a = 0 ∧ b = 0 := by
    intros a b h_eq
    have h_poly : Polynomial.X ^ 2 + Polynomial.X + 1 ∣ Polynomial.C a + Polynomial.C b * Polynomial.X := by
      refine' h_min_poly ▸ minpoly.isIntegrallyClosed_dvd _ _;
      · refine' ⟨ Polynomial.X ^ 2 + Polynomial.X + 1, _, _ ⟩ <;> norm_num [ h_min_poly ];
        · erw [ Polynomial.Monic, Polynomial.leadingCoeff ];
          norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
        · exact?;
      · aesop;
    have := Polynomial.degree_le_of_dvd h_poly;
    contrapose! this; simp_all +decide [ Polynomial.degree_add_eq_left_of_degree_lt ] ;
    exact ⟨ by exact ne_of_apply_ne ( fun p => ( p.coeff 0, p.coeff 1 ) ) ( by aesop ), lt_of_le_of_lt ( Polynomial.degree_add_le _ _ ) ( max_lt ( lt_of_le_of_lt Polynomial.degree_C_le ( by norm_num ) ) ( lt_of_le_of_lt ( Polynomial.degree_C_mul_X_le _ ) ( by norm_num ) ) ) ⟩;
  rw [ Fintype.linearIndependent_iff ] ; norm_num;
  exact fun g hg => h_lin_ind _ _ hg) (by
  -- Any element in the cyclotomic ring can be written as a combination of 1 and ω with integer coefficients.
  have h_comb : ∀ x : EisensteinInteger, ∃ a b : ℤ, x = a • 1 + b • ω := by
    intro x
    obtain ⟨a, b, hx⟩ : ∃ a b : ℤ, x = a + b * ω := by
      -- By definition of Eisenstein integers, every element can be written as $a + b\omega$ for some integers $a$ and $b$.
      have h_basis : ∀ x : EisensteinInteger, ∃ a b : ℤ, x = a + b * ω := by
        intro x
        have h_poly : ∃ p : Polynomial ℤ, x = Polynomial.aeval (R := ℤ) ω p := by
          have h_poly : ∀ x : EisensteinInteger, ∃ p : Polynomial ℤ, x = Polynomial.aeval (R := ℤ) ω p := by
            intro x
            have h_gen : x ∈ Algebra.adjoin ℤ {ω} := by
              convert Algebra.mem_top;
              -- Since ω is a primitive 3rd root of unity, the adjoin of ℤ and ω is the entire cyclotomic field.
              have h_adjoin : Algebra.adjoin ℤ {ω} = ⊤ := by
                have h_primitive : IsPrimitiveRoot ω 3 := by
                  convert IsCyclotomicExtension.zeta_spec 3 ℤ _
                have h_adjoin : Algebra.adjoin ℤ {ω} = ⊤ := by
                  have h_cyclotomic : IsCyclotomicExtension {3} ℤ EisensteinInteger := by
                    infer_instance
                  convert h_cyclotomic.adjoin_primitive_root_eq_top h_primitive using 1
                generalize_proofs at *;
                exact h_adjoin;
              exact h_adjoin
            rw [ Algebra.adjoin_singleton_eq_range_aeval ] at h_gen ; aesop;
          exact h_poly x
        obtain ⟨ p, rfl ⟩ := h_poly;
        -- Since $\omega$ is a root of $x^2 + x + 1$, we have $\omega^2 = -\omega - 1$.
        have h_omega_sq : ω^2 = -ω - 1 := by
          linear_combination' omega_sq_add_omega_add_one;
        induction' p using Polynomial.induction_on' with p q hp hq;
        · rcases hp with ⟨ a, b, hp ⟩ ; rcases hq with ⟨ c, d, hq ⟩ ; exact ⟨ a + c, b + d, by simp +decide [ hp, hq, add_mul ] ; ring ⟩;
        · induction' ‹ℕ› with n ih <;> simp_all +decide [ pow_succ, ← mul_assoc ];
          · exact ⟨ ‹_›, 0, by norm_num ⟩;
          · rcases ih with ⟨ a, b, h ⟩ ; exact ⟨ -b, a - b, by push_cast [ h ] ; linear_combination' h_omega_sq * b ⟩ ;
      exact h_basis x
    use a, b
    rw [hx]
    simp [Algebra.smul_def]
  generalize_proofs at *;
  intro x hx; obtain ⟨ a, b, rfl ⟩ := h_comb x; exact Submodule.add_mem _ ( Submodule.smul_mem _ _ ( Submodule.subset_span ⟨ 0, by norm_num ⟩ ) ) ( Submodule.smul_mem _ _ ( Submodule.subset_span ⟨ 1, by norm_num ⟩ ) ) ;)

lemma eisensteinBasis_apply (i : Fin 2) :
    eisensteinBasis i = ω ^ (i : ℕ) := by
  rw [eisensteinBasis, Module.Basis.mk_apply]

/-
The action of multiplication by ω on the basis elements is given by ω * 1 = ω and ω * ω = -1 - ω.
-/
lemma mul_omega_basis_zero : ω * eisensteinBasis 0 = eisensteinBasis 1 := by
  -- By definition of $eisensteinBasis$, we know that $eisensteinBasis 0 = 1$ and $eisensteinBasis 1 = ω$.
  simp [eisensteinBasis]

lemma mul_omega_basis_one : ω * eisensteinBasis 1 = -eisensteinBasis 0 - eisensteinBasis 1 := by
  rw [ eisensteinBasis_apply, eisensteinBasis_apply ];
  -- Using the given condition ω² + ω + 1 = 0, we can rearrange it to get ω² = -ω - 1.
  have h_omega_sq : ω^2 = -ω - 1 := by
    linear_combination' omega_sq_add_omega_add_one;
  simpa [ sq ] using h_omega_sq.trans ( by ring )

/-
The norm of q - ω is q² + q + 1.
-/
def M (q : ℤ) : Matrix (Fin 2) (Fin 2) ℤ := !![q, 1; -1, q + 1]

lemma det_M (q : ℤ) : (M q).det = q^2 + q + 1 := by
  unfold M; simp +decide [ Matrix.det_fin_two ] ; ring;

lemma toMatrix_eq_M (q : ℤ) :
    LinearMap.toMatrix eisensteinBasis eisensteinBasis (Algebra.lmul ℤ EisensteinInteger ((q : EisensteinInteger) - ω)) = M q := by
      ext i j;
      fin_cases i <;> fin_cases j <;> simp +decide [ *, LinearMap.toMatrix_apply ];
      · erw [ show ω * eisensteinBasis 0 = eisensteinBasis 1 from ?_, show ( q : EisensteinInteger ) * eisensteinBasis 0 = q • eisensteinBasis 0 from ?_ ];
        · erw [ LinearEquiv.map_smul ] ; aesop;
        · exact?;
        · exact?;
      · erw [ mul_omega_basis_one ] ; norm_num [ M ] ; ring;
        erw [ show ( q : EisensteinInteger ) * eisensteinBasis 1 = q • eisensteinBasis 1 by simp +decide [ Algebra.smul_def ] ] ; erw [ eisensteinBasis.repr.map_smul ] ; aesop;
      · unfold M; norm_num [ mul_omega_basis_zero ] ;
        erw [ show ( q : EisensteinInteger ) * eisensteinBasis 0 = q • eisensteinBasis 0 by simp +decide [ Algebra.smul_def ] ] ; erw [ LinearMap.map_smul ] ; aesop;
      · unfold M; norm_num [ mul_omega_basis_one ] ;
        erw [ show ( q : EisensteinInteger ) * eisensteinBasis 1 = q • eisensteinBasis 1 by simp +decide [ Algebra.smul_def ] ] ; erw [ eisensteinBasis.repr.map_smul ] ; norm_num;

lemma norm_q_sub_omega (q : ℤ) :
    eisensteinNorm ((q : EisensteinInteger) - ω) = q^2 + q + 1 := by
      -- We'll use that ω satisfies the polynomial x^2 + x + 1 = 0 to simplify the expression.
      have h_poly : ω^2 = -ω - 1 := by
        linear_combination' omega_sq_add_omega_add_one;
      convert norm_eq_det_mul _;
      convert LinearMap.det_toMatrix ( eisensteinBasis ) _ using 1;
      erw [ Matrix.det_fin_two ] ; norm_num [ eisensteinBasis_apply, h_poly ] ; ring;
      norm_num [ LinearMap.toMatrix_apply, mul_omega_basis_zero, mul_omega_basis_one ];
      erw [ show ( eisensteinBasis.repr ( q * eisensteinBasis 0 ) ) = Finsupp.single 0 q by
              erw [ show ( q : EisensteinInteger ) * eisensteinBasis 0 = q • eisensteinBasis 0 by simp +decide [ Algebra.smul_def ] ] ; erw [ eisensteinBasis.repr.map_smul ] ; aesop, show ( eisensteinBasis.repr ( q * eisensteinBasis 1 ) ) = Finsupp.single 1 q by
                                                                                                    convert eisensteinBasis.repr.map_smul q ( eisensteinBasis 1 ) using 1;
                                                                                                    · norm_num [ Algebra.smul_def ];
                                                                                                    · erw [ eisensteinBasis.repr_self ] ; aesop ] ; simp +decide ; ring;

/-
The norm of 1 - ω is 3.
-/
lemma norm_one_sub_omega : eisensteinNorm (1 - ω) = 3 := by
  convert norm_q_sub_omega 1 using 1

/-
Prove the norm of q-ω is q^2+q+1 using the matrix method.
-/
lemma det_M_proven (q : ℤ) : (M q).det = q^2 + q + 1 := by
  exact?

lemma toMatrix_eq_M_proven (q : ℤ) :
    LinearMap.toMatrix eisensteinBasis eisensteinBasis (Algebra.lmul ℤ EisensteinInteger ((q : EisensteinInteger) - ω)) = M q := by
      exact?

lemma norm_q_sub_omega_proven (q : ℤ) :
    eisensteinNorm ((q : EisensteinInteger) - ω) = q^2 + q + 1 := by
      -- Apply the lemma that states the norm of $q - \omega$ is $q^2 + q + 1$.
      apply norm_q_sub_omega

/-
Prove the norm of q-ω is q^2+q+1 using the matrix method.
-/
lemma det_M_v2 (q : ℤ) : (M q).det = q^2 + q + 1 := by
  exact?

lemma toMatrix_eq_M_v2 (q : ℤ) :
    LinearMap.toMatrix eisensteinBasis eisensteinBasis (Algebra.lmul ℤ EisensteinInteger ((q : EisensteinInteger) - ω)) = M q := by
      exact?

lemma norm_q_sub_omega_v2 (q : ℤ) :
    eisensteinNorm ((q : EisensteinInteger) - ω) = q^2 + q + 1 := by
      convert norm_q_sub_omega_proven q using 1

/-
The norm of q - ω is q² + q + 1.
-/
lemma norm_q_sub_omega_thm (q : ℤ) :
    eisensteinNorm ((q : EisensteinInteger) - ω) = q^2 + q + 1 := by
  rw [norm_eq_det_mul, ← LinearMap.det_toMatrix eisensteinBasis]
  rw [toMatrix_eq_M_v2]
  rw [det_M_v2]

/-
The norm of q - ω is coprime to 3.
-/
lemma norm_coprime_three (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime (eisensteinNorm ((q : EisensteinInteger) - ω)) 3 := by
      -- The norm of q - ω is q^2 + q + 1.
      have h_norm : eisensteinNorm ((q : EisensteinInteger) - ω) = q^2 + q + 1 := by
        convert norm_q_sub_omega_thm q using 1;
      -- Substitute the norm into the goal.
      rw [h_norm];
      rw [ Nat.ModEq ] at hq_mod; rw [ ← Nat.mod_add_div q 3, hq_mod ] ; norm_num; ring_nf;
      exact ⟨ 1, - ( q / 3 * 5 + ( q / 3 ) ^ 2 * 3 + 2 ), by ring ⟩

/-
The norm of q - ω is coprime to 3.
-/
lemma norm_coprime_three_proven (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime (eisensteinNorm ((q : EisensteinInteger) - ω)) 3 := by
      convert norm_coprime_three q hq_mod

/-
The norm of q - ω is coprime to 3.
-/
lemma norm_coprime_three_v2 (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime (eisensteinNorm ((q : EisensteinInteger) - ω)) 3 := by
      convert norm_coprime_three_proven q hq_mod using 1

/-
The norm of q - ω is coprime to 3.
-/
lemma norm_coprime_three_v3 (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime (eisensteinNorm ((q : EisensteinInteger) - ω)) 3 := by
      exact mod_cast norm_coprime_three_v2 q hq_mod

/-
3 can be written as a linear combination of q-ω and q-ω².
-/
lemma three_mem_ideal_of_factors (q : ℕ) :
    ∃ (a b : EisensteinInteger), a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2) = 3 := by
      -- Let's express 3 as a linear combination of $q - \omega$ and $q - \omega^2$.
      -- We start by noting that $(\omega - \omega^2) = \omega(1 - \omega)$.
      have h_diff : (ω - ω^2 : EisensteinInteger) = ω * (1 - ω) := by
        ring;
      -- We know that $3 = (\omega - \omega^2)(\omega^2 - \omega)$.
      have h_three : (3 : EisensteinInteger) = (ω - ω^2) * (ω^2 - ω) := by
        rw [ h_diff ] ; ring;
        rw [ show ω ^ 4 = ω ^ 3 * ω by ring, show ω ^ 3 = 1 by exact IsCyclotomicExtension.zeta_pow 3 ℤ EisensteinInteger ] ; ring;
        rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; ring;
      -- We know that $(q - \omega) - (q - \omega^2) = \omega^2 - \omega$, so $3$ is a multiple of the difference.
      have h_mult_diff : (3 : EisensteinInteger) = ((q : EisensteinInteger) - ω - ((q : EisensteinInteger) - ω^2)) * (ω - ω^2) := by
        grind;
      exact ⟨ ω - ω ^ 2, - ( ω - ω ^ 2 ), by linear_combination' h_mult_diff.symm ⟩

/-
3 can be written as a linear combination of q-ω and q-ω².
-/
lemma three_mem_ideal_of_factors_v2 (q : ℕ) :
    ∃ (a b : EisensteinInteger), a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2) = 3 := by
      exact?

/-
3 can be written as a linear combination of q-ω and q-ω².
-/
lemma three_mem_ideal_of_factors_v3 (q : ℕ) :
    ∃ (a b : EisensteinInteger), a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2) = 3 := by
      exact?

/-
ω² = -ω - 1.
-/
lemma omega_pow_reduction : ω^2 = -ω - 1 := by
  linear_combination omega_sq_add_omega_add_one

/-
3 can be written as a linear combination of q-ω and q-ω².
-/
lemma three_mem_ideal_of_factors_v4 (q : ℕ) :
    ∃ (a b : EisensteinInteger), a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2) = 3 := by
  use -(1 + 2*ω^2)
  use (1 + 2*ω^2)
  have h1 : ω^2 + ω + 1 = 0 := omega_sq_add_omega_add_one
  have h2 : ω^3 = 1 := IsCyclotomicExtension.zeta_pow 3 ℤ EisensteinInteger
  have h3 : ω^4 = ω := by rw [pow_succ, h2, one_mul]
  ring_nf
  rw [h3, h2]
  linear_combination -1 * h1

/-
The factors q-ω and q-ω² are coprime.
-/
lemma coprime_factors_of_norm_coprime_three_proven (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime ((q : EisensteinInteger) - ω) ((q : EisensteinInteger) - ω^2) := by
      obtain ⟨a, b, h⟩ : ∃ a b : EisensteinInteger, a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2) = 3 := by
        exact?;
      -- We know gcd(N(x), 3) = 1 in Z, so there exist s, t such that s * N(x) + t * 3 = 1.
      obtain ⟨s, t, hst⟩ : ∃ s t : ℤ, s * (eisensteinNorm ((q : EisensteinInteger) - ω)) + t * 3 = 1 := by
        have h_coprime : IsCoprime (eisensteinNorm ((q : EisensteinInteger) - ω)) 3 := by
          exact?;
        exact h_coprime;
      -- Substituting N(x) = x * y and 3 = a * x + b * y, we get:
      have h_subst : s * ((q : EisensteinInteger) - ω) * ((q : EisensteinInteger) - ω^2) + t * (a * ((q : EisensteinInteger) - ω) + b * ((q : EisensteinInteger) - ω^2)) = 1 := by
        have h_subst : eisensteinNorm ((q : EisensteinInteger) - ω) = ((q : EisensteinInteger) - ω) * ((q : EisensteinInteger) - ω^2) := by
          have h_norm : eisensteinNorm ((q : EisensteinInteger) - ω) = (q^2 + q + 1 : ℤ) := by
            convert norm_q_sub_omega_thm q using 1;
          rw [ h_norm ] ; ring;
          rw [ show ω ^ 3 = 1 by linear_combination' omega_sq_add_omega_add_one * ( ω - 1 ) ] ; ring;
          rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; push_cast ; ring;
        convert congr_arg ( ( ↑ ) : ℤ → EisensteinInteger ) hst using 1 ; push_cast [ h_subst ] ; ring;
        rw [ ← h ] ; ring;
      exact ⟨ s * ( q - ω ^ 2 ) + t * a, t * b, by linear_combination' h_subst ⟩

/-
The factors q-ω and q-ω² are coprime.
-/
lemma coprime_factors_of_norm_coprime_three_v2 (q : ℕ) (hq_mod : q ≡ 2 [MOD 3]) :
    IsCoprime ((q : EisensteinInteger) - ω) ((q : EisensteinInteger) - ω^2) := by
      convert coprime_factors_of_norm_coprime_three_proven q hq_mod using 1

/-
Check the signature of IsCoprime.map.
-/
#check IsCoprime.map

/-
If q is prime, q ≡ 2 (mod 3), then A = q²+q+1 factors in Z[ω] as A = N(q-ω) = (q-ω)(q-ω²). Moreover, this factorization yields gcd(q-ω, q-ω²) = 1 in Z[ω] (coprime Eisenstein integers).
-/
theorem result1_final (q : ℕ) (hq_prime : q.Prime) (hq_mod : q ≡ 2 [MOD 3]) :
    let A : ℤ := (q : ℤ)^2 + (q : ℤ) + 1
    let pi_eisenstein := (q : EisensteinInteger) - ω
    A = eisensteinNorm pi_eisenstein ∧
    A = pi_eisenstein * ((q : EisensteinInteger) - ω^2) ∧
    IsCoprime pi_eisenstein ((q : EisensteinInteger) - ω^2) := by
      refine' ⟨ _, _, _ ⟩;
      · convert norm_q_sub_omega_thm q |> Eq.symm using 1;
      · convert eisenstein_mul_conj q ( -1 ) using 1 ; ring;
        · rw [ show ω ^ 3 = 1 by
                convert IsCyclotomicExtension.zeta_pow 3 ℤ EisensteinInteger ] ; ring;
          erw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_pow_reduction ] ; norm_num ; ring;
        · convert eisenstein_mul_conj q ( -1 ) using 1 ; ring!;
      · exact?

/-
If q is prime, q ≡ 2 (mod 3), then A = q²+q+1 factors in Z[ω] as A = N(q-ω) = (q-ω)(q-ω²). Moreover, this factorization yields gcd(q-ω, q-ω²) = 1 in Z[ω] (coprime Eisenstein integers).
-/
theorem result1_eisenstein_factorization (q : ℕ) (hq_prime : q.Prime) (hq_mod : q ≡ 2 [MOD 3]) :
    let A : ℤ := (q : ℤ)^2 + (q : ℤ) + 1
    let pi_eisenstein := (q : EisensteinInteger) - ω
    A = eisensteinNorm pi_eisenstein ∧
    (A : EisensteinInteger) = pi_eisenstein * ((q : EisensteinInteger) - ω^2) ∧
    IsCoprime pi_eisenstein ((q : EisensteinInteger) - ω^2) := by
      convert result1_final q hq_prime hq_mod using 1

/-
If 3^{(A-1)/2} ≡ 1 (mod A), then 3^{(A-1)/2} ≡ 1 (mod π).
-/
theorem result3_order_constraint (q : ℕ) (hq_prime : q.Prime) (hq_mod : q ≡ 2 [MOD 3])
    (h_ft : ((eisensteinNorm ((q : EisensteinInteger) - ω) : EisensteinInteger) ∣ (3 : EisensteinInteger) ^ ((eisensteinNorm ((q : EisensteinInteger) - ω) - 1) / 2).toNat - 1)) :
    let pi_eisenstein := (q : EisensteinInteger) - ω
    pi_eisenstein ∣ (3 : EisensteinInteger) ^ ((eisensteinNorm pi_eisenstein - 1) / 2).toNat - 1 := by
      rw [ show ( eisensteinNorm ( ( q : EisensteinInteger ) - ω ) : ℤ ) = ( q : ℤ ) ^ 2 + ( q : ℤ ) + 1 from ?_ ] at h_ft;
      · convert dvd_trans _ h_ft;
        · convert norm_q_sub_omega_thm q using 1;
        · convert result1_eisenstein_factorization q hq_prime hq_mod |>.2.1.symm ▸ dvd_mul_right _ _ using 1;
      · convert norm_q_sub_omega_thm q using 1