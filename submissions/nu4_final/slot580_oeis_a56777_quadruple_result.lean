/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9845316c-07bd-40c2-94e5-d486ba8b0db5

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If p, p+2, p+6, p+8 are prime, then n = p(p+8) satisfies φ(n+12) = φ(n) + 12 and σ(n+12) = σ(n) + 12.
-/
theorem prime_quadruple_implies_conditions (p : ℕ) (hp : p.Prime)
  (hp2 : (p + 2).Prime) (hp6 : (p + 6).Prime) (hp8 : (p + 8).Prime) :
  let n := p * (p + 8)
  Nat.totient (n + 12) = Nat.totient n + 12 ∧
  ArithmeticFunction.sigma 1 (n + 12) = ArithmeticFunction.sigma 1 n + 12 := by
    -- Since gcd(p, p+8) = 1 and gcd(p, 8) = gcd(p, 2^3) = 1 for p > 3, we can use the multiplicativity of φ and σ₁ to separate the terms.
    have h_coprime_p8 : Nat.gcd p (p + 8) = 1 ∧ Nat.gcd (p + 2) (p + 6) = 1 := by
      have := Nat.coprime_primes hp hp8; ( have := Nat.coprime_primes hp2 hp6; aesop; )
    have h_coprime_26 : Nat.gcd (p + 2) (p + 6) = 1 := by
      exact h_coprime_p8.2

    -- Applying the multiplicativity results:
    have h_phi : Nat.totient (p * (p + 8)) = Nat.totient p * Nat.totient (p + 8) ∧ Nat.totient ((p + 2) * (p + 6)) = Nat.totient (p + 2) * Nat.totient (p + 6) := by
      exact ⟨ Nat.totient_mul h_coprime_p8.1, Nat.totient_mul h_coprime_26 ⟩
    have h_sigma : (ArithmeticFunction.sigma 1 (p * (p + 8))) = (ArithmeticFunction.sigma 1 p) * (ArithmeticFunction.sigma 1 (p + 8)) ∧ (ArithmeticFunction.sigma 1 ((p + 2) * (p + 6))) = (ArithmeticFunction.sigma 1 (p + 2)) * (ArithmeticFunction.sigma 1 (p + 6)) := by
      -- Applying the multiplicativity of the sum of divisors function:
      have h_sigma_mul : ∀ {a b : ℕ}, Nat.gcd a b = 1 → (ArithmeticFunction.sigma 1 (a * b)) = (ArithmeticFunction.sigma 1 a) * (ArithmeticFunction.sigma 1 b) := by
        simp +contextual [ ArithmeticFunction.sigma ];
        exact?;
      exact ⟨ h_sigma_mul h_coprime_p8.1, h_sigma_mul h_coprime_26 ⟩;
    convert And.intro ( show Nat.totient ( ( p + 2 ) * ( p + 6 ) ) = Nat.totient ( p * ( p + 8 ) ) + 12 from ?_ ) ( show ( ArithmeticFunction.sigma 1 ) ( ( p + 2 ) * ( p + 6 ) ) = ( ArithmeticFunction.sigma 1 ) ( p * ( p + 8 ) ) + 12 from ?_ ) using 1;
    · ring;
    · ring_nf at *;
    · simp_all +decide [ Nat.totient_prime ];
      rcases p with ( _ | _ | p ) <;> norm_num at * ; linarith;
    · simp_all +decide [ ArithmeticFunction.sigma_apply ];
      ring

/-
The only integers k with φ(k) = 12 are 13, 21, 26, 28, 36, 42.
-/
lemma totient_eq_12_solutions (k : ℕ) (h : Nat.totient k = 12) : k ∈ ({13, 21, 26, 28, 36, 42} : Finset ℕ) := by
  -- If $\phi(k) = 12$, then $k$ must be of the form $2^a \cdot 3^b \cdot 5^c \cdot 7^d \cdot 13^e$ where $a, b, c, d, e$ are non-negative integers.
  have h_form : ∃ a b c d e : ℕ, k = 2^a * 3^b * 5^c * 7^d * 13^e ∧ (a ≤ 5 ∧ b ≤ 2 ∧ c ≤ 1 ∧ d ≤ 1 ∧ e ≤ 1) := by
    -- Since $\phi(k) = 12$, $k$ must be of the form $k = 2^a \cdot 3^b \cdot 5^c \cdot 7^d \cdot 13^e$ where $a, b, c, d, e$ are non-negative integers.
    obtain ⟨a, b, c, d, e, hk⟩ : ∃ a b c d e : ℕ, k = 2^a * 3^b * 5^c * 7^d * 13^e := by
      -- Since $\phi(k) = 12$, $k$ must be of the form $k = 2^a \cdot 3^b \cdot 5^c \cdot 7^d \cdot 13^e$ where $a, b, c, d, e$ are non-negative integers. We prove this by considering the prime factorization of $k$.
      have h_prime_factors : ∀ p : ℕ, Nat.Prime p → p ∣ k → p = 2 ∨ p = 3 ∨ p = 5 ∨ p = 7 ∨ p = 13 := by
        intro p pp dp; have := Nat.totient_dvd_of_dvd dp; simp_all +decide [ Nat.dvd_prime ] ;
        rcases p with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | p ) <;> simp_all +arith +decide [ Nat.totient_prime ];
        linarith [ Nat.le_of_dvd ( by norm_num ) this ];
      use Nat.factorization k 2, Nat.factorization k 3, Nat.factorization k 5, Nat.factorization k 7, Nat.factorization k 13;
      conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self ( show k ≠ 0 by rintro rfl; contradiction ) ];
      rw [ Finsupp.prod_of_support_subset ];
      rotate_left;
      exacts [ { 2, 3, 5, 7, 13 }, by intro p hp; simpa using h_prime_factors p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ), by simp +decide, by simp +decide [ mul_assoc ] ];
    refine' ⟨ a, b, c, d, e, hk, _, _, _, _, _ ⟩ <;> contrapose! h <;> simp_all +decide [ Nat.totient_mul, Nat.totient_prime_pow ];
    · -- If $a > 5$, then $2^a$ is divisible by $64$, and thus $\phi(2^a)$ is divisible by $32$.
      have h_phi_2a : 32 ∣ Nat.totient (2^a) := by
        rw [ Nat.totient_prime_pow ] <;> norm_num;
        · exact dvd_trans ( by decide ) ( pow_dvd_pow _ ( Nat.le_pred_of_lt h ) );
        · linarith;
      exact fun h' => absurd ( h'.symm ▸ Nat.dvd_trans h_phi_2a ( Nat.totient_dvd_of_dvd <| dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_mul_right _ _ ) _ ) _ ) _ ) ) ( by decide );
    · -- If $b > 2$, then $3^b$ contributes at least $3^2 = 9$ to the totient function, making it impossible for $\phi(k)$ to be 12.
      have h_contra : Nat.totient (3 ^ b) ∣ Nat.totient (2 ^ a * 3 ^ b * 5 ^ c * 7 ^ d * 13 ^ e) := by
        exact Nat.totient_dvd_of_dvd <| dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_mul_left _ _ ) _ ) _ ) _;
      rcases b with ( _ | _ | _ | b ) <;> simp_all +decide [ Nat.totient_prime_pow ];
      exact fun h => by have := Nat.le_of_dvd ( by positivity ) h_contra; norm_num [ h ] at this; linarith [ Nat.pow_le_pow_right ( show 1 ≤ 3 by decide ) ( show b + 1 + 1 ≥ 2 by linarith ) ] ;
    · -- If $c > 1$, then $5^c$ contributes a factor of $5$ to the totient function, making it impossible for $\phi(k)$ to be $12$.
      have h_factor_5 : 5 ∣ Nat.totient (2 ^ a * 3 ^ b * 5 ^ c * 7 ^ d * 13 ^ e) := by
        rw [ Nat.totient_mul, Nat.totient_mul, Nat.totient_mul, Nat.totient_mul ];
        · rcases c with ( _ | _ | c ) <;> simp_all +decide [ Nat.totient_prime_pow ];
          exact dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_right ( dvd_mul_of_dvd_left ( by norm_num ) _ ) _ ) _ ) _;
        · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
        · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
        · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
        · apply_rules [ Nat.Coprime.mul_left, Nat.Coprime.pow ];
      exact fun h => by simp +decide only [h] at h_factor_5;
    · rw [ Nat.totient_mul, Nat.totient_mul, Nat.totient_mul, Nat.totient_mul ];
      · rcases d with ( _ | _ | d ) <;> simp_all +decide [ Nat.totient_prime_pow ];
        exact ne_of_apply_ne ( fun x => x % 7 ) ( by norm_num [ Nat.mul_mod, Nat.pow_mod ] );
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.Coprime.pow ];
    · rw [ Nat.totient_mul, Nat.totient_mul, Nat.totient_mul, Nat.totient_mul ];
      · rcases e with ( _ | _ | e ) <;> simp_all +decide [ Nat.totient_prime_pow ];
        grind;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
      · apply_rules [ Nat.Coprime.mul_left, Nat.coprime_pow_primes ] <;> norm_num;
  obtain ⟨ a, b, c, d, e, rfl, ha, hb, hc, hd, he ⟩ := h_form ; interval_cases a <;> interval_cases b <;> interval_cases c <;> interval_cases d <;> interval_cases e <;> revert h <;> native_decide;

/-
If p^2 divides n, then φ(n+12) is congruent to 12 modulo p(p-1).
-/
lemma phi_congruence (n : ℕ) (p : ℕ) (hp : p.Prime) (h_div : p ^ 2 ∣ n)
  (h_phi : Nat.totient (n + 12) = Nat.totient n + 12) :
  Nat.totient (n + 12) ≡ 12 [MOD p * (p - 1)] := by
    -- Since $p$ divides $n$, we have $p(p-1)$ divides $\varphi(n)$ by definition of totient function.
    have h_div_phi : p * (p - 1) ∣ Nat.totient n := by
      refine' Nat.dvd_trans _ ( Nat.totient_dvd_of_dvd h_div );
      rw [ Nat.totient_prime_pow hp ] <;> norm_num [ Nat.totient_prime hp ];
    exact h_phi.symm ▸ Nat.ModEq.add_right _ ( Nat.modEq_zero_iff_dvd.mpr h_div_phi )

/-
If p^2 divides n, then φ(n+12) is either 12 or at least p(p-1) + 12.
-/
lemma phi_dichotomy (n : ℕ) (p : ℕ) (hp : p.Prime) (h_div : p ^ 2 ∣ n)
  (h_phi : Nat.totient (n + 12) = Nat.totient n + 12) :
  Nat.totient (n + 12) = 12 ∨ Nat.totient (n + 12) ≥ p * (p - 1) + 12 := by
    -- By Lemma 3, $φ(n+12) ≡ 12 (mod p(p-1))$.
    obtain ⟨k, hk⟩ : ∃ k : ℕ, Nat.totient (n + 12) = k * p * (p - 1) + 12 := by
      -- By Lemma 3, $φ(n+12) ≡ 12 (mod p(p-1))$ implies that $φ(n+12) = k * p * (p - 1) + 12$ for some integer k.
      have h_congruence : Nat.totient (n + 12) ≡ 12 [MOD p * (p - 1)] := by
        exact?;
      rw [ ← Nat.mod_add_div ( Nat.totient ( n + 12 ) ) ( p * ( p - 1 ) ), h_congruence ];
      rcases p with ( _ | _ | _ | _ | _ | _ | _ | p ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
      · exact ⟨ ( n.totient + 12 ) / 2 - 6, by linarith [ Nat.sub_add_cancel ( show 6 ≤ ( n.totient + 12 ) / 2 from by linarith [ Nat.div_mul_cancel ( show 2 ∣ n.totient + 12 from Nat.dvd_of_mod_eq_zero ( by simp_all +decide [ Nat.ModEq ] ) ) ] ) ] ⟩;
      · rcases h_div with ⟨ k, rfl ⟩ ; simp_all +arith +decide [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
        exact ⟨ ( ( 9 * k ).totient + 12 ) / 6 - 2, by omega ⟩;
      · exact ⟨ ( n.totient + 12 ) / ( ( p + 7 ) * ( p + 6 ) ), by rw [ Nat.mod_eq_of_lt ] <;> nlinarith only [ hp.two_le ] ⟩;
    rcases k with ( _ | k ) <;> simp_all +decide [ mul_assoc ];
    grind

/-
It is impossible for $\phi(n+12) = 12$ if $n$ is divisible by $p^2$ for some prime $p \ge 5$.
-/
lemma phi_eq_12_impossible (n : ℕ) (p : ℕ) (hp : p.Prime) (hp5 : 5 ≤ p) (h_div : p ^ 2 ∣ n)
  (h_phi : Nat.totient (n + 12) = 12) : False := by
    -- Since $\phi(n+12) = 12$, we have $n+12 \in \{13, 21, 26, 28, 36, 42\}$.
    have h_n12 : n + 12 ∈ ({13, 21, 26, 28, 36, 42} : Finset ℕ) := by
      apply totient_eq_12_solutions; assumption;
    generalize_proofs at *; (
    have : n ≤ 42 := Nat.le_of_lt_succ ( by fin_cases h_n12 <;> linarith ) ; interval_cases n <;> simp_all +decide ;
    · nlinarith [ Nat.le_of_dvd ( by decide ) h_div ];
    · have : p ≤ 3 := Nat.le_of_lt_succ ( by nlinarith [ Nat.le_of_dvd ( by decide ) h_div ] ) ; interval_cases p ;
    · nlinarith [ Nat.le_of_dvd ( by decide ) h_div ];
    · have : p ≤ 4 := Nat.le_of_lt_succ ( by nlinarith [ Nat.le_of_dvd ( by decide ) h_div ] ) ; interval_cases p ;
    · have : p ≤ 5 := Nat.le_of_lt_succ ( by nlinarith [ Nat.le_of_dvd ( by decide ) h_div ] ) ; interval_cases p ; trivial;)

/-
If φ(m) ≡ m (mod p) and p does not divide m, then the product of (q-1) over prime factors of m is congruent to the product of q over prime factors of m modulo p.
-/
lemma phi_congruence_implies_mod_p (m : ℕ) (p : ℕ) (hp : p.Prime) (h_nodiv : ¬ p ∣ m)
  (h_phi : Nat.totient m ≡ m [MOD p]) :
  (∏ q ∈ m.primeFactors, (q - 1)) ≡ (∏ q ∈ m.primeFactors, q) [MOD p] := by
    -- Since $p$ does not divide $m$, we can multiply both sides of the congruence by $m$ to get $\prod_{q \mid m} (q - 1) \equiv \prod_{q \mid m} q \pmod{p}$.
    have h_mul : (∏ q ∈ m.primeFactors, (q - 1)) ≡ (∏ q ∈ m.primeFactors, q) [ZMOD p] := by
      -- Multiply both sides of the congruence by $m$ to get $\prod_{q \mid m} (q - 1) \equiv \prod_{q \mid m} q \pmod{p}$.
      have h_mul : (m * (∏ q ∈ m.primeFactors, (q - 1))) ≡ (m * (∏ q ∈ m.primeFactors, q)) [ZMOD p] := by
        have h_mul : (Nat.totient m : ℤ) * (∏ q ∈ m.primeFactors, q) ≡ m * (∏ q ∈ m.primeFactors, q) [ZMOD p] := by
          exact Int.ModEq.mul_right _ <| Int.natCast_modEq_iff.mpr h_phi;
        convert h_mul using 1;
        rw [ Nat.totient_eq_div_primeFactors_mul ];
        norm_cast; rw [ mul_right_comm, Nat.div_mul_cancel ( Nat.prod_primeFactors_dvd _ ) ] ;
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
      exact Eq.trans ( Finset.prod_congr rfl fun x hx => by rw [ Nat.cast_sub ( Nat.one_le_iff_ne_zero.mpr <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors hx ) ] ; norm_num ) h_mul;
    simp_all +decide [ ← Int.natCast_modEq_iff ];
    exact Eq.trans ( by rw [ Finset.prod_congr rfl ] ; intros x hx; rw [ Nat.cast_pred ( Nat.pos_of_mem_primeFactors hx ) ] ) h_mul

/-
If p^2 exactly divides n, then 1+p+p^2 divides σ(n).
-/
lemma sigma_div_prime_sq_of_exact (n : ℕ) (p : ℕ) (hp : p.Prime) (h_div : p ^ 2 ∣ n) (h_ndiv : ¬ p ^ 3 ∣ n) :
  1 + p + p ^ 2 ∣ ArithmeticFunction.sigma 1 n := by
    -- Since $p^2 \mid n$ and $p^3 \nmid n$, we can write $n$ as $n = p^2 * m$ where $m$ is not divisible by $p$.
    obtain ⟨m, hm⟩ : ∃ m, n = p^2 * m ∧ ¬p ∣ m := by
      exact Exists.elim h_div fun m hm => ⟨ m, hm, fun h => h_ndiv <| hm.symm ▸ mul_dvd_mul_left _ h ⟩;
    simp_all +decide [ ArithmeticFunction.sigma_apply, Finset.sum_range_succ', pow_succ' ];
    -- Using the multiplicative property of the sum of divisors function, we have σ(p^2 * m) = σ(p^2) * σ(m).
    have h_sigma_mul : ∑ x ∈ (p * p * m).divisors, x = (∑ x ∈ (p * p).divisors, x) * (∑ x ∈ m.divisors, x) := by
      have h_sigma_mul : ∀ {a b : ℕ}, Nat.gcd a b = 1 → (∑ x ∈ (a * b).divisors, x) = (∑ x ∈ a.divisors, x) * (∑ x ∈ b.divisors, x) := by
        exact?;
      exact h_sigma_mul <| Nat.Coprime.mul_left ( hp.coprime_iff_not_dvd.mpr hm.2 ) ( hp.coprime_iff_not_dvd.mpr hm.2 );
    simp_all +decide [ ← sq, Nat.divisors_prime_pow ];
    norm_num [ Finset.sum_range_succ ]

/-
If p^2 exactly divides n, then σ(n+12) is congruent to 12 modulo 1+p+p^2.
-/
lemma sigma_congruence_of_exact (n : ℕ) (p : ℕ) (hp : p.Prime) (h_div : p ^ 2 ∣ n) (h_ndiv : ¬ p ^ 3 ∣ n)
  (h_sigma : ArithmeticFunction.sigma 1 (n + 12) = ArithmeticFunction.sigma 1 n + 12) :
  ArithmeticFunction.sigma 1 (n + 12) ≡ 12 [MOD 1 + p + p ^ 2] := by
    -- By Lemma~\ref{lem:sigma_div_prime_sq_of_exact}, $1+p+p^2$ divides $\sigma(n)$.
    have h_divides : 1 + p + p^2 ∣ ArithmeticFunction.sigma 1 n := by
      convert sigma_div_prime_sq_of_exact n p hp h_div h_ndiv using 1;
    norm_num [ Nat.ModEq, Nat.add_mod, h_sigma, Nat.mod_eq_zero_of_dvd h_divides ]

/-
If m ≡ 12 (mod p^2) and φ(m) ≡ 12 (mod p(p-1)) with p ≥ 5, then m is not prime.
-/
lemma m_not_prime (m : ℕ) (p : ℕ) (hp : p.Prime) (hp5 : 5 ≤ p)
  (h_mod : m ≡ 12 [MOD p^2])
  (h_phi : Nat.totient m ≡ 12 [MOD p * (p - 1)]) : ¬ Nat.Prime m := by
    -- If m is prime, then φ(m) = m - 1.
    by_contra h_prime
    have h_phi_prime : Nat.totient m = m - 1 := by
      exact Nat.totient_prime h_prime;
    -- From the congruence m ≡ 12 (mod p^2), we have m - 1 ≡ 11 (mod p).
    have h_mod_p : m - 1 ≡ 11 [MOD p] := by
      have := h_mod.of_dvd <| dvd_pow_self _ two_ne_zero; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      cases m <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      linear_combination' this
    -- From the congruence m - 1 ≡ 12 (mod p(p-1)), we have m - 1 ≡ 12 (mod p).
    have h_mod_p' : m - 1 ≡ 12 [MOD p] := by
      exact h_phi_prime ▸ h_phi.of_dvd ( dvd_mul_right _ _ )
    -- Combining these two congruences, we get 11 ≡ 12 (mod p), which simplifies to 1 ≡ 0 (mod p).
    have h_contra : 1 ≡ 0 [MOD p] := by
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      linear_combination' h_mod_p'.symm;
    rcases p with ( _ | _ | p ) <;> contradiction

/-
If m ≡ 12 (mod p^2) and φ(m) ≡ 12 (mod p(p-1)) with p ≥ 5, then m is not a prime power.
-/
lemma m_not_prime_power (m : ℕ) (p : ℕ) (hp : p.Prime) (hp5 : 5 ≤ p)
  (h_mod : m ≡ 12 [MOD p^2])
  (h_phi : Nat.totient m ≡ 12 [MOD p * (p - 1)]) :
  ¬ IsPrimePow m := by
    -- Assume there exists a prime $q$ and exponent $k$ such that $m = q^k$.
    by_contra h_contra
    obtain ⟨q, k, hq⟩ : ∃ q k : ℕ, Nat.Prime q ∧ k ≥ 1 ∧ m = q^k := by
      rw [ isPrimePow_nat_iff ] at h_contra ; aesop;
    -- From h_mod, m ≡ 12 (mod p^2) => m ≡ 12 (mod p).
    have h_mod_p : m ≡ 12 [MOD p] := by
      exact h_mod.of_dvd <| dvd_pow_self _ two_ne_zero

    -- From h_phi, φ(m) ≡ 12 (mod p).
    have h_phi_p : Nat.totient m ≡ 12 [MOD p] := by
      exact h_phi.of_dvd <| dvd_mul_right _ _

    -- Since m is not divisible by p (12 is not 0 mod p), q is not p.
    have hq_ne_p : q ≠ p := by
      intro H; simp_all +decide [ Nat.ModEq, Nat.pow_mod ] ; have := Nat.mod_eq_of_lt hp.two_le; simp_all +decide ;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.mod_eq_of_lt hp.one_lt ];
      · rcases p with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | p ) <;> trivial;
      · rcases p with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | p ) <;> trivial

    -- So q is invertible mod p.
    have hq_inv : q ^ (k - 1) * (q - 1) ≡ q ^ k [MOD p] := by
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Nat.totient_prime_pow ];
      rw [ ← h_phi_p, Nat.totient_prime_pow hq.1 hq.2.1 ] ; aesop;
    -- Dividing by $q^{k-1}$, we get $q-1 \equiv q \pmod{p}$.
    have h_div : q - 1 ≡ q [MOD p] := by
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      rcases k with ( _ | k ) <;> simp_all +decide [ pow_succ, mul_assoc ];
      exact mul_left_cancel₀ ( show ( q : ZMod p ) ^ k ≠ 0 from pow_ne_zero _ <| by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hq_ne_p <| by have := Nat.prime_dvd_prime_iff_eq hp hq.1; aesop ) <| by linear_combination' hq_inv - h_mod_p;
    rcases q with ( _ | _ | q ) <;> simp_all +decide [ Nat.modEq_iff_dvd ];
    exact absurd h_div ( mod_cast hp.not_dvd_one )

/-
If m ≡ 12 (mod p^2) and φ(m) ≡ 12 (mod p(p-1)) with p ≥ 5, then no prime factor q of m is congruent to 1 modulo p.
-/
lemma prime_factor_not_one_mod_p (m : ℕ) (p : ℕ) (hp : p.Prime) (hp5 : 5 ≤ p)
  (h_mod : m ≡ 12 [MOD p^2])
  (h_phi : Nat.totient m ≡ 12 [MOD p * (p - 1)])
  (q : ℕ) (hq : q.Prime) (hq_div : q ∣ m) :
  ¬ (q ≡ 1 [MOD p]) := by
    intro hq_modtra; have h_div : p ∣ Nat.totient m := ?_ ; ( have := h_phi.gcd_eq ; simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ] ; );
    · replace := Nat.gcd_dvd_left ( Nat.totient m ) ( p * ( p - 1 ) ) ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
      replace h_phi := congr_arg ( · % p ) h_phi ; simp_all +decide [ Nat.add_mod, Nat.mul_mod, Nat.mod_eq_of_lt hp.one_lt ] ;
      rcases p with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | p ) <;> trivial;
    · -- Since $q \equiv 1 \pmod{p}$, we have $p \mid (q - 1)$.
      have h_div_q_minus_1 : p ∣ (q - 1) := by
        simpa [ ← Int.natCast_dvd_natCast, hq.pos ] using hq_modtra.symm.dvd
      generalize_proofs at *; (
      exact dvd_trans h_div_q_minus_1 ( Nat.totient_prime hq ▸ Nat.totient_dvd_of_dvd hq_div ))