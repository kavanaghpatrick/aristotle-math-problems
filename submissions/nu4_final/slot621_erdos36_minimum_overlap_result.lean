/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e256a2dc-2779-4b42-b1b8-07642a81e54c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the overlap between two finite sets of integers $A$ and $B$ for a shift $k$ as the number of pairs $(a, b) \in A \times B$ such that $a - b = k$. We define $M(n)$ as the minimum possible maximum overlap (over all $k$) for a partition of $\{1, \dots, 2n\}$ into two sets of size $n$. We prove that $M(1) = 1$ and $M(2) = 1$. Finally, we prove the upper bound $\limsup_{n \to \infty} M(n)/n \le 1/2$ by constructing a specific partition for each $n$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of Overlap between two sets A and B for a difference k.
-/
def Overlap (A B : Finset ℤ) (k : ℤ) : ℕ := ((A.product B).filter (fun (a, b) => a - b = k)).card

/-
MaxOverlap is the supremum of Overlap A B k over all k.
-/
noncomputable def MaxOverlap (A B : Finset ℤ) : ℕ := ⨆ k, Overlap A B k

/-
M(n) is the minimum of MaxOverlap A B over all partitions of {1, ..., 2n} into two sets A and B of equal size.
-/
noncomputable def M (n : ℕ) : ℕ := sInf {k | ∃ (A B : Finset ℤ), k = MaxOverlap A B ∧ Disjoint A B ∧ A ∪ B = Finset.Icc 1 (2 * n : ℤ) ∧ A.card = B.card}

/-
MinOverlapQuotient is the ratio of M(N) to N.
-/
noncomputable def MinOverlapQuotient (N : ℕ) := (M N : ℝ) / N

/-
M(1) = 1.
-/
theorem M_one : M 1 = 1 := by
  refine' le_antisymm ( csInf_le _ _ ) ( le_csInf _ _ );
  · exact ⟨ 0, fun k hk => hk.choose_spec.choose_spec.1.symm ▸ Nat.zero_le _ ⟩;
  · use { 1 }, { 2 } ; simp +decide [ MaxOverlap ] ;
    rw [ eq_comm, @ciSup_eq_of_forall_le_of_forall_lt_exists_gt ] <;> norm_num [ Overlap ];
    · exact fun i => Finset.card_le_one.mpr ( by aesop ) ;
    · exists -1;
  · refine' ⟨ _, ⟨ { 1 }, { 2 }, rfl, _, _, _ ⟩ ⟩ <;> decide;
  · simp +zetaDelta at *;
    intro b x y h₁ h₂ h₃ h₄; subst h₁; unfold MaxOverlap;
    -- Since $x$ and $y$ are disjoint and their union is $\{1, 2\}$, we must have $x = \{1\}$ and $y = \{2\}$ or $x = \{2\}$ and $y = \{1\}$.
    have h_cases : (x = {1} ∧ y = {2}) ∨ (x = {2} ∧ y = {1}) := by
      have h_cases : x ⊆ {1, 2} ∧ y ⊆ {1, 2} := by
        exact ⟨ fun a ha => Finset.mem_Icc.mp ( h₃ ▸ Finset.mem_union_left _ ha ) |> fun h => by rcases h with ⟨ _, _ ⟩ ; interval_cases a <;> trivial, fun a ha => Finset.mem_Icc.mp ( h₃ ▸ Finset.mem_union_right _ ha ) |> fun h => by rcases h with ⟨ _, _ ⟩ ; interval_cases a <;> trivial ⟩;
      have := Finset.card_le_card h_cases.1; ( have := Finset.card_le_card h_cases.2; simp_all +decide ; );
      interval_cases _ : y.card <;> simp_all +decide;
      · rw [ Finset.card_eq_one ] at * ; aesop;
      · have := Finset.eq_of_subset_of_card_le h_cases.1; ( have := Finset.eq_of_subset_of_card_le h_cases.2; aesop; );
    rcases h_cases with ( ⟨ rfl, rfl ⟩ | ⟨ rfl, rfl ⟩ ) <;> norm_num [ Overlap ];
    · exact le_trans ( by decide ) ( le_ciSup ( by exact ⟨ 1, Set.forall_mem_range.2 fun k => Finset.card_le_one.2 fun x hx y hy => by aesop ⟩ ) ( -1 ) );
    · exact le_trans ( by decide ) ( le_ciSup ( by exact ⟨ 1, Set.forall_mem_range.2 fun k => Finset.card_le_one.2 fun x hx y hy => by aesop ⟩ ) 1 )

/-
M(2) = 1.
-/
theorem M_two : M 2 = 1 := by
  refine' le_antisymm ( csInf_le _ _ ) ( le_csInf _ _ );
  · exact ⟨ 0, by rintro k ⟨ A, B, rfl, h₁, h₂, h₃ ⟩ ; exact Nat.zero_le _ ⟩;
  · -- Let's choose the sets $A = \{1, 4\}$ and $B = \{2, 3\}$.
    use {1, 4}, {2, 3};
    simp +decide [ MaxOverlap ];
    rw [ eq_comm, @ciSup_eq_of_forall_le_of_forall_lt_exists_gt ];
    · intro i; unfold Overlap; simp +decide ;
      rw [ Finset.card_le_one_iff ] ; aesop;
    · exact fun w hw => ⟨ 1, hw.trans_le <| by simp +decide [ Overlap ] ⟩;
  · refine' ⟨ _, ⟨ Finset.Icc 1 2, Finset.Icc 3 4, rfl, by decide, by decide, by decide ⟩ ⟩;
  · rintro k ⟨ A, B, rfl, h₁, h₂, h₃ ⟩;
    -- Since A and B are non-empty and their union is {1, 2, 3, 4}, there must be at least one pair (a, b) with a ∈ A and b ∈ B such that a - b is some integer k. The overlap for this k would be at least 1.
    obtain ⟨a, ha⟩ : ∃ a ∈ A, ∃ b ∈ B, a - b ∈ Finset.Icc (-3 : ℤ) 3 := by
      have h_card : A.card + B.card = 4 := by
        rw [ ← Finset.card_union_of_disjoint h₁, h₂ ] ; decide;
      rcases Finset.card_eq_two.mp ( by linarith : Finset.card A = 2 ) with ⟨ a₁, a₂, ha₁, ha₂, ha₃ ⟩ ; rcases Finset.card_eq_two.mp ( by linarith : Finset.card B = 2 ) with ⟨ b₁, b₂, hb₁, hb₂, hb₃ ⟩ ; simp_all +decide [ Finset.ext_iff ];
      cases h₂ b₁ ; cases h₂ b₂ ; cases h₂ a₁ ; cases h₂ a₂ ; norm_num at * ; omega;
    refine' le_trans _ ( le_ciSup _ ( a - ha.2.choose ) );
    · exact Finset.card_pos.mpr ⟨ ( a, ha.2.choose ), Finset.mem_filter.mpr ⟨ Finset.mem_product.mpr ⟨ ha.1, ha.2.choose_spec.1 ⟩, by linarith [ ha.2.choose_spec.2 ] ⟩ ⟩;
    · refine' ⟨ Finset.card ( A.product B ), Set.forall_mem_range.2 fun k => _ ⟩;
      exact Finset.card_filter_le _ _

/-
Definitions of the sets A and B for the upper bound construction.
-/
def construction_A (n : ℕ) : Finset ℤ :=
  let m := n / 2
  let k := n - m
  Finset.Icc 1 m ∪ Finset.Icc (2 * n - k + 1 : ℤ) (2 * n)

def construction_B (n : ℕ) : Finset ℤ :=
  let m := n / 2
  let k := n - m
  Finset.Icc (m + 1 : ℤ) (2 * n - k)

/-
The construction yields a valid partition into two sets of equal size n.
-/
theorem construction_valid (n : ℕ) (hn : n > 0) :
  Disjoint (construction_A n) (construction_B n) ∧
  (construction_A n) ∪ (construction_B n) = Finset.Icc 1 (2 * n : ℤ) ∧
  (construction_A n).card = (construction_B n).card := by
    unfold construction_A construction_B;
    constructor;
    · norm_num [ Finset.disjoint_left ];
      omega;
    · constructor;
      · ext x;
        simp +zetaDelta at *;
        omega;
      · rw [ Finset.card_union_of_disjoint ] <;> norm_num [ Finset.disjoint_left ] ; omega;
        intros; omega;

/-
The maximum overlap of the constructed partition is at most (n+1)/2.
-/
theorem construction_overlap (n : ℕ) (hn : n > 0) :
  MaxOverlap (construction_A n) (construction_B n) ≤ (n + 1) / 2 := by
    -- Let m = n / 2 and k = n - m. Note k = (n + 1) / 2.
    set m := n / 2 with hm
    set k := n - m with hk
    have hk_eq : k = (n + 1) / 2 := by
      omega;
    -- For fixed $d$, the number of pairs $(a, b)$ with $a - b = d$ is at most $m$ for $d < 0$ and at most $k$ for $d > 0$.
    have h_overlap_bounds : ∀ d : ℤ, Overlap (construction_A n) (construction_B n) d ≤ if d < 0 then m else k := by
      intro d
      unfold Overlap
      have h_pairs : ((construction_A n).product (construction_B n)).filter (fun (a, b) => a - b = d) ⊆ if d < 0 then Finset.image (fun a => (a, a - d)) (Finset.Icc 1 m) else Finset.image (fun a => (a, a - d)) (Finset.Icc (2 * n - k + 1 : ℤ) (2 * n)) := by
        simp +decide [ Finset.subset_iff ];
        intro a b ha hb hd; split_ifs <;> simp_all +decide [ construction_A, construction_B ] ;
        · omega;
        · exact ⟨ ha.resolve_left fun h => by linarith, by linarith ⟩;
      refine le_trans ( Finset.card_le_card h_pairs ) ?_;
      split_ifs <;> norm_num [ Finset.card_image_of_injective, Function.Injective ];
    refine' ciSup_le fun d => le_trans ( h_overlap_bounds d ) _;
    grind

/-
M(n) is at most (n+1)/2 for n > 0.
-/
theorem M_le_construction (n : ℕ) (hn : n > 0) : M n ≤ (n + 1) / 2 := by
  refine' le_trans ( csInf_le _ _ ) _;
  exact MaxOverlap ( construction_A n ) ( construction_B n );
  · exact ⟨ 0, fun k hk => Nat.zero_le _ ⟩;
  · exact ⟨ _, _, rfl, construction_valid n hn ⟩;
  · exact construction_overlap n hn

/-
The upper bound for the minimum overlap quotient is 1/2.
-/
theorem minimum_overlap.variants.upper.erdos_1955 :
  Filter.limsup MinOverlapQuotient Filter.atTop ≤ (1 : ℝ) / 2 := by
    -- We'll use that $M(n) \leq (n + 1) / 2$ for all $n$. Hence, $M(n) / n \leq (n + 1) / 2n = 1/2 + 1/(2n)$.
    have h_le : ∀ n : ℕ, n > 0 → (M n : ℝ) / n ≤ 1 / 2 + 1 / (2 * n) := by
      -- By definition of $M(n)$, we know that $M(n) \leq (n + 1) / 2$.
      have h_bound : ∀ n : ℕ, n > 0 → (M n : ℝ) ≤ (n + 1) / 2 := by
        intro n hn_pos
        have h_bound : (M n : ℝ) ≤ (n + 1) / 2 := by
          rw [ le_div_iff₀ ] <;> norm_cast;
          linarith [ M_le_construction n hn_pos, Nat.div_mul_le_self ( n + 1 ) 2 ]
        exact h_bound;
      intro n hn; convert div_le_div_of_nonneg_right ( h_bound n hn ) ( Nat.cast_nonneg n ) using 1; ring;
      norm_num [ hn.ne' ];
    refine' le_of_forall_pos_le_add fun ε ε_pos => _;
    refine' csInf_le _ _;
    · norm_num [ Filter.eventually_map ];
      exact ⟨ 0, by rintro x ⟨ n, hn ⟩ ; exact le_trans ( by exact div_nonneg ( Nat.cast_nonneg _ ) ( Nat.cast_nonneg _ ) ) ( hn _ le_rfl ) ⟩;
    · simp +zetaDelta at *;
      exact ⟨ ⌈ε⁻¹⌉₊ + 1, fun n hn => le_trans ( h_le n ( by linarith ) ) ( by norm_num; nlinarith [ Nat.le_ceil ( ε⁻¹ ), mul_inv_cancel₀ ( ne_of_gt ε_pos ), ( by norm_cast : ( ⌈ε⁻¹⌉₊ : ℝ ) + 1 ≤ n ), mul_inv_cancel₀ ( show ( n : ℝ ) ≠ 0 by norm_cast; linarith ) ] ) ⟩