/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 892f5f61-abfc-48a8-b06d-24cc26d380e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The radical of a natural number n is the product of its distinct prime factors.
-/
def rad (n : ℕ) : ℕ := ∏ p ∈ n.primeFactors, p

/-
A natural number n is powerful if for every prime p dividing n, p^2 also divides n.
-/
def Powerful (n : ℕ) : Prop := ∀ p, p.Prime → p ∣ n → p^2 ∣ n

/-
The ABC conjecture states that for every ε > 0, there exists a constant K_ε > 0 such that for all coprime positive integers a, b, c satisfying a + b = c, we have c < K_ε * rad(abc)^(1+ε).
-/
def ABC_conjecture : Prop :=
  ∀ ε > 0, ∃ K_ε > 0, ∀ a b c : ℕ,
    a > 0 → b > 0 → c > 0 →
    a.Coprime b → a + b = c →
    (c : ℝ) < K_ε * (rad (a * b * c) : ℝ) ^ (1 + ε)

/-
If n and n+2 are both powerful numbers, then n must be odd.
-/
lemma odd_of_powerful_n_n_plus_2 {n : ℕ} (h1 : Powerful n) (h2 : Powerful (n + 2)) : Odd n := by
  by_contra h_even;
  obtain ⟨ k, hk ⟩ := Nat.exists_prime_and_dvd ( show n + 2 ≠ 1 by linarith ) ; simp_all +decide [ Nat.primeFactors_mul ] ;
  obtain ⟨ m, hm ⟩ := h1 2 Nat.prime_two ( even_iff_two_dvd.mp h_even ) ; obtain ⟨ n, hn ⟩ := h2 2 Nat.prime_two ( even_iff_two_dvd.mp ( by simpa [ parity_simps ] using h_even ) ) ; omega;

/-
If a and b are coprime natural numbers, then rad(a * b) = rad(a) * rad(b).
-/
lemma rad_mul_of_coprime {a b : ℕ} (h : a.Coprime b) : rad (a * b) = rad a * rad b := by
  unfold rad;
  cases a <;> cases b <;> simp_all +decide [ Nat.primeFactors_mul ];
  rw [ Finset.prod_union ( Nat.Coprime.disjoint_primeFactors h ) ]

/-
For a non-zero powerful number n, rad(n) ≤ √n.
-/
lemma rad_le_sqrt_of_powerful {n : ℕ} (h : Powerful n) (hn : n ≠ 0) : (rad n : ℝ) ≤ Real.sqrt n := by
  refine Real.le_sqrt_of_sq_le ?_;
  norm_cast;
  -- By definition of powerful, each prime factor $p$ of $n$ appears with an exponent of at least 2 in the prime factorization of $n$.
  have h_prime_factors : ∀ p ∈ n.primeFactors, 2 ≤ (Nat.factorization n) p := by
    simp +zetaDelta at *;
    intro p pp dp hn; have := h p pp dp; rw [ ← Nat.factorization_le_iff_dvd ] at this <;> aesop;
  -- Therefore, $n \geq \prod_{p \in n.primeFactors} p^{2}$.
  have h_n_ge_prod : n ≥ ∏ p ∈ n.primeFactors, p ^ 2 := by
    have h_prod : n ≥ ∏ p ∈ n.primeFactors, p ^ (Nat.factorization n p) := by
      conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ] ;
      rfl;
    exact le_trans ( Finset.prod_le_prod' fun p hp => Nat.pow_le_pow_right ( Nat.pos_of_mem_primeFactors hp ) ( h_prime_factors p hp ) ) h_prod;
  simpa [ Finset.prod_pow ] using h_n_ge_prod

/-
If n, n+1, n+2 are powerful and n > 0, then rad(n(n+2)(n+1)^2) < (n+1)^1.5.
-/
lemma rad_bound_of_powerful_triple {n : ℕ} (h1 : Powerful n) (h2 : Powerful (n + 1)) (h3 : Powerful (n + 2)) (hn : n > 0) :
  (rad (n * (n + 2) * 1 * (n + 1)^2) : ℝ) < (n + 1 : ℝ) ^ (1.5 : ℝ) := by
    -- By definition of $rad$, we know that $rad(n(n+2)(n+1)^2) = rad(n) * rad(n+2) * rad(n+1)$.
    have h_rad : rad (n * (n + 2) * 1 * (n + 1) ^ 2) = rad n * rad (n + 2) * rad (n + 1) := by
      -- Since $n$, $n+2$, and $(n+1)^2$ are pairwise coprime, we can apply the multiplicative property of the radical function.
      have h_coprime : Nat.Coprime n (n + 2) ∧ Nat.Coprime (n * (n + 2)) ((n + 1) ^ 2) := by
        simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
        exact ⟨ odd_of_powerful_n_n_plus_2 h1 h3, by norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ] ⟩;
      convert rad_mul_of_coprime h_coprime.2 using 1 ; ring;
      rw [ ← rad_mul_of_coprime h_coprime.1 ] ; simp +decide [ rad ] ; ring;
      rw [ show 1 + n * 2 + n ^ 2 = ( 1 + n ) ^ 2 by ring, Nat.primeFactors_pow ] <;> norm_num;
    -- By lemma 2, we know that $rad(n) \leq \sqrt{n}$, $rad(n+2) \leq \sqrt{n+2}$, and $rad(n+1) \leq \sqrt{n+1}$.
    have h_rad_le_sqrt : (rad n : ℝ) ≤ Real.sqrt n ∧ (rad (n + 2) : ℝ) ≤ Real.sqrt (n + 2) ∧ (rad (n + 1) : ℝ) ≤ Real.sqrt (n + 1) := by
      exact ⟨ mod_cast rad_le_sqrt_of_powerful h1 hn.ne', mod_cast rad_le_sqrt_of_powerful h3 ( Nat.succ_ne_zero _ ), mod_cast rad_le_sqrt_of_powerful h2 ( Nat.succ_ne_zero _ ) ⟩;
    -- Therefore, $rad(n(n+2)(n+1)^2) \leq \sqrt{n(n+2)(n+1)}$.
    have h_rad_le_sqrt_prod : (rad (n * (n + 2) * 1 * (n + 1) ^ 2) : ℝ) ≤ Real.sqrt (n * (n + 2) * (n + 1)) := by
      convert mul_le_mul ( mul_le_mul h_rad_le_sqrt.1 h_rad_le_sqrt.2.1 ( by positivity ) ( by positivity ) ) h_rad_le_sqrt.2.2 ( by positivity ) ( by positivity ) using 1;
      · exact_mod_cast h_rad;
      · rw [ Real.sqrt_mul', Real.sqrt_mul' ] <;> positivity;
    refine lt_of_le_of_lt h_rad_le_sqrt_prod ?_;
    rw [ Real.sqrt_lt' <| by positivity ];
    rw [ ← Real.rpow_natCast _ 2, ← Real.rpow_mul ( by positivity ) ] ; norm_num ; ring_nf ; norm_cast ; nlinarith

/-
For any K and ε > 0, the set of natural numbers n such that n^ε < K is finite.
-/
lemma finite_of_bounded_power {K ε : ℝ} (hε : 0 < ε) : {n : ℕ | (n : ℝ) ^ ε < K}.Finite := by
  exact Set.finite_iff_bddAbove.2 ⟨ ⌊K ^ ( ε⁻¹ : ℝ ) ⌋₊, fun n hn => Nat.le_floor <| by exact le_trans ( by rw [ ← Real.rpow_mul ( Nat.cast_nonneg _ ) ] ; simp +decide [ hε.ne' ] ) <| Real.rpow_le_rpow ( by positivity ) hn.out.le <| by positivity ⟩

/-
If (n+1)^2 < K * ((n+1)^(3/2))^(6/5), then (n+1)^(1/5) < K.
-/
lemma algebraic_consequence_of_ABC {K : ℝ} {n : ℕ} (hK : 0 < K) (hn : 0 < n)
  (h_ineq : (n + 1 : ℝ)^2 < K * ((n + 1 : ℝ)^(3/2 : ℝ))^(6/5 : ℝ)) :
  (n + 1 : ℝ)^(1/5 : ℝ) < K := by
    contrapose! h_ineq ; norm_num at *;
    exact le_trans ( mul_le_mul_of_nonneg_right h_ineq ( by positivity ) ) ( by rw [ ← Real.rpow_mul ( by positivity ) ] ; rw [ ← Real.rpow_add ( by positivity ) ] ; norm_num )

/-
If n is odd, then n(n+2) and (n+1)^2 are coprime.
-/
lemma coprime_n_n_plus_2_n_plus_1_sq {n : ℕ} (h : Odd n) : Nat.Coprime (n * (n + 2)) ((n + 1)^2) := by
  norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
  norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ]

/-
For any natural number n, n(n+2) + 1 = (n+1)^2.
-/
lemma n_mul_n_plus_two_add_one (n : ℕ) : n * (n + 2) + 1 = (n + 1)^2 := by
  ring