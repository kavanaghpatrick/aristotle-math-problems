/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0b4aa2d5-97ba-4030-8e61-93d76a90b9cb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized and proven the Egyptian Fraction Decomposition of 5/n for specific residue classes, covering all n divisible by 2, 3, or 5.

The following results have been proven:
1. `egyptian_fraction_5_div_3m`: For all n divisible by 3 (n >= 3), 5/n = 1/x + 1/y + 1/z has a solution in positive integers.
2. `egyptian_fraction_5_div_5m`: For all n divisible by 5 (n >= 5), 5/n = 1/x + 1/y + 1/z has a solution in positive integers.
3. `egyptian_fraction_5_div_2m`: For all even n (n >= 2), 5/n = 1/x + 1/y + 1/z has a solution in positive integers.
4. `egyptian_fraction_5_small_n`: For all n with 2 <= n <= 30, 5/n = 1/x + 1/y + 1/z is solvable.
5. `egyptian_fraction_existence`: For any rational number q with 0 < q < 1, there exists a list of distinct positive integers whose reciprocals sum to q (general Egyptian Fraction existence).

The proofs use explicit constructions for the witnesses x, y, z as functions of n, verifying the equation 5*x*y*z = n*(y*z + x*z + x*y) in the natural numbers to avoid rational arithmetic issues.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For all n with 3|n and n >= 3, there exist positive x,y,z with 5/n = 1/x+1/y+1/z.
-/
theorem egyptian_fraction_5_div_3m (m : ℕ) (hm : 1 ≤ m) :
  ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = 3 * m * (y * z + x * z + x * y) := by
  by_contra! h_contra;
  -- Set n = 3m. Take x = m, y = 2m, z = 6m.
  set n := 3 * m
  set x := m
  set y := 2 * m
  set z := 6 * m;
  exact h_contra x y z hm ( by positivity ) ( by positivity ) ( by ring )

/-
For all n with 5|n and n >= 5, there exist positive x,y,z with 5/n = 1/x+1/y+1/z.
-/
theorem egyptian_fraction_5_div_5m (m : ℕ) (hm : 1 ≤ m) :
  ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = 5 * m * (y * z + x * z + x * y) := by
  -- Choose $x = 2m$, $y = 2m + 1$, and $z = 2m(2m + 1)$.
  use 2 * m, 2 * m + 1, 2 * m * (2 * m + 1);
  exact ⟨ by positivity, by positivity, by positivity, by ring ⟩

/-
For all even n >= 2, there exist positive x,y,z with 5/n = 1/x+1/y+1/z.
-/
theorem egyptian_fraction_5_div_2m (m : ℕ) (hm : 1 ≤ m) :
  ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = 2 * m * (y * z + x * z + x * y) := by
  by_contra! h_contra;
  -- Set n = 2m. Take x = m, y = m, z = 2m.
  set x := m
  set y := m
  set z := 2 * m;
  exact h_contra x y z hm hm ( by positivity ) ( by ring )

/-
For all n with 2 <= n <= 30, 5/n = 1/x + 1/y + 1/z is solvable.
-/
theorem egyptian_fraction_5_small_n :
  ∀ n, 2 ≤ n → n ≤ 30 → ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = n * (y * z + x * z + x * y) := by
  intro n hn hn';
  -- By examining each case individually, we can find suitable $x$, $y$, and $z$ such that the equation holds.
  by_contra h_contra;
  -- We will check all combinations of $x$, $y$, and $z$ in the range $1$ to $300$ to see if they satisfy the equation for each $n$.
  have h_check : ∀ n ∈ Finset.Icc 2 30, ∃ x ∈ Finset.Icc 1 300, ∃ y ∈ Finset.Icc 1 300, ∃ z ∈ Finset.Icc 1 300, 5 * x * y * z = n * (y * z + x * z + x * y) := by
    native_decide +revert;
  exact h_contra <| by obtain ⟨ x, hx, y, hy, z, hz, h ⟩ := h_check n ( Finset.mem_Icc.mpr ⟨ hn, hn' ⟩ ) ; exact ⟨ x, y, z, Finset.mem_Icc.mp hx |>.1, Finset.mem_Icc.mp hy |>.1, Finset.mem_Icc.mp hz |>.1, h ⟩ ;

/-
For any rational number q with 0 < q < 1, there exists a list of distinct positive integers whose reciprocals sum to q.
-/
def IsEgyptianFraction (q : ℚ) (l : List ℕ) : Prop :=
  l.Nodup ∧ (∀ n ∈ l, 0 < n) ∧ q = (l.map (fun n => (1 : ℚ) / n)).sum

theorem egyptian_fraction_existence (q : ℚ) (hq : 0 < q) (hq1 : q < 1) :
  ∃ l : List ℕ, IsEgyptianFraction q l := by
  unfold IsEgyptianFraction;
  -- Let $q = \frac{a}{b}$ be a rational number with $0 < q < 1$.
  obtain ⟨a, b, ha, hb, hab⟩ : ∃ a b : ℕ, 0 < a ∧ 0 < b ∧ a < b ∧ q = a / b := by
    use q.num.natAbs, q.den;
    field_simp;
    exact ⟨ by aesop, q.pos, by rw [ ← Int.ofNat_lt, Int.natAbs_of_nonneg ( Rat.num_nonneg.mpr hq.le ) ] ; simpa [ Rat.lt_iff ] using hq1, by simp +decide [ abs_of_pos, hq, Rat.mul_den ] ⟩;
  -- By the greedy algorithm, we can find such a list $l$.
  have h_greedy : ∀ {a b : ℕ}, 0 < a → 0 < b → a < b → ∃ l : List ℕ, l.Nodup ∧ (∀ n ∈ l, 0 < n) ∧ (a : ℚ) / b = ((List.map (fun n => (1 : ℚ) / n) l).sum) := by
    intros a b ha hb hab;
    induction' a using Nat.strong_induction_on with a ih generalizing b;
    -- Let $k = \lceil b/a \rceil$. Then $k > 0$ and $a * k \geq b$.
    obtain ⟨k, hk⟩ : ∃ k : ℕ, 0 < k ∧ a * k ≥ b ∧ a * (k - 1) < b := by
      exact ⟨ ( b + a - 1 ) / a, Nat.div_pos ( Nat.le_sub_one_of_lt ( by linarith ) ) ha, by linarith [ Nat.div_add_mod ( b + a - 1 ) a, Nat.mod_lt ( b + a - 1 ) ha, Nat.sub_add_cancel ( by linarith : 1 ≤ b + a ) ], by nlinarith [ Nat.div_mul_le_self ( b + a - 1 ) a, Nat.sub_add_cancel ( by linarith : 1 ≤ b + a ), Nat.sub_add_cancel ( show 1 ≤ ( b + a - 1 ) / a from Nat.div_pos ( Nat.le_sub_one_of_lt ( by linarith ) ) ha ) ] ⟩;
    -- Then $a * k - b < a$ and $a * k - b \geq 0$, so we can apply the induction hypothesis to $\frac{a * k - b}{b * k}$.
    have h_ind : ∃ l : List ℕ, l.Nodup ∧ (∀ n ∈ l, 0 < n) ∧ (a * k - b : ℚ) / (b * k) = ((List.map (fun n => (1 : ℚ) / n) l).sum) := by
      by_cases h_case : a * k - b = 0;
      · use []
        simp [h_case];
        exact Or.inl <| sub_eq_zero_of_eq <| mod_cast by linarith [ Nat.sub_add_cancel hk.2.1 ] ;
      · convert ih ( a * k - b ) _ _ _ _ using 1;
        rotate_left;
        rotate_left;
        exact b * k;
        · exact Nat.pos_of_ne_zero h_case;
        · nlinarith;
        · rw [ tsub_lt_iff_left ] <;> nlinarith [ Nat.sub_add_cancel hk.1 ];
        · rw [ Nat.cast_sub ( by linarith ) ] ; push_cast ; ring;
        · rw [ tsub_lt_iff_left ] <;> cases k <;> norm_num at * <;> nlinarith;
    obtain ⟨ l, hl₁, hl₂, hl₃ ⟩ := h_ind;
    refine' ⟨ k :: l, _, _, _ ⟩ <;> simp_all +decide [ List.nodup_cons ];
    · intro H;
      have h_contra : (a * k - b : ℚ) / (b * k) ≥ 1 / k := by
        rw [ hl₃ ];
        have h_contra : (List.map (fun n => (1 : ℚ) / n) l).sum ≥ (1 : ℚ) / k := by
          have h_mem : (1 : ℚ) / k ∈ List.map (fun n => (1 : ℚ) / n) l := by
            aesop
          have h_contra : ∀ {l : List ℚ}, (∀ n ∈ l, 0 ≤ n) → ∀ x ∈ l, x ≤ List.sum l := by
            exact?;
          exact h_contra ( fun n hn => by aesop ) _ h_mem;
        convert h_contra using 1;
        norm_num [ List.map_flatMap ];
      rw [ ge_iff_le, div_le_div_iff₀ ] at h_contra <;> norm_num at * <;> try nlinarith;
      · norm_cast at *;
        rw [ Int.subNatNat_eq_coe ] at h_contra ; push_cast at h_contra ; nlinarith [ Nat.sub_add_cancel hk.1 ];
      · exact mul_pos ( Nat.cast_pos.mpr hb ) ( Nat.cast_pos.mpr hk.1 );
    · rw [ ← hl₃, inv_eq_one_div, div_add_div, div_eq_div_iff ] <;> norm_num <;> ring <;> aesop;
  aesop