/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5b5bf303-ce30-4b18-93b8-95219874619e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d94555c4-f79e-4416-97a2-c3cdf5251251

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the attack on the Sierpinski Conjecture (Erdős-Straus for 5/n) for the case n ≡ 1 (mod 5).

Key results:
1. `sierpinski_div_2`, `sierpinski_div_3`: Solvability for n even or divisible by 3.
2. `sierpinski_mod_4_3`: Solvability for n ≡ 3 (mod 4).
3. `sierpinski_mod_60_21`, `sierpinski_mod_60_41`: Solvability for n ≡ 21, 41 (mod 60).
4. `sierpinski_reduction_final`: A reduction theorem proving that for n ≥ 4 with n ≡ 1 (mod 5), the conjecture holds for all cases except possibly n ≡ 1 (mod 60).
5. `sierpinski_bounded_verification_10000`: Verified the conjecture for all n < 10000 using `native_decide`.

We also proved auxiliary lemmas such as `sierpinski_mul_solvable` (multiplicative property) and `sierpinski_has_factor_mod_4_3` (solvability if n has a factor ≡ 3 mod 4). The remaining open case is n ≡ 1 (mod 60).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of SierpinskiSolvable: 5/n can be written as sum of three unit fractions.
-/
def SierpinskiSolvable (n : ℕ) : Prop := ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
If n is even and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_2 {n : ℕ} (h1 : n ≠ 0) (h2 : 2 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨ k, rfl ⟩ := h2;
  use 2 * k, k, k;
  grind

/-
If n is divisible by 3 and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_3 {n : ℕ} (h1 : n ≠ 0) (h2 : 3 ∣ n) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by $3$, we can write $n = 3k$ for some $k$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 3 * k := h2;
  -- We can write 5/(3k) = 1/k + 2/(3k).
  use k, 2 * k, 6 * k;
  exact ⟨ Nat.pos_of_ne_zero ( by aesop ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), by push_cast; ring ⟩

/-
If n = 5(2k+1) + 1, then SierpinskiSolvable n.
-/
theorem sierpinski_mod_5_q_odd {k : ℕ} : SierpinskiSolvable (5 * (2 * k + 1) + 1) := by
  convert sierpinski_div_2 _ _ using 1 <;> norm_num;
  grind

/-
Reduction lemma: if 4/(n(2k+1)) is solvable, then SierpinskiSolvable (10k+1).
-/
theorem sierpinski_mod_10_1_reduction {k : ℕ} (hk : k > 0)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((10 * k + 1 : ℚ) * (2 * k + 1)) = 1 / y + 1 / z) :
  SierpinskiSolvable (10 * k + 1) := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    -- Therefore, $5 / (10k + 1) = 1 / (2k + 1) + 1 / y + 1 / z$.
    have h_eq : (5 : ℚ) / (10 * k + 1) = 1 / (2 * k + 1) + 1 / y + 1 / z := by
      field_simp at h ⊢;
      grind;
    exact ⟨ 2 * k + 1, y, z, by positivity, by positivity, by positivity, by simpa [ ← @Rat.cast_inj ℝ ] using h_eq ⟩

/-
If n ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_4_3 {n : ℕ} (h : n % 4 = 3) : SierpinskiSolvable n := by
  -- Since n % 4 = 3, we can write n as 4k + 3 for some integer k.
  obtain ⟨k, rfl⟩ : ∃ k, n = 4 * k + 3 := by
    exact ⟨ n / 4, by rw [ ← h, Nat.div_add_mod ] ⟩;
  use 4 * k + 3, k + 1, ( k + 1 ) * ( 4 * k + 3 );
  field_simp
  ring;
  exact ⟨ by positivity, by positivity, by positivity, by push_cast; ring ⟩

/-
If we can solve the n ≡ 1 (mod 20) case, then we can solve all n ≡ 1 (mod 5).
-/
theorem sierpinski_reduction_to_mod_20 (h_mod_20 : ∀ n : ℕ, n % 20 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 5 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    by_cases h_even : Even n;
    · exact sierpinski_div_2 hn ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod4 : n % 4 = 3;
      · exact sierpinski_mod_4_3 ( by omega );
      · convert h_mod_20 n ( by rw [ ← Nat.mod_mod_of_dvd n ( by decide : 4 ∣ 20 ) ] at h_mod4; rw [ ← Nat.mod_mod_of_dvd n ( by decide : 5 ∣ 20 ) ] at hn_mod; rw [ Nat.not_even_iff ] at h_even; omega ) using 1

/-
Correctness of the heuristic check function.
-/
def checkSierpinski (n : ℕ) (limitX : ℕ) (limitK : ℕ) : Option (ℕ × ℕ × ℕ) :=
  let start := n / 5 + 1
  (List.range limitX).findSome? fun i =>
    let x := start + i
    let A := 5 * x - n
    let B := n * x
    (List.range limitK).findSome? fun j =>
      let k := j + 1
      if (B + k) % A == 0 then
        let y := (B + k) / A
        if (B * y) % k == 0 then
          let z := (B * y) / k
          some (x, y, z)
        else none
      else none

theorem checkSierpinski_correct {n : ℕ} {limitX limitK : ℕ} {x y z : ℕ}
  (hn : n ≠ 0)
  (h : checkSierpinski n limitX limitK = some (x, y, z)) :
  SierpinskiSolvable n := by
    unfold checkSierpinski at h;
    obtain ⟨i, hi⟩ : ∃ i ∈ List.range limitX, ∃ j ∈ List.range limitK, (n * (n / 5 + 1 + i) + (j + 1)) % (5 * (n / 5 + 1 + i) - n) = 0 ∧ (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) % (j + 1) = 0 ∧ (n / 5 + 1 + i, ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n)), (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) / (j + 1)) = (x, y, z) := by
      rw [ List.findSome?_eq_some_iff ] at h;
      obtain ⟨ l₁, a, l₂, h₁, h₂, h₃ ⟩ := h;
      rw [ List.findSome?_eq_some_iff ] at h₂;
      grind;
    rcases hi with ⟨ hi₁, j, hj₁, hj₂, hj₃, rfl, rfl, rfl ⟩;
    refine' ⟨ n / 5 + 1 + i, ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ), n * ( n / 5 + 1 + i ) * ( ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ) ) / ( j + 1 ), _, _, _, _ ⟩;
    · positivity;
    · exact Nat.div_pos ( Nat.le_of_dvd ( Nat.succ_pos _ ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by omega ) );
    · refine' Nat.div_pos _ ( Nat.succ_pos _ );
      refine' Nat.le_of_dvd _ ( Nat.dvd_of_mod_eq_zero hj₃ );
      exact Nat.mul_pos ( Nat.mul_pos ( Nat.pos_of_ne_zero hn ) ( by positivity ) ) ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) );
    · rw [ Nat.cast_div, Nat.cast_div ];
      · field_simp;
        rw [ Nat.cast_sub ] <;> push_cast;
        · rw [ add_div', mul_div_assoc' ];
          · rw [ eq_div_iff ];
            · rw [ Nat.cast_div ( Nat.dvd_of_mod_eq_zero hj₂ ) ] <;> norm_num;
              · field_simp;
                rw [ div_add', div_eq_div_iff ] <;> norm_cast <;> norm_num;
                · exact Or.inl ( by rw [ Nat.cast_sub ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ] ; push_cast; ring );
                · omega;
                · omega;
                · omega;
              · omega;
            · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
          · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
        · omega;
      · exact Nat.dvd_of_mod_eq_zero hj₃;
      · positivity;
      · exact Nat.dvd_of_mod_eq_zero hj₂;
      · exact ne_of_gt <| Nat.cast_pos.mpr <| Nat.sub_pos_of_lt <| by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ;

/-
If n ≡ 21 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_21 {n : ℕ} (h : n % 60 = 21) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by 3, we can apply the theorem `sierpinski_div_3`.
  have h_div_3 : 3 ∣ n := by
    omega
  exact sierpinski_div_3 (by
  grind) h_div_3

/-
Bounded verification of Sierpinski conjecture for n < 100.
-/
def verifySierpinskiStep (n : ℕ) : Bool :=
  if n % 5 == 1 && n >= 4 then
    (checkSierpinski n 100 1000).isSome
  else
    true

def verifySierpinskiUpTo (N : ℕ) : Bool :=
  (List.range N).all verifySierpinskiStep

theorem sierpinski_bounded_verification : verifySierpinskiUpTo 100 = true := by native_decide

/-
If k is SierpinskiSolvable, then any multiple k*m is also SierpinskiSolvable.
-/
theorem sierpinski_mul_solvable {k m : ℕ} (hm : m > 0) (h : SierpinskiSolvable k) : SierpinskiSolvable (k * m) := by
  obtain ⟨ x, y, z, hx, hy, hz, h' ⟩ := h;
  use x * m, y * m, z * m;
  simp_all +decide [ mul_comm, mul_assoc, mul_left_comm, div_eq_mul_inv ];
  linear_combination' h' * ( m : ℚ ) ⁻¹

/-
If n ≡ 41 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_41 {n : ℕ} (h : n % 60 = 41) : SierpinskiSolvable n := by
  -- Let $x = 12k + 9$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 60 * k + 41 := by
    exact ⟨ n / 60, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let $x = 12k + 9$, $y = (60k + 41)(4k + 3)$, and $z = (60k + 41)(12k + 9)$.
  use 12 * k + 9, (60 * k + 41) * (4 * k + 3), (60 * k + 41) * (12 * k + 9);
  field_simp;
  exact ⟨ by linarith, by positivity, by positivity, by push_cast; ring ⟩

/-
If n has a divisor d ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_has_factor_mod_4_3 {n : ℕ} (hn : n ≠ 0) (h : ∃ d, d ∣ n ∧ d % 4 = 3) : SierpinskiSolvable n := by
  -- Apply the sierpinski_mod_4_3 theorem to the divisor d.
  obtain ⟨d, hd_div, hd_mod⟩ := h;
  have hd_solvable : SierpinskiSolvable d := by
    exact sierpinski_mod_4_3 hd_mod;
  obtain ⟨ k, rfl ⟩ := hd_div; exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop ) ) hd_solvable;

/-
If we can solve n ≡ 1 (mod 60), we can solve all n ≡ 1 (mod 20).
-/
theorem sierpinski_reduction_to_mod_60_1 (h_mod_60_1 : ∀ n : ℕ, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 20 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    have h_cases : n % 60 = 1 ∨ n % 60 = 21 ∨ n % 60 = 41 := by
      omega;
    exact h_cases.elim ( fun h => h_mod_60_1 n h ) fun h => h.elim ( fun h => sierpinski_mod_60_21 h ) fun h => sierpinski_mod_60_41 h

/-
Reduction to the case where all prime factors are 1 mod 4.
-/
theorem sierpinski_reduction_hard_primes
  (h_hard : ∀ n, n ≥ 4 → (∀ p, p.Prime → p ∣ n → p % 4 = 1) → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → SierpinskiSolvable n := by
    intro n hn; by_cases h_even : Even n; simp_all +decide [ Nat.even_iff ] ;
    · exact sierpinski_div_2 ( by linarith ) ( Nat.dvd_of_mod_eq_zero h_even );
    · by_cases h_factor : ∃ p, Nat.Prime p ∧ p ∣ n ∧ p % 4 = 3;
      · exact sierpinski_has_factor_mod_4_3 ( by linarith ) ⟨ h_factor.choose, h_factor.choose_spec.2.1, h_factor.choose_spec.2.2 ⟩;
      · apply h_hard n hn;
        intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
        have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
        exact absurd ( even_iff_two_dvd.mpr dp ) ( by simpa using h_even )

/-
If SierpinskiSolvable holds for all primes, it holds for all n >= 2.
-/
theorem sierpinski_reduction_to_primes (h_primes : ∀ p : ℕ, p.Prime → SierpinskiSolvable p) :
  ∀ n : ℕ, n ≥ 2 → SierpinskiSolvable n := by
    intro n hn;
    obtain ⟨ p, hp ⟩ := Nat.exists_prime_and_dvd ( by linarith : n ≠ 1 );
    obtain ⟨ k, rfl ⟩ := hp.2;
    exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( h_primes p hp.1 )

/-
Greedy reduction: if 20/(n(n+4)) is sum of 2 unit fractions, then n is solvable.
-/
theorem sierpinski_greedy_reduction {n : ℕ} (hn : n ≠ 0) (h_mod : n % 5 = 1)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 20 / ((n : ℚ) * (n + 4)) = 1 / y + 1 / z) :
  SierpinskiSolvable n := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    use (n + 4) / 5, y, z;
    rw [ Nat.cast_div ] <;> norm_num;
    · field_simp at h ⊢;
      exact ⟨ by omega, hy, hz, by linarith ⟩;
    · omega

/-
Bounded verification of Sierpinski conjecture for n < 1000.
-/
theorem sierpinski_bounded_verification_1000 : verifySierpinskiUpTo 1000 = true := by native_decide

/-
Bounded verification of Sierpinski conjecture for n < 10000.
-/
theorem sierpinski_bounded_verification_10000 : verifySierpinskiUpTo 10000 = true := by native_decide

/-
Final reduction: The only open case for n ≡ 1 (mod 5) is n ≡ 1 (mod 60).
-/
theorem sierpinski_reduction_final (h_mod_60_1 : ∀ n, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → n % 5 = 1 → SierpinskiSolvable n := by
    intro n hn h;
    by_cases h_even : Even n;
    · exact sierpinski_div_2 ( by linarith ) ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod_4 : n % 4 = 3;
      · exact?;
      · by_cases h_mod_20 : n % 20 = 1;
        · exact sierpinski_reduction_to_mod_60_1 h_mod_60_1 n ( by linarith ) h_mod_20;
        · grind

/-
Reduction lemma for n = 60q + 1: if 4/((60q+1)(12q+1)) is a sum of two unit fractions, then n is solvable.
-/
theorem sierpinski_mod_60_1_reduction {q : ℕ} (hq : q > 0)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z) :
  SierpinskiSolvable (60 * q + 1) := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    use 12 * q + 1, y, z;
    field_simp at *;
    exact ⟨ by linarith, hy, hz, by push_cast; linarith ⟩

/-
If n ≡ 301 (mod 420), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_420_301 {n : ℕ} (h : n % 420 = 301) : SierpinskiSolvable n := by
  have h3 : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 7, Nat.dvd_of_mod_eq_zero ( by omega ), by norm_num ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by omega ) h3

/-
If n ≡ 121 (mod 660), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_660_121 {n : ℕ} (h : n % 660 = 121) : SierpinskiSolvable n := by
  -- Since 11 is a factor of n and 11 ≡ 3 (mod 4), by sierpinski_has_factor_mod_4_3, n is solvable.
  have h_factor : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 11, Nat.dvd_of_mod_eq_zero ( by omega ), by norm_num ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by aesop_cat ) h_factor

/-
If n ≡ 361 (mod 1140), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_1140_361 {n : ℕ} (h : n % 1140 = 361) : SierpinskiSolvable n := by
  -- Since $19 \mid n$ and $19 \equiv 3 \pmod{4}$, we can apply the theorem `sierpinski_has_factor_mod_4_3`.
  have h_factor : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 19, Nat.dvd_of_mod_eq_zero ( by omega ), by decide ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by aesop_cat ) h_factor

/-
Bounded verification of Sierpinski conjecture for n < 100000.
-/
theorem sierpinski_bounded_verification_100000 : verifySierpinskiUpTo 100000 = true := by native_decide

/-
If n has a divisor d ≡ 3 (mod 4), then 4/n is the sum of two unit fractions.
-/
lemma four_div_n_solvable_2_of_factor_mod_4_3 {n : ℕ} (hn : n > 0)
  (h : ∃ d, d ∣ n ∧ d % 4 = 3) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (n : ℚ) = 1 / y + 1 / z := by
    -- Let $p$ be a prime factor of $d$ such that $p \equiv 3 \pmod{4}$.
    obtain ⟨p, hp_prime, hp_div, hp_mod⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ∧ p % 4 = 3 := by
      obtain ⟨ d, hd₁, hd₂ ⟩ := h;
      by_contra h_no_prime;
      -- If $d$ has no prime factors congruent to $3 \mod 4$, then all prime factors of $d$ must be congruent to $1 \mod 4$.
      have h_all_prime_factors_1_mod_4 : ∀ p : ℕ, Nat.Prime p → p ∣ d → p % 4 = 1 := by
        intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
        · have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
          omega;
        · exact h_no_prime p pp ( dvd_trans dp hd₁ ) h;
      -- Since all prime factors of $d$ are congruent to $1 \mod 4$, $d$ itself must be congruent to $1 \mod 4$.
      have h_d_congruent_to_1_mod_4 : d % 4 = 1 := by
        rw [ ← Nat.prod_primeFactorsList ( show d ≠ 0 from by aesop_cat ) ] ; rw [ List.prod_nat_mod ] ; ( ( erw [ List.prod_eq_one ] <;> intros <;> aesop ) );
      cases h_d_congruent_to_1_mod_4.symm.trans hd₂;
    -- Let $n = p * k$.
    obtain ⟨k, rfl⟩ : ∃ k, n = p * k := hp_div;
    -- Let $m = \frac{p + 1}{4}$. Since $p \equiv 3 \pmod{4}$, $m$ is an integer.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, p = 4 * m - 1 := by
      exact ⟨ p / 4 + 1, by omega ⟩;
    -- Let $y = kmp$ and $z = km$.
    use k * m * p, k * m;
    rcases m with ( _ | m ) <;> simp_all +decide [ Nat.mul_succ ];
    -- Combine and simplify the fractions on the right-hand side.
    field_simp
    ring

/-
If n ≡ 241 (mod 420), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_420_241 {n : ℕ} (h : n % 420 = 241) : SierpinskiSolvable n := by
  -- By the reduction lemma, if $4/((60q+1)(12q+1))$ is a sum of two unit fractions, then $n$ is solvable.
  have h_reduction : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * ((n - 1) / 60) + 1) * (12 * ((n - 1) / 60) + 1) : ℚ) = 1 / y + 1 / z := by
    convert four_div_n_solvable_2_of_factor_mod_4_3 _ _ using 1;
    case convert_1 => exact ( 60 * ( ( n - 1 ) / 60 ) + 1 ) * ( 12 * ( ( n - 1 ) / 60 ) + 1 );
    · cases n <;> norm_num at *;
      norm_num [ Nat.cast_div ( show 60 ∣ ( ‹_› : ℕ ) from Nat.dvd_of_mod_eq_zero ( by omega ) ) ];
    · positivity;
    · use 7;
      rw [ ← Nat.mod_add_div n 420, h ] ; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ];
      norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ];
      norm_num [ show 420 * ( n / 420 ) / 60 = 7 * ( n / 420 ) by rw [ Nat.div_eq_of_eq_mul_left ] <;> linarith ];
  have h_div : SierpinskiSolvable (60 * ((n - 1) / 60) + 1) := by
    convert sierpinski_mod_60_1_reduction ( show 0 < ( n - 1 ) / 60 from Nat.div_pos ( Nat.le_sub_one_of_lt ( by omega ) ) ( by decide ) ) _ using 1;
    convert h_reduction using 6;
    rw [ Nat.cast_div ( show 60 ∣ n - 1 from Nat.dvd_of_mod_eq_zero ( by omega ) ) ( by norm_num ) ] ; norm_num;
    rw [ Nat.cast_sub ( by omega ) ] ; push_cast ; ring;
  rw [ show n = 60 * ( ( n - 1 ) / 60 ) + 1 by omega ] ; exact h_div

/-
If n ≡ 601 (mod 660), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_660_601 {n : ℕ} (h : n % 660 = 601) : SierpinskiSolvable n := by
  obtain ⟨q, hq⟩ : ∃ q : ℕ, n = 660 * q + 601 := by
    exact ⟨ n / 660, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- We need to check if $4 / ((60 * (11 * q + 10) + 1 : ℚ) * (12 * (11 * q + 10) + 1)) = 1 / y + 1 / z$ has positive integer solutions $y, z$.
  have h_check : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * (11 * q + 10) + 1 : ℚ) * (12 * (11 * q + 10) + 1)) = 1 / y + 1 / z := by
    -- By the lemma, since $M = (60 * (11 * q + 10) + 1) * (12 * (11 * q + 10) + 1)$ has a factor $11$ which is $3 \mod 4$, $4 / M$ is a sum of two unit fractions.
    have h_factor : ∃ d, d ∣ ((60 * (11 * q + 10) + 1) * (12 * (11 * q + 10) + 1)) ∧ d % 4 = 3 := by
      exact ⟨ 11, Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, Nat.mul_mod ] ), by norm_num ⟩;
    convert four_div_n_solvable_2_of_factor_mod_4_3 _ h_factor using 1 ; norm_cast;
    positivity;
  convert sierpinski_mod_60_1_reduction _ _ using 1;
  rotate_left;
  exacts [ 11 * q + 10, by norm_num, by simpa using h_check, by linarith ]

/-
If n ≡ 661 (mod 1140), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_1140_661 {n : ℕ} (h : n % 1140 = 661) : SierpinskiSolvable n := by
  -- Let n = 1140k + 661.
  obtain ⟨k, rfl⟩ : ∃ k, n = 1140 * k + 661 := by
    exact ⟨ n / 1140, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let x = 12(19k+11) + 1 = 228k + 133 = 19(12k+7).
  set x := 12 * (19 * k + 11) + 1
  set M := (1140 * k + 661) * x;
  -- By four_div_n_solvable_2_of_factor_mod_4_3, 4/M is a sum of two unit fractions.
  have h4M : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (M : ℚ) = 1 / y + 1 / z := by
    have h_factor : ∃ d, d ∣ M ∧ d % 4 = 3 := by
      simp +zetaDelta at *;
      exact ⟨ 19, Nat.dvd_of_mod_eq_zero ( by ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ), by norm_num ⟩;
    convert four_div_n_solvable_2_of_factor_mod_4_3 ( show M > 0 from Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ) ) h_factor using 1;
  convert sierpinski_mod_60_1_reduction _ _ using 1;
  rotate_left;
  exact 19 * k + 11;
  · grind;
  · grind;
  · ring

/-
General reduction: if p is a prime ≡ 3 (mod 4) and p divides (60a+1)(12a+1), then any n ≡ 60a+1 (mod 60p) is solvable.
-/
theorem sierpinski_linear_reduction {p a : ℕ} (hp : p.Prime) (hp3 : p % 4 = 3)
  (h_div : ((60 * a + 1) * (12 * a + 1)) % p = 0) :
  ∀ n, n % (60 * p) = (60 * a + 1) % (60 * p) → SierpinskiSolvable n := by
    -- Let's rewrite the goal using the provided solution.
    intro n hn_mod
    obtain ⟨q, hq⟩ : ∃ q, n = 60 * q + 1 ∧ q % p = a % p := by
      obtain ⟨q, hq⟩ : ∃ q, n = 60 * q + 1 := by
        use (n - 1) / 60;
        have hq : n % 60 = 1 := by
          have := congr_arg ( · % 60 ) hn_mod; norm_num [ Nat.add_mod, Nat.mul_mod ] at this; aesop;
        omega
      generalize_proofs at *; (
      simp_all +decide [ Nat.add_mod, Nat.mul_mod_mul_left ];
      have := Nat.modEq_iff_dvd.mp hn_mod.symm; norm_num at this;
      obtain ⟨ k, hk ⟩ := this; nlinarith [ show k = 0 by nlinarith [ Nat.zero_le ( q % p ), Nat.zero_le ( a % p ), Nat.mod_lt q hp.pos, Nat.mod_lt a hp.pos ] ] ;);
    -- By the reduction lemma, if $4/((60q+1)(12q+1))$ is a sum of two unit fractions, then $n$ is solvable.
    have h_reduction : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z := by
      have h_factor : ∃ d, d ∣ (60 * q + 1) * (12 * q + 1) ∧ d % 4 = 3 := by
        use p;
        simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_mul ];
        exact Or.imp ( fun h => Nat.dvd_of_mod_eq_zero <| by simpa [ Nat.add_mod, Nat.mul_mod, hq.2 ] using Nat.mod_eq_zero_of_dvd h ) ( fun h => Nat.dvd_of_mod_eq_zero <| by simpa [ Nat.add_mod, Nat.mul_mod, hq.2 ] using Nat.mod_eq_zero_of_dvd h ) h_div;
      have := four_div_n_solvable_2_of_factor_mod_4_3 ( show 0 < ( 60 * q + 1 ) * ( 12 * q + 1 ) by positivity ) h_factor; aesop;
    rcases q with ( _ | q ) <;> simp_all +decide;
    · norm_num [ ← hq.2 ] at *;
      rcases h_reduction with ⟨ y, hy, x, hx, h ⟩ ; rw [ inv_add_inv, eq_div_iff ] at h <;> norm_cast at * <;> nlinarith [ Nat.Prime.one_lt hp ] ;
    · convert sierpinski_mod_60_1_reduction ( Nat.succ_pos q ) _ using 1;
      aesop

/-
Definition of hard case: all prime factors of (60q+1)(12q+1) are 1 mod 4. If not hard case, then solvable.
-/
def SierpinskiHardCase (q : ℕ) : Prop :=
  ∀ p, p.Prime → p ∣ ((60 * q + 1) * (12 * q + 1)) → p % 4 = 1

theorem solvable_of_not_hard {q : ℕ} (hq : q > 0) (h : ¬ SierpinskiHardCase q) :
  SierpinskiSolvable (60 * q + 1) := by
    -- If not hard case, then ∃ p, p.Prime, p ∣ (60 * q + 1) * (12 * q + 1), p % 4 ≠ 1
    obtain ⟨p, hp_prime, hp_div, hp_mod⟩ : ∃ p : ℕ, p.Prime ∧ p ∣ (60 * q + 1) * (12 * q + 1) ∧ p % 4 ≠ 1 := by
      contrapose! h; aesop;
    -- Since p is odd and not 1 mod 4, it must be 3 mod 4.
    have hp_mod_3 : p % 4 = 3 := by
      obtain ⟨ k, hk ⟩ := hp_div; replace hk := congr_arg ( · % 4 ) hk; norm_num [ Nat.add_mod, Nat.mul_mod ] at hk; have := Nat.mod_lt p zero_lt_four; interval_cases p % 4 <;> simp_all +decide ;
      omega;
    convert sierpinski_mod_60_1_reduction _ _ using 1;
    · assumption;
    · convert four_div_n_solvable_2_of_factor_mod_4_3 _ _;
      norm_cast;
      · positivity;
      · use p

/-
Strong reduction: It suffices to prove solvability for n = 60q + 1 where all prime factors of n and 12q + 1 are 1 mod 4.
-/
theorem sierpinski_strong_reduction
  (h : ∀ q : ℕ, q > 0 →
    (∀ p, p.Prime → p ∣ (60 * q + 1) → p % 4 = 1) →
    (∀ p, p.Prime → p ∣ (12 * q + 1) → p % 4 = 1) →
    SierpinskiSolvable (60 * q + 1)) :
  ∀ n, n ≥ 4 → n % 60 = 1 → SierpinskiSolvable n := by
    -- Assume n ≥ 4 and n ≡ 1 (mod 60). Then n = 60q + 1 for some q > 0.
    intro n hn hn_mod
    obtain ⟨q, hq_pos, rfl⟩ : ∃ q, q > 0 ∧ n = 60 * q + 1 := by
      exact ⟨ n / 60, by omega, by omega ⟩;
    by_cases hq : SierpinskiHardCase q;
    · exact h q hq_pos ( fun p pp dp => hq p pp ( dvd_mul_of_dvd_left dp _ ) ) ( fun p pp dp => hq p pp ( dvd_mul_of_dvd_right dp _ ) );
    · exact?

/-
If q ≡ 1 (mod 3), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_3_1_reduction {q : ℕ} (hq : q % 3 = 1) : SierpinskiSolvable (60 * q + 1) := by
  -- Let $n = 60q + 1$.
  let n := 60 * q + 1;
  -- Let $x = 12q + 2$.
  let x := 12 * q + 2
  use x, (n * x * (n * x + 1)) / 9, (n * x + 1) / 9
  generalize_proofs at *; (
  -- Now let's verify that these values satisfy the equation.
  have h_eq : 5 / (n : ℚ) = 1 / x + 1 / ((n * x * (n * x + 1)) / 9) + 1 / ((n * x + 1) / 9) := by
    simp +zetaDelta at *; (
    -- Combine and simplify the fractions on the right-hand side.
    field_simp
    ring); -- This completes the proof.
  generalize_proofs at *; (
  rw [ Nat.cast_div, Nat.cast_div ] <;> norm_num at *;
  · grind;
  · grind +ring;
  · grind +ring))

/-
If q ≡ 18 or 21 (mod 23), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_23_18_21 {q : ℕ} (h : q % 23 = 18 ∨ q % 23 = 21) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · -- Let's apply the linear reduction theorem with p=23.
    have h_linear_reduction : ∀ n, n % (60 * 23) = (60 * 18 + 1) % (60 * 23) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · norm_num;
      · norm_num;
    grind;
  · -- Apply the sierpinski_linear_reduction theorem with p=23 and a=21.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 23) (by norm_num : 23 % 4 = 3) (by norm_num : ((60 * 21 + 1) * (12 * 21 + 1)) % 23 = 0);
    grind

/-
If q ≡ 16 or 18 (mod 31), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_31_16_18 {q : ℕ} (h : q % 31 = 16 ∨ q % 31 = 18) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 31, h ] ;
  · -- Apply the sierpinski_linear_reduction theorem with p=31 and a=16.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 31) (by norm_num : 31 % 4 = 3) (by norm_num : ((60 * 16 + 1) * (12 * 16 + 1)) % 31 = 0) (60 * (16 + 31 * (q / 31)) + 1) (by
    grind);
  · -- Apply the sierpinski_linear_reduction theorem with p=31 and a=18.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 31) (by norm_num : 31 % 4 = 3) (by norm_num : ((60 * 18 + 1) * (12 * 18 + 1)) % 31 = 0);
    grind

/-
If q ≡ 5 or 25 (mod 43), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_43_5_25 {q : ℕ} (h : q % 43 = 5 ∨ q % 43 = 25) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the reduction lemma with p=43 and the appropriate a based on the congruence of q mod 43.
  apply sierpinski_linear_reduction (by norm_num : Nat.Prime 43) (by norm_num : 43 % 4 = 3);
  rotate_right;
  exact if h' : q % 43 = 5 then 5 else 25;
  · split_ifs <;> norm_num;
  · grind

/-
If q ≡ 18 or 43 (mod 47), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_47_18_43 {q : ℕ} (h : q % 47 = 18 ∨ q % 47 = 43) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 47 ) ( by norm_num ) _ _ ( show ( 60 * q + 1 ) % ( 60 * 47 ) = ( 60 * 18 + 1 ) % ( 60 * 47 ) by omega ) using 1;
    exact?;
  · have h_linear_reduction : ∀ n, n % (60 * 47) = (60 * 43 + 1) % (60 * 47) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · exact?;
      · norm_num;
    exact h_linear_reduction _ ( by omega )

/-
If q ≡ 54 or 58 (mod 59), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_59_54_58 {q : ℕ} (h : q % 59 = 54 ∨ q % 59 = 58) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · -- Apply the linear reduction with p=59 and a=54.
    have h_linear : ∀ n, n % (60 * 59) = (60 * 54 + 1) % (60 * 59) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · norm_num;
      · norm_num;
    exact h_linear _ ( by omega );
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 59 ) ( by norm_num ) _ _ ( Nat.ModEq.symm <| Nat.modEq_of_dvd <| ?_ ) using 1;
    exacts [ 58, by norm_num, by exact ⟨ q / 59 - 58 / 59, by omega ⟩ ]

/-
If q ≡ 39 or 48 (mod 67), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_67_39_48 {q : ℕ} (h : q % 67 = 39 ∨ q % 67 = 48) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 67, h ];
  · -- Apply the linear reduction with p=67 and a=39.
    have h_linear : ∀ n, n % (60 * 67) = (60 * 39 + 1) % (60 * 67) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction; norm_num; norm_num; norm_num;
    grind +ring;
  · -- Apply the sierpinski_linear_reduction theorem with p=67 and a=48.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 67) (by norm_num : 67 % 4 = 3) (by norm_num : ((60 * 48 + 1) * (12 * 48 + 1)) % 67 = 0) (60 * (48 + 67 * (q / 67)) + 1) (by
    grind)

/-
If q ≡ 13 or 65 (mod 71), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_71_13_65 {q : ℕ} (h : q % 71 = 13 ∨ q % 71 = 65) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 71, h ];
  · have := sierpinski_linear_reduction ( by norm_num : Nat.Prime 71 ) ( by norm_num ) ( by norm_num : ( ( 60 * 13 + 1 ) * ( 12 * 13 + 1 ) ) % 71 = 0 ) ( 60 * ( 13 + 71 * ( q / 71 ) ) + 1 ) ?_ <;> norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
    · exact this;
    · grind +ring;
  · -- Apply the sierpinski_linear_reduction theorem with p=71.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 71) (by norm_num : 71 % 4 = 3) (by norm_num : ((60 * 65 + 1) * (12 * 65 + 1)) % 71 = 0);
    grind +ring

/-
If q ≡ 4 or 5 (mod 7), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_7_4_5 {q : ℕ} (h : q % 7 = 4 ∨ q % 7 = 5) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 7 ) ( by norm_num ) _ _ using 1;
    rotate_left;
    exact 4;
    norm_num;
    exact 60 * q + 1;
    grind;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 7 ) ( by norm_num ) _ _ using 1;
    rotate_left;
    exact 5;
    decide +kernel;
    exact 60 * q + 1;
    grind

/-
If q ≡ 6 (mod 19), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_19_6 {q : ℕ} (h : q % 19 = 6) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the sierpinski_linear_reduction theorem with p=19 and a=6.
  apply sierpinski_linear_reduction (by norm_num : Nat.Prime 19) (by norm_num : 19 % 4 = 3) (by norm_num : ((60 * 6 + 1) * (12 * 6 + 1)) % 19 = 0);
  rw [ ← Nat.mod_add_div q 19, h ] ; ring_nf; norm_num;

/-
If q ≡ 2 or 10 (mod 11), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_11_2_10 {q : ℕ} (h : q % 11 = 2 ∨ q % 11 = 10) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the sierpinski_linear_reduction theorem with p=11.
  have h_linear : ∀ n, n % (60 * 11) = (60 * q + 1) % (60 * 11) → SierpinskiSolvable n := by
    apply sierpinski_linear_reduction;
    · norm_num;
    · norm_num;
    · rcases h with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ];
  exact h_linear _ rfl

/-
If q ≡ 25 or 46 (mod 79), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_79_25_46 {q : ℕ} (h : q % 79 = 25 ∨ q % 79 = 46) : SierpinskiSolvable (60 * q + 1) := by
  -- We use sierpinski_linear_reduction with p=79.
  have h_div : 79 ∣ ((60 * q + 1) * (12 * q + 1)) := by
    rcases h with ( h | h ) <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, h ];
  exact solvable_of_not_hard ( by omega ) ( by
    intro H; have := H 79; norm_num at this;
    contradiction )

/-
If q ≡ 65 or 76 (mod 83), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_83_65_76 {q : ℕ} (h : q % 83 = 65 ∨ q % 83 = 76) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 83, h ];
  · -- By sierpinski_linear_reduction, since 83 divides (60*65 + 1)(12*65 + 1), we can conclude that 60*(65 + 83*k) + 1 is solvable.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 83) (by norm_num : 83 % 4 = 3) (by norm_num : ((60 * 65 + 1) * (12 * 65 + 1)) % 83 = 0);
    grind;
  · -- Apply the sierpinski_linear_reduction theorem with p=83 and a=76.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 83) (by norm_num : 83 % 4 = 3) (by norm_num : ((60 * 76 + 1) * (12 * 76 + 1)) % 83 = 0) (60 * (76 + 83 * (q / 83)) + 1) (by
    grind)

/-
Bounded verification of Sierpinski conjecture for n < 200000.
-/
theorem sierpinski_bounded_verification_200000 : verifySierpinskiUpTo 200000 = true := by native_decide

/-
If q ≡ 12 or 60 (mod 103), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_103_12_60 {q : ℕ} (h : q % 103 = 12 ∨ q % 103 = 60) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 103 ) ( by norm_num : 103 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 12;
    norm_num;
    exact 60 * q + 1;
    grind;
  · -- Apply the linear reduction with p=103.
    apply sierpinski_linear_reduction;
    case p => exact 103;
    all_goals norm_num;
    rotate_right;
    exacts [ 60, by norm_num, by omega ]

/-
If q ≡ 41 or 98 (mod 107), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_107_41_98 {q : ℕ} (h : q % 107 = 41 ∨ q % 107 = 98) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 107 ) ( by norm_num : 107 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 41;
    decide +revert;
    exact 60 * q + 1;
    grind;
  · -- Apply the linear reduction with p=107.
    apply sierpinski_linear_reduction;
    rotate_left;
    rotate_left;
    rotate_left;
    rotate_left;
    exacts [ 107, 98, by norm_num, by norm_num, by norm_num, by omega ]

/-
If q ≡ 74 or 91 (mod 127), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_127_74_91 {q : ℕ} (h : q % 127 = 74 ∨ q % 127 = 91) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 127, h ];
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 127 ) ( by norm_num : 127 % 4 = 3 ) _ _ using 1 ; norm_num [ Nat.add_mod, Nat.mul_mod ];
    rotate_left;
    exact 74;
    decide +revert;
    exact 60 * ( 74 + 127 * ( q / 127 ) ) + 1;
    grind;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 127 ) ( by norm_num : 127 % 4 = 3 ) _ _ using 1 ; norm_num [ Nat.add_mod, Nat.mul_mod ];
    rotate_left;
    exact 91;
    decide +revert;
    exact 60 * ( 91 + 127 * ( q / 127 ) ) + 1;
    grind

/-
If q is in one of the covered residue classes, then 60q+1 is Sierpinski solvable.
-/
def IsCoveredByKnownReductions (q : ℕ) : Prop :=
  q % 3 = 1 ∨
  q % 7 = 4 ∨ q % 7 = 5 ∨
  q % 11 = 2 ∨ q % 11 = 10 ∨
  q % 19 = 6 ∨
  q % 23 = 18 ∨ q % 23 = 21 ∨
  q % 31 = 16 ∨ q % 31 = 18 ∨
  q % 43 = 5 ∨ q % 43 = 25 ∨
  q % 47 = 18 ∨ q % 47 = 43 ∨
  q % 59 = 54 ∨ q % 59 = 58 ∨
  q % 67 = 39 ∨ q % 67 = 48 ∨
  q % 71 = 13 ∨ q % 71 = 65 ∨
  q % 79 = 25 ∨ q % 79 = 46 ∨
  q % 83 = 65 ∨ q % 83 = 76 ∨
  q % 103 = 12 ∨ q % 103 = 60 ∨
  q % 107 = 41 ∨ q % 107 = 98 ∨
  q % 127 = 74 ∨ q % 127 = 91

theorem sierpinski_reduction_covered {q : ℕ} (h : IsCoveredByKnownReductions q) :
  SierpinskiSolvable (60 * q + 1) := by
    cases h;
    · exact?;
    · -- By contradiction, assume that $q$ is not in any of the covered residue classes.
      by_contra h_not_covered;
      -- Apply the appropriate theorem for each case to derive a contradiction.
      have h_cases : ∀ {q : ℕ}, q % 7 = 4 ∨ q % 7 = 5 → SierpinskiSolvable (60 * q + 1) := by
        exact?;
      exact h_not_covered <| by have := @sierpinski_mod_11_2_10 q; have := @sierpinski_mod_19_6 q; have := @sierpinski_mod_23_18_21 q; have := @sierpinski_mod_31_16_18 q; have := @sierpinski_mod_43_5_25 q; have := @sierpinski_mod_47_18_43 q; have := @sierpinski_mod_59_54_58 q; have := @sierpinski_mod_67_39_48 q; have := @sierpinski_mod_71_13_65 q; have := @sierpinski_mod_79_25_46 q; have := @sierpinski_mod_83_65_76 q; have := @sierpinski_mod_103_12_60 q; have := @sierpinski_mod_107_41_98 q; have := @sierpinski_mod_127_74_91 q; aesop;

/-
If q ≡ 24 or 120 (mod 131), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_131_24_120 {q : ℕ} (h : q % 131 = 24 ∨ q % 131 = 120) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general reduction theorem with p = 131 and a = 24 or a = 120.
  have h_reduction : ∀ n, n % (60 * 131) = (60 * 24 + 1) % (60 * 131) ∨ n % (60 * 131) = (60 * 120 + 1) % (60 * 131) → SierpinskiSolvable n := by
    intros n hn_mod
    obtain ⟨a, ha⟩ : ∃ a, n = 60 * a + 1 ∧ (a % 131 = 24 ∨ a % 131 = 120) := by
      exact ⟨ n / 60, by omega, by omega ⟩;
    convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 131 ) ( by norm_num : 131 % 4 = 3 ) _ n _ using 1;
    exacts [ a, by rcases ha.2 with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ], by simp +decide [ ha.1 ] ];
  grind +ring

/-
If q ≡ 44 or 81 (mod 139), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_139_44_81 {q : ℕ} (h : q % 139 = 44 ∨ q % 139 = 81) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · -- For q ≡ 44 (mod 139), we use sierpinski_linear_reduction with p=139.
    apply sierpinski_linear_reduction;
    rotate_left;
    rotate_left;
    rotate_left;
    rotate_left;
    exacts [ 139, 44, by norm_num, by norm_num, by norm_num, by omega ];
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 139 ) ( by norm_num : 139 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 81;
    decide +kernel;
    exact 60 * q + 1;
    grind

/-
If q ≡ 6 (mod 7), then SierpinskiSolvable (60q+1) using x=12q+3.
-/
theorem sierpinski_mod_7_6_reduction {q : ℕ} (hq : q % 7 = 6) : SierpinskiSolvable (60 * q + 1) := by
  -- Set $x = 12q + 3$, $y = M * z$, and $z = \frac{M + 1}{14}$ where $M = (60q + 1)(12q + 3)$.
  use 12 * q + 3, (60 * q + 1) * (12 * q + 3) * ((60 * q + 1) * (12 * q + 3) + 1) / 14, ((60 * q + 1) * (12 * q + 3) + 1) / 14;
  rw [ Nat.cast_div, Nat.cast_div ] <;> norm_num <;> ring;
  · field_simp;
    grind;
  · exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 7, hq ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] );
  · norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq ];
    rw [ ← Nat.mod_mod_of_dvd q ( by decide : 7 ∣ 14 ) ] at hq; have := Nat.mod_lt q ( by decide : 0 < 14 ) ; interval_cases q % 14 <;> trivial;

/-
General reduction for any prime p ≡ 3 (mod 4), p > 5.
-/
theorem sierpinski_general_modular_reduction {p : ℕ} (hp : p.Prime) (hp3 : p % 4 = 3) (hp5 : p > 5) :
  ∀ q, ((60 * q + 1) % p = 0 ∨ (12 * q + 1) % p = 0) → SierpinskiSolvable (60 * q + 1) := by
    intros q hq_mod
    have h_factor : p ∣ (60 * q + 1) * (12 * q + 1) := by
      exact hq_mod.elim ( fun h => dvd_mul_of_dvd_left ( Nat.dvd_of_mod_eq_zero h ) _ ) fun h => dvd_mul_of_dvd_right ( Nat.dvd_of_mod_eq_zero h ) _;
    have h_factor_mod : ∃ d, d ∣ (60 * q + 1) * (12 * q + 1) ∧ d % 4 = 3 := by
      exact ⟨ p, h_factor, hp3 ⟩;
    have h_four_div : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z := by
      convert four_div_n_solvable_2_of_factor_mod_4_3 _ h_factor_mod using 1;
      · norm_cast;
      · positivity;
    convert sierpinski_mod_60_1_reduction _ _ using 1;
    · contrapose! hq_mod; aesop;
    · convert h_four_div using 1

/-
Bounded verification of Sierpinski conjecture for n < 1,000,000.
-/
theorem sierpinski_bounded_verification_1000000 : verifySierpinskiUpTo 1000000 = true := by native_decide

/-
If q ≡ 78 or 88 (mod 151), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_151_78_88 {q : ℕ} (h : q % 151 = 78 ∨ q % 151 = 88) : SierpinskiSolvable (60 * q + 1) := by
  have := sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 151 ) ( by norm_num ) ( by norm_num );
  -- Apply the general modular reduction theorem with p=151.
  apply this q;
  omega

/-
If q ≡ 19 or 95 (mod 163), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_163_19_95 {q : ℕ} (h : q % 163 = 19 ∨ q % 163 = 95) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · have := sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 163 ) ( by norm_num ) ( by norm_num ) q;
    exact this ( by norm_num [ Nat.add_mod, Nat.mul_mod, h ] );
  · convert sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 163 ) ( by norm_num : 163 % 4 = 3 ) ( by norm_num ) q _ using 1;
    norm_num [ Nat.add_mod, Nat.mul_mod, h ]

/-
If q ≡ 64 or 153 (mod 167), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_167_64_153 {q : ℕ} (h : q % 167 = 64 ∨ q % 167 = 153) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction theorem with p=167.
  have h_mod_167 : ∀ q, ((60 * q + 1) % 167 = 0 ∨ (12 * q + 1) % 167 = 0) → SierpinskiSolvable (60 * q + 1) := by
    intros q hq
    apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 167) (by norm_num : 167 % 4 = 3) (by norm_num) q hq;
  exact h_mod_167 q ( by omega )

/-
If q ≡ 176 or 164 (mod 179), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_179_176_164 {q : ℕ} (h : q % 179 = 176 ∨ q % 179 = 164) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction theorem with p = 179.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 179) (by norm_num : 179 % 4 = 3) (by norm_num : 5 < 179) q;
  omega

/-
If q ≡ 35 or 175 (mod 191), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_191_35_175 {q : ℕ} (h : q % 191 = 35 ∨ q % 191 = 175) : SierpinskiSolvable (60 * q + 1) := by
  apply sierpinski_general_modular_reduction;
  exacts [ show Nat.Prime 191 by norm_num, by norm_num, by norm_num, by omega ]

/-
If q ≡ 63 or 116 (mod 199), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_199_63_116 {q : ℕ} (h : q % 199 = 63 ∨ q % 199 = 116) : SierpinskiSolvable (60 * q + 1) := by
  -- By sierpinski_general_modular_reduction, if $(60q+1)$ or $(12q+1)$ is divisible by a prime $p \equiv 3 \pmod{4}$, then $n = 60q+1$ is solvable.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 199) (by norm_num : 199 % 4 = 3) (by norm_num : 199 > 5) q;
  rcases h with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ]

/-
If q is in one of the extended covered residue classes, then 60q+1 is Sierpinski solvable.
-/
def IsCoveredByKnownReductionsExtended (q : ℕ) : Prop :=
  q % 3 = 1 ∨
  q % 7 = 4 ∨ q % 7 = 5 ∨
  q % 11 = 2 ∨ q % 11 = 10 ∨
  q % 19 = 6 ∨
  q % 23 = 18 ∨ q % 23 = 21 ∨
  q % 31 = 16 ∨ q % 31 = 18 ∨
  q % 43 = 5 ∨ q % 43 = 25 ∨
  q % 47 = 18 ∨ q % 47 = 43 ∨
  q % 59 = 54 ∨ q % 59 = 58 ∨
  q % 67 = 39 ∨ q % 67 = 48 ∨
  q % 71 = 13 ∨ q % 71 = 65 ∨
  q % 79 = 25 ∨ q % 79 = 46 ∨
  q % 83 = 65 ∨ q % 83 = 76 ∨
  q % 103 = 12 ∨ q % 103 = 60 ∨
  q % 107 = 41 ∨ q % 107 = 98 ∨
  q % 127 = 74 ∨ q % 127 = 91 ∨
  q % 131 = 24 ∨ q % 131 = 120 ∨
  q % 139 = 44 ∨ q % 139 = 81 ∨
  q % 151 = 78 ∨ q % 151 = 88 ∨
  q % 163 = 19 ∨ q % 163 = 95 ∨
  q % 167 = 64 ∨ q % 167 = 153 ∨
  q % 179 = 176 ∨ q % 179 = 164 ∨
  q % 191 = 35 ∨ q % 191 = 175 ∨
  q % 199 = 63 ∨ q % 199 = 116

theorem sierpinski_reduction_covered_extended {q : ℕ} (h : IsCoveredByKnownReductionsExtended q) :
  SierpinskiSolvable (60 * q + 1) := by
    obtain h|h := h;
    · exact sierpinski_mod_3_1_reduction h;
    · rcases h with ( h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h );
      all_goals try exact sierpinski_mod_7_4_5 ( Or.inl h ) ;
      all_goals try exact sierpinski_mod_7_4_5 ( Or.inr h );
      any_goals apply sierpinski_mod_11_2_10; tauto;
      exact sierpinski_mod_19_6 h
      all_goals try { exact sierpinski_mod_23_18_21 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_23_18_21 ( Or.inr h ) }
      all_goals try { exact sierpinski_mod_31_16_18 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_31_16_18 ( Or.inr h ) }
      all_goals try { exact sierpinski_mod_43_5_25 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_43_5_25 ( Or.inr h ) };
      any_goals apply sierpinski_mod_47_18_43; tauto;
      any_goals apply sierpinski_mod_59_54_58; tauto;
      any_goals apply sierpinski_mod_67_39_48; tauto;
      any_goals apply sierpinski_mod_71_13_65; tauto;
      any_goals apply sierpinski_mod_79_25_46; tauto;
      any_goals apply sierpinski_mod_83_65_76; tauto;
      any_goals apply sierpinski_mod_103_12_60; tauto;
      any_goals apply sierpinski_mod_107_41_98; tauto;
      any_goals apply sierpinski_mod_127_74_91; tauto;
      any_goals apply sierpinski_mod_131_24_120; tauto;
      any_goals apply sierpinski_mod_139_44_81; tauto;
      any_goals apply sierpinski_mod_151_78_88; tauto;
      any_goals apply sierpinski_mod_163_19_95; tauto;
      · exact sierpinski_mod_167_64_153 ( Or.inl h );
      · exact sierpinski_mod_167_64_153 ( Or.inr h );
      · exact sierpinski_mod_179_176_164 ( Or.inl h );
      · rcases h with ( h | h | h | h | h ) <;> [ exact sierpinski_mod_179_176_164 ( Or.inr h ) ; exact sierpinski_mod_191_35_175 ( Or.inl h ) ; exact sierpinski_mod_191_35_175 ( Or.inr h ) ; exact sierpinski_mod_199_63_116 ( Or.inl h ) ; exact sierpinski_mod_199_63_116 ( Or.inr h ) ]

/-
Find uncovered q up to 1000.
-/
def is_covered_q_bool (q : ℕ) : Bool :=
  q % 3 == 1 ||
  q % 7 == 4 || q % 7 == 5 ||
  q % 11 == 2 || q % 11 == 10 ||
  q % 19 == 6 ||
  q % 23 == 18 || q % 23 == 21 ||
  q % 31 == 16 || q % 31 == 18 ||
  q % 43 == 5 || q % 43 == 25 ||
  q % 47 == 18 || q % 47 == 43 ||
  q % 59 == 54 || q % 59 == 58 ||
  q % 67 == 39 || q % 67 == 48 ||
  q % 71 == 13 || q % 71 == 65 ||
  q % 79 == 25 || q % 79 == 46 ||
  q % 83 == 65 || q % 83 == 76 ||
  q % 103 == 12 || q % 103 == 60 ||
  q % 107 == 41 || q % 107 == 98 ||
  q % 127 == 74 || q % 127 == 91 ||
  q % 131 == 24 || q % 131 == 120 ||
  q % 139 == 44 || q % 139 == 81 ||
  q % 151 == 78 || q % 151 == 88 ||
  q % 163 == 19 || q % 163 == 95 ||
  q % 167 == 64 || q % 167 == 153 ||
  q % 179 == 176 || q % 179 == 164 ||
  q % 191 == 35 || q % 191 == 175 ||
  q % 199 == 63 || q % 199 == 116

def find_uncovered_q (limit : ℕ) : List ℕ :=
  (List.range limit).filter (fun q => !is_covered_q_bool q)

#eval find_uncovered_q 1000

/-
Helper function to check Erdős-Straus decomposition for 4/m.
-/
def check_erdos_straus_4 (m : ℕ) : Bool :=
  let m2 := m * m
  let divisors := (List.range (m2 + 1)).filter (fun d => d > 0 && m2 % d == 0)
  divisors.any fun d =>
    let d' := m2 / d
    (m + d) % 4 == 0 && (m + d') % 4 == 0

/-
Correctness of check_erdos_straus_4.
-/
theorem check_erdos_straus_4_correct {m : ℕ} (hm : m > 0) (h : check_erdos_straus_4 m = true) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (m : ℚ) = 1 / y + 1 / z := by
    -- Unfold the definition of `check_erdos_straus_4`.
    unfold check_erdos_straus_4 at h
    obtain ⟨d, hd_pos, hd_div, hd_mod⟩ : ∃ d, 0 < d ∧ d ∣ m^2 ∧ (m + d) % 4 = 0 ∧ (m + m^2 / d) % 4 = 0 := by
      norm_num +zetaDelta at *;
      exact h.imp fun x hx => ⟨ hx.2.1.1, by simpa only [ sq ] using Nat.dvd_of_mod_eq_zero hx.2.1.2, hx.2.2.1, by simpa only [ sq ] using hx.2.2.2 ⟩;
    obtain ⟨y, hy⟩ : ∃ y, m + d = 4 * y := by
      exact Nat.modEq_zero_iff_dvd.mp hd_mod.1;
    obtain ⟨z, hz⟩ : ∃ z, m + m^2 / d = 4 * z := by
      exact Nat.modEq_zero_iff_dvd.mp hd_mod.2;
    refine' ⟨ y, z, _, _, _ ⟩ <;> norm_num;
    · grind;
    · grind;
    · field_simp;
      rw [ div_add_div, mul_div, eq_div_iff ] <;> norm_cast <;> nlinarith [ Nat.div_mul_cancel hd_div ]

/-
Solvability for q=3.
-/
theorem sierpinski_specific_q_3 : SierpinskiSolvable (60 * 3 + 1) := by
  -- Let's choose $x = 46$.
  use 46;
  by_contra! h_contra;
  obtain ⟨x, y, hx, hy, h_eq⟩ : ∃ x y : ℕ, x > 0 ∧ y > 0 ∧ (5 / (60 * 3 + 1 : ℚ) - 1 / 46) = 1 / x + 1 / y := by
    norm_num +zetaDelta at *;
    exact ⟨ 170, by norm_num, 8326 * 170 / ( 170 * 49 - 8326 ), by norm_num ⟩;
  exact h_contra x y ( by norm_num ) hx hy ( by linear_combination' h_eq )

/-
Correctness of fast Erdős-Straus check.
-/
def check_erdos_straus_4_fast (m : ℕ) : Bool :=
  let m2 := m * m
  (List.range (m + 1)).any fun d =>
    d > 0 && m2 % d == 0 &&
    let d' := m2 / d
    (m + d) % 4 == 0 && (m + d') % 4 == 0

theorem check_erdos_straus_4_fast_correct {m : ℕ} (hm : m > 0) (h : check_erdos_straus_4_fast m = true) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (m : ℚ) = 1 / y + 1 / z := by
    unfold check_erdos_straus_4_fast at h;
    obtain ⟨d, hd⟩ : ∃ d ∈ List.range (m + 1), d > 0 ∧ m * m % d == 0 ∧ (m + d) % 4 == 0 ∧ (m + (m * m / d)) % 4 == 0 := by
      aesop;
    use (m + d) / 4, (m + (m * m / d)) / 4;
    simp_all +decide [ Nat.dvd_iff_mod_eq_zero ];
    refine' ⟨ _, _, _ ⟩;
    · omega;
    · exact Nat.le_of_dvd ( by nlinarith [ Nat.div_mul_cancel ( show d ∣ m * m from Nat.dvd_of_mod_eq_zero hd.2.2.1 ) ] ) ( Nat.dvd_of_mod_eq_zero hd.2.2.2.2 );
    · field_simp;
      ring;
      simpa [ hd.2.1.ne' ] using by ring;

/-
Solvability for q=8.
-/
theorem sierpinski_specific_q_8 : SierpinskiSolvable (60 * 8 + 1) := by
  -- By definition of `SierpinskiSolvable`, we need to show that there exist `x`, `y`, and `z` such that `5 / n = 1 / x + 1 / y + 1 / z`.
  unfold SierpinskiSolvable;
  norm_num +zetaDelta at *;
  by_contra h_contra;
  -- Let's choose any solution $x, y, z$ for $n = 481$.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ (5 / 481 : ℚ) = 1 / x + 1 / y + 1 / z := by
    use 111, 1443, 1443;
    norm_num;
  exact h_contra ⟨ x, hx_pos, y, hy_pos, z, hz_pos, by simpa using h_eq ⟩

/-
Find witness for q=9.
-/
def find_erdos_straus_4_witness (m : ℕ) : Option (ℕ × ℕ) :=
  let m2 := m * m
  (List.range (m + 1)).findSome? fun d =>
    if d > 0 && m2 % d == 0 then
      let d' := m2 / d
      if (m + d) % 4 == 0 && (m + d') % 4 == 0 then
        some ((m + d) / 4, (m + d') / 4)
      else none
    else none

#eval find_erdos_straus_4_witness ((60 * 9 + 1) * (12 * 9 + 1))

/-
Solvability for q=9.
-/
theorem sierpinski_specific_q_9 : SierpinskiSolvable (60 * 9 + 1) := by
  -- By definition of SierpinskiSolvable, we need to show that there exist positive integers x, y, z such that 5 / (60 * 9 + 1) = 1 / x + 1 / y + 1 / z.
  unfold SierpinskiSolvable;
  by_contra! h_contra;
  have h_witness : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / (60 * 9 + 1) = 1 / x + 1 / y + 1 / z := by
    have h_check : (checkSierpinski (60 * 9 + 1) 10000 10000).isSome = true := by
      native_decide +revert
    obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h_check;
    obtain ⟨ hx₁, hx₂ ⟩ := checkSierpinski_correct ( by norm_num ) hx;
    grind;
  exact h_contra _ _ _ h_witness.choose_spec.choose_spec.choose_spec.1 h_witness.choose_spec.choose_spec.choose_spec.2.1 h_witness.choose_spec.choose_spec.choose_spec.2.2.1 ( mod_cast h_witness.choose_spec.choose_spec.choose_spec.2.2.2 )

/-
Solvability for q=9.
-/
theorem sierpinski_q_9 : SierpinskiSolvable (60 * 9 + 1) := by
  convert sierpinski_specific_q_9 using 1

/-
Solvability for q=9 and q=3 with explicit witnesses.
-/
theorem sierpinski_q_9_solved : SierpinskiSolvable (60 * 9 + 1) := by
  use 110, 6615, 15746346
  norm_num

theorem sierpinski_q_3_solved : SierpinskiSolvable (60 * 3 + 1) := by
  use 39, 507, 91767
  norm_num

/-
Solvability for q=8 and q=14.
-/
theorem sierpinski_q_8 : SierpinskiSolvable (60 * 8 + 1) := by
  convert sierpinski_specific_q_8 using 1

theorem sierpinski_q_14 : SierpinskiSolvable (60 * 14 + 1) := by
  by_contra h_not_solvable;
  exact h_not_solvable <| by have := sierpinski_bounded_verification_100000; exact (by
  unfold verifySierpinskiUpTo at this;
  rw [ List.all_eq_true ] at this;
  specialize this 841 ; norm_num [ verifySierpinskiStep ] at this;
  exact checkSierpinski_correct ( by decide ) ( Option.get_mem ( by simpa using this ) ));

/-
Find witnesses for q=8, 14, 15, 17, 20, 23, 27, 29.
-/
#eval checkSierpinski 481 1000 10000
#eval checkSierpinski 841 1000 10000
#eval checkSierpinski 901 1000 10000
#eval checkSierpinski 1021 1000 10000
#eval checkSierpinski 1201 1000 10000
#eval checkSierpinski 1381 1000 10000
#eval checkSierpinski 1621 1000 10000
#eval checkSierpinski 1741 1000 10000

/-
Solvability for q=3, 15, 17.
-/
theorem sierpinski_q_3 : SierpinskiSolvable (60 * 3 + 1) := by
  exact sierpinski_q_3_solved

theorem sierpinski_q_15 : SierpinskiSolvable (60 * 15 + 1) := by
  -- Using the checkSierpinski function, we find that 60*15 + 1 = 901 is solvable.
  have h15 : (checkSierpinski 901 1000 10000).isSome := by
    native_decide +revert;
  obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h15;
  exact checkSierpinski_correct ( by norm_num ) hx

theorem sierpinski_q_17 : SierpinskiSolvable (60 * 17 + 1) := by
  -- Apply the checkSierpinski_correct theorem with the obtained (x, y, z).
  apply checkSierpinski_correct
  native_decide;
  rotate_left;
  exact 1000;
  exact 1000000;
  exact ( checkSierpinski 1021 1000 1000000 ).get!.1;
  exact ( checkSierpinski 1021 1000 1000000 ).get!.2.1
  exact ( checkSierpinski 1021 1000 1000000 ).get!.2.2
  native_decide +revert

/-
Solvability for q=15.
-/
theorem sierpinski_q_15_solved : SierpinskiSolvable (60 * 15 + 1) := by
  exact sierpinski_q_15

/-
Solvability for q=17 and q=20.
-/
theorem sierpinski_q_17_solved : SierpinskiSolvable (60 * 17 + 1) := by
  convert sierpinski_q_17 using 1

theorem sierpinski_q_20_solved : SierpinskiSolvable (60 * 20 + 1) := by
  exact?

/-
Solvability for q=23.
-/
theorem sierpinski_q_23 : SierpinskiSolvable (60 * 23 + 1) := by
  by_contra! h_contra;
  convert checkSierpinski_correct ( show ( 60 * 23 + 1 ) ≠ 0 by decide ) _ using 1;
  exact iff_of_false ( by tauto ) h_contra;
  exact 1000;
  exact 1000000;
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.fst );
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.snd |> Prod.fst );
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.snd |> Prod.snd );
  native_decide +revert

/-
Solvability for q=20, 27, 29.
-/
theorem sierpinski_q_20 : SierpinskiSolvable (60 * 20 + 1) := by
  exact sierpinski_q_20_solved

theorem sierpinski_q_27 : SierpinskiSolvable (60 * 27 + 1) := by
  by_contra! h_contra;
  convert sierpinski_mod_7_6_reduction _ using 1;
  rotate_left;
  exact ( 60 * 27 + 1 ) / 60;
  · norm_num;
  · norm_num [ h_contra ]

theorem sierpinski_q_29 : SierpinskiSolvable (60 * 29 + 1) := by
  -- Apply the checkSierpinski function to find the decomposition.
  have h_check : (checkSierpinski 1741 10000 100000).isSome := by
    native_decide;
  obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h_check; exact checkSierpinski_correct ( by decide ) hx;

/-
Solvability for q=30, 36, 38, 42, 45.
-/
theorem sierpinski_q_30 : SierpinskiSolvable (60 * 30 + 1) := by
  by_contra h_not_solvable;
  revert h_not_solvable;
  -- Let's choose any $q$ such that $q \equiv 30 \pmod{31}$.
  set q := 30;
  -- We'll use that $checkSierpinski(60q + 1, 1000, 10000)$ returns `some (x, y, z)` for $q = 30$.
  have h_check : checkSierpinski (60 * q + 1) 1000 10000 ≠ none := by
    native_decide;
  exact fun h => h <| by obtain ⟨ x, hx ⟩ := Option.ne_none_iff_exists'.mp h_check; exact checkSierpinski_correct ( by decide ) hx;

theorem sierpinski_q_36 : SierpinskiSolvable (60 * 36 + 1) := by
  by_contra! h_contra;
  -- Apply the checkSierpinski_correct theorem with the parameters limitX = 1000 and limitK = 10000.
  have h_check : checkSierpinski (60 * 36 + 1) 1000 10000 ≠ none := by
    native_decide +revert;
  obtain ⟨ x, hx ⟩ := Option.ne_none_iff_exists'.mp h_check;
  exact h_contra <| checkSierpinski_correct ( by norm_num ) hx

theorem sierpinski_q_38 : SierpinskiSolvable (60 * 38 + 1) := by
  -- Apply the checkSierpinski_correct theorem to conclude the proof.
  apply checkSierpinski_correct;
  all_goals norm_num;
  rotate_left;
  exact 2000;
  exact 1000000;
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.fst );
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.snd |> Prod.fst );
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.snd |> Prod.snd );
  native_decide +revert

theorem sierpinski_q_42 : SierpinskiSolvable (60 * 42 + 1) := by
  by_contra! h_contra;
  -- By definition of $SierpinskiSolvable$, we need to show that there exist positive integers $x, y, z$ such that $5 / 2521 = 1 / x + 1 / y + 1 / z$.
  have h_def : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 / 2521 : ℚ) = 1 / x + 1 / y + 1 / z := by
    by_contra! h_contra;
    -- Let's choose any solution $x, y, z$ for $n = 2521$ and derive a contradiction.
    obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 * x * y * z = 2521 * (y * z + x * z + x * y) := by
      simp +zetaDelta at *;
      -- Let's choose any solution $x, y, z$ for $n = 2521$ and derive a contradiction. We will use the method of Vieta jumping.
      have h_vieta : ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = 2521 * (y * z + x * z + x * y) := by
        have h_eq : ∃ x y : ℕ, 0 < x ∧ 0 < y ∧ 5 * x * y > 2521 * (x + y) ∧ (5 * x * y - 2521 * (x + y)) ∣ (2521 * x * y) := by
          by_cases h₂ : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, 5 * x * y > 2521 * (x + y) ∧ (5 * x * y - 2521 * (x + y)) ∣ (2521 * x * y);
          · exact ⟨ h₂.choose, h₂.choose_spec.2.choose, Finset.mem_Icc.mp h₂.choose_spec.1 |>.1, Finset.mem_Icc.mp h₂.choose_spec.2.choose_spec.1 |>.1, h₂.choose_spec.2.choose_spec.2.1, h₂.choose_spec.2.choose_spec.2.2 ⟩;
          · exact absurd h₂ ( by native_decide )
        obtain ⟨ x, y, hx, hy, hxy, h ⟩ := h_eq;
        use x, y, (2521 * x * y) / (5 * x * y - 2521 * (x + y));
        exact ⟨ hx, hy, Nat.div_pos ( Nat.le_of_dvd ( by positivity ) h ) ( Nat.sub_pos_of_lt hxy ), by nlinarith [ Nat.div_mul_cancel h, Nat.sub_add_cancel hxy.le ] ⟩;
      exact ⟨ _, h_vieta.choose_spec.choose_spec.choose_spec.1, _, h_vieta.choose_spec.choose_spec.choose_spec.2.1, _, h_vieta.choose_spec.choose_spec.choose_spec.2.2.1, h_vieta.choose_spec.choose_spec.choose_spec.2.2.2 ⟩;
    exact h_contra x y z hx_pos hy_pos hz_pos ( by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> norm_cast <;> first | positivity | linarith );
  exact h_contra h_def

theorem sierpinski_q_45 : SierpinskiSolvable (60 * 45 + 1) := by
  by_contra! h_contra;
  -- By contradiction, assume there exist positive integers $x, y, z$ such that $5 / (60 * 45 + 1) = 1 / x + 1 / y + 1 / z$.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / (60 * 45 + 1) = 1 / x + 1 / y + 1 / z := by
    have h_check : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 * x * y * z : ℚ) = (60 * 45 + 1) * (x * y + y * z + z * x) := by
      norm_cast;
      by_contra! h_contra;
      -- Let's choose any solution $x, y, z$ for $n = 2701$ and derive a contradiction. We will check all combinations of $x, y, z$ in the specified range.
      have h_check : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, ∃ z ∈ Finset.Icc 1 10000, 5 * x * y * z = 2701 * (x * y + y * z + z * x) := by
        by_cases h₂ : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, (5 * x * y - 2701 * (x + y)) ≠ 0 ∧ 2701 * x * y % (5 * x * y - 2701 * (x + y)) = 0 ∧ 2701 * x * y / (5 * x * y - 2701 * (x + y)) ∈ Finset.Icc 1 10000;
        · obtain ⟨ x, hx, y, hy, hxy ⟩ := h₂;
          use x, hx, y, hy, 2701 * x * y / (5 * x * y - 2701 * (x + y));
          simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
          nlinarith [ Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero hxy.2.1 ), Nat.sub_add_cancel ( show ( x + y ) * 2701 ≤ x * ( y * 5 ) from le_of_lt ( Nat.lt_of_sub_ne_zero hxy.1 ) ) ];
        · exact absurd h₂ ( by native_decide );
      obtain ⟨ x, hx, y, hy, z, hz, h ⟩ := h_check; exact h_contra x y z ( Finset.mem_Icc.mp hx |>.1 ) ( Finset.mem_Icc.mp hy |>.1 ) ( Finset.mem_Icc.mp hz |>.1 ) h;
    obtain ⟨ x, y, z, hx, hy, hz, h ⟩ := h_check; exact ⟨ x, y, z, hx, hy, hz, by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> first | positivity | linarith ⟩ ;
  exact h_contra ⟨ x, y, z, mod_cast hx_pos, mod_cast hy_pos, mod_cast hz_pos, mod_cast h_eq ⟩

/-
Solvability for q=17 and q=20.
-/
theorem sierpinski_q_17_v2 : SierpinskiSolvable (60 * 17 + 1) := by
  -- Apply the theorem that states if q is in the covered residue classes, then 60q+1 is solvable.
  apply sierpinski_q_17_solved

theorem sierpinski_q_20_v2 : SierpinskiSolvable (60 * 20 + 1) := by
  exact?

/-
Solvability for q=17.
-/
theorem sierpinski_q_17_verified : SierpinskiSolvable (60 * 17 + 1) := by
  exact sierpinski_q_17_v2