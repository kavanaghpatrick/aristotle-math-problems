/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 248e52fa-083d-4c72-95f1-46cffb234b8b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Filter

/-
Definition of the property that every non-empty zero-sum subsequence has the same length r.
-/
def HasUniqueZeroSumLength (p : ℕ) (a : Fin p → ZMod p) : Prop :=
  ∃ r, ∀ (S : Finset (Fin p)), S ≠ ∅ → ∑ i ∈ S, a i = 0 → S.card = r

/-
Definition of a minimal zero-sum sequence of length p.
-/
def IsMinimalZeroSum (p : ℕ) (a : Fin p → ZMod p) : Prop :=
  (∑ i, a i = 0) ∧ (∀ (S : Finset (Fin p)), S ≠ ∅ → S ≠ Finset.univ → ∑ i ∈ S, a i ≠ 0)

/-
The partial sums of a minimal zero-sum sequence are distinct on `Fin p`.
-/
lemma minimal_zero_sum_partial_sums_inj (p : ℕ) (a : Fin p → ZMod p) (h : IsMinimalZeroSum p a) :
    Function.Injective (fun k : Fin p => ∑ i ∈ Finset.filter (· < k) Finset.univ, a i) := by
  intro k l hkl
  by_contra hneq;
  -- Without loss of generality, assume $k < l$.
  wlog hkl' : k < l generalizing k l;
  · exact this hkl.symm ( Ne.symm hneq ) ( lt_of_le_of_ne ( le_of_not_gt hkl' ) ( Ne.symm hneq ) );
  · -- Then $\sum_{k=i}^{j-1} a_k = s_j - s_i = 0$.
    have h_zero_sum : ∑ i ∈ Finset.univ.filter (fun x => x < l) \ Finset.univ.filter (fun x => x < k), a i = 0 := by
      simp +zetaDelta at *;
      rw [ ← Finset.sum_sdiff ( show Finset.filter ( fun x => x < k ) Finset.univ ⊆ Finset.filter ( fun x => x < l ) Finset.univ from fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_filter.mp hx |>.1, lt_trans ( Finset.mem_filter.mp hx |>.2 ) hkl' ⟩ ) ] at * ; aesop;
    -- The set of indices $S = \{k \mid i \le k < j\}$ is non-empty (since $i < j$) and proper (since $S \subseteq \{0, ..., p-1\}$ and $j-i \le p-1 < p$).
    have h_nonempty : Finset.univ.filter (fun x => x < l) \ Finset.univ.filter (fun x => x < k) ≠ ∅ := by
      simp_all +decide [ Finset.ext_iff ];
      exact ⟨ k, hkl', le_rfl ⟩
    have h_proper : Finset.univ.filter (fun x => x < l) \ Finset.univ.filter (fun x => x < k) ≠ Finset.univ := by
      intro H; simp_all +decide [ Finset.ext_iff ] ;
      exact absurd ( H l ) ( by simp +decide );
    exact h.2 _ h_nonempty h_proper h_zero_sum

/-
Every sequence of length `p` in `ZMod p` contains a non-empty zero-sum subsequence.
-/
lemma davenport_zmod (p : ℕ) (hp : p > 0) (a : Fin p → ZMod p) :
    ∃ S : Finset (Fin p), S ≠ ∅ ∧ ∑ i ∈ S, a i = 0 := by
  by_contra! h_contra;
  -- Consider the partial sums $s_k = \sum_{i=0}^{k-1} a_i$ for $k = 0, 1, ..., p$.
  set s : Fin (p + 1) → (ZMod p) := fun k => ∑ i ∈ Finset.univ.filter (fun j => j.val < k.val), a i;
  have hs : ∀ k l : Fin (p + 1), k < l → s k ≠ s l := by
    intros k l hkl h_eq
    have h_sum_zero : ∑ i ∈ Finset.univ.filter (fun j => j.val < l.val) \ Finset.univ.filter (fun j => j.val < k.val), a i = 0 := by
      simp +zetaDelta at *;
      rw [ ← Finset.sum_sdiff <| show Finset.filter ( fun j : Fin p => ( j : ℕ ) < k ) Finset.univ ⊆ Finset.filter ( fun j : Fin p => ( j : ℕ ) < l ) Finset.univ from fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_filter.mp hx |>.1, lt_trans ( Finset.mem_filter.mp hx |>.2 ) hkl ⟩ ] at * ; aesop;
    refine h_contra _ ?_ h_sum_zero;
    simp_all +decide [ Finset.ext_iff ];
    exact ⟨ ⟨ k, by linarith [ Fin.is_lt k, Fin.is_lt l, show ( k : ℕ ) < l from hkl ] ⟩, by simpa using hkl, by simp +decide ⟩; -- This follows from the assumption h_contra.;
  -- Since there are $p + 1$ partial sums and only $p$ possible values in $\mathbb{Z}/p\mathbb{Z}$, by the pigeonhole principle, there must be at least two partial sums that are equal.
  have h_pigeonhole : Finset.card (Finset.image s (Finset.univ : Finset (Fin (p + 1)))) ≤ p := by
    cases p <;> [ aesop; exact le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ];
  exact h_pigeonhole.not_lt ( by rw [ Finset.card_image_of_injective _ fun k l hkl => le_antisymm ( not_lt.mp fun hkl' => hs _ _ hkl' hkl.symm ) ( not_lt.mp fun hkl' => hs _ _ hkl' hkl ) ] ; simp +decide )