/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f31dceeb-bc94-47b0-98c6-73d3f8c1fb5c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Eisenstein integer approach to the Feit-Thompson q ≡ 71 (mod 72) case.
Key results proven:
1.  **Eisenstein Factorization**: `eisenstein_norm_algebraic` and `isCoprime_pi_pi_bar` show that $A = q^2+q+1$ factors as $\pi\bar{\pi}$ with $\pi, \bar{\pi}$ coprime in $\mathbb{Z}[\omega]$ for $q \equiv 2 \pmod 3$.
2.  **Order Constraint**: `result_3_order` proves that if $3^{(A-1)/2} \equiv 1 \pmod A$, then the order of 3 modulo $\pi$ divides $(A-1)/2$.
3.  **Residue Properties for q=71**:
    *   `q_71_satisfies_FT_condition`: Confirmed $3^{(A-1)/2} \equiv 1 \pmod A$ for $q=71$, showing it is a "hard case".
    *   `three_is_cubic_residue_mod_pi_71`: Proved 3 is a cubic residue mod $\pi$ for $q=71$.
    *   `three_is_sextic_residue_mod_pi_71`: Proved 3 is a sextic residue mod $\pi$ for $q=71$.
    *   `q_divides_order_of_3_at_71` and `order_divisible_by_71`: Proved $q \mid \text{ord}_A(3)$ for $q=71$.
4.  **General Residue Properties**:
    *   `q_is_cubic_residue`: Proved $q$ is a cubic residue mod $A$ for all $q \equiv 71 \pmod{72}$.
    *   `neg_omega_sq_pow_A_sub_one_div_three`: Proved $(-\omega^2)^{(A-1)/3} \equiv 1 \pmod \pi$ for all $q \equiv 71 \pmod{72}$.
    *   `pi_prime_equiv_one_mod_nine`: Proved $\pi' \equiv 1 \pmod 9$ for all $q \equiv 71 \pmod{72}$.

These results establish the algebraic structure of the problem in $\mathbb{Z}[\omega]$ and verify the properties of the specific case $q=71$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define EisensteinInteger as the ring of integers of the 3rd cyclotomic field, and omega as a primitive 3rd root of unity.
-/
abbrev EisensteinInteger := NumberField.RingOfIntegers (CyclotomicField 3 ℚ)

noncomputable def omega : EisensteinInteger :=
  ⟨IsCyclotomicExtension.zeta 3 ℚ (CyclotomicField 3 ℚ),
   IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec 3 ℚ (CyclotomicField 3 ℚ)) (by norm_num)⟩

/-
omega is a primitive 3rd root of unity, so it satisfies the cyclotomic polynomial equation x^2 + x + 1 = 0.
-/
theorem omega_sq_add_omega_add_one : omega ^ 2 + omega + 1 = 0 := by
  -- We know that $\omega$ is a root of $x^2 + x + 1$, so $\omega^2 + \omega + 1 = 0$.
  have h_poly : (IsCyclotomicExtension.zeta 3 ℚ (CyclotomicField 3 ℚ)) ^ 2 + (IsCyclotomicExtension.zeta 3 ℚ (CyclotomicField 3 ℚ)) + 1 = 0 := by
    have := IsCyclotomicExtension.zeta_spec 3 ℚ ( CyclotomicField 3 ℚ );
    exact mul_left_cancel₀ ( sub_ne_zero_of_ne ( this.ne_one ( by decide ) ) ) ( by linear_combination' this.pow_eq_one );
  exact?

/-
The product (q - omega) * (q - omega^2) equals q^2 + q + 1 in the Eisenstein integers.
-/
theorem eisenstein_norm_algebraic (q : ℤ) :
    ((q : EisensteinInteger) - omega) * ((q : EisensteinInteger) - omega ^ 2) = q ^ 2 + q + 1 := by
      -- Substitute $\omega^2 = -\omega - 1$ from the earlier result.
      have h_omega_sq : omega^2 = -omega - 1 := by
        linear_combination' omega_sq_add_omega_add_one;
      rw [ h_omega_sq ] ; ring_nf at *;
      rw [ h_omega_sq ] ; ring

/-
The minimal polynomial of q - omega over Q is X^2 - (2q+1)X + (q^2+q+1).
-/
theorem minpoly_omega_sub_q (q : ℤ) :
    minpoly ℚ ((q : CyclotomicField 3 ℚ) - omega) = Polynomial.X ^ 2 - Polynomial.C (2 * q + 1 : ℚ) * Polynomial.X + Polynomial.C (q ^ 2 + q + 1 : ℚ) := by
      refine' Eq.symm ( minpoly.eq_of_irreducible_of_monic _ _ _ );
      · refine' ⟨ _, _ ⟩;
        · rw [ Polynomial.isUnit_iff ];
          exact fun ⟨ r, hr, hr' ⟩ => by have := congr_arg ( Polynomial.eval 0 ) hr'; norm_num at this; have := congr_arg ( Polynomial.eval 1 ) hr'; norm_num at this; have := congr_arg ( Polynomial.eval ( -1 ) ) hr'; norm_num at this; linarith;
        · -- Since the polynomial is quadratic, if it factors into two non-constant polynomials, they must both be linear.
          intro a b hab
          have h_deg : a.degree = 1 ∧ b.degree = 1 ∨ a.degree = 0 ∧ b.degree = 2 ∨ a.degree = 2 ∧ b.degree = 0 := by
            have h_deg : a.degree + b.degree = 2 := by
              rw [ ← Polynomial.degree_mul, ← hab, Polynomial.degree_add_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
              · erw [ Polynomial.degree_eq_natDegree ] <;> norm_num;
                · erw [ Polynomial.natDegree_add_C, Polynomial.natDegree_C_mul ] <;> norm_num;
                · exact ne_of_apply_ne ( Polynomial.eval 0 ) ( by norm_num; rcases q with ⟨ _ | _ | q ⟩ <;> norm_num <;> nlinarith );
              · erw [ Polynomial.degree_eq_natDegree ] <;> norm_num;
                · erw [ Polynomial.natDegree_add_C, Polynomial.natDegree_C_mul ] <;> norm_num;
                · exact ne_of_apply_ne ( Polynomial.eval 0 ) ( by norm_num; rcases q with ⟨ _ | _ | q ⟩ <;> norm_num <;> nlinarith );
            rw [ Polynomial.degree_eq_natDegree ( show a ≠ 0 from fun h => by subst h; replace hab := congr_arg ( Polynomial.eval 0 ) hab; norm_num at hab; nlinarith ), Polynomial.degree_eq_natDegree ( show b ≠ 0 from fun h => by subst h; replace hab := congr_arg ( Polynomial.eval 0 ) hab; norm_num at hab; nlinarith ) ] at * ; norm_cast at * ; omega;
          rcases h_deg with ( ⟨ ha, hb ⟩ | ⟨ ha, hb ⟩ | ⟨ ha, hb ⟩ ) <;> simp_all +decide [ Polynomial.isUnit_iff_degree_eq_zero ];
          -- If $a$ and $b$ are both linear, then they must have rational roots.
          obtain ⟨r, hr⟩ : ∃ r : ℚ, a.eval r = 0 := by
            exact Polynomial.exists_root_of_degree_eq_one ha
          obtain ⟨s, hs⟩ : ∃ s : ℚ, b.eval s = 0 := by
            exact Polynomial.exists_root_of_degree_eq_one hb;
          replace hab := congr_arg ( Polynomial.eval r ) hab ; simp_all +decide;
          nlinarith [ sq_nonneg ( r - ( q + 1 / 2 ) ), show ( q : ℚ ) ^ 2 + q + 1 > 0 by nlinarith ];
      · have h_root : (omega : CyclotomicField 3 ℚ) ^ 2 + (omega : CyclotomicField 3 ℚ) + 1 = 0 := by
          convert omega_sq_add_omega_add_one using 1;
          erw [ ← Subtype.coe_inj ] ; norm_num;
          exact?;
        norm_num; linear_combination' h_root;
      · rw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
        · norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
        · refine' lt_of_le_of_lt ( Polynomial.natDegree_mul_le .. ) _ ; norm_num;
          erw [ Polynomial.natDegree_add_C, Polynomial.natDegree_C_mul ] <;> norm_num

/-
The norm of q - omega is the determinant of the multiplication map by q - omega.
-/
theorem norm_omega_sub_q_eq_det (q : ℤ) :
    Algebra.norm ℤ ((q : EisensteinInteger) - omega) =
    LinearMap.det (LinearMap.mulLeft ℤ ((q : EisensteinInteger) - omega)) := by
      exact?

/-
The characteristic polynomial of the linear map given by multiplication by omega is X^2 + X + 1.
-/
theorem charpoly_mulLeft_omega :
    LinearMap.charpoly (LinearMap.mulLeft ℤ omega) = Polynomial.X ^ 2 + Polynomial.X + 1 := by
      -- The minimal polynomial of omega is X^2 + X + 1.
      have h_minpoly : minpoly ℤ omega = Polynomial.X ^ 2 + Polynomial.X + 1 := by
        -- Since $\omega$ is a primitive third root of unity, its minimal polynomial over $\mathbb{Z}$ is the cyclotomic polynomial $\Phi_3(X) = X^2 + X + 1$.
        have h_min_poly : minpoly ℤ omega = Polynomial.cyclotomic 3 ℤ := by
          have h_minpoly : IsPrimitiveRoot (omega : CyclotomicField 3 ℚ) 3 := by
            convert IsCyclotomicExtension.zeta_spec 3 ℚ ( CyclotomicField 3 ℚ ) using 1;
          have h_minpoly : minpoly ℚ (omega : CyclotomicField 3 ℚ) = Polynomial.cyclotomic 3 ℚ := by
            rw [ h_minpoly.minpoly_eq_cyclotomic_of_irreducible ( Polynomial.cyclotomic.irreducible_rat <| by decide ) ];
          have h_minpoly_int : minpoly ℤ omega = Polynomial.cyclotomic 3 ℤ := by
            have h_minpoly_eq : minpoly ℚ (omega : CyclotomicField 3 ℚ) = Polynomial.map (algebraMap ℤ ℚ) (minpoly ℤ omega) := by
              convert minpoly.isIntegrallyClosed_eq_field_fractions' _ _;
              convert Iff.rfl;
              rotate_left;
              exact ℤ;
              exact CyclotomicField 3 ℚ;
              all_goals try infer_instance;
              exact ℚ;
              all_goals try infer_instance;
              exact ↑omega;
              · exact?;
              · congr!;
                convert minpoly.algebraMap_eq _ _;
                · infer_instance;
                · exact Subtype.coe_injective
            refine' Polynomial.map_injective ( algebraMap ℤ ℚ ) Int.cast_injective <| _;
            aesop;
          exact h_minpoly_int;
        rw [ h_min_poly, Polynomial.cyclotomic_three ];
      have h_deg : Module.finrank ℤ (EisensteinInteger) = 2 := by
        have h_deg : Module.finrank ℤ (EisensteinInteger) = Module.finrank ℚ (CyclotomicField 3 ℚ) := by
          convert ( NumberField.RingOfIntegers.rank ( CyclotomicField 3 ℚ ) );
        have h_deg : Module.finrank ℚ (CyclotomicField 3 ℚ) = Nat.totient 3 := by
          have h_cyclotomic : IsCyclotomicExtension {3} ℚ (CyclotomicField 3 ℚ) := by
            infer_instance
          convert h_cyclotomic.finrank using 1;
          exact ⟨ fun h => fun _ => h, fun h => h <| Polynomial.cyclotomic.irreducible_rat <| by decide ⟩;
        aesop;
      have h_charpoly : (LinearMap.mulLeft ℤ omega).charpoly = minpoly ℤ omega := by
        have h_minpoly_div_charpoly : minpoly ℤ omega ∣ (LinearMap.mulLeft ℤ omega).charpoly := by
          refine' minpoly.isIntegrallyClosed_dvd _ _;
          · exact?;
          · have := LinearMap.aeval_self_charpoly ( LinearMap.mulLeft ℤ omega );
            convert congr_arg ( fun f => f 1 ) this using 1;
            simp +decide [ Polynomial.aeval_eq_sum_range ]
        have h_deg_eq : Polynomial.natDegree (minpoly ℤ omega) = Polynomial.natDegree ((LinearMap.mulLeft ℤ omega).charpoly) := by
          rw [ h_minpoly, Polynomial.natDegree_add_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ];
          rw [ LinearMap.charpoly ];
          rw [ Matrix.charpoly_natDegree_eq_dim ];
          rw [ ← h_deg, Module.finrank_eq_card_basis ( Module.Free.chooseBasis ℤ EisensteinInteger ) ]
        obtain ⟨ q, hq ⟩ := h_minpoly_div_charpoly;
        have h_monic : Polynomial.Monic (minpoly ℤ omega) ∧ Polynomial.Monic ((LinearMap.mulLeft ℤ omega).charpoly) := by
          exact ⟨ h_minpoly.symm ▸ by erw [ Polynomial.Monic, Polynomial.leadingCoeff ] ; erw [ Polynomial.natDegree_add_C ] ; erw [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ], LinearMap.charpoly_monic _ ⟩;
        have h_q_monic : Polynomial.Monic q := by
          simp_all +decide [ Polynomial.Monic.def, Polynomial.leadingCoeff_mul ];
          aesop;
        have := congr_arg Polynomial.natDegree hq; rw [ Polynomial.natDegree_mul' ] at this <;> aesop;
      rw [h_charpoly, h_minpoly]

/-
The norm of q - omega in the Eisenstein integers is q^2 + q + 1.
-/
theorem norm_omega_sub_q (q : ℤ) : Algebra.norm ℤ ((q : EisensteinInteger) - omega) = q ^ 2 + q + 1 := by
  convert norm_omega_sub_q_eq_det q using 1;
  -- The characteristic polynomial of `mulLeft(omega)` is `P(X) = det(X * id - mulLeft(omega))`.
  have h_charpoly : LinearMap.det (LinearMap.mulLeft ℤ ((q : EisensteinInteger) - omega)) = Polynomial.eval (q : ℤ) (LinearMap.charpoly (LinearMap.mulLeft ℤ omega)) := by
    rw [ LinearMap.charpoly ];
    -- By definition of matrix multiplication and the characteristic polynomial, we have:
    have h_charpoly : LinearMap.toMatrix (Module.Free.chooseBasis ℤ EisensteinInteger) (Module.Free.chooseBasis ℤ EisensteinInteger) (LinearMap.mulLeft ℤ ((q : EisensteinInteger) - omega)) = Matrix.diagonal (fun _ => q) - LinearMap.toMatrix (Module.Free.chooseBasis ℤ EisensteinInteger) (Module.Free.chooseBasis ℤ EisensteinInteger) (LinearMap.mulLeft ℤ omega) := by
      ext i j;
      simp +decide [ LinearMap.toMatrix_apply, Matrix.diagonal ];
      simp +decide [ sub_mul, Algebra.leftMulMatrix_apply ];
      erw [ LinearMap.toMatrix_apply ];
      erw [ show ( q : EisensteinInteger ) * ( Module.Free.chooseBasis ℤ EisensteinInteger ) j = q • ( Module.Free.chooseBasis ℤ EisensteinInteger ) j by simp +decide [ Algebra.smul_def ] ] ; erw [ LinearEquiv.map_smul ] ; aesop;
    rw [ ← LinearMap.det_toMatrix ( Module.Free.chooseBasis ℤ EisensteinInteger ) ];
    rw [ h_charpoly, Matrix.charpoly ];
    simp +decide [ Matrix.det_apply', Polynomial.eval_finset_sum ];
    simp +decide [ Matrix.diagonal, Polynomial.eval_prod ];
    exact Finset.sum_congr rfl fun _ _ => by congr; ext; aesop;
  rw [ h_charpoly, charpoly_mulLeft_omega ] ; norm_num

/-
If q is a prime with q = 2 mod 3, then q - omega and q - omega^2 are coprime in the Eisenstein integers.
-/
theorem isCoprime_pi_pi_bar (q : ℕ) (hq_prime : q.Prime) (hq_mod : q % 3 = 2) :
    IsCoprime ((q : EisensteinInteger) - omega) ((q : EisensteinInteger) - omega ^ 2) := by
      by_contra h_not_coprime;
      -- Then there exists a prime ideal $\mathfrak{p}$ in the Eisenstein integers such that $\mathfrak{p}$ divides both $q - \omega$ and $q - \omega^2$.
      obtain ⟨p, hp_prime, hp_div⟩ : ∃ p : Ideal EisensteinInteger, p.IsPrime ∧ p ∣ Ideal.span {(q : EisensteinInteger) - omega} ∧ p ∣ Ideal.span {(q : EisensteinInteger) - omega ^ 2} := by
        -- Since the ideals are not coprime, their greatest common divisor is not the entire ring.
        have h_gcd : Ideal.span {(q : EisensteinInteger) - omega} ⊔ Ideal.span {(q : EisensteinInteger) - omega ^ 2} ≠ ⊤ := by
          rw [ Ne.eq_def, Ideal.eq_top_iff_one ];
          rw [ Submodule.mem_sup ];
          simp_all +decide [ Ideal.mem_span_singleton ];
          exact fun x hx y hy hxy => h_not_coprime <| by exact ⟨ hx.choose, hy.choose, by linear_combination' hxy - hx.choose_spec - hy.choose_spec ⟩ ;
        obtain ⟨ p, hp ⟩ := Ideal.exists_le_maximal _ h_gcd;
        exact ⟨ p, hp.1.isPrime, Ideal.dvd_iff_le.mpr ( le_trans ( le_sup_left ) hp.2 ), Ideal.dvd_iff_le.mpr ( le_trans ( le_sup_right ) hp.2 ) ⟩;
      -- Since $p$ divides both $q - \omega$ and $q - \omega^2$, it must also divide their difference, which is $\omega^2 - \omega$.
      have hp_div_diff : p ∣ Ideal.span {omega ^ 2 - omega} := by
        have hp_div_diff : p ∣ Ideal.span {(q : EisensteinInteger) - omega} ∧ p ∣ Ideal.span {(q : EisensteinInteger) - omega ^ 2} → p ∣ Ideal.span {((q : EisensteinInteger) - omega) - ((q : EisensteinInteger) - omega ^ 2)} := by
          simp +contextual [ Ideal.span_singleton_le_iff_mem ];
          exact fun h₁ h₂ => by simpa using p.sub_mem h₁ h₂;
        convert hp_div_diff hp_div using 1 ; ring;
      -- The norm of $\omega^2 - \omega$ is 3, so $p$ must divide 3.
      have hp_div_3 : p ∣ Ideal.span {3} := by
        have hp_norm : (omega ^ 2 - omega) * (omega - omega ^ 2) = 3 := by
          have h_norm : omega ^ 2 + omega + 1 = 0 := by
            exact?;
          grind +ring;
        rw [ ← hp_norm ];
        refine' dvd_trans hp_div_diff _;
        exact Ideal.dvd_iff_le.mpr ( Ideal.span_singleton_le_span_singleton.mpr <| dvd_mul_right _ _ );
      -- Since $p$ divides 3, it must also divide $q^2 + q + 1$.
      have hp_div_q2q1 : p ∣ Ideal.span {(q : EisensteinInteger) ^ 2 + q + 1} := by
        have hp_div_q2q1 : (q : EisensteinInteger) ^ 2 + q + 1 = ((q : EisensteinInteger) - omega) * ((q : EisensteinInteger) - omega ^ 2) := by
          convert eisenstein_norm_algebraic q |> Eq.symm using 1;
        simp_all +decide [ Ideal.dvd_iff_le ];
        exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr ( Ideal.mul_mem_right _ _ ( hp_div.1 ( Ideal.subset_span ( Set.mem_singleton _ ) ) ) ) );
      -- Since $p$ divides 3 and $q^2 + q + 1$, and $q \equiv 2 \pmod{3}$, we have $q^2 + q + 1 \equiv 1 \pmod{3}$.
      have hp_div_1 : p ∣ Ideal.span {1} := by
        have hp_div_1 : p ∣ Ideal.span {3} ∧ p ∣ Ideal.span {(q : EisensteinInteger) ^ 2 + q + 1} → p ∣ Ideal.span {1} := by
          intro h
          have h_coprime : IsCoprime (3 : EisensteinInteger) ((q : EisensteinInteger) ^ 2 + q + 1) := by
            -- Since $q \equiv 2 \pmod{3}$, we have $q^2 + q + 1 \equiv 1 \pmod{3}$.
            have h_mod : (q : ℤ) ^ 2 + q + 1 ≡ 1 [ZMOD 3] := by
              norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod, sq, hq_mod ];
              norm_cast; simp +decide [ hq_mod ] ;
            -- Since $q^2 + q + 1 \equiv 1 \pmod{3}$, we can write $q^2 + q + 1 = 3k + 1$ for some integer $k$.
            obtain ⟨k, hk⟩ : ∃ k : ℤ, (q : ℤ) ^ 2 + q + 1 = 3 * k + 1 := by
              exact h_mod.symm.dvd.imp fun k hk => by linarith;
            -- Since $q^2 + q + 1 = 3k + 1$, we can write $1 = (q^2 + q + 1) - 3k$.
            have h_eq : (1 : EisensteinInteger) = (q : EisensteinInteger) ^ 2 + q + 1 - 3 * k := by
              norm_cast at * ; aesop;
            exact ⟨ -k, 1, by linear_combination' h_eq.symm ⟩;
          have h_coprime : Ideal.span {3} ⊔ Ideal.span {(q : EisensteinInteger) ^ 2 + q + 1} = ⊤ := by
            rw [ Ideal.eq_top_iff_one ];
            rw [ Submodule.mem_sup ];
            rcases h_coprime with ⟨ a, b, h ⟩ ; exact ⟨ a * 3, Ideal.mem_span_singleton.mpr ⟨ a, by ring ⟩, b * ( q ^ 2 + q + 1 ), Ideal.mem_span_singleton.mpr ⟨ b, by ring ⟩, by linear_combination' h ⟩ ;
          simp_all +decide [ Ideal.span_singleton_one ];
          exact h_coprime ▸ Ideal.dvd_iff_le.mpr ( sup_le ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr h.1 ) ) ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr h.2 ) ) );
        exact hp_div_1 ⟨ hp_div_3, hp_div_q2q1 ⟩;
      simp_all +decide [ Ideal.dvd_iff_le ];
      exact hp_prime.ne_top rfl

/-
If 3^{(A-1)/2} ≡ 1 (mod A), then the order of 3 modulo pi divides (A-1)/2.
-/
theorem result_3 (q : ℕ) (hq_prime : q.Prime) (hq_mod : q % 3 = 2)
    (h_fermat : (3 : ℤ) ^ ((q ^ 2 + q) / 2) ≡ 1 [ZMOD (q ^ 2 + q + 1 : ℤ)]) :
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    orderOf (Ideal.Quotient.mk (Ideal.span {pi}) (3 : EisensteinInteger)) ∣ (q ^ 2 + q) / 2 := by
      -- Since $3$ is a unit in the quotient ring, we can apply the definition of order.
      have h_unit : (3 : EisensteinInteger) ^ ((q ^ 2 + q) / 2) - 1 ∈ Ideal.span {(q : EisensteinInteger) - omega} := by
        -- By definition of Eisenstein integers, we know that $q^2 + q + 1$ is divisible by $(q : EisensteinInteger) - omega$.
        have h_div : (q ^ 2 + q + 1 : EisensteinInteger) ∈ Ideal.span {(q : EisensteinInteger) - omega} := by
          have h_div : (q : EisensteinInteger) ^ 2 + q + 1 = ((q : EisensteinInteger) - omega) * ((q : EisensteinInteger) - omega ^ 2) := by
            convert eisenstein_norm_algebraic q |> Eq.symm using 1;
          exact h_div.symm ▸ Ideal.mem_span_singleton.mpr ⟨ _, rfl ⟩;
        obtain ⟨ k, hk ⟩ := h_fermat.symm.dvd;
        convert Ideal.mul_mem_right _ _ h_div using 1 ; norm_cast at * ; aesop;
      rw [ orderOf_dvd_iff_pow_eq_one ];
      erw [ Ideal.Quotient.eq ] ; aesop

/-
Define modular exponentiation for natural numbers.
-/
def powMod (b e m : ℕ) : ℕ :=
  if m = 0 then 0 else
  if e = 0 then 1 % m else
  let p := powMod b (e / 2) m
  let p2 := (p * p) % m
  if e % 2 = 1 then (p2 * b) % m else p2
termination_by e
decreasing_by
  simp_wf
  have : e / 2 < e := Nat.div_lt_self (Nat.pos_of_ne_zero (by assumption)) (by norm_num)
  exact this

/-
If 3^{(A-1)/2} ≡ 1 (mod A), then the order of 3 modulo pi divides (A-1)/2.
-/
theorem result_3_order (q : ℕ) (hq_prime : q.Prime) (hq_mod : q % 3 = 2)
    (h_fermat : (3 : ℤ) ^ ((q ^ 2 + q) / 2) ≡ 1 [ZMOD (q ^ 2 + q + 1 : ℤ)]) :
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    orderOf (Ideal.Quotient.mk (Ideal.span {pi}) (3 : EisensteinInteger)) ∣ (q ^ 2 + q) / 2 := by
      convert result_3 q hq_prime hq_mod _;
      convert h_fermat using 1

/-
Evaluate 3^2556 mod 5113.
-/
#eval powMod 3 2556 5113

/-
Evaluate 3^1704 mod 5113 to check if 3 is a cubic residue.
-/
#eval powMod 3 1704 5113

/-
For q=71, the Feit-Thompson condition 3^((A-1)/2) = 1 mod A is satisfied.
-/
theorem q_71_satisfies_FT_condition :
    let q := 71
    let A := q ^ 2 + q + 1
    powMod 3 ((A - 1) / 2) A = 1 := by
  native_decide

/-
If q = 71 mod 72, then A - 1 is divisible by 9.
-/
theorem A_sub_one_div_nine (q : ℕ) (hq_mod : q % 72 = 71) :
    let A := q ^ 2 + q + 1
    9 ∣ A - 1 := by
      rw [ ← Nat.mod_add_div q 72 ] ; norm_num [ hq_mod, Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ] ;
      norm_num [ Nat.add_mod, Nat.mul_mod ]

/-
If q = 71 mod 72, then (-omega^2)^((A-1)/3) = 1 modulo pi.
-/
theorem neg_omega_sq_pow_A_sub_one_div_three (q : ℕ) (hq_prime : q.Prime) (hq_mod : q % 72 = 71) :
    let A := q ^ 2 + q + 1
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    Ideal.Quotient.mk (Ideal.span {pi}) ((-omega ^ 2) ^ ((A - 1) / 3)) = 1 := by
      -- Since E = (A-1)/3 is even and 3 | E, we know (-omega^2)^E = 1.
      have h_equiv : (-omega^2) ^ ((q^2 + q + 1 - 1) / 3) = 1 := by
        -- Since $E$ is even and $3 \mid E$, we have $(-omega^2)^E = 1$.
        have h_even : (-omega^2) ^ ((q ^ 2 + q) / 3) = 1 := by
          have h_even_E : Even ((q ^ 2 + q) / 3) := by
            exact even_iff_two_dvd.mpr ( Nat.dvd_div_of_mul_dvd ( by rw [ ← Nat.mod_add_div q 72, hq_mod ] ; ring_nf; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] ) )
          have h_div3 : 3 ∣ (q ^ 2 + q) / 3 := by
            exact Nat.dvd_div_of_mul_dvd ( by exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 72, hq_mod ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ) )
          obtain ⟨ k, hk ⟩ := h_div3; rw [ hk ] ; ring;
          -- Since $\omega^3 = 1$, we have $\omega^{k*6} = (\omega^3)^{2k} = 1^{2k} = 1$.
          have h_omega_pow : omega ^ (k * 6) = 1 := by
            have h_omega_pow : omega ^ 3 = 1 := by
              convert IsPrimitiveRoot.pow_eq_one ( show IsPrimitiveRoot ( omega : CyclotomicField 3 ℚ ) 3 from ?_ ) using 1;
              · erw [ ← Subtype.coe_inj ] ; norm_num;
                exact?;
              · convert IsCyclotomicExtension.zeta_spec 3 ℚ ( CyclotomicField 3 ℚ ) using 1;
            rw [ ( by ring : k * 6 = 3 * ( k * 2 ) ), pow_mul, h_omega_pow, one_pow ];
          by_cases h : Even k <;> simp_all +decide [ Nat.even_mul ];
        exact h_even;
      aesop

/-
Evaluate (-70)^1704 mod 5113.
-/
#eval powMod (5113 - 70) 1704 5113

/-
If q = 71 mod 72, then q+1 is divisible by 9.
-/
theorem q_plus_one_div_nine (q : ℕ) (hq_mod : q % 72 = 71) : 9 ∣ q + 1 := by
  omega

/-
If q = 71 mod 72, then q is a cubic residue modulo A.
-/
theorem q_is_cubic_residue (q : ℕ) (hq_mod : q % 72 = 71) :
    let A := q ^ 2 + q + 1
    (q : ZMod A) ^ ((A - 1) / 3) = 1 := by
      -- Since $q^3 \equiv 1 \pmod{q^2 + q + 1}$, we have $q^{(q^2 + q)/3} \equiv 1 \pmod{q^2 + q + 1}$.
      have h_exp : q ^ ((q ^ 2 + q) / 3) ≡ 1 [MOD (q ^ 2 + q + 1)] := by
        -- Since $q^3 \equiv 1 \pmod{q^2 + q + 1}$, we have $q^{(q^2 + q)/3} \equiv 1 \pmod{q^2 + q + 1}$ by properties of modular arithmetic.
        have h_exp : q ^ 3 ≡ 1 [MOD (q ^ 2 + q + 1)] := by
          exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by use q - 1; cases q <;> norm_num at * ; linarith );
        convert h_exp.pow ( ( q ^ 2 + q ) / 3 / 3 ) using 1 <;> ring;
        rw [ Nat.div_mul_cancel ( Nat.dvd_div_of_mul_dvd _ ) ];
        exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 72, hq_mod ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] );
      simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_exp

/-
pi is congruent to 1 modulo 1 - omega.
-/
theorem pi_equiv_one_mod_one_sub_omega (q : ℕ) (hq_mod : q % 3 = 2) :
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    pi - 1 ∈ Ideal.span {1 - omega} := by
      -- Since $q \equiv 2 \pmod{3}$, we have $q - 2 \equiv 0 \pmod{3}$, thus $3 \mid (q - 2)$.
      have h_div : (3 : ℤ) ∣ (q - 2 : ℤ) := by
        omega;
      -- Since $3 \mid (q - 2)$, we have $(q - 2) \in \text{Ideal.span} \{1 - \omega\}$.
      have h_div_ideal : (q - 2 : EisensteinInteger) ∈ Ideal.span {1 - omega} := by
        obtain ⟨ k, hk ⟩ := h_div;
        -- Since $3$ is in the ideal generated by $1 - \omega$, we can write $3 = (1 - \omega)(1 - \omega^2)$.
        have h_three : (3 : EisensteinInteger) = (1 - omega) * (1 - omega^2) := by
          have := omega_sq_add_omega_add_one;
          grind;
        rw [ Ideal.mem_span_singleton ];
        rw [ show ( q : EisensteinInteger ) - 2 = 3 * k from ?_ ];
        · exact dvd_mul_of_dvd_left ( h_three.symm ▸ dvd_mul_right _ _ ) _;
        · norm_cast;
      convert Ideal.add_mem _ h_div_ideal ( Ideal.mem_span_singleton_self ( 1 - omega ) ) using 1 ; ring

/-
pi' = omega * pi is equal to 1 + (q+1)omega.
-/
theorem pi_prime_eq (q : ℕ) :
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    let pi' := omega * pi
    pi' = 1 + ((q : EisensteinInteger) + 1) * omega := by
      have h_sub : omega^2 = -omega - 1 := by
        exact eq_sub_of_add_eq <| by linear_combination' omega_sq_add_omega_add_one;
      linear_combination' -h_sub

/-
pi' is congruent to 1 modulo 9.
-/
theorem pi_prime_equiv_one_mod_nine (q : ℕ) (hq_mod : q % 72 = 71) :
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    let pi' := omega * pi
    pi' - 1 ∈ Ideal.span {9} := by
      -- From Theorem 5, q+1 is divisible by 9.
      have hq_plus_one_div_nine : 9 ∣ (q + 1) := by
        omega;
      -- Since $9 \mid q + 1$, we have $(q + 1) * \omega$ is divisible by $9$.
      have h_mul_div_nine : ∀ (x : ℕ), 9 ∣ x → (x : EisensteinInteger) * omega ∈ Ideal.span {9} := by
        intro x hx_div
        obtain ⟨k, hk⟩ := hx_div
        simp [hk, Ideal.mem_span_singleton];
        exact dvd_mul_of_dvd_left ( dvd_mul_right _ _ ) _;
      convert h_mul_div_nine ( q + 1 ) hq_plus_one_div_nine using 1 ; ring;
      rw [ show omega ^ 2 = -omega - 1 by linear_combination' omega_sq_add_omega_add_one ] ; push_cast ; ring

/-
For q=71, 1-omega is a cubic residue modulo pi.
-/
theorem one_sub_omega_is_cubic_residue_71 :
    let q : ℕ := 71
    let A : ℕ := q ^ 2 + q + 1
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    Ideal.Quotient.mk (Ideal.span {pi}) ((1 - omega) ^ ((A - 1) / 3)) = 1 := by
      -- Since $q = 71$, we have $q - 1 = 70$, and thus $(-\omega)^{70} \equiv 1 \pmod{\pi}$.
      have h_cong : (Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) ((1 - omega) ^ ((71 ^ 2 + 71) / 3))) = (Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) ((-70 : EisensteinInteger) ^ ((71 ^ 2 + 71) / 3))) := by
        apply Ideal.Quotient.eq.mpr;
        rw [ Ideal.mem_span_singleton ];
        refine' dvd_trans _ ( sub_dvd_pow_sub_pow _ _ _ );
        exact ⟨ 1, by ring ⟩;
      -- Since $(-70)^{1704} = 1 \pmod{5113}$, we have $(-70)^{1704} \equiv 1 \pmod{\pi}$.
      have h_mod : ((-70 : ℤ) ^ ((71 ^ 2 + 71) / 3) : ℤ) ≡ 1 [ZMOD 5113] := by
        native_decide +revert;
      -- Since $(-70)^{1704} = 1 \pmod{5113}$, we have $(-70)^{1704} \equiv 1 \pmod{\pi}$ by definition of modular equivalence.
      have h_mod_eq : ∀ (x : ℤ), x ≡ 1 [ZMOD 5113] → (Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) (x : EisensteinInteger)) = 1 := by
        intros x hx_mod
        have h_div : (5113 : EisensteinInteger) ∈ Ideal.span {(71 : EisensteinInteger) - omega} := by
          have h_div : (5113 : EisensteinInteger) = (71 - omega) * (71 - omega^2) := by
            have := eisenstein_norm_algebraic 71; norm_num at this; exact this.symm;
          exact h_div.symm ▸ Ideal.mem_span_singleton.mpr ⟨ _, rfl ⟩;
        obtain ⟨ k, hk ⟩ := hx_mod.symm.dvd;
        erw [ sub_eq_iff_eq_add'.mp hk ] ; norm_num [ Ideal.Quotient.eq_zero_iff_mem.mpr h_div ] ;
      grind

/-
Check if (1-71)^1704 = 1 mod 5113 using ZMod.
-/
theorem check_zmod_pow :
    let q : ℕ := 71
    let A : ℕ := q ^ 2 + q + 1
    let k : ℕ := (A - 1) / 3
    (1 - (q : ZMod A)) ^ k = 1 := by
  native_decide

/-
For q=71, 3 is a cubic residue modulo pi.
-/
theorem three_is_cubic_residue_mod_pi_71 :
    let q : ℕ := 71
    let A : ℕ := q ^ 2 + q + 1
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    Ideal.Quotient.mk (Ideal.span {pi}) ((3 : EisensteinInteger) ^ ((A - 1) / 3)) = 1 := by
      -- From Theorem 1, we know that $(-\omega^2)^k \equiv 1 \pmod{\pi}$.
      have h_neg_omega_sq_pow : Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) ((-omega ^ 2) ^ 1704) = 1 := by
        convert neg_omega_sq_pow_A_sub_one_div_three 71 ( by norm_num ) ( by norm_num ) using 1;
      -- From Theorem 2, we know that $(1 - \omega)^k \equiv 1 \pmod{\pi}$.
      have h_one_sub_omega_pow : Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) ((1 - omega) ^ 1704) = 1 := by
        convert one_sub_omega_is_cubic_residue_71 using 1;
      -- By definition of $3$, we know that $3 = -\omega^2 * (1 - \omega)^2$.
      have h_three_def : (3 : EisensteinInteger) = -omega ^ 2 * (1 - omega) ^ 2 := by
        have h_three_def : omega ^ 2 + omega + 1 = 0 := by
          exact?;
        grind +ring;
      simp_all +decide [ mul_pow ];
      rw [ ← pow_mul, mul_comm, pow_mul, h_one_sub_omega_pow, one_pow ]

/-
For q=71, 3 is a sextic residue modulo pi.
-/
theorem three_is_sextic_residue_mod_pi_71 :
    let q : ℕ := 71
    let A : ℕ := q ^ 2 + q + 1
    let pi : EisensteinInteger := (q : EisensteinInteger) - omega
    Ideal.Quotient.mk (Ideal.span {pi}) ((3 : EisensteinInteger) ^ ((A - 1) / 6)) = 1 := by
      convert result_3 71 ( by norm_num ) ( by norm_num ) _ using 1;
      · rw [ orderOf_dvd_iff_pow_eq_one ];
        constructor <;> intro h <;> simp_all +decide [ pow_mul ];
        · rw [ ( by ring : 2556 = 852 * 3 ), pow_mul, h, one_pow ];
        · have h_order : (Ideal.Quotient.mk (Ideal.span {(71 : EisensteinInteger) - omega}) 3) ^ 1704 = 1 := by
            have := three_is_cubic_residue_mod_pi_71; aesop;
          grind;
      · native_decide +revert

/-
For q=71, q divides the order of 3 modulo A.
-/
theorem q_divides_order_of_3_at_71 :
    let q := 71
    let A := q ^ 2 + q + 1
    powMod 3 (q + 1) A ≠ 1 := by
  native_decide

/-
71 divides the multiplicative order of 3 modulo 5113.
-/
theorem order_divisible_by_71 : 71 ∣ orderOf (3 : ZMod 5113) := by
  by_contra h_contra;
  -- Since $k$ divides $5112$ and $71$ does not divide $k$, $k$ must divide $72$.
  have hk_div_72 : orderOf (3 : ZMod 5113) ∣ 72 := by
    have hk_div_72 : orderOf (3 : ZMod 5113) ∣ 71 * 72 := by
      exact orderOf_dvd_iff_pow_eq_one.mpr ( by native_decide );
    exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( orderOf ( 3 : ZMod 5113 ) ) 71 from Nat.Coprime.symm <| Nat.Prime.coprime_iff_not_dvd ( by norm_num ) |>.2 h_contra ) hk_div_72 );
  exact absurd hk_div_72 ( by erw [ orderOf_dvd_iff_pow_eq_one ] ; native_decide )