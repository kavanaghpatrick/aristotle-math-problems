/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 45578f1d-6718-476b-89bd-9393e844ab72

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A group G is a Leinster group if the sum of the orders of its normal subgroups equals 2 * |G|.
-/
def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

/-
S_1 is not a Leinster group.
-/
theorem symmetric_not_leinster_1 : ¬ IsLeinster (Equiv.Perm (Fin 1)) := by
  -- The only subgroup of $S_1$ is the trivial subgroup, which has order 1.
  have h_subgroups : ∀ H : Subgroup (Equiv.Perm (Fin 1)), H = ⊥ := by
    exact?;
  -- Therefore, the sum of the orders of all normal subgroups of $S_1$ is $1$.
  simp [IsLeinster, h_subgroups];
  simp +decide [ Fintype.card_subtype ] ; aesop

/-
S_2 is not a Leinster group.
-/
theorem symmetric_not_leinster_2 : ¬ IsLeinster (Equiv.Perm (Fin 2)) := by
  simp +decide [ IsLeinster ];
  rw [ show ( Finset.univ : Finset { H : Subgroup ( Equiv.Perm ( Fin 2 ) ) // H.Normal } ) = { ⟨ ⊥, by infer_instance ⟩, ⟨ ⊤, by infer_instance ⟩ } from ?_ ];
  · simp +decide [ Subgroup.eq_top_iff' ];
  · ext ⟨H, hH⟩
    simp [Finset.mem_insert, Finset.mem_singleton];
    by_cases h : H = ⊥ <;> simp_all +decide [ Subgroup.eq_bot_iff_forall, Subgroup.eq_top_iff' ];
    obtain ⟨ x, hx₁, hx₂ ⟩ := h; have := H.mul_mem hx₁ hx₁; fin_cases x <;> simp_all +decide ;
    exact Or.inr fun x => by fin_cases x <;> aesop;

/-
S_3 is not a Leinster group.
-/
theorem symmetric_not_leinster_3 : ¬ IsLeinster (Equiv.Perm (Fin 3)) := by
  -- The normal subgroups of $S_3$ are $\{e\}$, $A_3$ (the alternating group), and $S_3$ itself.
  have h_normal_subgroups : {H : Subgroup (Equiv.Perm (Fin 3)) | H.Normal} = {⊥, alternatingGroup (Fin 3), ⊤} := by
    ext H;
    constructor;
    · have h_card : ∀ H : Subgroup (Equiv.Perm (Fin 3)), H.Normal → Fintype.card H = 1 ∨ Fintype.card H = 3 ∨ Fintype.card H = 6 := by
        intro H hH
        have h_card : Fintype.card H ∣ 6 := by
          convert Subgroup.card_subgroup_dvd_card H;
          · rw [ Nat.card_eq_fintype_card ];
          · simp +decide [ Fintype.card_perm ];
        have := Nat.le_of_dvd ( by decide ) h_card; interval_cases _ : Fintype.card H <;> simp_all +decide;
        -- If $H$ has order 2, then it must be generated by a transposition.
        obtain ⟨σ, hσ⟩ : ∃ σ : Equiv.Perm (Fin 3), σ ∈ H ∧ σ ≠ 1 ∧ ∀ τ ∈ H, τ = 1 ∨ τ = σ := by
          have h_card_two : Finset.card (Finset.filter (fun σ : Equiv.Perm (Fin 3) => σ ∈ H) (Finset.univ : Finset (Equiv.Perm (Fin 3)))) = 2 := by
            convert ‹Fintype.card H = 2› using 1;
            rw [ Fintype.card_subtype ];
          have := Finset.card_eq_two.mp h_card_two;
          obtain ⟨ x, y, hxy, h ⟩ := this; simp_all +decide [ Finset.ext_iff ];
          have := H.one_mem; aesop;
        have := hH.conj_mem σ hσ.1 ( Equiv.swap 0 1 ) ; simp_all +decide;
        cases hσ.2.2 _ this <;> simp_all +decide;
        · fin_cases σ <;> simp_all +decide;
        · fin_cases σ <;> simp_all +decide;
          have := hH.conj_mem _ hσ.1 ( Equiv.swap 1 2 ) ; simp_all +decide;
          cases hσ.2 _ this <;> simp_all +decide;
      intro hH;
      specialize h_card H hH;
      rcases h_card with ( h | h | h );
      · simp_all +decide [ Fintype.card_eq_one_iff ];
        exact Or.inl <| eq_bot_iff.mpr fun x hx => h.choose_spec.2 x hx ▸ h.choose_spec.2 1 ( H.one_mem ) ▸ rfl;
      · have h_alt : ∀ {g : Equiv.Perm (Fin 3)}, g ∈ H → g ∈ alternatingGroup (Fin 3) := by
          have h_alt : ∀ {g : Equiv.Perm (Fin 3)}, g ∈ H → g ∈ alternatingGroup (Fin 3) := by
            intro g hg
            have h_order : orderOf g ∣ 3 := by
              have h_order : orderOf g ∣ Fintype.card H := by
                have h_order : orderOf g ∣ Fintype.card (Subgroup.zpowers g) := by
                  rw [ Fintype.card_zpowers ];
                exact h_order.trans ( by simpa using Subgroup.card_dvd_of_le ( Subgroup.zpowers_le.mpr hg ) );
              aesop
            have := Nat.le_of_dvd ( by decide ) h_order; interval_cases _ : orderOf g <;> simp_all +decide [ orderOf_eq_iff ] ;
            fin_cases g <;> simp_all +decide;
          assumption;
        have h_alt : H = alternatingGroup (Fin 3) := by
          exact SetLike.ext' ( by exact Set.eq_of_subset_of_card_le ( fun g hg => h_alt hg ) ( by simp +decide [ h ] ) )
        aesop;
      · have := Subgroup.card_mul_index H; simp_all +decide ;
        simp_all +decide [ Fintype.card_perm ];
        simp_all +decide [ Nat.factorial ];
    · rintro ( rfl | rfl | rfl ) <;> norm_num [ Subgroup.normal_of_characteristic ];
  -- Substitute the normal subgroups into the sum.
  have h_sum : ∑ H : {H : Subgroup (Equiv.Perm (Fin 3)) // H.Normal}, Nat.card H = 1 + 3 + 6 := by
    have h_sum : ∑ H ∈ ({⊥, alternatingGroup (Fin 3), ⊤} : Finset (Subgroup (Equiv.Perm (Fin 3)))), Nat.card H = 1 + 3 + 6 := by
      rw [ Finset.sum_insert, Finset.sum_insert ] <;> simp +decide [ Nat.card_eq_fintype_card ];
      · simp +decide [ Subgroup.eq_top_iff' ];
      · simp +decide [ Subgroup.eq_top_iff' ];
        simp +decide [ eq_comm, Subgroup.eq_bot_iff_forall ];
    convert h_sum using 1;
    refine' Finset.sum_bij ( fun H _ => H.val ) _ _ _ _ <;> simp +decide [ Set.ext_iff ] at *;
    · exact fun x hx => h_normal_subgroups x |>.1 hx;
    · exact ⟨ by infer_instance, by infer_instance, by infer_instance ⟩;
  unfold IsLeinster; simp_all +decide ;

/-
Check if the type of subgroups of S4 is a Fintype.
-/
#check Fintype (Subgroup (Equiv.Perm (Fin 4)))

/-
The set of normal subgroups of S_4.
-/
def normalSubgroupsS4 : Finset (Subgroup (Equiv.Perm (Fin 4))) :=
  {⊥, Subgroup.closure {Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3}, alternatingGroup (Fin 4), ⊤}

/-
The subgroups in `normalSubgroupsS4` are all normal.
-/
theorem normalSubgroupsS4_subset :
    normalSubgroupsS4 ⊆ Finset.filter (fun H : Subgroup (Equiv.Perm (Fin 4)) => H.Normal) Finset.univ := by
      simp +decide [ Finset.subset_iff ];
      unfold normalSubgroupsS4;
      -- The trivial subgroup is normal.
      simp [Subgroup.normal_of_characteristic];
      constructor;
      intro n hn g;
      rw [ Subgroup.mem_closure ] at hn ⊢;
      intro K hK; specialize hn ( K.comap ( MulAut.conj g ) ) ; simp_all +decide [ Set.insert_subset_iff, Set.singleton_subset_iff ] ;
      -- Since $g$ is a permutation, conjugating $(0 1)(2 3)$ and $(0 2)(1 3)$ by $g$ will result in elements that are still in $K$.
      have h_conj : ∀ g : Equiv.Perm (Fin 4), g * (Equiv.swap 0 1 * Equiv.swap 2 3) * g⁻¹ ∈ K ∧ g * (Equiv.swap 0 2 * Equiv.swap 1 3) * g⁻¹ ∈ K := by
        intro g
        have h_conj : ∀ g : Equiv.Perm (Fin 4), g * (Equiv.swap 0 1 * Equiv.swap 2 3) * g⁻¹ = Equiv.swap 0 1 * Equiv.swap 2 3 ∨ g * (Equiv.swap 0 1 * Equiv.swap 2 3) * g⁻¹ = Equiv.swap 0 2 * Equiv.swap 1 3 ∨ g * (Equiv.swap 0 1 * Equiv.swap 2 3) * g⁻¹ = Equiv.swap 0 3 * Equiv.swap 1 2 := by
          native_decide +revert;
        have h_conj : ∀ g : Equiv.Perm (Fin 4), g * (Equiv.swap 0 2 * Equiv.swap 1 3) * g⁻¹ = Equiv.swap 0 1 * Equiv.swap 2 3 ∨ g * (Equiv.swap 0 2 * Equiv.swap 1 3) * g⁻¹ = Equiv.swap 0 2 * Equiv.swap 1 3 ∨ g * (Equiv.swap 0 2 * Equiv.swap 1 3) * g⁻¹ = Equiv.swap 0 3 * Equiv.swap 1 2 := by
          native_decide +revert;
        have h_conj : Equiv.swap 0 3 * Equiv.swap 1 2 ∈ K := by
          convert K.mul_mem hK.1 hK.2 using 1 ; decide;
        grind;
      exact hn ( h_conj g |>.1 ) ( h_conj g |>.2 )

/-
There is no normal subgroup of S_4 of order 2.
-/
lemma no_normal_subgroup_order_2 (H : Subgroup (Equiv.Perm (Fin 4))) (hH : H.Normal) (h_card : Nat.card H = 2) : False := by
  -- Since H is normal of order 2, it contains an element x of order 2.
  obtain ⟨x, hx⟩ : ∃ x ∈ H, x ≠ 1 ∧ orderOf x = 2 := by
    -- Since H is a subgroup of S4 with order 2, it must have exactly two elements. The identity element is always in H, so the other element must be of order 2.
    have h_two_elements : ∃ x : Equiv.Perm (Fin 4), x ∈ H ∧ x ≠ 1 := by
      contrapose! h_card;
      rw [ show H = ⊥ by exact eq_bot_iff.mpr h_card ] ; simp +decide;
    obtain ⟨ x, hx₁, hx₂ ⟩ := h_two_elements; use x; have := orderOf_dvd_iff_pow_eq_one.mpr ( show x ^ 2 = 1 from ?_ ) ; simp_all +decide [ Nat.dvd_prime ] ;
    have h_order : ∀ y : H, y ^ Nat.card H = 1 := by
      simp +decide [ pow_card_eq_one ];
    aesop;
  -- Since H is normal, x is in the center of S4 (or at least its conjugacy class is {x}).
  have h_center : ∀ y : Equiv.Perm (Fin 4), y * x * y⁻¹ ∈ H := by
    exact fun y => hH.conj_mem _ hx.1 y;
  have h_conj : Finset.card (Finset.image (fun y : Equiv.Perm (Fin 4) => y * x * y⁻¹) (Finset.univ : Finset (Equiv.Perm (Fin 4)))) ≤ 2 := by
    have h_conj : Finset.card (Finset.image (fun y : Equiv.Perm (Fin 4) => y * x * y⁻¹) (Finset.univ : Finset (Equiv.Perm (Fin 4)))) ≤ Finset.card (Finset.filter (fun y : Equiv.Perm (Fin 4) => y ∈ H) (Finset.univ : Finset (Equiv.Perm (Fin 4)))) := by
      exact Finset.card_le_card fun y hy => by aesop;
    simp_all +decide [ Fintype.card_subtype ];
  fin_cases x <;> simp +decide at hx h_conj ⊢

/-
There is no normal subgroup of S_4 of order 3.
-/
lemma no_normal_subgroup_order_3 (H : Subgroup (Equiv.Perm (Fin 4))) (hH : H.Normal) (h_card : Nat.card H = 3) : False := by
  -- Let H be a normal subgroup of S4 with order 3. Then H must contain a 3-cycle.
  obtain ⟨g, hg⟩ : ∃ g : Equiv.Perm (Fin 4), g ∈ H ∧ orderOf g = 3 := by
    have := Fact.mk ( show Nat.Prime 3 by decide ) ; have := exists_prime_orderOf_dvd_card 3 ( by rw [ Nat.card_eq_fintype_card ] at h_card; aesop_cat : 3 ∣ Fintype.card H ) ; aesop;
  -- Since $H$ is normal, it must contain all conjugates of $g$.
  have h_conjugates : ∀ h : Equiv.Perm (Fin 4), h * g * h⁻¹ ∈ H := by
    exact fun h => hH.conj_mem _ hg.1 h;
  -- Since $H$ contains all conjugates of $g$, and there are more than 3 conjugates of $g$ in $S_4$, $H$ must have more than 3 elements.
  have h_conjugates_card : Finset.card (Finset.image (fun h : Equiv.Perm (Fin 4) => h * g * h⁻¹) (Finset.univ : Finset (Equiv.Perm (Fin 4)))) > 3 := by
    simp +decide only [orderOf_eq_iff] at hg;
    fin_cases g <;> simp +decide at hg ⊢;
  have h_conjugates_subset : Finset.image (fun h : Equiv.Perm (Fin 4) => h * g * h⁻¹) (Finset.univ : Finset (Equiv.Perm (Fin 4))) ⊆ Finset.filter (fun x => x ∈ H) (Finset.univ : Finset (Equiv.Perm (Fin 4))) := by
    exact Finset.image_subset_iff.mpr fun h _ => by simpa using h_conjugates h;
  exact h_conjugates_card.not_le ( le_trans ( Finset.card_le_card h_conjugates_subset ) ( by rw [ ← Nat.card_eq_finsetCard ] ; aesop ) )

/-
There is no normal subgroup of S_4 of order 6.
-/
lemma no_normal_subgroup_order_6 (H : Subgroup (Equiv.Perm (Fin 4))) (hH : H.Normal) (h_card : Nat.card H = 6) : False := by
  -- Since H is normal of order 6, it contains a 3-cycle (Sylow 3-theorem or Cauchy).
  obtain ⟨g, hg⟩ : ∃ g : Equiv.Perm (Fin 4), g ∈ H ∧ orderOf g = 3 := by
    have := Fact.mk ( by decide : Nat.Prime 3 ) ; have := exists_prime_orderOf_dvd_card 3 ( by rw [ Nat.card_eq_fintype_card ] at h_card; aesop_cat : 3 ∣ Fintype.card H ) ; aesop;
  -- Since H is normal, it contains all 3-cycles.
  have h_all_3cycles : ∀ g : Equiv.Perm (Fin 4), orderOf g = 3 → g ∈ H := by
    -- Since H is normal, it contains all conjugates of g.
    have h_conjugates : ∀ h : Equiv.Perm (Fin 4), h * g * h⁻¹ ∈ H := by
      exact fun h => hH.conj_mem _ hg.1 h;
    -- Since any two 3-cycles are conjugate in S4, we can find an h such that h * g * h⁻¹ = g'.
    have h_conj : ∀ g' : Equiv.Perm (Fin 4), orderOf g' = 3 → ∃ h : Equiv.Perm (Fin 4), h * g * h⁻¹ = g' := by
      simp_all +decide [ orderOf_eq_iff ];
      fin_cases g <;> simp +decide at hg ⊢;
    exact fun g' hg' => by obtain ⟨ h, rfl ⟩ := h_conj g' hg'; exact h_conjugates h;
  -- The set of 3-cycles in S4 has 8 elements.
  have h_3cycles_card : Finset.card (Finset.filter (fun g : Equiv.Perm (Fin 4) => orderOf g = 3) Finset.univ) = 8 := by
    simp +decide only [orderOf_eq_iff];
  exact absurd ( Finset.card_le_card ( show Finset.filter ( fun g : Equiv.Perm ( Fin 4 ) => orderOf g = 3 ) Finset.univ ⊆ Finset.filter ( fun g : Equiv.Perm ( Fin 4 ) => g ∈ H ) Finset.univ from fun x hx => by aesop ) ) ( by rw [ Finset.card_filter, Finset.card_filter ] at *; simp_all +decide [ Fintype.card_subtype ] )

/-
There is no normal subgroup of S_4 of order 8.
-/
lemma no_normal_subgroup_order_8 (H : Subgroup (Equiv.Perm (Fin 4))) (hH : H.Normal) (h_card : Nat.card H = 8) : False := by
  -- Since $H$ is normal in $S_4$, its index is 3.
  have h_index : Nat.card (Equiv.Perm (Fin 4)) / Nat.card H = 3 := by
    simp_all +decide [ Fintype.card_perm ];
  -- In a group of order 3, $x^3 = 1$ for all $x$.
  have h_cube : ∀ g : Equiv.Perm (Fin 4), (g : Equiv.Perm (Fin 4) ⧸ H) ^ 3 = 1 := by
    have h_cube : Nat.card (Equiv.Perm (Fin 4) ⧸ H) = 3 := by
      have := Subgroup.card_eq_card_quotient_mul_card_subgroup H; aesop;
    have h_cube : ∀ g : Equiv.Perm (Fin 4) ⧸ H, g ^ Nat.card (Equiv.Perm (Fin 4) ⧸ H) = 1 := by
      exact?;
    grind;
  -- So for any $g \in S_4$, $(gH)^3 = H$, i.e., $g^3 \in H$.
  have h_cube_in_H : ∀ g : Equiv.Perm (Fin 4), g^3 ∈ H := by
    intro g; specialize h_cube g; erw [ ← QuotientGroup.eq_one_iff ] at *; aesop;
  -- Take any transposition $t$. $t^2 = 1$, so $t^3 = t * t^2 = t * 1 = t$.
  have h_transposition : ∀ t : Equiv.Perm (Fin 4), t^2 = 1 → t ∈ H := by
    intro t ht; specialize h_cube_in_H t; simp_all +decide [ pow_succ ] ;
  -- Transpositions generate $S_4$, so $H$ must contain all transpositions.
  have h_all_transpositions : ∀ t : Equiv.Perm (Fin 4), t ∈ H := by
    intro t
    induction' t using Equiv.Perm.swap_induction_on with t ht ih;
    · exact H.one_mem;
    · exact H.mul_mem ( h_transposition _ ( by simp +decide [ *, sq ] ) ) ‹_›;
  exact absurd h_card ( by rw [ show H = ⊤ from eq_top_iff.mpr fun x hx => h_all_transpositions x ] ; simp +decide )

/-
The only normal subgroup of S_4 of order 4 is the Klein four-group.
-/
lemma unique_normal_subgroup_order_4 (H : Subgroup (Equiv.Perm (Fin 4))) (hH : H.Normal) (h_card : Nat.card H = 4) :
  H = Subgroup.closure {Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3} := by
    -- Since H is normal and has order 4, it must be contained in the set of elements of order 2 in S4.
    have h_contained : ∀ h ∈ H, h = 1 ∨ h = Equiv.swap 0 1 * Equiv.swap 2 3 ∨ h = Equiv.swap 0 2 * Equiv.swap 1 3 ∨ h = Equiv.swap 0 3 * Equiv.swap 1 2 := by
      -- Since H is normal and has order 4, it must be contained in the set of elements of order 2 in S4. Therefore, h must be one of these elements.
      have h_order : ∀ h ∈ H, h^2 = 1 := by
        have h_order : ∀ h ∈ H, orderOf h ∣ 4 := by
          intro h hh; have := orderOf_dvd_iff_pow_eq_one.2 ( show h ^ 4 = 1 from ?_ ) ; aesop;
          have h_contained : ∀ h : H, h ^ Fintype.card H = 1 := by
            exact fun x => by rw [ pow_card_eq_one ] ;
          convert h_contained ⟨ h, hh ⟩ ; aesop;
        intro h hh; specialize h_order h hh; have := Nat.le_of_dvd ( by decide ) h_order; interval_cases _ : orderOf h <;> simp_all +decide ;
        · rw [ ← ‹orderOf h = 2›, pow_orderOf_eq_one ];
        · have h_contradiction : ∀ g : Equiv.Perm (Fin 4), orderOf g = 4 → ¬(∀ k : Equiv.Perm (Fin 4), k * g * k⁻¹ ∈ H) := by
            intros g hg h_conj
            have h_contradiction : Finset.card (Finset.image (fun k : Equiv.Perm (Fin 4) => k * g * k⁻¹) Finset.univ) ≤ Finset.card (Finset.filter (fun x : Equiv.Perm (Fin 4) => x ∈ H) Finset.univ) := by
              exact Finset.card_le_card fun x hx => by aesop;
            have h_contradiction : Finset.card (Finset.image (fun k : Equiv.Perm (Fin 4) => k * g * k⁻¹) Finset.univ) = 6 := by
              have h_contradiction : ∀ g : Equiv.Perm (Fin 4), orderOf g = 4 → Finset.card (Finset.image (fun k : Equiv.Perm (Fin 4) => k * g * k⁻¹) Finset.univ) = 6 := by
                simp +decide [ orderOf_eq_iff ];
              exact h_contradiction g hg;
            simp_all +decide [ Fintype.card_subtype ];
          exact False.elim <| h_contradiction h ‹_› fun k => hH.conj_mem _ hh k;
      have h_order : ∀ h ∈ H, h = 1 ∨ h = Equiv.swap 0 1 * Equiv.swap 2 3 ∨ h = Equiv.swap 0 2 * Equiv.swap 1 3 ∨ h = Equiv.swap 0 3 * Equiv.swap 1 2 ∨ h = Equiv.swap 0 1 ∨ h = Equiv.swap 0 2 ∨ h = Equiv.swap 0 3 ∨ h = Equiv.swap 1 2 ∨ h = Equiv.swap 1 3 ∨ h = Equiv.swap 2 3 := by
        intro h hh; specialize h_order h hh; fin_cases h <;> simp +decide at h_order ⊢;
      have h_not_transpositions : ∀ h ∈ H, h ≠ Equiv.swap 0 1 ∧ h ≠ Equiv.swap 0 2 ∧ h ≠ Equiv.swap 0 3 ∧ h ≠ Equiv.swap 1 2 ∧ h ≠ Equiv.swap 1 3 ∧ h ≠ Equiv.swap 2 3 := by
        intros h hh
        have h_conj : ∀ g : Equiv.Perm (Fin 4), g * h * g⁻¹ ∈ H := by
          exact fun g => hH.conj_mem _ hh g;
        have h_conj : Finset.card (Finset.image (fun g : Equiv.Perm (Fin 4) => g * h * g⁻¹) Finset.univ) ≤ Finset.card (Finset.filter (fun x : Equiv.Perm (Fin 4) => x ∈ H) Finset.univ) := by
          exact Finset.card_le_card fun x hx => by aesop;
        simp_all +decide [ Fintype.card_subtype ];
        exact ⟨ fun h' => by subst h'; exact absurd h_conj ( by native_decide ), fun h' => by subst h'; exact absurd h_conj ( by native_decide ), fun h' => by subst h'; exact absurd h_conj ( by native_decide ), fun h' => by subst h'; exact absurd h_conj ( by native_decide ), fun h' => by subst h'; exact absurd h_conj ( by native_decide ), fun h' => by subst h'; exact absurd h_conj ( by native_decide ) ⟩;
      grind +ring;
    refine' le_antisymm _ _;
    · intro h hh; specialize h_contained h hh; rcases h_contained with ( rfl | rfl | rfl | rfl ) <;> simp +decide [ Subgroup.mem_closure ] ;
      · exact fun K hK => hK <| Set.mem_insert _ _;
      · exact fun K hK => hK <| Set.mem_insert_of_mem _ <| Set.mem_singleton _;
      · simp +decide [ Set.insert_subset_iff, Set.singleton_subset_iff ];
        intro K hK₁ hK₂; convert K.mul_mem hK₁ hK₂ using 1; simp +decide [ mul_assoc ] ;
    · simp_all +decide [ Set.insert_subset_iff, Subgroup.closure_le ];
      have h_card_H : Finset.card (Finset.filter (fun h : Equiv.Perm (Fin 4) => h ∈ H) (Finset.univ : Finset (Equiv.Perm (Fin 4)))) = 4 := by
        convert h_card using 1;
        rw [ Fintype.card_subtype ];
      have h_card_H : Finset.filter (fun h : Equiv.Perm (Fin 4) => h ∈ H) (Finset.univ : Finset (Equiv.Perm (Fin 4))) = {1, Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3, Equiv.swap 0 3 * Equiv.swap 1 2} := by
        exact Finset.eq_of_subset_of_card_le ( fun x hx => by simpa using h_contained x <| Finset.mem_filter.mp hx |>.2 ) ( by simp +decide [ h_card_H ] );
      simp_all +decide [ Finset.ext_iff, Set.ext_iff ]

/-
The normal subgroups of S_4 are exactly ⊥, V_4, A_4, and ⊤.
-/
theorem normal_subgroups_S4_eq :
    Finset.filter (fun H : Subgroup (Equiv.Perm (Fin 4)) => H.Normal) Finset.univ = normalSubgroupsS4 := by
      apply Finset.Subset.antisymm;
      · intro H hH
        have h_card : Nat.card H = 1 ∨ Nat.card H = 4 ∨ Nat.card H = 12 ∨ Nat.card H = 24 := by
          have h_card : Nat.card H ∣ 24 := by
            simpa using Subgroup.card_subgroup_dvd_card H;
          have := Nat.le_of_dvd ( by decide ) h_card; interval_cases _ : Nat.card H <;> simp_all ( config := { decide := Bool.true } ) only;
          · exact no_normal_subgroup_order_2 H ( by simpa using hH ) ‹_›;
          · exact no_normal_subgroup_order_3 H ( by simpa using hH ) ‹_›;
          · exact no_normal_subgroup_order_6 H ( by simpa using hH ) ‹_›;
          · exact no_normal_subgroup_order_8 H ( by aesop ) ( by aesop );
        rcases h_card with ( h | h | h | h ) <;> simp_all +decide [ normalSubgroupsS4 ];
        · simp_all +decide [ Fintype.card_eq_one_iff, Subgroup.eq_bot_iff_forall ];
          exact Or.inl fun x hx => by obtain ⟨ y, hy, hy' ⟩ := h; have := hy' 1 ( H.one_mem ) ; have := hy' x hx; aesop;
        · have := unique_normal_subgroup_order_4 H hH ( by simpa [ Fintype.card_subtype ] using h ) ; aesop;
        · have h_index : H.index = 2 := by
            have := Subgroup.index_mul_card H; simp_all +decide ;
            exact mul_right_cancel₀ ( by decide ) this;
          exact Or.inr <| Or.inr <| Or.inl <| by exact?;
        · have := Subgroup.card_mul_index H; simp_all +decide ;
          simp_all +decide [ Fintype.card_perm ];
          simp_all +decide [ Nat.factorial ];
      · convert normalSubgroupsS4_subset using 1

/-
S_4 is not a Leinster group.
-/
theorem symmetric_not_leinster_4 : ¬ IsLeinster (Equiv.Perm (Fin 4)) := by
  rw [ IsLeinster ];
  -- By definition of $normalSubgroupsS4$, we know that its cardinality is 4, so we can calculate the sum.
  have h_sum : ∑ H : { H : Subgroup (Equiv.Perm (Fin 4)) // H.Normal }, Nat.card H = ∑ H ∈ Finset.filter (fun H : Subgroup (Equiv.Perm (Fin 4)) => H.Normal) Finset.univ, Nat.card H := by
    refine' Finset.sum_bij ( fun H _ => H.val ) _ _ _ _ <;> aesop;
  rw [ h_sum, show ( Finset.filter ( fun H : Subgroup ( Equiv.Perm ( Fin 4 ) ) => H.Normal ) Finset.univ : Finset ( Subgroup ( Equiv.Perm ( Fin 4 ) ) ) ) = { ⊥, Subgroup.closure { Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3 }, alternatingGroup ( Fin 4 ), ⊤ } from ?_ ];
  · rw [ Finset.sum_insert, Finset.sum_insert, Finset.sum_insert ] <;> simp +decide [ Fintype.card_subtype ];
    · rw [ show ( Finset.filter ( fun x : Equiv.Perm ( Fin 4 ) => x ∈ Subgroup.closure { Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3 } ) Finset.univ : Finset ( Equiv.Perm ( Fin 4 ) ) ) = { 1, Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3, Equiv.swap 0 3 * Equiv.swap 1 2 } from ?_ ] ; simp +decide [ Fintype.card_subtype ];
      ext x;
      simp +decide [ Subgroup.mem_closure_pair ];
      constructor;
      · refine' Subgroup.closure_induction _ _ _ _;
        · simp +decide;
        · decide +revert;
        · rintro x y hx hy ( rfl | rfl | rfl | rfl ) ( rfl | rfl | rfl | rfl ) <;> decide;
        · rintro x hx ( rfl | rfl | rfl | rfl ) <;> decide;
      · rintro ( rfl | rfl | rfl | rfl ) <;> [ exact Subgroup.one_mem _; exact Subgroup.subset_closure ( Set.mem_insert _ _ ) ; exact Subgroup.subset_closure ( Set.mem_insert_of_mem _ ( Set.mem_singleton _ ) ) ; exact by rw [ show ( Equiv.swap 0 3 * Equiv.swap 1 2 : Equiv.Perm ( Fin 4 ) ) = ( Equiv.swap 0 1 * Equiv.swap 2 3 ) * ( Equiv.swap 0 2 * Equiv.swap 1 3 ) by decide ] ; exact Subgroup.mul_mem _ ( Subgroup.subset_closure ( Set.mem_insert _ _ ) ) ( Subgroup.subset_closure ( Set.mem_insert_of_mem _ ( Set.mem_singleton _ ) ) ) ];
    · simp +decide [ Subgroup.eq_top_iff' ];
    · constructor <;> intro h <;> have := congr_arg ( fun H => H.carrier ) h <;> simp +decide [ Set.ext_iff ] at this;
      · replace h := SetLike.ext_iff.mp h ( Equiv.swap 0 1 * Equiv.swap 0 2 ) ; simp +decide at h;
        rw [ Subgroup.mem_closure ] at h;
        specialize h ( Subgroup.centralizer { Equiv.swap 0 1 * Equiv.swap 2 3, Equiv.swap 0 2 * Equiv.swap 1 3 } ) ; simp +decide [ Set.insert_subset_iff, Subgroup.mem_centralizer_iff ] at h;
      · contrapose! this;
        refine' ⟨ Equiv.swap 0 1, _ ⟩;
        rw [ Subgroup.mem_closure ];
        simp +decide [ Set.insert_subset_iff ];
        refine' ⟨ _, _, _, _ ⟩;
        exact?;
        · simp +decide [ alternatingGroup ];
        · simp +decide [ alternatingGroup ];
        · simp +decide [ Equiv.Perm.mem_alternatingGroup ];
    · simp +decide [ eq_comm, Subgroup.eq_bot_iff_forall, Subgroup.eq_top_iff' ];
      rw [ eq_comm, Subgroup.closure_eq_bot_iff ] ; simp +decide;
  · convert normal_subgroups_S4_eq using 1