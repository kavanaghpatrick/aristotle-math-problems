/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7e275d90-5d8c-4074-909c-0eee94738004

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a Leinster group as a finite group where the sum of the orders of its normal subgroups equals twice the order of the group. We prove that a finite abelian group is a Leinster group if and only if it is cyclic and its order is a perfect number.

The proof proceeds in two directions:
1.  **Reverse direction (`cyclic_perfect_implies_leinster`)**: If a group is cyclic and its order is perfect, it is a Leinster group. This relies on the fact that for a cyclic group, the sum of subgroup orders equals the sum of the divisors of the group's order (`sum_subgroup_orders_cyclic`). Since the order is perfect, this sum is twice the group's order.
2.  **Forward direction (`leinster_implies_cyclic_perfect`)**: If an abelian group is a Leinster group, it must be cyclic and have a perfect order. We show that if a finite abelian group is not cyclic, the sum of its subgroup orders is strictly greater than twice its order (`sum_subgroup_orders_gt_two_mul_card_of_not_cyclic`). This is proven by showing that any non-cyclic finite abelian group has a quotient isomorphic to $Z_p \times Z_p$ (`exists_quotient_Zp_times_Zp_of_not_cyclic`), and for such groups, the sum of subgroup orders is large enough to violate the Leinster condition.

Key lemmas include:
-   `isLeinster_iff_sumSubgroupOrders_eq`: For abelian groups, the Leinster condition is equivalent to the sum of all subgroup orders being twice the group order.
-   `sum_subgroup_orders_cyclic`: For a cyclic group, the sum of subgroup orders equals the sum of divisors of the group order.
-   `sum_subgroup_orders_quotient_lt`: Relates the sum of subgroup orders of a group to that of a quotient by a non-trivial normal subgroup.
-   `sum_subgroup_orders_Zp_times_Zp`: Shows that for $Z_p \times Z_p$, the sum of subgroup orders is strictly greater than twice the group order.
-   `exists_quotient_Zp_times_Zp_of_not_cyclic`: Establishes that any non-cyclic finite abelian group has a quotient isomorphic to $Z_p \times Z_p$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A finite group G is a Leinster group if the sum of the orders of its normal subgroups equals twice the order of G.
-/
def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

/-
For an abelian group, the Leinster condition is equivalent to the sum of all subgroup orders being twice the group order.
-/
def sumSubgroupOrders (G : Type*) [Group G] [Fintype G] : ℕ :=
  ∑ H : Subgroup G, Nat.card H

theorem isLeinster_iff_sumSubgroupOrders_eq (G : Type*) [CommGroup G] [Fintype G] :
    IsLeinster G ↔ sumSubgroupOrders G = 2 * Fintype.card G := by
  unfold sumSubgroupOrders IsLeinster;
  rw [ ← Finset.sum_subset ( Finset.subset_univ ( Finset.image ( fun H : { H : Subgroup G // H.Normal } ↦ H.val ) Finset.univ ) ) ];
  · rw [ Finset.sum_image ] ; aesop;
  · simp +contextual;
    exact?

/-
For a cyclic group, the sum of subgroup orders equals the sum of divisors of the group order.
-/
theorem sum_subgroup_orders_cyclic (G : Type*) [Group G] [Fintype G] [IsCyclic G] :
    sumSubgroupOrders G = ∑ d ∈ (Fintype.card G).divisors, d := by
  -- By definition of cyclic groups, every subgroup is of the form $\langle g^k \rangle$ for some divisor $k$ of $n$.
  have h_subgroups : ∀ H : Subgroup G, ∃ d : ℕ, d ∣ Fintype.card G ∧ Nat.card H = d := by
    exact fun H => ⟨ _, by simpa using Subgroup.card_subgroup_dvd_card H, rfl ⟩;
  -- Let $d$ be a divisor of $n$. We need to show that there is exactly one subgroup of order $d$.
  have h_unique_subgroup : ∀ d : ℕ, d ∣ Fintype.card G → ∃! H : Subgroup G, Nat.card H = d := by
    intro d hd;
    -- Let $g$ be a generator of $G$. Then every subgroup of $G$ is of the form $\langle g^k \rangle$ for some divisor $k$ of $|G|$.
    obtain ⟨g, hg⟩ : ∃ g : G, ∀ x : G, x ∈ Subgroup.zpowers g := by
      exact IsCyclic.exists_generator;
    -- Let $k$ be a divisor of $|G|$. Then the subgroup generated by $g^k$ has order $|G|/k$.
    have h_subgroup_order : ∀ k : ℕ, k ∣ Fintype.card G → Nat.card (Subgroup.zpowers (g ^ (Fintype.card G / k))) = k := by
      intro k hk; rw [ Nat.card_eq_fintype_card ] ; simp +decide [ Fintype.card_zpowers ] ;
      rw [ orderOf_pow' ] <;> norm_num [ orderOf_eq_card_of_forall_mem_zpowers hg ];
      · rw [ Nat.gcd_eq_right ( Nat.div_dvd_of_dvd hk ), Nat.div_div_self hk ( by aesop ) ];
      · exact ⟨ Nat.ne_of_gt ( Nat.pos_of_dvd_of_pos hk ( Fintype.card_pos ) ), Nat.le_of_dvd ( Fintype.card_pos ) hk ⟩;
    refine' ⟨ Subgroup.zpowers ( g ^ ( Fintype.card G / d ) ), h_subgroup_order d hd, fun H hH => _ ⟩;
    -- Since $H$ is a subgroup of $G$ and $G$ is cyclic, $H$ must be generated by some element $h$ of $G$.
    obtain ⟨h, hh⟩ : ∃ h : G, H = Subgroup.zpowers h := by
      have h_subgroup_gen : ∀ H : Subgroup G, ∃ h : G, H = Subgroup.zpowers h := by
        intro H
        have h_subgroup_gen : IsCyclic H := by
          exact?;
        obtain ⟨ x, hx ⟩ := h_subgroup_gen.exists_generator;
        refine' ⟨ x, le_antisymm _ _ ⟩;
        · exact fun y hy => by obtain ⟨ k, hk ⟩ := hx ⟨ y, hy ⟩ ; exact ⟨ k, by simpa [ Subtype.ext_iff ] using hk ⟩ ;
        · aesop;
      exact h_subgroup_gen H;
    -- Since $h$ is in the subgroup generated by $g$, we can write $h = g^k$ for some integer $k$.
    obtain ⟨k, hk⟩ : ∃ k : ℕ, h = g ^ k := by
      obtain ⟨ k, rfl ⟩ := hg h;
      norm_num +zetaDelta at *;
      rw [ ← zpow_mod_orderOf ];
      exact ⟨ Int.toNat ( k % orderOf g ), by rw [ ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ ( Nat.cast_ne_zero.mpr ( ne_of_gt ( orderOf_pos g ) ) ) ) ] ⟩;
    -- Since $h = g^k$, we have $|H| = |g^k| = \frac{|G|}{\gcd(k, |G|)}$.
    have h_order : Nat.card (Subgroup.zpowers (g ^ k)) = Fintype.card G / Nat.gcd k (Fintype.card G) := by
      rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers ];
      rw [ orderOf_pow, orderOf_eq_card_of_forall_mem_zpowers hg ];
      simp +decide [ Nat.gcd_comm, Nat.card_eq_fintype_card ];
    have h_gcd : Nat.gcd k (Fintype.card G) = Fintype.card G / d := by
      have h_gcd : Fintype.card G / Nat.gcd k (Fintype.card G) = d := by
        grind +ring;
      rw [ ← h_gcd, Nat.div_div_self ( Nat.gcd_dvd_right _ _ ) ( by aesop ) ];
    have h_subgroup_eq : Subgroup.zpowers (g ^ k) = Subgroup.zpowers (g ^ (Nat.gcd k (Fintype.card G))) := by
      refine' le_antisymm _ _ <;> simp +decide [ Subgroup.zpowers_le ];
      · have h_subgroup_eq : ∃ m : ℕ, k = m * Nat.gcd k (Fintype.card G) := by
          exact exists_eq_mul_left_of_dvd ( Nat.gcd_dvd_left _ _ );
        obtain ⟨ m, hm ⟩ := h_subgroup_eq; rw [ hm ] ; simp +decide [ pow_mul' ] ;
        rw [ ← hm ] ; simp +decide [ pow_mul' ] ;
      · have := Nat.gcd_eq_gcd_ab k ( Fintype.card G );
        simp +decide [ ← zpow_natCast, ← zpow_mul, this ];
        simp +decide [ zpow_add, zpow_mul ];
    grind;
  choose! f hf₁ hf₂ using h_unique_subgroup;
  -- By definition of $f$, we know that every subgroup of $G$ is of the form $f(d)$ for some divisor $d$ of $n$.
  have h_all_subgroups : ∀ H : Subgroup G, ∃ d : ℕ, d ∣ Fintype.card G ∧ H = f d := by
    exact fun H => by obtain ⟨ d, hd₁, hd₂ ⟩ := h_subgroups H; exact ⟨ d, hd₁, hf₂ d hd₁ H hd₂ ⟩ ;
  -- Therefore, the sum of the orders of all subgroups of $G$ is equal to the sum of the divisors of $n$.
  have h_sum_eq : ∑ H : Subgroup G, Nat.card H = ∑ d ∈ Nat.divisors (Fintype.card G), Nat.card (f d) := by
    have h_sum_eq : Finset.image (fun d => f d) (Nat.divisors (Fintype.card G)) = Finset.univ := by
      ext H; specialize h_all_subgroups H; aesop;
    rw [ ← h_sum_eq, Finset.sum_image ];
    intro d hd d' hd' h; have := hf₁ d ( Nat.dvd_of_mem_divisors hd ) ; have := hf₁ d' ( Nat.dvd_of_mem_divisors hd' ) ; aesop;
  exact h_sum_eq.trans ( Finset.sum_congr rfl fun d hd => hf₁ d ( Nat.dvd_of_mem_divisors hd ) )

/-
If a finite abelian group is cyclic and its order is perfect, then it is a Leinster group.
-/
theorem cyclic_perfect_implies_leinster (G : Type*) [CommGroup G] [Fintype G]
    (h_cyclic : IsCyclic G) (h_perfect : Nat.Perfect (Fintype.card G)) :
    IsLeinster G := by
  -- By definition of cyclic groups, the sum of the orders of all subgroups of G is equal to the sum of the divisors of the order of G.
  have h_sum : ∑ H : Subgroup G, Nat.card H = ∑ d ∈ (Fintype.card G).divisors, d := by
    convert sum_subgroup_orders_cyclic G using 1;
  convert isLeinster_iff_sumSubgroupOrders_eq G |>.2 _;
  convert h_sum using 1;
  rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self, h_perfect.1, two_mul ]

/-
The sum of subgroup orders of a group is strictly greater than the contribution from subgroups containing a non-trivial normal subgroup.
-/
theorem sum_subgroup_orders_quotient_lt (G : Type*) [Group G] [Fintype G] (N : Subgroup G) [N.Normal] (hN : N ≠ ⊥) :
    Fintype.card N * sumSubgroupOrders (G ⧸ N) < sumSubgroupOrders G := by
  -- Let's express the sum of the orders of the subgroups of $G$ that contain $N$.
  have h_subgroups_with_N : ∑ H ∈ Finset.filter (fun H : Subgroup G => N ≤ H) (Finset.univ : Finset (Subgroup G)), Nat.card H = Fintype.card N * sumSubgroupOrders (G ⧸ N) := by
    -- By definition of quotient group, each subgroup $H$ of $G$ that contains $N$ corresponds to a subgroup of $G/N$.
    have h_subgroup_bijection : Finset.image (fun H : Subgroup (G ⧸ N) => Subgroup.comap (QuotientGroup.mk' N) H) (Finset.univ : Finset (Subgroup (G ⧸ N))) = Finset.filter (fun H : Subgroup G => N ≤ H) (Finset.univ : Finset (Subgroup G)) := by
      ext H
      simp [Finset.mem_image, Finset.mem_filter];
      constructor;
      · rintro ⟨ a, rfl ⟩;
        exact?;
      · intro hNH
        use Subgroup.map (QuotientGroup.mk' N) H;
        ext x; simp +decide [ QuotientGroup.eq ] ; aesop;
    -- By definition of quotient group, the order of each subgroup $H$ of $G$ that contains $N$ is equal to the order of the corresponding subgroup of $G/N$ multiplied by the order of $N$.
    have h_order_bijection : ∀ H : Subgroup (G ⧸ N), Nat.card (Subgroup.comap (QuotientGroup.mk' N) H) = Nat.card N * Nat.card H := by
      intro H;
      have := Subgroup.card_mul_index H; simp_all +decide [ Subgroup.index_comap ] ;
      have := Subgroup.card_eq_card_quotient_mul_card_subgroup N; simp_all +decide [ mul_comm ] ;
      have := Subgroup.index_mul_card ( Subgroup.comap ( QuotientGroup.mk' N ) H ) ; simp_all +decide [ mul_comm, mul_assoc, mul_left_comm ] ;
      rw [ show ( Subgroup.comap ( QuotientGroup.mk' N ) H ).index = H.index from ?_ ] at this;
      · nlinarith [ show 0 < Fintype.card ( G ⧸ N ) from Fintype.card_pos ];
      · rw [ Subgroup.index_comap ] ; aesop;
    rw [ ← h_subgroup_bijection, Finset.sum_image ];
    · simp +decide only [h_order_bijection, sumSubgroupOrders, Finset.mul_sum _ _ _];
      simp +decide only [Nat.card_eq_fintype_card];
    · intro H₁ _ H₂ _ h; simp_all +decide [ SetLike.ext_iff ] ;
      intro x; obtain ⟨ y, rfl ⟩ := QuotientGroup.mk_surjective x; exact h y;
  rw [ ← h_subgroups_with_N, sumSubgroupOrders ];
  rw [ ← Finset.sum_sdiff ( Finset.subset_univ ( Finset.filter ( fun H => N ≤ H ) Finset.univ ) ) ];
  exact lt_add_of_pos_left _ ( Finset.sum_pos ( fun H hH => Nat.card_pos ) ⟨ ⊥, by aesop ⟩ )

/-
The sum of subgroup orders of Z_p x Z_p is strictly greater than twice its order.
-/
theorem sum_subgroup_orders_Zp_times_Zp (p : ℕ) [Fact (Nat.Prime p)] :
    2 * Fintype.card (Multiplicative (ZMod p × ZMod p)) < sumSubgroupOrders (Multiplicative (ZMod p × ZMod p)) := by
  -- Let's count the number of subgroups of order p in G.
  have h_subgroups_p : Fintype.card {H : Subgroup (Multiplicative (ZMod p × ZMod p)) // Nat.card H = p} ≥ p + 1 := by
    -- Consider the subgroups generated by elements of the form $(a, b)$ where $a, b \in \mathbb{Z}/p\mathbb{Z}$ and $(a, b) \neq (0, 0)$.
    have h_subgroups : Finset.card (Finset.image (fun (ab : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) ≥ p + 1 := by
      -- Each non-zero element $(a, b)$ generates a subgroup of order $p$, and there are $p^2 - 1$ such elements.
      have h_subgroups_count : Finset.card (Finset.image (fun (ab : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) ≥ Finset.card (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p))) / (p - 1) := by
        have h_subgroups_count : ∀ ab ∈ Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)), Finset.card (Finset.filter (fun (cd : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd cd) = Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (cd : ZMod p × ZMod p) => cd ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) ≤ p - 1 := by
          intros ab hab
          have h_subgroup_eq : ∀ cd ∈ Finset.filter (fun (cd : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd cd) = Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (cd : ZMod p × ZMod p) => cd ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p))), ∃ k : ZMod p, k ≠ 0 ∧ cd = k • ab := by
            intros cd hcd
            have h_subgroup_eq : Multiplicative.ofAdd cd ∈ Subgroup.zpowers (Multiplicative.ofAdd ab) := by
              exact hcd |> Finset.mem_filter.mp |>.2 ▸ Subgroup.mem_zpowers _;
            obtain ⟨ k, hk ⟩ := h_subgroup_eq;
            refine' ⟨ k, _, _ ⟩ <;> simp_all +decide [ Prod.ext_iff, zpow_eq_pow ];
            · intro hk'; replace hk := congr_arg Multiplicative.toAdd hk; simp_all +decide [ zpow_eq_pow ] ;
              simp_all +decide [ Prod.ext_iff ];
              grind +ring;
            · replace hk := congr_arg Multiplicative.toAdd hk ; aesop;
          have h_subgroup_eq : Finset.card (Finset.filter (fun (cd : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd cd) = Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (cd : ZMod p × ZMod p) => cd ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) ≤ Finset.card (Finset.image (fun (k : ZMod p) => k • ab) (Finset.filter (fun (k : ZMod p) => k ≠ 0) (Finset.univ : Finset (ZMod p)))) := by
            exact Finset.card_le_card fun x hx => by obtain ⟨ k, hk, rfl ⟩ := h_subgroup_eq x hx; exact Finset.mem_image.mpr ⟨ k, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hk ⟩, rfl ⟩ ;
          exact h_subgroup_eq.trans ( Finset.card_image_le.trans ( by simp +decide [ Finset.filter_ne' ] ) );
        have h_subgroups_count : Finset.card (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p))) ≤ Finset.card (Finset.image (fun (ab : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) * (p - 1) := by
          have h_subgroups_count : Finset.card (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p))) ≤ Finset.sum (Finset.image (fun (ab : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd ab)) (Finset.filter (fun (ab : ZMod p × ZMod p) => ab ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p)))) (fun H => Finset.card (Finset.filter (fun (cd : ZMod p × ZMod p) => Subgroup.zpowers (Multiplicative.ofAdd cd) = H) (Finset.filter (fun (cd : ZMod p × ZMod p) => cd ≠ (0, 0)) (Finset.univ : Finset (ZMod p × ZMod p))))) := by
            rw [ ← Finset.card_biUnion ];
            · exact Finset.card_le_card fun x hx => by aesop;
            · exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz₁ hz₂ => hxy <| by aesop;
          refine le_trans h_subgroups_count ?_;
          exact Finset.sum_le_card_nsmul _ _ _ fun x hx => by rcases Finset.mem_image.mp hx with ⟨ y, hy, rfl ⟩ ; aesop;
        exact Nat.div_le_of_le_mul <| by linarith;
      simp_all +decide [ Finset.filter_ne' ];
      exact le_trans ( by rw [ show p * p - 1 = ( p - 1 ) * ( p + 1 ) by zify; cases p <;> norm_num ; linarith ] ; rw [ Nat.mul_div_cancel_left _ ( Nat.sub_pos_of_lt ( Nat.Prime.one_lt Fact.out ) ) ] ) h_subgroups_count;
    -- Each subgroup generated by an element of the form $(a, b)$ where $a, b \in \mathbb{Z}/p\mathbb{Z}$ and $(a, b) \neq (0, 0)$ has order $p$.
    have h_subgroups_order : ∀ ab : ZMod p × ZMod p, ab ≠ (0, 0) → Nat.card (Subgroup.zpowers (Multiplicative.ofAdd ab)) = p := by
      intro ab hab; rw [ Nat.card_eq_fintype_card ] ; simp_all +decide [ Fintype.card_zpowers ] ;
      have h_order : addOrderOf ab ∣ p := by
        rw [ addOrderOf_dvd_iff_nsmul_eq_zero ];
        simp +decide [ Prod.ext_iff ];
      rw [ Nat.dvd_prime Fact.out ] at h_order ; aesop;
    refine' le_trans h_subgroups _;
    rw [ Fintype.card_subtype ];
    exact Finset.card_le_card fun x hx => by aesop;
  -- Each subgroup of order $p$ contributes $p$ to the sum of subgroup orders.
  have h_contribution_p : ∑ H : Subgroup (Multiplicative (ZMod p × ZMod p)), Nat.card H ≥ ∑ H ∈ Finset.univ.filter (fun H : Subgroup (Multiplicative (ZMod p × ZMod p)) => Nat.card H = p), Nat.card H + Nat.card (⊥ : Subgroup (Multiplicative (ZMod p × ZMod p))) + Nat.card (⊤ : Subgroup (Multiplicative (ZMod p × ZMod p))) := by
    have h_contribution_p : ∑ H : Subgroup (Multiplicative (ZMod p × ZMod p)), Nat.card H ≥ ∑ H ∈ Finset.univ.filter (fun H : Subgroup (Multiplicative (ZMod p × ZMod p)) => Nat.card H = p) ∪ {⊥, ⊤}, Nat.card H := by
      exact Finset.sum_le_sum_of_subset ( Finset.subset_univ _ );
    convert h_contribution_p using 1 ; rw [ Finset.sum_union ] <;> norm_num ; ring;
    exact ⟨ Ne.symm <| Nat.Prime.ne_one Fact.out, Nat.ne_of_gt <| lt_mul_of_one_lt_right ( Nat.Prime.pos Fact.out ) <| Nat.Prime.one_lt Fact.out ⟩;
  -- Each subgroup of order $p$ contributes $p$ to the sum of subgroup orders, and there are at least $p + 1$ such subgroups.
  have h_contribution_p_count : ∑ H ∈ Finset.univ.filter (fun H : Subgroup (Multiplicative (ZMod p × ZMod p)) => Nat.card H = p), Nat.card H ≥ (p + 1) * p := by
    have h_final : ∑ H ∈ Finset.univ.filter (fun H : Subgroup (Multiplicative (ZMod p × ZMod p)) => Nat.card H = p), Nat.card H ≥ (Finset.card (Finset.univ.filter (fun H : Subgroup (Multiplicative (ZMod p × ZMod p)) => Nat.card H = p))) * p := by
      exact le_trans ( by norm_num ) ( Finset.sum_le_sum fun x hx => show Nat.card x ≥ p from by aesop );
    exact le_trans ( Nat.mul_le_mul_right _ h_subgroups_p ) ( by simpa [ Fintype.card_subtype ] using h_final );
  simp_all +decide [ sumSubgroupOrders ];
  nlinarith [ show p > 1 from Fact.out ]

/-
If gcd(n, m) > 1, then Z_n x Z_m has a quotient isomorphic to Z_p x Z_p.
-/
theorem exists_quotient_Zp_times_Zp_of_gcd_gt_one {n m : ℕ} (h : 1 < n.gcd m) :
    ∃ (p : ℕ) (hp : Fact (Nat.Prime p)) (N : Subgroup (Multiplicative (ZMod n) × Multiplicative (ZMod m))),
      N.Normal ∧ Nonempty ((Multiplicative (ZMod n) × Multiplicative (ZMod m)) ⧸ N ≃* Multiplicative (ZMod p × ZMod p)) := by
  -- Let $d = \gcd(n, m)$. Since $d > 1$, there exists a prime $p$ dividing $d$.
  obtain ⟨p, hp_prime, hp_div⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ Nat.gcd n m := by
    exact Nat.exists_prime_and_dvd h.ne';
  have h_surjective : ∃ f : (Multiplicative (ZMod n) × Multiplicative (ZMod m)) →* Multiplicative (ZMod p × ZMod p), Function.Surjective f := by
    -- Since $p$ divides both $n$ and $m$, there exist surjective homomorphisms from $ZMod n$ to $ZMod p$ and from $ZMod m$ to $ZMod p$.
    obtain ⟨f1, hf1⟩ : ∃ f1 : ZMod n →+* ZMod p, Function.Surjective f1 := by
      have h_surjective : ∃ f : ZMod n →+* ZMod p, Function.Surjective f := by
        have h_div : p ∣ n := by
          exact Nat.dvd_trans hp_div <| Nat.gcd_dvd_left _ _
        exact ⟨ ZMod.castHom ( by simpa using h_div ) _, by exact? ⟩;
      exact h_surjective
    obtain ⟨f2, hf2⟩ : ∃ f2 : ZMod m →+* ZMod p, Function.Surjective f2 := by
      have h_surjective : p ∣ m := by
        exact Nat.dvd_trans hp_div ( Nat.gcd_dvd_right _ _ );
      obtain ⟨ k, rfl ⟩ := h_surjective;
      refine' ⟨ _, _ ⟩;
      exact ZMod.castHom ( dvd_mul_right p k ) ( ZMod p );
      exact?;
    refine' ⟨ _, _ ⟩;
    refine' { .. };
    use fun x => Multiplicative.ofAdd ( f1 ( Multiplicative.toAdd x.1 ), f2 ( Multiplicative.toAdd x.2 ) );
    all_goals simp_all +decide [ Function.Surjective ];
    · exact?;
    · exact fun a b => ⟨ hf1 a, hf2 b ⟩;
  cases' h_surjective with f hf_surjectivejective;
  refine' ⟨ p, ⟨ hp_prime ⟩, f.ker, _, _ ⟩;
  · infer_instance;
  · refine' ⟨ _ ⟩;
    exact?

/-
If a product of cyclic groups is not cyclic, then there is a pair of factors with non-coprime orders.
-/
theorem exists_gcd_gt_one_of_prod_not_cyclic {ι : Type*} [Fintype ι] {n : ι → ℕ}
    (h_gt_one : ∀ i, 1 < n i)
    (h_not_cyclic : ¬ IsCyclic ((i : ι) → Multiplicative (ZMod (n i)))) :
    ∃ i j, i ≠ j ∧ 1 < (n i).gcd (n j) := by
  -- If all pairs were coprime, then by the Chinese Remainder Theorem, the product would be isomorphic to $Z_{\prod n_i}$, which is cyclic.
  by_contra h_coprime
  have h_iso : Nonempty ((Π i, Multiplicative (ZMod (n i))) ≃* Multiplicative (ZMod (∏ i, n i))) := by
    have h_iso : Nonempty ((Π i, ZMod (n i)) ≃+* ZMod (∏ i, n i)) := by
      refine' ⟨ _ ⟩;
      have h_crt : ∀ i j : ι, i ≠ j → Nat.gcd (n i) (n j) = 1 := by
        exact fun i j hij => le_antisymm ( le_of_not_gt fun h => h_coprime ⟨ i, j, hij, h ⟩ ) ( Nat.gcd_pos_of_pos_left _ ( pos_of_gt ( h_gt_one i ) ) );
      exact?;
    exact ⟨ h_iso.some.toMultiplicative ⟩;
  obtain ⟨ f ⟩ := h_iso;
  refine' h_not_cyclic _;
  obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := Multiplicative ( ZMod ( ∏ i, n i ) ) );
  exact ⟨ f.symm g, fun x => by obtain ⟨ k, hk ⟩ := hg ( f x ) ; exact ⟨ k, by simpa [ ← f.injective.eq_iff ] using hk ⟩ ⟩

/-
Any non-cyclic finite abelian group has a quotient isomorphic to Z_p x Z_p for some prime p.
-/
theorem exists_quotient_Zp_times_Zp_of_not_cyclic (G : Type*) [CommGroup G] [Fintype G] (h_not_cyclic : ¬ IsCyclic G) :
    ∃ (p : ℕ) (hp : Fact (Nat.Prime p)) (N : Subgroup G) (hN : N.Normal),
      Nonempty ((G ⧸ N) ≃* Multiplicative (ZMod p × ZMod p)) := by
  have := @exists_quotient_Zp_times_Zp_of_gcd_gt_one;
  -- Since $G$ is not cyclic, there exists a surjective homomorphism $\phi: G \to \mathbb{Z}_{p} \times \mathbb{Z}_{p}$ for some prime $p$.
  obtain ⟨p, hp, ϕ, hϕ⟩ : ∃ p : ℕ, ∃ hp : Fact (Nat.Prime p), ∃ ϕ : G →* Multiplicative (ZMod p × ZMod p), Function.Surjective ϕ := by
    have h_decomp : ∃ (ι : Type) (x : Fintype ι) (n : ι → ℕ), (∀ i, 1 < n i) ∧ Nonempty (G ≃* ((i : ι) → Multiplicative (ZMod (n i)))) := by
      convert CommGroup.equiv_prod_multiplicative_zmod_of_finite G using 1;
    obtain ⟨ ι, x, n, hn, ⟨ e ⟩ ⟩ := h_decomp;
    -- Since $G$ is not cyclic, there exist $i \neq j$ such that $\gcd(n_i, n_j) > 1$.
    obtain ⟨i, j, hij, h_gcd⟩ : ∃ i j : ι, i ≠ j ∧ 1 < Nat.gcd (n i) (n j) := by
      apply exists_gcd_gt_one_of_prod_not_cyclic;
      · exact hn;
      · contrapose! h_not_cyclic;
        exact?;
    obtain ⟨ p, hp, N, hN₁, ⟨ f ⟩ ⟩ := this h_gcd;
    refine' ⟨ p, hp, _, _ ⟩;
    refine' MonoidHom.comp ( f.toMonoidHom.comp ( QuotientGroup.mk' N ) ) ( MonoidHom.comp ( MonoidHom.mk' ( fun x => ( x i, x j ) ) ( by
      simp +decide [ Prod.ext_iff ] ) ) ( e.toMonoidHom ) )
    generalize_proofs at *;
    intro x;
    obtain ⟨ y, hy ⟩ := f.surjective x;
    obtain ⟨ z, rfl ⟩ := QuotientGroup.mk_surjective y;
    use e.symm ( Function.update ( Function.update ( fun _ => 1 ) i z.1 ) j z.2 );
    simp +decide [ ← hy ];
    simp +decide [ Function.update_apply, hij ];
  -- The kernel of $\phi$ is a normal subgroup $N$ of $G$.
  use p, hp, ϕ.ker, by
    infer_instance
  generalize_proofs at *;
  exact ⟨ ( QuotientGroup.quotientKerEquivOfSurjective ϕ hϕ ) ⟩

/-
If a finite abelian group is not cyclic, then the sum of its subgroup orders is strictly greater than twice its order.
-/
theorem sum_subgroup_orders_gt_two_mul_card_of_not_cyclic (G : Type*) [CommGroup G] [Fintype G] (h_not_cyclic : ¬ IsCyclic G) :
    2 * Fintype.card G < sumSubgroupOrders G := by
  -- By `exists_quotient_Zp_times_Zp_of_not_cyclic`, there exists a prime $p$ and a normal subgroup $N$ such that $G/N \cong Z_p \times Z_p$.
  obtain ⟨p, hp, N, hN_normal, h_quotient⟩ : ∃ (p : ℕ) (hp : Fact (Nat.Prime p)) (N : Subgroup G) (hN : N.Normal),
    Nonempty ((G ⧸ N) ≃* Multiplicative (ZMod p × ZMod p)) := by
      exact?;
  by_cases hN : N = ⊥;
  · have h_iso : Nonempty (G ≃* Multiplicative (ZMod p × ZMod p)) := by
      refine' ⟨ _ ⟩;
      have h_iso : G ⧸ N ≃* G := by
        subst hN;
        exact?;
      exact h_iso.symm.trans h_quotient.some;
    have h_iso_card : Fintype.card G = Fintype.card (Multiplicative (ZMod p × ZMod p)) := by
      exact Fintype.card_congr h_iso.some.toEquiv;
    have h_iso_sum : sumSubgroupOrders G = sumSubgroupOrders (Multiplicative (ZMod p × ZMod p)) := by
      obtain ⟨ f ⟩ := h_iso;
      refine' Finset.sum_bij ( fun H _ => Subgroup.map f.toMonoidHom H ) _ _ _ _ <;> simp +decide [ Subgroup.map_comap_eq, Subgroup.comap_map_eq ];
      · intro a₁ a₂ h; ext x; replace h := SetLike.ext_iff.mp h ( f x ) ; aesop;
      · intro b; use Subgroup.comap f.toMonoidHom b; ext; simp +decide [ Subgroup.mem_map, Subgroup.mem_comap ] ;
        exact ⟨ fun ⟨ x, hx₁, hx₂ ⟩ => hx₂ ▸ hx₁, fun hx => ⟨ f.symm ‹_›, by simpa using hx, by simp +decide ⟩ ⟩;
      · intro a; exact Fintype.card_congr ( Equiv.ofBijective ( fun x => ⟨ f x, x, x.2, rfl ⟩ ) ⟨ fun x y hxy => by aesop, fun x => by aesop ⟩ ) ;
    exact h_iso_sum.symm ▸ h_iso_card.symm ▸ sum_subgroup_orders_Zp_times_Zp p;
  · -- Since $N$ is non-trivial, we can apply the quotient lemma to get $|N| * sumSubgroupOrders (G/N) < sumSubgroupOrders G$.
    have h_quotient_lemma : Fintype.card N * sumSubgroupOrders (G ⧸ N) < sumSubgroupOrders G := by
      convert sum_subgroup_orders_quotient_lt G N _;
      exact hN;
    -- Since $G/N \cong Z_p \times Z_p$, we have `sumSubgroupOrders (G/N) > 2 * |G/N|`.
    have h_sum_quotient : sumSubgroupOrders (G ⧸ N) > 2 * Fintype.card (G ⧸ N) := by
      have h_sum_quotient : sumSubgroupOrders (Multiplicative (ZMod p × ZMod p)) > 2 * Fintype.card (Multiplicative (ZMod p × ZMod p)) := by
        exact?;
      obtain ⟨ f ⟩ := h_quotient;
      convert h_sum_quotient using 1;
      · refine' Finset.sum_bij ( fun H _ => Subgroup.map f.toMonoidHom H ) _ _ _ _ <;> simp +decide;
        · intro a₁ a₂ h; ext x; replace h := SetLike.ext_iff.mp h ( f x ) ; aesop;
        · intro b; use Subgroup.comap ( f : G ⧸ N →* Multiplicative ( ZMod p × ZMod p ) ) b; ext; simp +decide [ Subgroup.mem_map, Subgroup.mem_comap ] ;
          exact ⟨ fun ⟨ x, hx₁, hx₂ ⟩ => hx₂ ▸ hx₁, fun hx => ⟨ f.symm ‹_›, by simpa using hx, by simp +decide ⟩ ⟩;
        · intro a; rw [ Fintype.card_subtype, Fintype.card_subtype ] ;
          rw [ ← Finset.card_image_of_injective _ f.injective ] ; congr ; ext ; aesop;
      · rw [ Fintype.card_congr f.toEquiv ];
    have := Subgroup.card_eq_card_quotient_mul_card_subgroup N;
    simp_all +decide [ mul_comm ];
    nlinarith [ show 0 < Fintype.card N from Fintype.card_pos_iff.mpr ⟨ 1 ⟩ ]

/-
If a finite abelian group is a Leinster group, then it is cyclic and its order is perfect.
-/
theorem leinster_implies_cyclic_perfect (G : Type*) [CommGroup G] [Fintype G] (h : IsLeinster G) :
    IsCyclic G ∧ Nat.Perfect (Fintype.card G) := by
  have h_cyclic : IsCyclic G := by
    have h_sum : sumSubgroupOrders G = 2 * (Fintype.card G) := by
      exact?
    contrapose! h_sum;
    exact ne_of_gt ( sum_subgroup_orders_gt_two_mul_card_of_not_cyclic G h_sum );
  -- Since G is cyclic, we can apply the theorem about cyclic groups to get that the sum of the divisors of the order of G equals twice the order of G.
  have h_divisors : ∑ d ∈ (Fintype.card G).divisors, d = 2 * (Fintype.card G) := by
    rw [ ← sum_subgroup_orders_cyclic G, ← isLeinster_iff_sumSubgroupOrders_eq G |>.1 h ];
  simp_all +decide [ Nat.Perfect, Nat.sum_divisors_eq_sum_properDivisors_add_self ];
  exact ⟨ by linarith, Fintype.card_pos ⟩

/-
A finite abelian group is a Leinster group if and only if it is cyclic and its order is a perfect number.
-/
theorem abelian_is_leinster_iff_cyclic_perfect (G : Type*) [CommGroup G] [Fintype G] :
    IsLeinster G ↔ IsCyclic G ∧ Nat.Perfect (Fintype.card G) := by
  exact ⟨ fun h => leinster_implies_cyclic_perfect G h, fun h => cyclic_perfect_implies_leinster G h.1 h.2 ⟩