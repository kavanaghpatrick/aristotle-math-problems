/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 97ceb2a5-4014-499f-94a5-5ced720ff5dd

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes a counterexample to the Casas-Alvero conjecture in positive characteristic p.
The conjecture states that if a polynomial P shares a common factor with each of its Hasse derivatives P^(i) for i < deg(P), then P is a power of a linear factor (X - a)^d.
This is false in characteristic p. We prove that P = X^(p+1) - X^p over ZMod p is a counterexample.

Main results:
- `HasCasasAlveroProp`: Definition of the property.
- `counterexample_poly`: Definition of P = X^(p+1) - X^p.
- `counterexample_poly_monic`: P is monic.
- `counterexample_poly_natDegree`: deg(P) = p+1.
- `counterexample_poly_hasCasasAlveroProp`: P satisfies the Casas-Alvero property.
- `counterexample_poly_not_power_linear`: P is not of the form (X - a)^d.
- `casas_alvero.positive_char_counterexample`: The main theorem stating the existence of such a counterexample.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Casas-Alvero property for a polynomial P: P shares a common factor with each of its Hasse derivatives of order i < deg(P).
-/
def HasCasasAlveroProp {R : Type*} [CommSemiring R] (P : Polynomial R) : Prop :=
  ∀ i ∈ Finset.range P.natDegree, ¬ IsCoprime P (P.hasseDeriv i)

/-
The counterexample polynomial P = X^(p+1) - X^p over ZMod p.
-/
def counterexample_poly (p : ℕ) : Polynomial (ZMod p) := Polynomial.X ^ (p + 1) - Polynomial.X ^ p

/-
The counterexample polynomial is monic.
-/
open Polynomial

lemma counterexample_poly_monic {p : ℕ} (hp : p.Prime) : Monic (counterexample_poly p) := by
  unfold counterexample_poly; erw [ Polynomial.Monic, Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num [ hp.pos ] ;
  haveI := Fact.mk hp; norm_num;
  exact WithBot.coe_lt_coe.mpr ( Nat.lt_succ_self p )

/-
The degree of the counterexample polynomial is p+1.
-/
open Polynomial

lemma counterexample_poly_natDegree {p : ℕ} (hp : p.Prime) : (counterexample_poly p).natDegree = p + 1 := by
  erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ];
  · haveI := Fact.mk hp; simp +decide [ Polynomial.natDegree_X_pow ] ;
  · norm_num [ Polynomial.X_pow_eq_monomial, hp.ne_zero ];
    rcases p with ( _ | _ | p ) <;> tauto;

/-
Binomial coefficient C(p, i) is 0 mod p for 0 < i < p.
-/
lemma choose_p_eq_zero {p : ℕ} (hp : p.Prime) (i : ℕ) (hi : 0 < i) (hip : i < p) : (Nat.choose p i : ZMod p) = 0 := by
  exact by rw [ ZMod.natCast_eq_zero_iff ] ; exact hp.dvd_choose_self ( by linarith ) ( by linarith ) ; ;

/-
Binomial coefficient C(p+1, i) is 0 mod p for 1 < i < p.
-/
lemma choose_succ_p_eq_zero {p : ℕ} (hp : p.Prime) (i : ℕ) (hi : 1 < i) (hip : i < p) : (Nat.choose (p+1) i : ZMod p) = 0 := by
  rcases i <;> simp_all +decide [ Nat.choose_eq_zero_of_lt ];
  exact_mod_cast by haveI := Fact.mk hp; rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.dvd_add ( hp.dvd_choose_self ( by linarith ) ( by linarith ) ) ( hp.dvd_choose_self ( by linarith ) ( by linarith ) ) ;

/-
The first Hasse derivative of the counterexample polynomial is X^p.
-/
open Polynomial

lemma hasseDeriv_counterexample_one {p : ℕ} (hp : p.Prime) :
    hasseDeriv 1 (counterexample_poly p) = X ^ p := by
      unfold counterexample_poly; simp +decide [ Polynomial.derivative_pow ] ;

/-
The i-th Hasse derivative of the counterexample polynomial is 0 for 1 < i < p.
-/
open Polynomial

lemma hasseDeriv_counterexample_mid {p : ℕ} (hp : p.Prime) (i : ℕ) (hi : 1 < i) (hip : i < p) :
    hasseDeriv i (counterexample_poly p) = 0 := by
      -- By definition of hasse derivative, we have:
      have h_def : hasseDeriv i (counterexample_poly p) = (Nat.choose (p + 1) i : ZMod p) • Polynomial.X ^ (p + 1 - i) - (Nat.choose p i : ZMod p) • Polynomial.X ^ (p - i) := by
        unfold counterexample_poly;
        rcases le_or_gt i ( p + 1 ) with h2|h2 <;> simp_all +decide [ Polynomial.hasseDeriv_monomial ];
        · simp +decide [ Polynomial.hasseDeriv ];
          simp +decide [ Polynomial.sum_over_range, Polynomial.smul_eq_C_mul ];
          simp +decide [ Finset.sum_range_succ, Polynomial.natDegree_X_pow, Polynomial.X_pow_eq_monomial ];
          simp +decide [ Finset.sum_range_succ, Polynomial.ext_iff ];
          intro n; split_ifs <;> simp_all +decide [ Polynomial.coeff_monomial ] ;
          · linarith [ hp.two_le ];
          · rw [ Finset.sum_eq_zero, Finset.sum_eq_zero ] <;> aesop;
        · linarith;
      -- By choose_succ_p_eq_zero and choose_p_eq_zero, we have C(p+1, i) = 0 mod p and C(p, i) = 0 mod p.
      have h_choose_zero : (Nat.choose (p + 1) i : ZMod p) = 0 ∧ (Nat.choose p i : ZMod p) = 0 := by
        exact ⟨ by simpa using choose_succ_p_eq_zero hp i hi hip, by simpa using choose_p_eq_zero hp i ( by linarith ) ( by linarith ) ⟩;
      aesop

/-
The p-th Hasse derivative of the counterexample polynomial is X - 1.
-/
open Polynomial

lemma hasseDeriv_counterexample_p {p : ℕ} (hp : p.Prime) :
    hasseDeriv p (counterexample_poly p) = X - 1 := by
      unfold counterexample_poly; norm_num [ Nat.choose, Polynomial.hasseDeriv ] ;
      norm_num [ Polynomial.sum_over_range ];
      rw [ show ( Polynomial.X ^ ( p + 1 ) - Polynomial.X ^ p : Polynomial ( ZMod p ) ).natDegree = p + 1 from ?_ ];
      · rw [ Finset.sum_eq_add ( p ) ( p + 1 ) ] <;> norm_num [ Polynomial.X, Polynomial.monomial_eq_zero_iff ];
        · ring;
        · aesop;
        · grind;
      · rw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ];
        · haveI := Fact.mk hp; norm_num;
        · haveI := Fact.mk hp; simp +decide ;

/-
The counterexample polynomial satisfies the Casas-Alvero property.
-/
open Polynomial

lemma counterexample_poly_hasCasasAlveroProp {p : ℕ} (hp : p.Prime) :
    HasCasasAlveroProp (counterexample_poly p) := by
      intro i hiAlveroProp;
      -- We consider different cases for i: i=0, i=1, 1 < i < p, and i=p.
      by_cases h_cases : i = 0 ∨ i = 1 ∨ i = p;
      · rcases h_cases with ( rfl | rfl | rfl ) <;> simp_all +decide [ isCoprime_zero_right ];
        · rintro ⟨ a, b, h ⟩;
          replace h := congr_arg ( Polynomial.eval 0 ) h ; simp_all +decide [ counterexample_poly ];
          rcases p with ( _ | _ | p ) <;> cases h ; contradiction;
        · intro h; obtain ⟨ a, b, h ⟩ := h; replace h := congr_arg ( Polynomial.eval 0 ) h; rcases p with ( _ | _ | p ) <;> simp_all +decide ;
          unfold counterexample_poly at h; norm_num at h;
          cases h;
        · -- By definition of $counterexample_poly$, we know that its $i$-th Hasse derivative is $X - 1$.
          have h_has_deriv : (Polynomial.hasseDeriv i (counterexample_poly i)) = Polynomial.X - 1 := by
            exact?;
          rw [ h_has_deriv ];
          rintro ⟨ a, b, h ⟩;
          replace h := congr_arg ( Polynomial.eval 1 ) h ; norm_num [ counterexample_poly ] at h;
          rcases i with ( _ | _ | i ) <;> cases h ; contradiction;
      · -- For $1 < i < p$, we know that $P^{(i)} = 0$.
        have h_hasDeriv_zero : hasseDeriv i (counterexample_poly p) = 0 := by
          convert hasseDeriv_counterexample_mid hp i ( lt_of_le_of_ne ( Nat.succ_le_of_lt ( Nat.pos_of_ne_zero fun hi => h_cases <| Or.inl hi ) ) ( Ne.symm <| by tauto ) ) ( by { rw [ counterexample_poly_natDegree hp ] at hiAlveroProp; exact lt_of_le_of_ne ( by linarith [ Finset.mem_range.mp hiAlveroProp ] ) ( by tauto ) } ) using 1;
        haveI := Fact.mk hp; simp_all +decide [ isCoprime_zero_right ] ;
        haveI := Fact.mk hp; exact fun h => absurd ( Polynomial.natDegree_eq_zero_of_isUnit h ) ( by erw [ counterexample_poly_natDegree hp ] ; linarith [ hp.two_le ] ) ;

/-
The counterexample polynomial is not a power of a linear factor (X - α).
-/
open Polynomial

lemma counterexample_poly_not_power_linear {p : ℕ} (hp : p.Prime) :
    ¬∃ α : ZMod p, counterexample_poly p = (X - C α) ^ (counterexample_poly p).natDegree := by
      norm_num +zetaDelta at *;
      -- Let's consider the polynomial $P(X) = X^{p+1} - X^p$ and show it cannot be written as $(X - \alpha)^{p+1}$ for any $\alpha \in \mathbb{F}_p$.
      intro α hα
      have h_eval_zero : (α : ZMod p) = 0 := by
        haveI := Fact.mk hp; replace hα := congr_arg ( Polynomial.eval 0 ) hα; simp_all +decide [ Polynomial.eval_pow, Polynomial.eval_X, Polynomial.eval_C ] ;
        unfold counterexample_poly at hα; norm_num at hα; ring_nf at hα; aesop;
      have h_eval_one : (1 - α : ZMod p) = 0 := by
        replace hα := congr_arg ( Polynomial.eval 1 ) hα ; simp_all +decide [ counterexample_poly ]
      have h_contra : (0 : ZMod p) = 1 := by
        grind
      exact absurd h_contra (by
      haveI := Fact.mk hp; norm_num;)

/-
There exists a field K of characteristic p and a polynomial P over K that is a counterexample to the Casas-Alvero conjecture.
-/
open Polynomial

theorem casas_alvero.positive_char_counterexample {p : ℕ} (hp : p.Prime) :
    ∃ (K : Type*) (_ : Field K) (_ : CharP K p),
      let P : Polynomial K := X ^ (p + 1) - X ^ p
      Monic P ∧ HasCasasAlveroProp P ∧
      ¬∃ α : K, P = (X - C α) ^ P.natDegree := by
        refine' ⟨ _, _, _, _, _, _ ⟩;
        exact ULift ( ZMod p );
        all_goals haveI := Fact.mk hp; try infer_instance;
        · rw [ Polynomial.Monic, Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num [ hp.one_lt ];
          exact WithBot.coe_lt_coe.mpr ( Nat.lt_succ_self p );
        · have h_casas_alvero : HasCasasAlveroProp (counterexample_poly p) := by
            have := counterexample_poly_hasCasasAlveroProp hp
            convert this using 1;
          convert h_casas_alvero;
          unfold HasCasasAlveroProp;
          constructor <;> intro h i hi;
          · exact h_casas_alvero i hi;
          · convert h i _;
            · constructor <;> rintro ⟨ a, b, h ⟩;
              · refine' ⟨ a.map ( ULift.ringEquiv.toRingHom ), b.map ( ULift.ringEquiv.toRingHom ), _ ⟩;
                convert congr_arg ( Polynomial.map ULift.ringEquiv.toRingHom ) h using 1;
                · simp +decide [ Polynomial.map_mul, Polynomial.map_add, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_X ];
                  unfold counterexample_poly; simp +decide [ Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_X ] ;
                  simp +decide [ Polynomial.hasseDeriv ];
                  simp +decide [ Polynomial.sum_over_range ];
                  simp +decide [ Polynomial.map_sum, Polynomial.map_monomial ];
                  exact Or.inl ( by congr <;> ext <;> aesop );
                · norm_num;
              · refine' ⟨ Polynomial.map ( algebraMap ( ZMod p ) ( ULift ( ZMod p ) ) ) a, Polynomial.map ( algebraMap ( ZMod p ) ( ULift ( ZMod p ) ) ) b, _ ⟩;
                convert congr_arg ( Polynomial.map ( algebraMap ( ZMod p ) ( ULift ( ZMod p ) ) ) ) h using 1;
                · simp +decide [ Polynomial.map_mul, Polynomial.map_add, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_X, Polynomial.hasseDeriv ];
                  simp +decide [ Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_X, counterexample_poly ];
                  field_simp;
                  simp +decide [ Polynomial.sum_def, Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_pow, Polynomial.map_X ];
                  convert Or.inl rfl;
                  convert rfl;
                  convert rfl;
                  ext; simp [Polynomial.coeff_X_pow, Polynomial.coeff_sub];
                  split_ifs <;> simp +decide [ * ];
                · norm_num;
            · convert hi using 1;
              unfold counterexample_poly; norm_num [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] ;
        · convert counterexample_poly_not_power_linear hp using 1;
          constructor <;> rintro ⟨ α, hα ⟩;
          · convert hα using 1;
            constructor <;> intro h;
            · convert hα using 1;
            · convert h using 1;
              constructor <;> intro h;
              · convert hα using 1;
              · use α.down;
                convert congr_arg ( Polynomial.map ( ULift.ringEquiv.toRingHom ) ) h using 1;
                · unfold counterexample_poly; norm_num;
                · simp +decide [ Polynomial.map_pow, Polynomial.map_sub, Polynomial.map_X, Polynomial.map_C ];
                  congr!;
                  convert counterexample_poly_natDegree hp using 1;
                  rw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ hp.one_lt ];
          · refine' ⟨ ⟨ α ⟩, _ ⟩;
            convert congr_arg ( Polynomial.map ( algebraMap ( ZMod p ) ( ULift ( ZMod p ) ) ) ) hα using 1;
            · unfold counterexample_poly; norm_num;
            · unfold counterexample_poly; norm_num [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] ;
              rfl