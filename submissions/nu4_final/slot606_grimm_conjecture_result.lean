/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 14a3a1f2-0f65-4bf9-8b28-e5532770d9f9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized Grimm's Conjecture and proved several structural lemmas and bounded cases.
Key results include:
1.  `grimm_k_eq_1`, `grimm_k_eq_2`, `grimm_k_eq_3`: Proofs for small cases k=1, 2, 3.
2.  `grimm_coprime_lemma`: A structural lemma stating that gcd(n+i, n+j) divides |i-j|.
3.  `grimm_hall_reduction`: A reduction of Grimm's Conjecture to Hall's Marriage Theorem condition on prime factors.
4.  `checkGrimm` and `verifyGrimmUpTo`: Computable functions to verify the conjecture for bounded ranges.
5.  `grimm_bounded_500`: A computational verification that Grimm's Conjecture holds for all prime gaps up to 500.
6.  `grimm_implies_distinct_factors`: Proof that Grimm's Conjecture implies the number of distinct prime factors is at least k.

The formalization uses Mathlib's number theory and combinatorics libraries, specifically `Nat.Prime`, `Nat.gcd`, and `HallMarriageTheorem`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for Grimm's Conjecture.
-/
/-- A range of numbers n+1, ..., n+k is composite if all numbers in it are composite. -/
def IsCompositeRange (n k : ℕ) : Prop :=
  ∀ i < k, ¬ Nat.Prime (n + 1 + i) ∧ 1 < n + 1 + i

/-- Grimm's condition holds for n, k if there exist distinct primes dividing n+1, ..., n+k. -/
def GrimmHolds (n k : ℕ) : Prop :=
  ∃ p : Fin k → ℕ, Function.Injective p ∧ ∀ i, (p i).Prime ∧ (p i) ∣ (n + 1 + i)

/-- Grimm's Conjecture: For any range of composite numbers, Grimm's condition holds. -/
def GrimmConjecture : Prop :=
  ∀ n k, IsCompositeRange n k → GrimmHolds n k

/-
Grimm's Conjecture holds for k=1.
-/
theorem grimm_k_eq_1 : ∀ n, IsCompositeRange n 1 → GrimmHolds n 1 := by
  intros n h_composite
  obtain ⟨p, hp_prime, hp_div⟩ : ∃ p, Nat.Prime p ∧ p ∣ (n + 1) := by
    exact Nat.exists_prime_and_dvd ( by linarith [ h_composite 0 ( by decide ) ] );
  use fun _ => p;
  simp_all +decide [ Function.Injective, Fin.eq_zero ]

/-
Grimm's Conjecture holds for k=2.
-/
theorem grimm_k_eq_2 : ∀ n, IsCompositeRange n 2 → GrimmHolds n 2 := by
  intro n h
  obtain ⟨p1, hp1⟩ : ∃ p1, Nat.Prime p1 ∧ p1 ∣ (n + 1) := by
    exact Nat.exists_prime_and_dvd ( by specialize h 0; aesop )
  obtain ⟨p2, hp2⟩ : ∃ p2, Nat.Prime p2 ∧ p2 ∣ (n + 2) := by
    exact Nat.exists_prime_and_dvd ( by linarith )
  have h_distinct : p1 ≠ p2 := by
    rintro rfl; have := Nat.dvd_sub' hp2.2 hp1.2; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
  exact ⟨ fun i => if i = 0 then p1 else p2, by intros i j h; fin_cases i <;> fin_cases j <;> aesop, fun i => by fin_cases i <;> aesop ⟩

/-
If n+1 is composite, then n+1 and n+3 cannot both be powers of 2.
-/
lemma not_both_powers_of_two (n : ℕ) (h1 : ¬ Nat.Prime (n + 1)) (h2 : 1 < n + 1) :
  ¬ ((∃ a, n + 1 = 2 ^ a) ∧ (∃ b, n + 3 = 2 ^ b)) := by
    rintro ⟨ ⟨ a, ha ⟩, ⟨ b, hb ⟩ ⟩;
    rcases a with ( _ | _ | a ) <;> rcases b with ( _ | _ | b ) <;> simp_all +arith +decide [ Nat.pow_succ' ];
    omega

/-
Helper lemma for Grimm's Conjecture k=3: if gcd(n+1, n+3) = 2, distinct prime factors exist.
-/
lemma grimm_k_eq_3_helper (n : ℕ) (h_composite : IsCompositeRange n 3) (h_gcd : Nat.gcd (n + 1) (n + 3) = 2) :
  ∃ p1 p2 p3, Nat.Prime p1 ∧ Nat.Prime p2 ∧ Nat.Prime p3 ∧
    p1 ∣ (n + 1) ∧ p2 ∣ (n + 2) ∧ p3 ∣ (n + 3) ∧
    p1 ≠ p2 ∧ p1 ≠ p3 ∧ p2 ≠ p3 := by
      -- Since n+2 is composite and odd, � it� must have a prime factor p2 that is not  �2�. Let's choose such a prime p2.
      obtain ⟨p2, hp2⟩ : ∃ p2 : ℕ, Nat.Prime p2 ∧ p2 ∣ n + 2 ∧ p2 ≠ 2 := by
        -- Since n+2 is composite and odd, it must have a prime factor other than 2.
        have h_odd_composite : Odd (n + 2) ∧ ¬Nat.Prime (n + 2) := by
          have := h_composite 1 ( by decide ) ; simp_all +decide [ Nat.add_mod ] ;
          have := Nat.gcd_dvd_left ( n + 1 ) ( n + 3 ) ; ( have := Nat.gcd_dvd_right ( n + 1 ) ( n + 3 ) ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ; );
        exact ⟨ Nat.minFac ( n + 2 ), Nat.minFac_prime ( by aesop ), Nat.minFac_dvd _, fun h => by simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ⟩;
      -- Since n+1 and n+3 are even, their prime factors are 2. But we need distinct primes. So, for n+1, � we� can take 2 as p1. For n+3, we can take another prime factor, say p3. But how do we ensure that p3 is distinct from p2?
      by_cases h1 : ∃ a, n + 1 = 2 ^ a;
      · -- Since n+3 is � not� a power of 2, it must have an odd prime factor. Let's choose such a prime p3.
        obtain ⟨p3, hp3⟩ : ∃ p3 : ℕ, Nat.Prime p3 ∧ p3 ∣ n + 3 ∧ p3 ≠ 2 := by
          by_cases h3 : ∃ b, n + 3 = 2 ^ b;
          · exact False.elim <| not_both_powers_of_two n ( by have := h_composite 0; aesop ) ( by have := h_composite 0; aesop ) ⟨ h1, h3 ⟩;
          · contrapose! h3;
            rw [ ← Nat.prod_primeFactorsList ( by linarith : n + 3 ≠ 0 ) ] ; rw [ List.prod_eq_pow_single 2 ] ; aesop;
            exact fun x hx hx' => False.elim <| hx <| h3 x ( Nat.prime_of_mem_primeFactorsList hx' ) <| Nat.dvd_of_mem_primeFactorsList hx';
        use 2, p2, p3;
        simp_all +decide [ Nat.dvd_prime ];
        exact ⟨ h_gcd ▸ Nat.gcd_dvd_left _ _, Ne.symm hp2.2.2, Ne.symm hp3.2.2, fun h => by have := Nat.dvd_gcd hp2.2.1 ( h.symm ▸ hp3.2.1 ) ; simp_all +decide [ ( by ring : n + 3 = n + 2 + 1 ) ] ⟩;
      · -- Since n+1 is not a power of � �2, it must have an odd prime factor. Let �'s� choose such a prime p1.
        obtain ⟨p1, hp1⟩ : ∃ p1 : ℕ, Nat.Prime p1 ∧ p1 ∣ n + 1 ∧ p1 ≠ 2 := by
          contrapose! h1;
          rw [ ← Nat.prod_primeFactorsList ( by linarith : n + 1 ≠ 0 ) ] ; rw [ List.prod_eq_pow_single 2 ] ; aesop;
          exact fun x hx hx' => False.elim <| hx <| h1 x ( Nat.prime_of_mem_primeFactorsList hx' ) <| Nat.dvd_of_mem_primeFactorsList hx';
        use p1, p2, 2;
        have := Nat.gcd_dvd_left ( n + 1 ) ( n + 3 ) ; ( have := Nat.gcd_dvd_right ( n + 1 ) ( n + 3 ) ; simp_all +decide [ Nat.dvd_prime ] ; );
        rintro rfl; have := Nat.dvd_gcd hp1.2.1 hp2.2.1; simp_all +decide ;
        simp_all +decide [ ( by ring : n + 2 = n + 1 + 1 ) ]

/-
Grimm's Conjecture holds for k=3.
-/
theorem grimm_k_eq_3 : ∀ n, IsCompositeRange n 3 → GrimmHolds n 3 := by
  intro n;
  intro h_range
  by_cases h_gcd : Nat.gcd (n + 1) (n + 3) = 2;
  · -- Use the helper lemma to obtain distinct primes p1, p2, and p3.
    obtain ⟨p1, p2, p3, hp1, hp2, hp3, hp12, hp13, hp23⟩ := grimm_k_eq_3_helper n h_range h_gcd;
    use ![p1, p2, p3];
    simp_all +decide [ Fin.forall_fin_succ, Function.Injective ];
    tauto;
  · -- Since gcd(n+1, n+3) = 1, n+1, n+2, and n+3 are pairwise coprime.
    have h_coprime : Nat.gcd (n + 1) (n + 2) = 1 ∧ Nat.gcd (n + 2) (n + 3) = 1 ∧ Nat.gcd (n + 1) (n + 3) = 1 := by
      norm_num [ ( by ring : n + 3 = n + 1 + 2 ), ( by ring : n + 2 = n + 1 + 1 ) ] at *;
      simp_all +decide [ ( by ring : n + 1 + 2 = n + 1 + 1 + 1 ) ];
      cases Nat.even_or_odd' ( n + 1 ) ; aesop;
    use fun i => Nat.minFac ( n + 1 + i );
    simp_all +decide [ Fin.forall_fin_succ, Function.Injective ];
    have := Nat.minFac_dvd ( n + 1 ) ; have := Nat.minFac_dvd ( n + 2 ) ; have := Nat.minFac_dvd ( n + 3 ) ; simp_all +decide [ Nat.dvd_prime ] ;
    exact ⟨ ⟨ ⟨ fun h => by have := Nat.dvd_gcd ‹Nat.minFac ( n + 1 ) ∣ n + 1› ( h.symm ▸ ‹Nat.minFac ( n + 2 ) ∣ n + 2› ) ; aesop, fun h => by have := Nat.dvd_gcd ‹Nat.minFac ( n + 1 ) ∣ n + 1› ( h.symm ▸ ‹Nat.minFac ( n + 3 ) ∣ n + 3› ) ; aesop ⟩, ⟨ fun h => by have := Nat.dvd_gcd ( h.symm ▸ ‹Nat.minFac ( n + 1 ) ∣ n + 1› ) ‹Nat.minFac ( n + 2 ) ∣ n + 2› ; aesop, fun h => by have := Nat.dvd_gcd ‹Nat.minFac ( n + 2 ) ∣ n + 2› ( h.symm ▸ ‹Nat.minFac ( n + 3 ) ∣ n + 3› ) ; aesop ⟩, fun h => by have := Nat.dvd_gcd ( h.symm ▸ ‹Nat.minFac ( n + 1 ) ∣ n + 1› ) ‹Nat.minFac ( n + 3 ) ∣ n + 3› ; aesop, fun h => by have := Nat.dvd_gcd ‹Nat.minFac ( n + 2 ) ∣ n + 2› ( h.symm ▸ ‹Nat.minFac ( n + 3 ) ∣ n + 3› ) ; aesop ⟩, by rintro rfl; specialize h_range 0; simp_all +decide ⟩

/-
The GCD of two numbers in the range divides the difference of their indices.
-/
theorem grimm_coprime_lemma (n : ℕ) (i j : ℕ) (h_neq : i ≠ j) :
  Nat.gcd (n + 1 + i) (n + 1 + j) ∣ (if i < j then j - i else i - j) := by
    split_ifs <;> [ exact Nat.dvd_sub' ( Nat.gcd_dvd_right _ _ ) ( Nat.gcd_dvd_left _ _ ) |> fun x => by simpa [ * ] using x; ; exact Nat.dvd_sub' ( Nat.gcd_dvd_left _ _ ) ( Nat.gcd_dvd_right _ _ ) |> fun x => by simpa [ * ] using x ];
    · convert Nat.dvd_sub' ( Nat.gcd_dvd_right _ _ ) ( Nat.gcd_dvd_left _ _ ) using 1 ; omega;
    · convert Nat.dvd_sub' ( Nat.gcd_dvd_left _ _ ) ( Nat.gcd_dvd_right _ _ ) using 1 ; omega

/-
Grimm's Conjecture reduces to Hall's condition on the prime factors.
-/
/-- Hall's condition for the prime factors of the range n+1, ..., n+k. -/
def GrimmHallCondition (n k : ℕ) : Prop :=
  ∀ (s : Finset (Fin k)), s.card ≤ (s.biUnion (fun i => (n + 1 + i).primeFactors)).card

theorem grimm_hall_reduction (n k : ℕ) (h_composite : IsCompositeRange n k) :
  GrimmHallCondition n k → GrimmHolds n k := by
    have := @Finset.all_card_le_biUnion_card_iff_exists_injective;
    contrapose! this;
    refine' ⟨ Fin k, ℕ, _, fun i => Nat.primeFactors ( n + 1 + i ), Or.inl ⟨ _, _ ⟩ ⟩;
    exact?;
    · intro s; specialize this; have := this.1 s; aesop;
    · exact fun f hf => not_forall.mp fun h => this.2 ⟨ f, hf, fun i => by have := h i; aesop ⟩

/-
Correctness of the computable Grimm check.
-/
/-- A computable check for Grimm's condition using Hall's condition. -/
def checkGrimm (n k : ℕ) : Bool :=
  let s_pow := 2 ^ k
  List.range s_pow |>.all fun mask =>
    let s := (List.range k).filter (fun i => (mask >>> i) % 2 = 1)
    let neighbors : Finset ℕ := s.foldl (fun acc i => acc ∪ (n + 1 + i).primeFactors) ∅
    s.length ≤ neighbors.card

theorem checkGrimm_correct (n k : ℕ) (h_composite : IsCompositeRange n k) :
  checkGrimm n k = true → GrimmHolds n k := by
    intro h_checkGrimm_true
    apply grimm_hall_reduction n k h_composite;
    unfold checkGrimm at h_checkGrimm_true;
    intro s; specialize h_checkGrimm_true; simp_all +decide [ List.all_eq ] ;
    convert h_checkGrimm_true ( Nat.ofBits ( fun i => if i ∈ s then 1 else 0 ) ) _ using 1;
    · rw [ ← Multiset.coe_card ];
      rw [ ← Multiset.toFinset_card_of_nodup ] <;> norm_num [ List.nodup_range ];
      · refine' Finset.card_bij ( fun x hx => x ) _ _ _ <;> aesop;
      · exact List.Nodup.filter _ ( List.nodup_range );
    · congr! 1;
      have h_bitmask : ∀ i : Fin k, i ∈ s ↔ (Nat.ofBits (fun j => if j ∈ s then 1 else 0) : ℕ).testBit i := by
        intro i; rw [ Nat.testBit_ofBits ] ; aesop;
      have h_bitmask : Finset.image (fun i : Fin k => (i : ℕ)) s = List.toFinset (List.filter (fun i : ℕ => (Nat.ofBits (fun j => if j ∈ s then 1 else 0) : ℕ).testBit i) (List.range k)) := by
        ext; aesop;
      convert congr_arg ( fun x : Finset ℕ => Finset.biUnion x fun i => ( n + 1 + i ).primeFactors ) h_bitmask using 1;
      · ext; simp [Finset.mem_biUnion, Finset.mem_image];
      · induction' ( List.filter ( fun i => ( Nat.ofBits fun j => if j ∈ s then 1 else 0 ).testBit i ) ( List.range k ) ) using List.reverseRecOn with i hi <;> aesop;
    · exact Nat.ofBits_lt_two_pow _

/-
Correctness of the bounded verification function.
-/
/-- Verifies Grimm's conjecture for all prime gaps up to N. -/
def verifyGrimmUpTo (N : ℕ) : Bool :=
  let primes := (List.range (N + 1)).filter Nat.Prime
  primes.zip (primes.drop 1) |>.all fun ⟨p, q⟩ =>
    let k := q - p - 1
    if k = 0 then true else checkGrimm p k

theorem verifyGrimmUpTo_correct (N : ℕ) (h_verify : verifyGrimmUpTo N = true) :
  ∀ p q, p < q → q ≤ N → Nat.Prime p → Nat.Prime q → (∀ m, p < m → m < q → ¬ Nat.Prime m) →
  GrimmHolds p (q - p - 1) := by
    revert h_verify;
    intro h_verif;
    -- By definition of `verifyGrimmUpTo`, if `verifyGrimmUpTo N = Bool.true`, then `checkGrimm p (q - p - 1) = Bool.true` for all consecutive primes $p$ and $q$ with $q \leq N$.
    have h_check : ∀ p q, p < q → q ≤ N → Nat.Prime p → Nat.Prime q → (∀ m, p < m → m < q → ¬Nat.Prime m) → checkGrimm p (q - p - 1) = Bool.true := by
      unfold verifyGrimmUpTo at h_verif;
      -- We'll use that primes are generated in increasing order to show that the pairs are consecutive.
      have h_consecutive : ∀ {l : List ℕ}, List.Sorted (· < ·) l → ∀ p q, p ∈ l → q ∈ l → p < q → (∀ m, p < m → m < q → m ∉ l) → (p, q) ∈ List.zip l (List.tail l) := by
        intros l hl p q hp hq hpq h_no_primes
        induction' l with hd tl ih generalizing p q;
        · contradiction;
        · by_cases h_cases : p = hd;
          · rcases tl <;> simp_all +decide [ List.Sorted ];
            grind;
          · simp +zetaDelta at *;
            rcases tl <;> simp_all +decide [ List.zip ];
            grind;
      intro p q hpq hq hp hq' h; specialize @h_consecutive ( List.filter ( fun b => Nat.Prime b ) ( List.range ( N + 1 ) ) ) ?_ p q ?_ ?_ hpq ?_ <;> simp_all +decide [ List.mem_filter, List.mem_range ] ;
      · refine' List.pairwise_filter.mpr _;
        norm_num [ List.pairwise_iff_get ];
        exact?;
      · linarith;
      · grind;
      · specialize h_verif p q h_consecutive ; aesop;
    intros p q hpq hq h_prime_p h_prime_q h_no_prime_between
    have h_composite : IsCompositeRange p (q - p - 1) := by
      intro i hi; constructor <;> norm_num at *;
      · exact h_no_prime_between _ ( by omega ) ( by omega );
      · linarith [ h_prime_p.two_le ]
    have h_check_true : checkGrimm p (q - p - 1) = Bool.true := h_check p q hpq hq h_prime_p h_prime_q h_no_prime_between
    exact checkGrimm_correct p (q - p - 1) h_composite h_check_true

/-
Grimm's Conjecture implies that the number of distinct prime factors is at least k.
-/
theorem grimm_implies_distinct_factors (n k : ℕ) :
  GrimmHolds n k → (Finset.univ.biUnion (fun (i : Fin k) => (n + 1 + i).primeFactors)).card ≥ k := by
    intro h
    obtain ⟨p, hp_inj, hp_prime⟩ := h;
    -- Since $p$ is injective and each $p(i)$ is a � prime� factor of $n + 1 + i$, the image of $p$ is a subset of the union of the prime factors.
    have h_subset : Finset.image p Finset.univ ⊆ Finset.biUnion (Finset.univ : Finset (Fin k)) (fun i => (n + 1 + i).primeFactors) := by
      exact Finset.image_subset_iff.mpr fun i _ => Finset.mem_biUnion.mpr ⟨ i, Finset.mem_univ _, Nat.mem_primeFactors.mpr ⟨ hp_prime i |>.1, hp_prime i |>.2, by aesop ⟩ ⟩;
    exact le_trans ( by rw [ Finset.card_image_of_injective _ hp_inj ] ; simpa ) ( Finset.card_mono h_subset )

/-
Grimm's Conjecture holds for all prime gaps up to 500 (verified computationally).
-/
theorem grimm_bounded_500 : verifyGrimmUpTo 500 = true := by
  native_decide