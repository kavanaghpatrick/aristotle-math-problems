/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 44b96fd4-3335-4b15-892a-c8de78455c08

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
`IsLeinster G` is the property that the sum of the orders of all normal subgroups of `G` is equal to `2 * |G|`.
-/
open BigOperators

def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Nat.card G

/-
No number of the form `p^2 * q^2` (where `p` and `q` are distinct primes) is a perfect number.
-/
theorem not_perfect_p2q2 (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (hpq : p ≠ q) : ¬ Nat.Perfect (p^2 * q^2) := by
      -- Assume there exist distinct primes $p$ and $q$ such that $n = p^2 q^2$ is perfect.
      by_contra hn
      obtain ⟨hpq, h⟩ : p ≠ q ∧ Nat.Perfect (p^2 * q^2) := by
        exact ⟨ hpq, hn ⟩;
      -- Then we have $σ(p^2 q^2) = (1 + p + p^2)(1 + q + q^2) = 2p^2 q^2$.
      have h_sigma : (1 + p + p^2) * (1 + q + q^2) = 2 * p^2 * q^2 := by
        have h_sigma : ∑ d ∈ Nat.divisors (p^2 * q^2), d = (1 + p + p^2) * (1 + q + q^2) := by
          -- The divisors of $p^2 q^2$ are $1, p, p^2, q, pq, p^2q, q^2, pq^2, p^2q^2$.
          have h_divisors : Nat.divisors (p^2 * q^2) = Finset.image (fun d => p^d.1 * q^d.2) (Finset.product (Finset.range 3) (Finset.range 3)) := by
            conv_lhs => rw [ Nat.divisors_mul, Nat.divisors_prime_pow hp, Nat.divisors_prime_pow hq ] ;
            ext; rw [ Finset.mem_mul ] ; aesop;
          rw [ h_divisors, Finset.sum_image ] <;> norm_num [ Finset.sum ] ; ring;
          norm_num [ Set.InjOn ];
          intro a b ha hb a' b' ha' hb' H; have := congr_arg ( fun x => x.factorization p ) H; have := congr_arg ( fun x => x.factorization q ) H; norm_num [ hp.ne_zero, hq.ne_zero ] at *; aesop;
        rw [ ← h_sigma, Nat.sum_divisors_eq_sum_properDivisors_add_self, h.1 ] ; ring;
      -- Without loss of generality, assume $p > q$.
      wlog hp_gt_hq : p > q generalizing p q;
      · grind;
      · -- Then we have $p^2 \mid (1 + q + q^2)$.
        have h_div : p^2 ∣ (1 + q + q^2) := by
          have h_div : p^2 ∣ ((1 + p + p^2) * (1 + q + q^2)) := by
            exact h_sigma.symm ▸ ⟨ 2 * q ^ 2, by ring ⟩;
          exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( p ^ 2 ) ( 1 + p + p ^ 2 ) from by simp [ sq, Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ] ) h_div );
        have := Nat.le_of_dvd ( by nlinarith only [ hq.two_le ] ) h_div;
        nlinarith only [ this, hp_gt_hq, hq.two_le, hp.two_le ]

/-
For a cyclic group `G`, the sum of the orders of its normal subgroups is equal to the sum of the divisors of `|G|`.
-/
lemma sum_normal_eq_sigma_of_cyclic (G : Type*) [Group G] [Fintype G] [IsCyclic G] :
    ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = ∑ d ∈ Nat.divisors (Nat.card G), d := by
      -- Since $G$ is cyclic, every subgroup is normal. Therefore, the set of normal subgroups is exactly the set of all subgroups of $G$.
      have h_normal_subgroups : {H : Subgroup G | H.Normal} = Set.univ := by
        ext H
        simp [Subgroup.Normal];
        have h_cyclic : ∀ g : G, ∀ h : G, g * h = h * g := by
          grind;
        constructor ; aesop;
      -- Since $G$ is cyclic, every subgroup is determined by its order, which is a divisor of $|G|$. Thus, the set of subgroups is in bijection with the set of divisors of $|G|$.
      have h_subgroups_bijection : {H : Subgroup G | H.Normal} = Set.image (fun d => Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / d))) (Nat.divisors (Nat.card G)) := by
        ext H
        simp [h_normal_subgroups];
        -- Since $G$ is cyclic, every subgroup $H$ is generated by some element $g^k$ for some integer $k$.
        obtain ⟨k, hk⟩ : ∃ k : ℕ, H = Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ k) := by
          -- Since $G$ is cyclic, every subgroup $H$ is generated by some element $g^k$ for some integer $k$. Use this fact.
          obtain ⟨g, hg⟩ : ∃ g : G, H = Subgroup.zpowers g := by
            have h_cyclic_subgroup : IsCyclic H := by
              exact?;
            obtain ⟨ g, hg ⟩ := h_cyclic_subgroup.exists_generator;
            refine' ⟨ g, le_antisymm _ _ ⟩ <;> intro x hx <;> simp_all +decide [ Subgroup.mem_zpowers_iff ];
            · exact Exists.elim ( hg x hx ) fun k hk => ⟨ k, by simpa [ Subtype.ext_iff ] using hk ⟩;
            · exact hx.elim fun k hk => hk ▸ Subgroup.zpow_mem _ g.2 _;
          -- Since $g$ is an element of $G$, we can write it as $g = h^k$ for some integer $k$.
          obtain ⟨k, hk⟩ : ∃ k : ℤ, g = (Classical.choose (IsCyclic.exists_generator (α := G))) ^ k := by
            have := Classical.choose_spec ( IsCyclic.exists_generator ( α := G ) )
            generalize_proofs at *;
            exact Exists.elim ( this g ) fun k hk => ⟨ k, hk.symm ⟩;
          cases' Int.eq_nat_or_neg k with hk hk ; aesop;
        refine' ⟨ Fintype.card G / Nat.gcd ( Fintype.card G ) k, Nat.div_dvd_of_dvd ( Nat.gcd_dvd_left _ _ ), _ ⟩;
        rw [ hk, Nat.div_div_self ] <;> norm_num [ Nat.gcd_dvd_left, Nat.gcd_dvd_right ];
        refine' le_antisymm _ _ <;> simp +decide [ Subgroup.zpowers_le ];
        · have := Nat.gcd_eq_gcd_ab ( Fintype.card G ) k;
          use Nat.gcdB (Fintype.card G) k
          have h_exp : (Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Nat.gcd (Fintype.card G) k) = ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G)) ^ (Nat.gcdA (Fintype.card G) k) * ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ k) ^ (Nat.gcdB (Fintype.card G) k) := by
            group;
            rw [this]
          simp_all +decide [ pow_mul, pow_add ];
        · -- Since $g$ is a generator of $G$, we know that $g^k$ is in the subgroup generated by $g^{\gcd(|G|, k)}$.
          have h_gen : ∃ m : ℕ, k = m * Nat.gcd (Fintype.card G) k := by
            exact exists_eq_mul_left_of_dvd ( Nat.gcd_dvd_right _ _ );
          obtain ⟨ m, hm ⟩ := h_gen; rw [ hm ] ; simp +decide [ pow_mul' ] ;
          rw [ ← hm ] ; exact Subgroup.pow_mem _ ( Subgroup.mem_zpowers _ ) _;
      -- Therefore, the sum of the orders of the normal subgroups is equal to the sum of the divisors of $|G|$.
      have h_sum_eq : ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = ∑ d ∈ Nat.divisors (Nat.card G), Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / d))) := by
        have h_sum_eq : ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = ∑ H ∈ Finset.image (fun d => Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / d))) (Nat.divisors (Nat.card G)), Nat.card H := by
          refine' Finset.sum_bij ( fun H _ => H.val ) _ _ _ _ <;> simp_all +decide [ Set.ext_iff ];
        rw [ h_sum_eq, Finset.sum_image ];
        intro x hx y hy hxy;
        have h_card_eq : Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / x))) = x ∧ Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / y))) = y := by
          have h_card_eq : ∀ d ∈ Nat.divisors (Nat.card G), Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / d))) = d := by
            intro d hd
            have h_card_eq : Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Nat.card G / d))) = Nat.card G / Nat.gcd (Nat.card G) (Nat.card G / d) := by
              rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers ];
              rw [ orderOf_pow ];
              rw [ orderOf_eq_card_of_forall_mem_zpowers ];
              exact fun x => Classical.choose_spec ( IsCyclic.exists_generator ( α := G ) ) x;
            rw [ h_card_eq, Nat.gcd_eq_right ( Nat.div_dvd_of_dvd <| Nat.dvd_of_mem_divisors hd ), Nat.div_div_self ] <;> aesop;
          exact ⟨ h_card_eq x hx, h_card_eq y hy ⟩;
        aesop;
      rw [ h_sum_eq ];
      refine' Finset.sum_congr rfl fun d hd => _;
      rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers ];
      rw [ orderOf_pow ];
      have := Classical.choose_spec ( IsCyclic.exists_generator ( α := G ) );
      rw [ orderOf_eq_card_of_forall_mem_zpowers this ];
      rw [ Nat.gcd_eq_right ( Nat.div_dvd_of_dvd ( Nat.dvd_of_mem_divisors hd ) ), Nat.div_div_self ( Nat.dvd_of_mem_divisors hd ) ( by aesop ) ]

/-
For groups `A` and `B` with coprime orders, the sum of normal subgroup orders of `A × B` is the product of the sums for `A` and `B`.
-/
def sumNormal (G : Type*) [Group G] [Fintype G] : ℕ :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H

theorem sumNormal_prod_of_coprime {A B : Type*} [Group A] [Fintype A] [Group B] [Fintype B]
    (h_coprime : Nat.Coprime (Nat.card A) (Nat.card B)) :
    sumNormal (A × B) = sumNormal A * sumNormal B := by
      -- Let $H$ be a normal subgroup of $A \times B$. Then $H$ is of the form $H_A \times H_B$ where $H_A$ is a normal subgroup of $A$ and $H_B$ is a normal subgroup of $B$.
      have h_normal_subgroups : ∀ H : {H : Subgroup (A × B) // H.Normal}, ∃ H_A : {H : Subgroup A // H.Normal}, ∃ H_B : {H : Subgroup B // H.Normal}, H.val = Subgroup.prod H_A.val H_B.val := by
        intro H
        obtain ⟨H_A, H_B, hH⟩ : ∃ H_A : Subgroup A, ∃ H_B : Subgroup B, H.val = Subgroup.prod H_A H_B := by
          have h_prod : ∀ (H : Subgroup (A × B)), Nat.Coprime (Nat.card A) (Nat.card B) → ∃ H_A : Subgroup A, ∃ H_B : Subgroup B, H = H_A.prod H_B := by
            intro H h_coprime
            have h_prod : ∀ (x : A × B), x ∈ H → (x.1, 1) ∈ H ∧ (1, x.2) ∈ H := by
              intro x hx
              have h1 : (x.1, 1) ∈ H := by
                -- Since $|A|$ and $|B|$ are coprime, there exists an integer $k$ such that $k \cdot |B| \equiv 1 \pmod{|A|}$.
                obtain ⟨k, hk⟩ : ∃ k : ℕ, k * Nat.card B ≡ 1 [MOD Nat.card A] := by
                  have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime.symm;
                  rcases n : Nat.card A with ( _ | _ | n ) <;> simp_all +decide [ mul_comm, Nat.ModEq ];
                  exact ⟨ 0, by simp +decide ⟩;
                -- Since $k \cdot |B| \equiv 1 \pmod{|A|}$, we have $(x.1, x.2)^{k \cdot |B|} = (x.1^{k \cdot |B|}, x.2^{k \cdot |B|}) = (x.1, 1)$.
                have h_exp : (x.1, x.2) ^ (k * Nat.card B) = (x.1, 1) := by
                  have h_exp : x.1 ^ (k * Nat.card B) = x.1 ∧ x.2 ^ (k * Nat.card B) = 1 := by
                    have h_exp : x.1 ^ (k * Nat.card B) = x.1 ^ (k * Nat.card B % Nat.card A) := by
                      exact?;
                    simp_all +decide [ Nat.ModEq, Nat.mod_eq_of_lt ];
                    rw [ ← Nat.mod_add_div ( k * Fintype.card B ) ( Fintype.card B ), pow_add, pow_mul ] ; simp +decide [ pow_card_eq_one ];
                  exact Prod.ext h_exp.1 h_exp.2;
                exact h_exp ▸ H.pow_mem hx _
              have h2 : (1, x.2) ∈ H := by
                convert H.mul_mem hx ( H.inv_mem h1 ) using 1 ; aesop
              exact ⟨h1, h2⟩;
            refine' ⟨ H.comap ( MonoidHom.inl A B ), H.comap ( MonoidHom.inr A B ), le_antisymm _ _ ⟩ <;> intro x <;> simp_all +decide [ Subgroup.mem_prod ];
            · exact h_prod x.1 x.2;
            · exact fun hx₁ hx₂ => by simpa using H.mul_mem hx₁ hx₂;
          exact h_prod _ h_coprime;
        refine' ⟨ ⟨ H_A, _ ⟩, ⟨ H_B, _ ⟩, hH ⟩ <;> simp_all +decide [ Subgroup.Normal ];
        · have := H.2; simp_all +decide [ Subgroup.Normal ] ;
          refine' ⟨ fun x hx => _ ⟩;
          intro g; have := this.conj_mem _ ( show ( x, 1 ) ∈ H_A.prod H_B from ⟨ hx, H_B.one_mem ⟩ ) ( g, 1 ) ; simp_all +decide [ Subgroup.mem_prod ] ;
        · have := H.2;
          refine' ⟨ fun b hb => _ ⟩;
          intro g
          have := this.conj_mem _ ( show ( 1, b ) ∈ H.val from by simpa using hH.symm ▸ Subgroup.mem_prod.mpr ⟨ H_A.one_mem, hb ⟩ ) ( 1, g ) ; simp_all +decide [ Subgroup.mem_prod ] ;
      -- The map $(N_A, N_B) \mapsto N_A \times N_B$ is a bijection between pairs of normal subgroups and normal subgroups of the product.
      have h_bijection : ∀ H : {H : Subgroup (A × B) // H.Normal}, ∃! (p : {H : Subgroup A // H.Normal} × {H : Subgroup B // H.Normal}), H.val = Subgroup.prod p.1.val p.2.val := by
        intro H
        obtain ⟨H_A, H_B, hH⟩ := h_normal_subgroups H
        use (H_A, H_B);
        simp +decide [ hH, Subgroup.ext_iff ];
        intro a ha b hb h; have := h 1 1; simp_all +decide [ Subgroup.mem_prod ] ;
        exact ⟨ Subtype.ext <| by ext x; specialize h x 1; aesop, Subtype.ext <| by ext x; specialize h 1 x; aesop ⟩;
      -- By the bijection, we can rewrite the sum over normal subgroups of $A \times B$ as a sum over pairs of normal subgroups of $A$ and $B$.
      have h_sum_eq : ∑ H : {H : Subgroup (A × B) // H.Normal}, (Nat.card H.val) = ∑ p : {H : Subgroup A // H.Normal} × {H : Subgroup B // H.Normal}, (Nat.card (Subgroup.prod p.1.val p.2.val)) := by
        choose f hf hf' using h_bijection;
        refine' Finset.sum_bij ( fun H _ => f H ) _ _ _ _ <;> simp +decide [ hf ];
        · grind +ring;
        · intro a ha b hb;
          refine' ⟨ Subgroup.prod a b, _, _ ⟩;
          exact?;
          exact hf' ⟨ a.prod b, by infer_instance ⟩ ( ⟨ ⟨ a, ha ⟩, ⟨ b, hb ⟩ ⟩ ) rfl ▸ rfl;
      -- The cardinality of the product of two subgroups is the product of their cardinalities.
      have h_card_prod : ∀ (H_A : {H : Subgroup A // H.Normal}) (H_B : {H : Subgroup B // H.Normal}), Nat.card (Subgroup.prod H_A.val H_B.val) = Nat.card H_A.val * Nat.card H_B.val := by
        simp +decide [ Nat.card_eq_fintype_card, Fintype.card_subtype ];
        intro H hH K hK; rw [ ← Finset.card_product ] ; congr; ext ⟨ x, y ⟩ ; simp +decide [ Subgroup.mem_prod ] ;
      simp +decide only [sumNormal, h_sum_eq, h_card_prod];
      erw [ Finset.sum_product, Finset.sum_mul_sum ]

/-
If `G` is a group of order `p^2` and exponent `p`, then the number of subgroups of order `p` is `p + 1`.
-/
lemma card_subgroups_order_p_of_exponent_p (p : ℕ) (hp : Nat.Prime p) (G : Type*) [Group G] [Fintype G]
    (hcard : Nat.card G = p^2) (hexp : Monoid.exponent G = p) :
    Finset.card (Finset.filter (fun H : Subgroup G => Nat.card H = p) Finset.univ) = p + 1 := by
      -- Since the exponent of $G$ is $p$, every element $g \in G$ satisfies $g^p = 1$.
      have h_all_p : ∀ g : G, g ^ p = 1 := by
        exact fun g => by rw [ ← hexp, Monoid.pow_exponent_eq_one ] ;
      -- Since $|G| = p^2$, any non-identity element has order $p$ (it divides $p^2$ and is not 1, and $g^p=1$ implies order divides $p$).
      have h_order_p : ∀ g : G, g ≠ 1 → Nat.card (Subgroup.zpowers g) = p := by
        intro g hg_ne_one
        have h_order_div : Nat.card (Subgroup.zpowers g) ∣ p := by
          rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers ];
          exact orderOf_dvd_of_pow_eq_one ( h_all_p g )
        have h_order_ne_one : Nat.card (Subgroup.zpowers g) ≠ 1 := by
          simp +decide [ hg_ne_one, Fintype.card_zpowers ]
        have h_order_eq_p : Nat.card (Subgroup.zpowers g) = p := by
          rw [ Nat.dvd_prime hp ] at h_order_div ; aesop
        exact h_order_eq_p;
      -- Let $S$ be the set of subgroups of order $p$.
      set S := Finset.filter (fun H : Subgroup G => Nat.card H = p) (Finset.univ : Finset (Subgroup G));
      -- Since every non-identity element of $G$ generates a subgroup of order $p$, the set of non-identity elements of $G$ is in bijection with the set of subgroups of order $p$.
      have h_bij : Finset.card (Finset.filter (fun g : G => g ≠ 1) (Finset.univ : Finset G)) = Finset.sum S (fun H => Finset.card (Finset.filter (fun g : G => g ≠ 1 ∧ Subgroup.zpowers g = H) (Finset.univ : Finset G))) := by
        rw [ ← Finset.card_biUnion ] ; congr ; ext g ; aesop;
        exact fun H hH H' hH' hHH' => Finset.disjoint_left.mpr fun x hx hx' => hHH' <| by aesop;
      -- Since each subgroup of order $p$ has exactly $p-1$ non-identity elements, we have $Finset.card (Finset.filter (fun g : G => g ≠ 1 ∧ Subgroup.zpowers g = H) (Finset.univ : Finset G)) = p - 1$ for each $H \in S$.
      have h_card_filter : ∀ H ∈ S, Finset.card (Finset.filter (fun g : G => g ≠ 1 ∧ Subgroup.zpowers g = H) (Finset.univ : Finset G)) = p - 1 := by
        intro H hH
        have h_card_filter : Finset.card (Finset.filter (fun g : G => g ≠ 1 ∧ Subgroup.zpowers g = H) (Finset.univ : Finset G)) = Finset.card (Finset.filter (fun g : G => g ≠ 1) (Finset.filter (fun g : G => g ∈ H) (Finset.univ : Finset G))) := by
          congr 1 with g ; simp +decide [ Subgroup.mem_zpowers_iff ];
          constructor <;> intro hg <;> simp_all +decide [ Subgroup.zpowers_eq_closure ];
          · exact hg.2 ▸ Subgroup.subset_closure ( Set.mem_singleton g );
          · have h_subgroup_eq : Subgroup.closure {g} ≤ H := by
              aesop;
            exact SetLike.ext' ( Set.eq_of_subset_of_card_le h_subgroup_eq ( by aesop ) );
        simp_all +decide [ Finset.filter_ne', Finset.filter_and ];
        rw [ ← Nat.card_eq_finsetCard ] ; aesop;
      rcases p with ( _ | _ | p ) <;> simp_all +decide [ Finset.filter_ne' ];
      nlinarith only [ h_bij, Nat.sub_add_cancel ( show 1 ≤ Nat.succ ( Nat.succ p ) ^ 2 from Nat.one_le_pow _ _ ( Nat.succ_pos _ ) ) ]

/-
For a group `G` of order `p^2`, the sum of normal subgroup orders is either `1 + p + p^2` or `1 + p + 2p^2`.
-/
lemma sumNormal_p2 (p : ℕ) (hp : Nat.Prime p) (G : Type*) [Group G] [Fintype G]
    (hcard : Nat.card G = p^2) :
    sumNormal G = 1 + p + p^2 ∨ sumNormal G = 1 + p + 2 * p^2 := by
      -- By `IsPGroup.commutative_of_card_eq_prime_sq`, G is abelian. Thus every subgroup is normal.
      have h_abelian : ∀ (H : Subgroup G), H.Normal := by
        have h_abelian : IsPGroup p G ∧ Fintype.card G = p^2 := by
          simp +zetaDelta at *;
          exact ⟨ fun g => ⟨ 2, by rw [ ← hcard, pow_card_eq_one ] ⟩, hcard ⟩;
        have h_abelian : IsPGroup p G → Fintype.card G = p^2 → ∀ (H : Subgroup G), H.Normal := by
          intros hPGroup hcard
          have h_abelian : ∀ (g h : G), g * h = h * g := by
            haveI := Fact.mk hp; have := @IsPGroup.commutative_of_card_eq_prime_sq p G; aesop;
          intro H; constructor; intro g hg; simp_all +decide [ mul_assoc, Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ] ;
        exact h_abelian ( by tauto ) ( by tauto );
      -- If $G$ is cyclic:
      by_cases hcyclic : IsCyclic G;
      · -- By `sum_normal_eq_sigma_of_cyclic`, sum is $\sigma(p^2) = 1 + p + p^2$.
        have h_cyclic_sum : sumNormal G = ∑ d ∈ Nat.divisors (Nat.card G), d := by
          apply sum_normal_eq_sigma_of_cyclic;
        simp_all +decide [ Nat.divisors_prime_pow ];
        exact Or.inl ( by simp +decide [ Finset.sum_range_succ ] );
      · -- By `not_isCyclic_iff_exponent_eq_prime`, the exponent of $G$ is $p$.
        have hexp : Monoid.exponent G = p := by
          exact?;
        -- By `card_subgroups_order_p_of_exponent_p`, there are $p+1$ subgroups of order $p$.
        have h_subgroups_p : Finset.card (Finset.filter (fun H : Subgroup G => Nat.card H = p) Finset.univ) = p + 1 := by
          convert card_subgroups_order_p_of_exponent_p p hp G hcard hexp using 1;
        -- There is 1 subgroup of order 1 (trivial) and 1 subgroup of order $p^2$ (whole group).
        have h_subgroups_1_p2 : Finset.card (Finset.filter (fun H : Subgroup G => Nat.card H = 1) Finset.univ) = 1 ∧ Finset.card (Finset.filter (fun H : Subgroup G => Nat.card H = p^2) Finset.univ) = 1 := by
          constructor <;> rw [ Finset.card_eq_one ];
          · use ⊥; ext H; simp [Nat.card_eq_one_iff_unique];
            rw [ Fintype.card_eq_one_iff ] ; aesop;
          · use ⊤;
            ext H; simp [hcard];
            constructor <;> intro hH <;> have := Subgroup.card_mul_index H <;> simp_all +decide [ pow_succ' ];
            simp_all +decide [ hp.ne_zero, hp.ne_one, mul_assoc ];
        -- Therefore, the sum of the orders of the normal subgroups is $1 \cdot 1 + (p+1) \cdot p + 1 \cdot p^2 = 1 + p + p^2 + p^2 = 1 + p + 2p^2$.
        have h_sum : sumNormal G = ∑ d ∈ ({1, p, p^2} : Finset ℕ), d * (Finset.card (Finset.filter (fun H : Subgroup G => Nat.card H = d) Finset.univ)) := by
          have h_sum : sumNormal G = ∑ H : Subgroup G, Nat.card H := by
            refine' Finset.sum_bij ( fun H _ => H.val ) _ _ _ _ <;> simp +decide [ h_abelian ];
          have h_sum : ∑ H : Subgroup G, Nat.card H = ∑ d ∈ ({1, p, p^2} : Finset ℕ), ∑ H ∈ Finset.filter (fun H : Subgroup G => Nat.card H = d) Finset.univ, Nat.card H := by
            rw [ ← Finset.sum_biUnion ];
            · rw [ show ( Finset.biUnion { 1, p, p ^ 2 } fun d => Finset.filter ( fun H : Subgroup G => Nat.card H = d ) Finset.univ ) = Finset.univ from ?_ ];
              ext H; simp [Finset.mem_biUnion];
              have := Subgroup.card_subgroup_dvd_card H; simp_all +decide [ Nat.dvd_prime_pow ] ;
              rcases this with ⟨ k, hk₁, hk₂ ⟩ ; interval_cases k <;> simp +decide [ hk₂ ] ;
            · exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz hz' => hxy <| by aesop;
          rw [ ‹sumNormal G = ∑ H : Subgroup G, Nat.card H›, h_sum ];
          exact Finset.sum_congr rfl fun x hx => by rw [ Finset.sum_congr rfl fun y hy => Finset.mem_filter.mp hy |>.2 ] ; simp +decide [ mul_comm ] ;
        rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.pow_succ ];
        grind

/-
For any possible values of the sum of normal subgroup orders for groups of order `p^2` and `q^2`, their product is not equal to `2 * p^2 * q^2`.
-/
lemma sumNormal_p2q2_ne_two_mul (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q) (hpq : p ≠ q)
    (Sp Sq : ℕ)
    (hSp : Sp = 1 + p + p^2 ∨ Sp = 1 + p + 2 * p^2)
    (hSq : Sq = 1 + q + q^2 ∨ Sq = 1 + q + 2 * q^2) :
    Sp * Sq ≠ 2 * p^2 * q^2 := by
      rcases hSp with ( rfl | rfl ) <;> rcases hSq with ( rfl | rfl ) <;> ring_nf <;> intro h <;> have := congr_arg Even h <;> norm_num [ hp.even_iff, hq.even_iff, parity_simps ] at this ⊢;
      · grind;
      · grind;
      · grind;
      · nlinarith [ hp.two_le, hq.two_le, mul_pos hp.pos hq.pos ]

/-
The sum of the orders of normal subgroups is invariant under group isomorphism.
-/
open BigOperators

lemma sumNormal_congr {G K : Type*} [Group G] [Fintype G] [Group K] [Fintype K] (e : G ≃* K) :
    sumNormal G = sumNormal K := by
      convert rfl;
      refine' Finset.sum_bij ( fun H _ => ⟨ H.1.map e.symm.toMonoidHom, _ ⟩ ) _ _ _ _ <;> simp +decide;
      · convert H.2.map e.symm.toMonoidHom;
        exact ⟨ fun h => fun _ => h, fun h => h e.symm.surjective ⟩;
      · intro a ha b hb h; ext x; replace h := SetLike.ext_iff.mp h ( e.symm x ) ; aesop;
      · intro a ha;
        refine' ⟨ a.map e, _, _ ⟩;
        · convert ha.map e.toMonoidHom;
          exact ⟨ fun h => fun _ => h, fun h => h e.surjective ⟩;
        · exact?;
      · intro a ha;
        refine' Fintype.card_congr _;
        refine' Equiv.ofBijective ( fun x => ⟨ e.symm x, x, x.2, rfl ⟩ ) ⟨ fun x y h => _, fun x => _ ⟩ <;> aesop

/-
`IsLeinster G` is equivalent to `sumNormal G = 2 * |G|`.
-/
open BigOperators

lemma isLeinster_iff_sumNormal (G : Type*) [Group G] [Fintype G] :
    IsLeinster G ↔ sumNormal G = 2 * Nat.card G := by
      exact?

#check IsNilpotent

#check Group.IsNilpotent

/-
In a nilpotent group, every Sylow subgroup is normal.
-/
lemma sylow_normal_of_nilpotent {G : Type*} [Group G] [Group.IsNilpotent G]
    {p : ℕ} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) : P.Normal := by
      -- Since $G$ is nilpotent, it satisfies the normalizer condition.
      have h_normalizer : ∀ H : Subgroup G, H ≠ ⊤ → H < Subgroup.normalizer H := by
        intro H hH;
        refine' lt_of_le_of_ne ( Subgroup.le_normalizer ) fun h => hH _;
        -- Since $G$ is nilpotent, its upper central series reaches $G$.
        have h_upper_central_series : ∃ n, upperCentralSeries G n = ⊤ := by
          exact?;
        -- Since $H$ is equal to its normalizer, we have $H \geq \text{center}(G)$.
        have h_center : ∀ n, upperCentralSeries G n ≤ H := by
          intro n
          induction' n with n ih;
          · simp +decide [ upperCentralSeriesAux ];
          · intro x hx;
            rw [ h ];
            intro y;
            constructor <;> intro hy <;> have := hx y <;> simp +decide [ mul_assoc, Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right, ih ] at this ⊢;
            · simpa [ mul_assoc ] using H.mul_mem ( ih this ) hy;
            · simpa [ mul_assoc ] using H.mul_mem ( H.inv_mem hy ) ( ih this );
        exact le_top.antisymm ( h_upper_central_series.choose_spec ▸ h_center _ );
      contrapose! h_normalizer;
      refine' ⟨ Subgroup.normalizer ( P : Subgroup G ), _, _ ⟩ <;> simp_all +decide [ Subgroup.normalizer_eq_top_iff ]

/-
A nilpotent group of order `p^2 * q^2` is isomorphic to the product of a subgroup of order `p^2` and a subgroup of order `q^2`.
-/
lemma iso_prod_sylow_of_nilpotent_p2q2 (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (hpq : p ≠ q) (G : Type*) [Group G] [Fintype G] [Group.IsNilpotent G]
    (hcard : Nat.card G = p^2 * q^2) :
    ∃ (P Q : Subgroup G), Nat.card P = p^2 ∧ Nat.card Q = q^2 ∧ Nonempty (G ≃* P × Q) := by
      -- Since `G` is nilpotent, every Sylow subgroup is normal (`sylow_normal_of_nilpotent`).
      obtain ⟨P, hP⟩ : ∃ P : Subgroup G, Nat.card P = p^2 ∧ P.Normal := by
        have h_sylow : ∃ P : Sylow p G, True := by
          simp +zetaDelta at *;
        obtain ⟨ P, - ⟩ := h_sylow;
        refine' ⟨ P.toSubgroup, _, _ ⟩;
        · haveI := Fact.mk hp;
          have := Sylow.card_eq_multiplicity P;
          simp_all +decide [ Nat.factorization_mul, hp.ne_zero, hq.ne_zero ];
        · convert sylow_normal_of_nilpotent P;
          exact ⟨ hp ⟩
      obtain ⟨Q, hQ⟩ : ∃ Q : Subgroup G, Nat.card Q = q^2 ∧ Q.Normal := by
        norm_num +zetaDelta at *;
        -- By definition of nilpotency, the Sylow q-subgroup Q of G is normal.
        obtain ⟨Q, hQ⟩ : ∃ Q : Sylow q G, Q.Normal := by
          haveI := Fact.mk hq; exact ⟨ Classical.arbitrary _, sylow_normal_of_nilpotent _ ⟩ ;
        refine' ⟨ Q, _, hQ ⟩;
        convert Q.card_eq_multiplicity;
        · rw [ Nat.card_eq_fintype_card ];
        · simp +decide [ hcard, hp.ne_zero, hq.ne_zero ];
          simp +decide [ hp.factorization, hq.factorization, hpq ];
        · exact ⟨ hq ⟩;
      -- Since `P` and `Q` are normal and their orders are coprime, `P ∩ Q = ⊥`.
      have h_inter : P ⊓ Q = ⊥ := by
        have h_inter : Nat.card (↥(P ⊓ Q)) ∣ Nat.gcd (Nat.card P) (Nat.card Q) := by
          exact Nat.dvd_gcd ( Subgroup.card_dvd_of_le inf_le_left ) ( Subgroup.card_dvd_of_le inf_le_right );
        simp_all +decide [ Nat.coprime_pow_primes ];
        rw [ Fintype.card_eq_one_iff ] at h_inter ; aesop;
      -- Since `P` and `Q` are normal and `P ∩ Q = ⊥`, elements of `P` commute with elements of `Q`.
      have h_comm : ∀ x ∈ P, ∀ y ∈ Q, x * y = y * x := by
        intro x hx y hy
        have h_comm : x * y * x⁻¹ * y⁻¹ ∈ P ⊓ Q := by
          exact ⟨ by simpa [ mul_assoc ] using P.mul_mem hx ( hP.2.conj_mem _ ( P.inv_mem hx ) y ), by simpa [ mul_assoc ] using Q.mul_mem ( hQ.2.conj_mem _ hy x ) ( Q.inv_mem hy ) ⟩;
        simp_all +decide [ mul_inv_eq_iff_eq_mul ];
      -- Since `P` and `Q` are normal and `P ∩ Q = ⊥`, the map `(x, y) \mapsto xy` is a homomorphism from `P \times Q` to `G`.
      have h_hom : Function.Bijective (fun pq : P × Q => pq.1 * pq.2 : P × Q → G) := by
        have h_inj : Function.Injective (fun pq : P × Q => pq.1 * pq.2 : P × Q → G) := by
          intro pq pq' h_eq
          have h_eq' : (pq.1 : G)⁻¹ * pq'.1 = pq.2 * (pq'.2 : G)⁻¹ := by
            simp_all +decide [ mul_assoc, eq_mul_inv_of_mul_eq h_eq ]
          have h_eq'' : (pq.1 : G)⁻¹ * pq'.1 ∈ P ∧ (pq.1 : G)⁻¹ * pq'.1 ∈ Q := by
            exact ⟨ P.mul_mem ( P.inv_mem pq.1.2 ) pq'.1.2, h_eq'.symm ▸ Q.mul_mem pq.2.2 ( Q.inv_mem pq'.2.2 ) ⟩
          have h_eq''' : (pq.1 : G)⁻¹ * pq'.1 = 1 := by
            exact Subgroup.mem_bot.mp ( h_inter ▸ Subgroup.mem_inf.mpr h_eq'' )
          have h_eq'''' : pq.1 = pq'.1 := by
            exact Subtype.ext ( inv_mul_eq_one.mp h_eq''' ) ▸ rfl
          have h_eq''''' : pq.2 = pq'.2 := by
            aesop
          aesop;
        have := Fintype.bijective_iff_injective_and_card ( fun pq : P × Q => ( pq.1 : G ) * pq.2 ) ; aesop;
      refine' ⟨ P, Q, hP.1, hQ.1, ⟨ _ ⟩ ⟩;
      symm;
      refine' { Equiv.ofBijective _ h_hom with .. };
      simp +decide [ mul_assoc, h_comm ];
      simp +contextual [ ← mul_assoc, h_comm ]

/-
If `G` is a nilpotent group of order `p^2 * q^2`, then `G` is not a Leinster group.
-/
open BigOperators

lemma not_leinster_of_nilpotent_p2q2 (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (hpq : p ≠ q) (G : Type*) [Group G] [Fintype G] [Group.IsNilpotent G]
    (hcard : Nat.card G = p^2 * q^2) :
    ¬ IsLeinster G := by
      -- By `iso_prod_sylow_of_nilpotent_p2q2`, there exist subgroups $P, Q$ such that $|P|=p^2$, $|Q|=q^2$, and $G \cong P \times Q$.
      obtain ⟨P, Q, hP, hQ, h_iso⟩ : ∃ (P Q : Subgroup G), Nat.card P = p ^ 2 ∧ Nat.card Q = q ^ 2 ∧ Nonempty (G ≃* P × Q) := by
        exact?;
      -- By `sumNormal_congr`, `sumNormal G = sumNormal (P × Q)`.
      have h_sumNormal : sumNormal G = sumNormal (P × Q) := by
        exact sumNormal_congr h_iso.some;
      -- By `sumNormal_prod_of_coprime`, `sumNormal (P × Q) = sumNormal P * sumNormal Q`.
      have h_sumNormal_prod : sumNormal (P × Q) = sumNormal P * sumNormal Q := by
        convert sumNormal_prod_of_coprime _;
        simp_all +decide [ Nat.coprime_pow_primes ];
        exact hp.coprime_iff_not_dvd.mpr fun h => hpq <| Nat.prime_dvd_prime_iff_eq hp hq |>.1 h;
      -- By `sumNormal_p2`, `sumNormal P \in \{1+p+p^2, 1+p+2p^2\}$ and `sumNormal Q \in \{1+q+q^2, 1+q+2q^2\}$.
      have h_sumNormal_P : sumNormal P = 1 + p + p^2 ∨ sumNormal P = 1 + p + 2 * p^2 := by
        convert sumNormal_p2 p hp P hP
      have h_sumNormal_Q : sumNormal Q = 1 + q + q^2 ∨ sumNormal Q = 1 + q + 2 * q^2 := by
        convert sumNormal_p2 q hq Q hQ using 1;
      -- By `sumNormal_p2q2_ne_two_mul`, `sumNormal P * sumNormal Q \ne 2 p^2 q^2`.
      have h_sumNormal_ne : sumNormal P * sumNormal Q ≠ 2 * p^2 * q^2 := by
        exact sumNormal_p2q2_ne_two_mul p q hp hq hpq _ _ h_sumNormal_P h_sumNormal_Q;
      exact fun h => h_sumNormal_ne <| by linarith [ isLeinster_iff_sumNormal G |>.1 h ] ;

/-
If `H` and `K` are normal subgroups of a finite group `G` with coprime orders such that `|H| * |K| = |G|`, then `G` is isomorphic to `H × K`.
-/
open BigOperators

lemma iso_prod_of_coprime_normal_subgroups {G : Type*} [Group G] [Fintype G]
    (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal]
    (h_coprime : Nat.Coprime (Nat.card H) (Nat.card K))
    (h_card : Nat.card H * Nat.card K = Nat.card G) :
    Nonempty (G ≃* H × K) := by
      -- By definition of coprimality, $H \cap K = \{1\}$.
      have h_inter : (H ⊓ K) = ⊥ := by
        exact?;
      -- Since $H$ and $K$ are normal and their orders are coprime, every element in $G$ can be uniquely written as a product of an element in $H$ and an element in $K$.
      have h_decomp : ∀ g : G, ∃! (hk : ↥H × ↥K), hk.1.val * hk.2.val = g := by
        have h_decomp : ∀ g : G, ∃ (hk : ↥H × ↥K), hk.1.val * hk.2.val = g := by
          have h_decomp : Finset.image (fun (hk : ↥H × ↥K) => hk.1.val * hk.2.val) (Finset.univ : Finset (↥H × ↥K)) = Finset.univ := by
            refine' Finset.eq_of_subset_of_card_le ( Finset.subset_univ _ ) _;
            rw [ Finset.card_image_of_injective ];
            · aesop;
            · intro x y hxy;
              have h_eq : (x.1 : G)⁻¹ * y.1 = x.2 * (y.2 : G)⁻¹ := by
                simp_all +decide [ mul_assoc, eq_mul_inv_of_mul_eq hxy ];
              have h_eq : (x.1 : G)⁻¹ * y.1 ∈ H ∧ (x.2 : G) * (y.2 : G)⁻¹ ∈ K := by
                exact ⟨ H.mul_mem ( H.inv_mem x.1.2 ) y.1.2, K.mul_mem x.2.2 ( K.inv_mem y.2.2 ) ⟩;
              simp_all +decide [ Subgroup.eq_bot_iff_forall ];
              simp_all +decide [ mul_eq_one_iff_eq_inv ];
              grind;
          exact fun g => Finset.mem_image.mp ( h_decomp.symm ▸ Finset.mem_univ g ) |> Exists.imp fun x hx => hx.2;
        -- To prove uniqueness, assume there are two pairs $(h_1, k_1)$ and $(h_2, k_2)$ such that $h_1 k_1 = h_2 k_2$.
        intro g
        obtain ⟨hk, hk_eq⟩ := h_decomp g
        have h_unique : ∀ (hk1 hk2 : ↥H × ↥K), hk1.1.val * hk1.2.val = hk2.1.val * hk2.2.val → hk1 = hk2 := by
          intro hk1 hk2 h_eq
          have h_eq' : (hk1.1.val⁻¹ * hk2.1.val) = (hk1.2.val * hk2.2.val⁻¹) := by
            simp +decide [ mul_assoc, eq_mul_inv_of_mul_eq h_eq ];
          -- Since $H$ and $K$ are normal and their orders are coprime, $hk1.1⁻¹ * hk2.1$ must be in both $H$ and $K$, hence it must be the identity.
          have h_id : (hk1.1.val⁻¹ * hk2.1.val) ∈ H ⊓ K := by
            exact ⟨ H.mul_mem ( H.inv_mem hk1.1.2 ) hk2.1.2, h_eq'.symm ▸ K.mul_mem hk1.2.2 ( K.inv_mem hk2.2.2 ) ⟩;
          simp_all +decide [ mul_eq_one_iff_eq_inv ];
          grind;
        exact ⟨ hk, hk_eq, fun hk' hk'_eq => h_unique hk' hk ( hk'_eq.trans hk_eq.symm ) ⟩;
      -- Define the map $\phi: H \times K \to G$ by $\phi(h, k) = hk$.
      set phi : ↥H × ↥K → G := fun hk => hk.1.val * hk.2.val;
      -- Show that $\phi$ is a homomorphism.
      have h_hom : ∀ hk₁ hk₂ : ↥H × ↥K, phi (hk₁ * hk₂) = phi hk₁ * phi hk₂ := by
        intro hk₁ hk₂;
        -- Since $H$ and $K$ are normal subgroups, elements of $H$ commute with elements of $K$.
        have h_comm : ∀ h₁ h₂ : G, h₁ ∈ H → h₂ ∈ K → h₁ * h₂ = h₂ * h₁ := by
          intro h₁ h₂ hh₁ hh₂
          have h_comm : h₁ * h₂ * h₁⁻¹ * h₂⁻¹ ∈ H ⊓ K := by
            exact ⟨ by simpa [ mul_assoc ] using H.mul_mem hh₁ ( hH.conj_mem _ ( H.inv_mem hh₁ ) h₂ ), by simpa [ mul_assoc ] using K.mul_mem ( hK.conj_mem _ hh₂ h₁ ) ( K.inv_mem hh₂ ) ⟩;
          simp_all +decide [ mul_inv_eq_iff_eq_mul ];
        simp +zetaDelta at *;
        simp +decide only [mul_assoc];
        simp +decide only [← mul_assoc, h_comm _ _ hk₂.1.2 hk₁.2.2];
      -- Show that $\phi$ is bijective.
      have h_bijective : Function.Bijective phi := by
        exact ⟨ fun x y hxy => ExistsUnique.unique ( h_decomp _ ) hxy rfl, fun g => ExistsUnique.exists ( h_decomp g ) ⟩;
      refine' ⟨ _ ⟩;
      exact MulEquiv.symm ( { Equiv.ofBijective phi h_bijective with map_mul' := h_hom } )

/-
A nilpotent group of order `p^2 * q^2` is isomorphic to the product of a subgroup of order `p^2` and a subgroup of order `q^2`.
-/
open BigOperators

lemma iso_prod_sylow_of_nilpotent_p2q2_v2 (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (hpq : p ≠ q) (G : Type*) [Group G] [Fintype G] [Group.IsNilpotent G]
    (hcard : Nat.card G = p^2 * q^2) :
    ∃ (P Q : Subgroup G), Nat.card P = p^2 ∧ Nat.card Q = q^2 ∧ Nonempty (G ≃* P × Q) := by
      exact?

/-
The exponent of `p` in the prime factorization of `p^2 * q^2` is 2.
-/
lemma factorization_p2q2_p (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q) (hpq : p ≠ q) :
    (p^2 * q^2).factorization p = 2 := by
      rw [ Nat.factorization_mul ] <;> aesop

/-
The exponent of `q` in the prime factorization of `p^2 * q^2` is 2.
-/
lemma factorization_p2q2_q (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q) (hpq : p ≠ q) :
    (p^2 * q^2).factorization q = 2 := by
      rw [ Nat.factorization_mul ] <;> aesop

/-
If `G` is a nilpotent group of order `p^2 * q^2`, then `G` is not a Leinster group.
-/
open BigOperators

lemma not_leinster_of_nilpotent_p2q2_v2 (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (hpq : p ≠ q) (G : Type*) [Group G] [Fintype G] [Group.IsNilpotent G]
    (hcard : Nat.card G = p^2 * q^2) :
    ¬ IsLeinster G := by
      convert not_leinster_of_nilpotent_p2q2 p q hp hq hpq G hcard

/-
If `p < q` and `(p, q) ≠ (2, 3)`, then the Sylow `q`-subgroup of a group of order `p^2 * q^2` is normal.
-/
lemma sylow_q_normal_of_p_lt_q (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (h_lt : p < q) (h_ne : p ≠ 2 ∨ q ≠ 3) (G : Type*) [Group G] [Fintype G]
    (hcard : Nat.card G = p^2 * q^2) :
    ∀ (Q : Sylow q G), Q.Normal := by
      -- By Sylow's theorems, the number of Sylow $q$-subgroups $n_q$ satisfies $n_q \equiv 1 \pmod q$ and $n_q \mid p^2$.
      have h_sylow_count : ∀ (Q : Sylow q G), (Nat.card (Sylow q G)) ≡ 1 [MOD q] ∧ Nat.card (Sylow q G) ∣ p^2 := by
        haveI := Fact.mk hq;
        intro Q
        have h_sylow_count : (Nat.card (Sylow q G)) ≡ 1 [MOD q] := by
          exact?
        have h_sylow_div : (Nat.card (Sylow q G)) ∣ p^2 := by
          have h_sylow_div : (Nat.card (Sylow q G)) ∣ Nat.card G := by
            convert Subgroup.card_quotient_dvd_card ( Subgroup.normalizer Q.toSubgroup ) using 1;
            exact?;
          exact Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( Nat.card ( Sylow q G ) ) ( q ^ 2 ) from Nat.Coprime.pow_right _ <| Nat.Coprime.symm <| hq.coprime_iff_not_dvd.2 fun h => by have := Nat.modEq_zero_iff_dvd.1 ( h_sylow_count.symm.trans <| Nat.modEq_zero_iff_dvd.2 h ) ; simp_all +decide [ Nat.modEq_iff_dvd' ] ) <| h_sylow_div.trans <| hcard.symm ▸ dvd_rfl
        exact ⟨h_sylow_count, h_sylow_div⟩;
      -- Since $p < q$, $p \not\equiv 1 \pmod q$. Thus $n_q \ne p$.
      have h_sylow_count_ne_p : ∀ (Q : Sylow q G), Nat.card (Sylow q G) ≠ p := by
        intro Q hQ; specialize h_sylow_count Q; simp_all +decide [ Nat.ModEq, Nat.mod_eq_of_lt h_lt ] ;
        rcases q with ( _ | _ | _ | q ) <;> simp_all +decide [ Nat.mod_eq_of_lt ];
      -- If $n_q = p^2$, then $p^2 \equiv 1 \pmod q$, so $q \mid (p^2 - 1) = (p-1)(p+1)$.
      have h_sylow_count_eq_p2 : ∀ (Q : Sylow q G), Nat.card (Sylow q G) = p^2 → q ∣ (p - 1) * (p + 1) := by
        intro Q hQ
        have h_cong : p^2 ≡ 1 [MOD q] := by
          exact hQ ▸ h_sylow_count Q |>.1;
        rw [ mul_comm, ← Nat.sq_sub_sq ];
        simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( show 1 ≤ p ^ 2 from pow_pos hp.pos _ ) ] using h_cong.symm.dvd;
      -- Since $q$ is prime and $q \mid (p-1)(p+1)$, it must divide one of the factors.
      have h_sylow_count_eq_p2_div : ∀ (Q : Sylow q G), Nat.card (Sylow q G) = p^2 → q ∣ (p - 1) ∨ q ∣ (p + 1) := by
        exact fun Q hQ => hq.dvd_mul.mp ( h_sylow_count_eq_p2 Q hQ );
      -- Since $q$ is prime and $q \mid (p-1)(p+1)$, it must divide one of the factors. However, $q > p$, so $q \nmid (p-1)$.
      have h_sylow_count_eq_p2_div_p1 : ∀ (Q : Sylow q G), Nat.card (Sylow q G) = p^2 → q ∣ (p + 1) := by
        exact fun Q hQ => Or.resolve_left ( h_sylow_count_eq_p2_div Q hQ ) ( Nat.not_dvd_of_pos_of_lt ( Nat.sub_pos_of_lt hp.one_lt ) ( Nat.lt_of_le_of_lt ( Nat.pred_le _ ) h_lt ) );
      -- Since $q$ is prime and $q \mid (p+1)$, it must be that $q = p + 1$.
      have h_sylow_count_eq_p2_div_p1_eq : ∀ (Q : Sylow q G), Nat.card (Sylow q G) = p^2 → q = p + 1 := by
        exact fun Q hQ => by linarith [ Nat.le_of_dvd ( Nat.succ_pos _ ) ( h_sylow_count_eq_p2_div_p1 Q hQ ) ] ; ;
      -- Since $q$ is prime and $q = p + 1$, it must be that $p = 2$ and $q = 3$.
      have h_sylow_count_eq_p2_div_p1_eq_2_3 : ∀ (Q : Sylow q G), Nat.card (Sylow q G) = p^2 → p = 2 ∧ q = 3 := by
        intro Q hQ; specialize h_sylow_count_eq_p2_div_p1_eq Q hQ; rcases p with ( _ | _ | _ | p ) <;> simp_all +arith +decide;
        cases Nat.Prime.eq_two_or_odd hp <;> cases Nat.Prime.eq_two_or_odd hq <;> simp_all +arith +decide [ Nat.add_mod, Nat.mul_mod ];
      intro Q
      by_cases hQ : Nat.card (Sylow q G) = p^2;
      · exact False.elim ( h_ne.elim ( fun h => h ( h_sylow_count_eq_p2_div_p1_eq_2_3 Q hQ |>.1 ) ) fun h => h ( h_sylow_count_eq_p2_div_p1_eq_2_3 Q hQ |>.2 ) );
      · have := h_sylow_count Q;
        rw [ Nat.dvd_prime_pow hp ] at this;
        rcases this.2 with ⟨ k, hk₁, hk₂ ⟩ ; interval_cases k <;> simp_all +decide;
        rw [ Fintype.card_eq_one_iff ] at hk₂;
        obtain ⟨ x, hx ⟩ := hk₂;
        have h_normal : ∀ g : G, g • x = x := by
          exact fun g => hx _;
        have h_normal : ∀ g : G, ∀ h : G, h ∈ x → g * h * g⁻¹ ∈ x := by
          intro g h hh; specialize h_normal g; rw [ ← h_normal ] ; exact (by
          exact ⟨ h, hh, rfl ⟩);
        constructor;
        intro n hn g; specialize hx Q; aesop;

/-
If `p < q` are primes and `(p, q) ≠ (2, 3)`, then `p^2` is not congruent to `1` modulo `q`.
-/
lemma p_sq_not_equiv_one_mod_q (p q : ℕ) (hp : Nat.Prime p) (hq : Nat.Prime q)
    (h_lt : p < q) (h_ne : p ≠ 2 ∨ q ≠ 3) : ¬ p^2 ≡ 1 [MOD q] := by
      -- Assume for contradiction that $p^2 \equiv 1 \pmod{q}$.
      by_contra h_contra
      have h_div : q ∣ (p - 1) * (p + 1) := by
        rw [ mul_comm, ← Nat.sq_sub_sq ] ; exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div ( p ^ 2 ) q, h_contra ] ; norm_num [ Nat.mod_eq_of_lt hq.two_le ] ) ;
      rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.Prime.dvd_mul ];
      rcases h_div with ( h | h ) <;> have := Nat.le_of_dvd ( Nat.succ_pos _ ) h <;> simp_all +arith +decide [ Nat.prime_dvd_prime_iff_eq ];
      · linarith;
      · cases this.eq_or_lt <;> first | linarith | simp_all +arith +decide [ Nat.prime_dvd_prime_iff_eq ] ;
        cases Nat.Prime.eq_two_or_odd hp <;> cases Nat.Prime.eq_two_or_odd hq <;> simp_all +arith +decide [ Nat.add_mod, Nat.pow_mod ]