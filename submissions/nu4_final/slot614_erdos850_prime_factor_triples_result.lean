/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7ef62fa0-8b33-4270-89ec-6ed5dff0a93b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.primeFactors

/-
Helper definitions for the Erdos problem. coincides x y means they have the same prime factors. erdos_triple x y means x, x+1, x+2 coincide with y, y+1, y+2 respectively.
-/
def coincides (x y : ℕ) : Prop := x.primeFactors = y.primeFactors

def erdos_triple (x y : ℕ) : Prop :=
  coincides x y ∧ coincides (x + 1) (y + 1) ∧ coincides (x + 2) (y + 2)

/-
Disproof of size_constraint: There exist x, y such that primeFactors(x) = primeFactors(y), x < y, but y < 2x.
-/
theorem size_constraint_false : ∃ x y, x > 0 ∧ coincides x y ∧ x < y ∧ ¬(y ≥ 2 * x) := by
  -- Consider $x = 12$ and $y = 18$.
  use 12, 18
  norm_num [coincides] at *; -- This will lead to a contradiction.
   -- This will skip the current goal and proceed with the next one.
   -- This will skip the current goal and proceed with the next one.;
  native_decide +revert

/-
For any n ≥ 1, gcd(n, n+1) = 1, gcd(n+1, n+2) = 1, and gcd(n, n+2) ∈ {1, 2}.
-/
theorem coprimality_constraints (n : ℕ) (h : n ≥ 1) :
    Nat.gcd n (n + 1) = 1 ∧ Nat.gcd (n + 1) (n + 2) = 1 ∧ (Nat.gcd n (n + 2) = 1 ∨ Nat.gcd n (n + 2) = 2) := by
      norm_num [ add_assoc ];
      exact ⟨ by norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ], by rcases Nat.even_or_odd' n with ⟨ c, rfl | rfl ⟩ <;> simp +arith +decide ⟩

/-
If x ≥ 2 and p is an odd prime, then p cannot be a prime factor of both x and x+1, nor of both x and x+2.
-/
theorem prime_factor_disjointness (x : ℕ) (hx : x ≥ 2) (p : ℕ) (hp : Nat.Prime p) (hp_odd : p ≠ 2) :
    (p ∉ x.primeFactors ∨ p ∉ (x + 1).primeFactors) ∧
    (p ∉ x.primeFactors ∨ p ∉ (x + 2).primeFactors) := by
      by_cases h : p ∣ x <;> by_cases h' : p ∣ x + 1 <;> by_cases h'' : p ∣ x + 2 <;> simp_all +decide [ Nat.dvd_add_right, Nat.dvd_add_left, Nat.Prime.dvd_mul ];
      have := Nat.le_of_dvd ( by decide ) h''; interval_cases p <;> trivial;

/-
For any n ≥ 1 and odd prime p, p divides at most one of {n, n+1, n+2}.
-/
theorem odd_prime_divides_at_most_one_consecutive_triple (n : ℕ) (hn : n ≥ 1) (p : ℕ) (hp : Nat.Prime p) (hp_odd : p ≠ 2) :
    (p ∣ n → ¬p ∣ n + 1 ∧ ¬p ∣ n + 2) ∧
    (p ∣ n + 1 → ¬p ∣ n ∧ ¬p ∣ n + 2) ∧
    (p ∣ n + 2 → ¬p ∣ n ∧ ¬p ∣ n + 1) := by
      refine' ⟨ fun h => _, fun h => _, fun h => _ ⟩;
      · simp_all +decide [ Nat.dvd_add_right ];
        exact ⟨ hp.ne_one, Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne hp.two_le ( Ne.symm hp_odd ) ) ⟩;
      · exact ⟨ fun h' => by have := Nat.dvd_sub' h h'; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ], fun h' => by have := Nat.dvd_sub' h' h; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ⟩;
      · constructor <;> intro H <;> have := Nat.dvd_sub' h H <;> simp_all +arith +decide [ Nat.prime_dvd_prime_iff_eq ]

/-
If x and y form an Erdos triple, then x and y have the same parity (i.e., x ≡ y mod 2).
-/
theorem parity_constraint {x y : ℕ} (h : erdos_triple x y) : x % 2 = y % 2 := by
  -- If x is even, then x+1 is odd, so 2 ∉ primeFactors(x+1).
  by_cases hx_even : x % 2 = 0;
  · -- If x is even, then x+1 is odd, so 2 ∉ primeFactors(x+1). Since primeFactors(x+1) = primeFactors(y+1), 2 ∉ primeFactors(y+1), so y+1 is odd, so y is even.
    have h_even_y : 2 ∉ (y + 1).primeFactors := by
      have := h.2.1;
      rw [ ← this ];
      norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, hx_even ];
    cases Nat.mod_two_eq_zero_or_one y <;> simp_all +decide [ Nat.add_mod ];
  · have := h.2.1; have := h.2.2; unfold coincides at *; simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_iff_eq ] ;
    replace := Finset.ext_iff.mp this 2 ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod ] ;

/-
If x and y form an Erdos triple, then for any odd prime p dividing both x and y, p cannot divide x+1, x+2, y+1, or y+2.
-/
theorem key_structural_constraint {x y : ℕ} (h : erdos_triple x y) (p : ℕ) (hp : Nat.Prime p) (hp_odd : p ≠ 2) :
    (p ∣ x ∧ p ∣ y → ¬p ∣ x + 1 ∧ ¬p ∣ x + 2 ∧ ¬p ∣ y + 1 ∧ ¬p ∣ y + 2) := by
      intro h_div
      have h_not_div_x1 : ¬p ∣ x + 1 := by
        exact fun h => hp.not_dvd_one <| by simpa using Nat.dvd_gcd h h_div.1;
      have h_not_div_x2 : ¬p ∣ x + 2 := by
        intro h_div_x2; haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.factorial ] ;
        rcases p with ( _ | _ | _ | p ) <;> cases h_div_x2 <;> contradiction
      have h_not_div_y1 : ¬p ∣ y + 1 := by
        exact fun h' => by have := Nat.dvd_gcd h_div.2 h'; aesop;;
      have h_not_div_y2 : ¬p ∣ y + 2 := by
        exact fun h => hp_odd <| by have := Nat.dvd_sub' h h_div.2; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
      exact ⟨h_not_div_x1, h_not_div_x2, h_not_div_y1, h_not_div_y2⟩

/-
For all x, y < 100 with x ≠ y, they do not form an Erdos triple.
-/
theorem bounded_verification_small : ∀ x y, x < 100 → y < 100 → x ≠ y → ¬erdos_triple x y := by
  intros x y hx hy hxy herdos_triple
  obtain ⟨h_x, h_y⟩ := herdos_triple;
  -- By examining all pairs (x, y) with x < y < 100, we can verify that no such pairs satisfy the Erdos triple condition.
  have h_exhaustive : ∀ x ∈ Finset.range 100, ∀ y ∈ Finset.range 100, x < y → ¬ (Nat.primeFactors x = Nat.primeFactors y ∧ Nat.primeFactors (x + 1) = Nat.primeFactors (y + 1) ∧ Nat.primeFactors (x + 2) = Nat.primeFactors (y + 2)) := by
    native_decide;
  cases lt_or_gt_of_ne hxy <;> [ exact h_exhaustive _ ( Finset.mem_range.mpr hx ) _ ( Finset.mem_range.mpr hy ) ‹_› ⟨ h_x, h_y ⟩ ; exact h_exhaustive _ ( Finset.mem_range.mpr hy ) _ ( Finset.mem_range.mpr hx ) ‹_› ⟨ h_x.symm, h_y.1.symm, h_y.2.symm ⟩ ]

/-
If x = 2^k is part of an Erdos triple with y, then y must also be a power of 2.
-/
theorem erdos_triple_pow_two_implies_y_pow_two {k y : ℕ} (hk : k > 0) (h : erdos_triple (2^k) y) : ∃ m, y = 2^m := by
  -- By definition of coincides, we know that the prime factors of y are the same as those of 2^k.
  have h_prime_factors : y.primeFactors = {2} := by
    have := h.1;
    rw [ ← this, Nat.primeFactors_pow ] <;> norm_num [ hk.ne' ];
  rw [ ← Nat.factorization_prod_pow_eq_self ( show y ≠ 0 by rintro rfl; simp_all +decide ) ] ; rw [ Finsupp.prod ] ; aesop;

/-
If n > 0 and prime p divides 2^n + 1, then the exponent of 2 in the prime factorization of the multiplicative order of 2 modulo p is exactly one greater than the exponent of 2 in n.
-/
theorem order_of_two_mod_p_of_dvd_pow_add_one_corrected {n : ℕ} {p : ℕ} (hn : n > 0) (hp : Nat.Prime p) (h : p ∣ 2^n + 1) :
    (orderOf (2 : ZMod p)).factorization 2 = n.factorization 2 + 1 := by
      -- Let $d$ be the order of $2$ modulo $p$. Then $d$ divides $2n$ but not $n$.
      set d := orderOf (2 : ZMod p) with hd
      have hd_div : d ∣ 2 * n := by
        rw [ orderOf_dvd_iff_pow_eq_one ];
        simp_all +decide [ ← ZMod.natCast_eq_zero_iff, pow_mul' ];
        rw [ add_eq_zero_iff_eq_neg ] at h ; aesop
      have hd_not_div : ¬(d ∣ n) := by
        rw [ orderOf_dvd_iff_pow_eq_one ] at *;
        intro H; haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
        rcases n with ( _ | _ | n ) <;> norm_num [ pow_succ' ] at * ; aesop;
        aesop;
      -- Since $d$ divides $2n$ but not $n$, we have $v2(d) = v2(2n)$.
      have hv2_d_eq_v2_2n : (Nat.factorization d) 2 = (Nat.factorization (2 * n)) 2 := by
        obtain ⟨ k, hk ⟩ := hd_div;
        rw [ hk, Nat.factorization_mul ] <;> norm_num;
        · exact Nat.factorization_eq_zero_of_not_dvd fun h => hd_not_div <| by exact ⟨ k / 2, by nlinarith [ Nat.div_mul_cancel h ] ⟩ ;
        · grind;
        · grind;
      rw [ hv2_d_eq_v2_2n, Nat.factorization_mul ] <;> norm_num [ hn.ne' ];
      ring

/-
If the 2-adic valuations of k and m are different, then 2^k + 1 and 2^m + 1 are coprime.
-/
theorem pow_two_add_one_coprime_of_v2_ne {k m : ℕ} (h : k.factorization 2 ≠ m.factorization 2) :
    Nat.Coprime (2^k + 1) (2^m + 1) := by
      -- Assume there exists a prime $p$ that divides both $2^k + 1$ and $2^m + 1$.
      by_contra h_contra
      obtain ⟨p, hp_prime, hp_div_k, hp_div_m⟩ : ∃ p, Nat.Prime p ∧ p ∣ 2^k + 1 ∧ p ∣ 2^m + 1 := by
        exact Nat.Prime.not_coprime_iff_dvd.mp h_contra;
      -- Then $2^k \equiv -1 \pmod p$ and $2^m \equiv -1 \pmod p$.
      have h_cong_k : 2 ^ k ≡ -1 [ZMOD p] := by
        exact Eq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using hp_div_k;
      have h_cong_m : 2 ^ m ≡ -1 [ZMOD p] := by
        exact Eq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using hp_div_m;
      -- Then $2^{2k} \equiv 1 \pmod p$ and $2^{2m} \equiv 1 \pmod p$, so the order $d$ of $2$ modulo $p$ divides both $2k$ and $2m$.
      have h_order_divides_2k_2m : orderOf (2 : ZMod p) ∣ 2 * k ∧ orderOf (2 : ZMod p) ∣ 2 * m := by
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, orderOf_dvd_iff_pow_eq_one ];
        exact ⟨ by linear_combination' h_cong_k * h_cong_k, by linear_combination' h_cong_m * h_cong_m ⟩;
      -- Also, $2^k \equiv -1 \not\equiv 1 \pmod p$, so $d$ does not divide $k$.
      have h_order_not_divides_k : ¬(orderOf (2 : ZMod p) ∣ k) := by
        rw [ orderOf_dvd_iff_pow_eq_one ];
        haveI := Fact.mk hp_prime; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        rw [ neg_eq_iff_add_eq_zero ] ; ring ; aesop;
      -- Similarly, $2^m \equiv -1 \not\equiv 1 \pmod p$, so $d$ does not divide $m$.
      have h_order_not_divides_m : ¬(orderOf (2 : ZMod p) ∣ m) := by
        intro h; haveI := Fact.mk hp_prime; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, orderOf_dvd_iff_pow_eq_one ] ;
      -- Therefore, $v_2(d) = v_2(2k) = v_2(k) + 1$ and $v_2(d) = v_2(2m) = v_2(m) + 1$.
      have h_v2_order : (orderOf (2 : ZMod p)).factorization 2 = (2 * k).factorization 2 ∧ (orderOf (2 : ZMod p)).factorization 2 = (2 * m).factorization 2 := by
        obtain ⟨ a, ha ⟩ := h_order_divides_2k_2m.1; obtain ⟨ b, hb ⟩ := h_order_divides_2k_2m.2; simp_all +decide [ Nat.factorization_mul ] ;
        rw [ Nat.factorization_mul, Nat.factorization_mul ] <;> norm_num;
        · exact ⟨ Nat.factorization_eq_zero_of_not_dvd fun ha' => h_order_not_divides_k <| by exact ⟨ a / 2, by nlinarith [ Nat.div_mul_cancel ha' ] ⟩, Nat.factorization_eq_zero_of_not_dvd fun hb' => h_order_not_divides_m <| by exact ⟨ b / 2, by nlinarith [ Nat.div_mul_cancel hb' ] ⟩ ⟩;
        · exact isOfFinOrder_iff_pow_eq_one.mpr ⟨ p - 1, Nat.sub_pos_of_lt hp_prime.one_lt, by haveI := Fact.mk hp_prime; simpa [ ← ZMod.intCast_eq_intCast_iff ] using ZMod.pow_card_sub_one_eq_one ( by intro h; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ) ⟩;
        · rintro rfl; simp_all +singlePass;
        · exact isOfFinOrder_iff_pow_eq_one.mpr ⟨ p - 1, Nat.sub_pos_of_lt hp_prime.one_lt, by haveI := Fact.mk hp_prime; simpa [ ← ZMod.intCast_eq_intCast_iff ] using ZMod.pow_card_sub_one_eq_one ( by intro h; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ) ⟩;
        · rintro rfl; simp_all +singlePass;
      rcases k with ( _ | k ) <;> rcases m with ( _ | m ) <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
      exact h ( by linarith )

/-
If 2^k+1 and 2^m+1 have the same prime factors, then k and m have the same 2-adic valuation.
-/
theorem coincides_pow_two_add_one_implies_v2_eq {k m : ℕ} (hk : k > 0) (hm : m > 0) (h : coincides (2^k + 1) (2^m + 1)) :
    k.factorization 2 = m.factorization 2 := by
      by_contra h_contra;
      -- By pow_two_add_one_coprime_of_v2_ne, 2^k+1 and 2^m+1 are coprime.
      have h_coprime : Nat.Coprime (2^k + 1) (2^m + 1) := by
        exact?;
      -- Since $2^k + 1$ and $2^m + 1$ are coprime, their prime factors must be disjoint.
      have h_disjoint : Disjoint (Nat.primeFactors (2^k + 1)) (Nat.primeFactors (2^m + 1)) := by
        exact h_coprime.disjoint_primeFactors;
      simp_all +decide [ Finset.disjoint_left, coincides ]

/-
coincides (2^k + 2) (2^m + 2) is equivalent to coincides (2^(k-1) + 1) (2^(m-1) + 1) for k, m >= 1.
-/
theorem coincides_succ_pow_two {k m : ℕ} (hk : k ≥ 1) (hm : m ≥ 1) :
    coincides (2^k + 2) (2^m + 2) ↔ coincides (2^(k-1) + 1) (2^(m-1) + 1) := by
      unfold coincides;
      rw [ show 2 ^ k + 2 = 2 * ( 2 ^ ( k - 1 ) + 1 ) by rw [ mul_add, ← pow_succ', Nat.sub_add_cancel hk ], show 2 ^ m + 2 = 2 * ( 2 ^ ( m - 1 ) + 1 ) by rw [ mul_add, ← pow_succ', Nat.sub_add_cancel hm ], Nat.primeFactors_mul, Nat.primeFactors_mul ] <;> norm_num;
      by_cases h : 2 ∈ ( 2 ^ ( k - 1 ) + 1 |> Nat.primeFactors ) <;> by_cases h' : 2 ∈ ( 2 ^ ( m - 1 ) + 1 |> Nat.primeFactors ) <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod ];
      · rcases k with ( _ | _ | k ) <;> rcases m with ( _ | _ | m ) <;> norm_num at *;
      · rcases k with ( _ | _ | k ) <;> rcases m with ( _ | _ | m ) <;> norm_num at *;
        norm_num [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
        intro h; specialize h ( Nat.minFac ( 2 ^ ( m + 1 ) + 1 ) ) ( Nat.minFac_prime ( by norm_num ) ) ( Nat.minFac_dvd _ ) ; simp_all +decide [ Nat.dvd_add_right ( dvd_pow_self _ _ ) ] ;
      · rcases k with ( _ | _ | k ) <;> rcases m with ( _ | _ | m ) <;> simp_all +decide;
        norm_num [ Finset.eq_singleton_iff_unique_mem ];
        exact fun h => absurd ( h ( Nat.minFac ( 2 ^ ( k + 1 ) + 1 ) ) ( Nat.minFac_prime ( by norm_num ) ) ( Nat.minFac_dvd _ ) ) ( by norm_num [ Nat.dvd_add_right ( dvd_pow_self _ _ ) ] );
      · rcases k with ( _ | _ | k ) <;> rcases m with ( _ | _ | m ) <;> simp_all +decide;
        constructor <;> intro h <;> ext p <;> by_cases hp : p = 2 <;> simp_all +decide [ Nat.dvd_add_right, dvd_pow_self ];
        intro pp; replace h := Finset.ext_iff.mp h p; aesop;