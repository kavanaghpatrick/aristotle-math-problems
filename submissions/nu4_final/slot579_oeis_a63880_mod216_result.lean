/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 12045ca9-f136-4d22-8f43-f89c51776eeb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of unitary divisors and the sum of unitary divisors function (usigma).
A divisor d of n is unitary if gcd(d, n/d) = 1.
usigma(n) is the sum of all unitary divisors of n.
-/
def unitaryDivisors (n : ℕ) : Finset ℕ :=
  n.divisors.filter (fun d => n.gcd (n / d) = 1)

def usigma (n : ℕ) : ℕ :=
  ∑ d ∈ unitaryDivisors n, d

/-
Check values of usigma and sigma for 6 and 108.
-/
#eval usigma 6
#eval ArithmeticFunction.sigma 1 6
#eval usigma 108
#eval ArithmeticFunction.sigma 1 108

/-
Check behavior of divisors and usigma at 0.
-/
#eval Nat.divisors 0
#eval usigma 0

/-
Define the ratio function R(n) = σ(n) / usigma(n).
-/
noncomputable def ratio (n : ℕ) : ℚ := (ArithmeticFunction.sigma 1 n : ℚ) / (usigma n : ℚ)

/-
The condition ratio(n) = 2 is equivalent to σ(n) = 2·usigma(n).
-/
theorem ratio_eq_two_iff (n : ℕ) (hn : n > 0) :
  ratio n = 2 ↔ ArithmeticFunction.sigma 1 n = 2 * usigma n := by
    unfold ratio;
    constructor <;> intro h <;> rw [ div_eq_iff ] at * <;> norm_cast at * <;> aesop

/-
Correct definition of unitary divisors and usigma.
A divisor d of n is unitary if gcd(d, n/d) = 1.
usigma'(n) is the sum of unitary divisors.
-/
def unitaryDivisors' (n : ℕ) : Finset ℕ :=
  n.divisors.filter (fun d => Nat.gcd d (n / d) = 1)

def usigma' (n : ℕ) : ℕ :=
  ∑ d ∈ unitaryDivisors' n, d

/-
Define usigma as an ArithmeticFunction.
-/
def usigmaAF : ArithmeticFunction ℕ :=
  ⟨usigma', by
    simp only [usigma', unitaryDivisors']
    have : Nat.divisors 0 = ∅ := by rfl
    simp [this]⟩

/-
usigma is a multiplicative function.
-/
theorem usigma_is_multiplicative : usigmaAF.IsMultiplicative := by
  -- To prove multiplicativity, we use the fact that the product of unitary divisors of two coprime numbers is unitary.
  have h_unitary_mul : ∀ a b : ℕ, a.Coprime b → ∀ d ∈ Nat.divisors (a * b), Nat.gcd d (a * b / d) = 1 ↔ ∃ d1 ∈ Nat.divisors a, ∃ d2 ∈ Nat.divisors b, d = d1 * d2 ∧ Nat.gcd d1 (a / d1) = 1 ∧ Nat.gcd d2 (b / d2) = 1 := by
    intro a b hab;
    -- If $d$ divides $a*b$ and $\gcd(d, a*b/d) = 1$, then $d$ can be written as $d1*d2$ where $d1$ divides $a$ and $d2$ divides $b$, and $\gcd(d1, a/d1) = 1$ and $\gcd(d2, b/d2) = 1$.
    intro d hd
    constructor
    intro h_gcd
    obtain ⟨d1, d2, hd1, hd2, hd_eq⟩ : ∃ d1 d2, d1 ∣ a ∧ d2 ∣ b ∧ d = d1 * d2 := by
      exact Exists.imp ( by aesop ) ( Nat.dvd_mul.mp ( Nat.dvd_of_mem_divisors hd ) );
    · refine' ⟨ d1, _, d2, _, hd_eq, _, _ ⟩ <;> simp_all +decide [ Nat.mul_div_mul_comm ];
      · simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      · simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
    · rintro ⟨ d1, hd1, d2, hd2, rfl, h1, h2 ⟩;
      rw [ Nat.mul_div_mul_comm ( Nat.dvd_of_mem_divisors hd1 ) ( Nat.dvd_of_mem_divisors hd2 ) ];
      apply_rules [ Nat.Coprime.mul_left, Nat.Coprime.symm ];
      · exact Nat.Coprime.coprime_dvd_left ( Nat.dvd_of_mem_divisors hd1 ) ( Nat.Coprime.coprime_dvd_right ( Nat.div_dvd_of_dvd <| Nat.dvd_of_mem_divisors hd2 ) hab );
      · refine' Nat.Coprime.mul_right _ _;
        · refine' Nat.Coprime.coprime_dvd_left ( Nat.dvd_of_mem_divisors hd2 ) _;
          exact hab.symm.coprime_dvd_right ( Nat.div_dvd_of_dvd <| Nat.dvd_of_mem_divisors hd1 );
        · assumption;
  -- Apply the hypothesis `h_unitary_mul` to rewrite the unitary divisors of `a * b` in terms of the unitary divisors of `a` and `b`.
  have h_unitary_divisors : ∀ a b : ℕ, a.Coprime b → unitaryDivisors' (a * b) = Finset.image (fun (p : ℕ × ℕ) => p.1 * p.2) (unitaryDivisors' a ×ˢ unitaryDivisors' b) := by
    intros a b hab
    ext d
    simp [unitaryDivisors', h_unitary_mul a b hab];
    constructor <;> intro h;
    · rcases h_unitary_mul a b hab d ( Nat.mem_divisors.mpr ⟨ h.1.1, by aesop ⟩ ) |>.1 h.2 with ⟨ d1, hd1, d2, hd2, rfl, hd1', hd2' ⟩ ; use d1, d2 ; aesop;
    · rcases h with ⟨ x, y, ⟨ ⟨ ⟨ hx₁, hx₂ ⟩, hx₃ ⟩, ⟨ ⟨ hy₁, hy₂ ⟩, hy₃ ⟩ ⟩, rfl ⟩ ; specialize h_unitary_mul a b hab ( x * y ) ; simp_all +decide [ Nat.mul_dvd_mul ] ;
      exact ⟨ x, hx₁, y, hy₁, rfl, hx₃, hy₃ ⟩;
  -- Apply the hypothesis `h_unitary_divisors` to rewrite the sum of unitary divisors of `a * b` in terms of the sums of unitary divisors of `a` and `b`.
  have h_unitary_sum : ∀ a b : ℕ, a.Coprime b → usigma' (a * b) = usigma' a * usigma' b := by
    intros a b hab
    simp [h_unitary_divisors a b hab, usigma'];
    rw [ Finset.sum_image, Finset.sum_product ];
    · rw [ Finset.sum_mul_sum ];
    · intros p hp q hq h_eq; simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ] ;
      -- Since $p.1 \mid a$ and $q.1 \mid a$, and $\gcd(a, b) = 1$, it follows that $p.1 = q.1$.
      have h_p1_eq_q1 : p.1 = q.1 := by
        exact Nat.dvd_antisymm ( by exact Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( p.1 ) ( q.2 ) from Nat.Coprime.coprime_dvd_left ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hp.1 |>.1 ) <| Nat.Coprime.coprime_dvd_right ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hq.2 |>.1 ) hab ) <| h_eq ▸ dvd_mul_right _ _ ) ( by exact Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( q.1 ) ( p.2 ) from Nat.Coprime.coprime_dvd_left ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hq.1 |>.1 ) <| Nat.Coprime.coprime_dvd_right ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hp.2 |>.1 ) hab ) <| h_eq.symm ▸ dvd_mul_right _ _ );
      unfold unitaryDivisors' at *; aesop;
  constructor <;> aesop

/-
For a prime power p^k with k >= 1, the sum of unitary divisors is 1 + p^k.
The only unitary divisors are 1 and p^k.
-/
theorem usigma_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≥ 1) :
  usigma' (p ^ k) = 1 + p ^ k := by
    unfold usigma' unitaryDivisors';
    norm_num [ Nat.divisors_prime_pow hp, Finset.sum_filter ];
    rw [ Finset.sum_range_succ ];
    rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', Nat.div_eq_of_lt ];
    · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.div_self ];
    · rw [ Finset.sum_eq_single 0 ] <;> simp_all +decide [ Nat.pow_succ', Nat.mul_assoc, Nat.mul_div_assoc, hp.ne_zero ];
      · rw [ Nat.div_self ( by exact Nat.mul_pos hp.pos ( Nat.mul_pos hp.pos ( pow_pos hp.pos _ ) ) ) ] ; aesop;
      · intro b hb hb'; rcases b with ( _ | _ | b ) <;> simp_all +decide [ Nat.pow_succ', Nat.mul_div_assoc, Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ] ;
        · exact hp.ne_one;
        · norm_num [ Nat.mul_div_mul_left, hp.pos ];
          rw [ Nat.Coprime, Nat.gcd_eq_left ( Nat.dvd_div_of_mul_dvd _ ) ];
          · aesop;
          · rw [ ← pow_succ ] ; exact pow_dvd_pow _ ( Nat.succ_le_of_lt hb )

/-
Define ratio' using the correct usigma' function.
-/
noncomputable def ratio' (n : ℕ) : ℚ := (ArithmeticFunction.sigma 1 n : ℚ) / (usigma' n : ℚ)

/-
Prove ratio'(p) = 1 for prime p.
-/
theorem ratio'_prime {p : ℕ} (hp : p.Prime) : ratio' p = 1 := by
  -- For a prime $p$, the only unitary divisors are $1$ and $p$, so usigma'(p) = 1 + p.
  have h_unitary_prime : usigma' p = 1 + p := by
    convert usigma_prime_pow hp ( Nat.succ_pos 0 ) using 1;
    · norm_num;
    · norm_num;
  unfold ratio';
  rw [ div_eq_iff ] <;> norm_cast <;> simp_all +decide [ ArithmeticFunction.sigma_apply, Nat.Prime.ne_zero ];
  ring

/-
Prove the formula for ratio'(p^k).
-/
theorem ratio'_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≥ 1) :
  ratio' (p ^ k) = ((p : ℚ) ^ (k + 1) - 1) / ((p - 1) * ((p : ℚ) ^ k + 1)) := by
    -- By definition of $ratio'$, we have:
    unfold ratio';
    rw [ show ( ArithmeticFunction.sigma 1 ) ( p ^ k ) = ∑ i ∈ Finset.range ( k + 1 ), p ^ i from ?_, show usigma' ( p ^ k ) = 1 + p ^ k from ?_ ];
    · norm_num [ ← geom_sum_mul, mul_comm ];
      rw [ mul_div_mul_right _ _ ( sub_ne_zero_of_ne ( mod_cast hp.ne_one ) ) ] ; ring;
    · convert usigma_prime_pow hp hk using 1;
    · simp +decide [ ArithmeticFunction.sigma, Nat.divisors_prime_pow hp ]

/-
Prove ratio'(p^k) > 1 for k >= 2.
-/
theorem ratio'_prime_pow_gt_one {p k : ℕ} (hp : p.Prime) (hk : k ≥ 2) :
  ratio' (p ^ k) > 1 := by
    have h_ratio : ratio' (p ^ k) = ((p : ℚ) ^ (k + 1) - 1) / ((p - 1) * ((p : ℚ) ^ k + 1)) := by
      convert ratio'_prime_pow hp ( by linarith ) using 1;
    rw [ h_ratio, gt_iff_lt, one_lt_div ] <;> nlinarith [ show ( p : ℚ ) ≥ 2 by exact_mod_cast hp.two_le, pow_lt_pow_right₀ ( show ( p : ℚ ) > 1 by exact_mod_cast hp.one_lt ) ( show k > 1 by linarith ), pow_succ' ( p : ℚ ) k ]

/-
Upper bound for ratio'(p^k): R(p^k) < p/(p-1).
Proof:
R(p^k) = (p^(k+1)-1)/((p-1)(p^k+1))
We want to show (p^(k+1)-1)/((p-1)(p^k+1)) < p/(p-1)
<=> (p^(k+1)-1)/(p^k+1) < p
<=> p^(k+1)-1 < p(p^k+1)
<=> p^(k+1)-1 < p^(k+1)+p
<=> -1 < p
which is true for any prime p.
-/
theorem ratio_bound {p k : ℕ} (hp : p.Prime) (hk : k ≥ 2) :
  ratio' (p ^ k) < (p : ℚ) / ((p : ℚ) - 1) := by
    -- Substitute the formula for ratio' (p^k) from theorem ratio'_prime_pow.
    rw [ratio'_prime_pow hp (by linarith)];
    rw [ div_lt_div_iff₀ ] <;> nlinarith [ show ( p : ℚ ) > 1 by exact mod_cast hp.one_lt, pow_pos ( show ( p : ℚ ) > 0 by exact mod_cast hp.pos ) k, pow_succ' ( p : ℚ ) k ]

/-
Upper bound for ratio'(2^k): R(2^k) < 2.
Follows from ratio_bound with p=2: R(2^k) < 2/(2-1) = 2.
-/
theorem ratio_two_bound {k : ℕ} (hk : k ≥ 2) :
  ratio' (2 ^ k) < 2 := by
    convert ratio_bound ( by norm_num : Nat.Prime 2 ) hk using 1 ; norm_num

/-
Upper bound for ratio'(3^k): R(3^k) < 1.5.
Follows from ratio_bound with p=3: R(3^k) < 3/2.
-/
theorem ratio_three_bound {k : ℕ} (hk : k ≥ 2) :
  ratio' (3 ^ k) < 3/2 := by
    convert ratio_bound ( by norm_num : Nat.Prime 3 ) hk using 1 ; norm_num

/-
Check that arithmetic functions map 0 to 0.
-/
theorem ArithmeticFunction_map_zero {R : Type*} [Zero R] (f : ArithmeticFunction R) : f 0 = 0 := by
  exact f.map_zero

/-
Define ratioAF as an ArithmeticFunction.
ratio'(0) = 0 because sigma(0)=0 and usigma'(0)=0.
-/
def ratioAF : ArithmeticFunction ℚ :=
  ⟨ratio', by
    simp only [ratio', usigma', unitaryDivisors']
    rw [ArithmeticFunction_map_zero]
    simp
  ⟩

/-
Prove that ratio' is multiplicative.
ratio'(mn) = sigma(mn)/usigma'(mn) = (sigma(m)sigma(n))/(usigma'(m)usigma'(n)) = ratio'(m)ratio'(n).
-/
theorem ratio'_is_multiplicative :
  ∀ {m n : ℕ}, m.Coprime n → ratio' (m * n) = ratio' m * ratio' n := by
    intros m n h_coprime;
    -- By definition of ratio', we have ratio' (m * n) = (ArithmeticFunction.sigma 1 (m * n)) / (usigma' (m * n)).
    simp [ratio'];
    -- By definition of multiplicative functions, we have that if $f$ and $g$ are multiplicative, then $f(m * n) = f(m) * f(n)$ and $g(m * n) = g(m) * g(n)$ for coprime $m$ and $n$.
    have h_mul_sigma : ArithmeticFunction.sigma 1 (m * n) = ArithmeticFunction.sigma 1 m * ArithmeticFunction.sigma 1 n := by
      simp +decide [ ArithmeticFunction.sigma, Nat.divisors_mul ];
      rw [ ← Nat.divisors_mul ];
      exact?
    have h_mul_usigma : usigma' (m * n) = usigma' m * usigma' n := by
      convert usigma_is_multiplicative.2 h_coprime using 1;
    rw [ h_mul_sigma, h_mul_usigma, Nat.cast_mul, Nat.cast_mul, div_mul_div_comm ]

/-
Prove ratio'(108) = 2.
108 = 4 * 27 = 2^2 * 3^3.
ratio'(108) = ratio'(2^2) * ratio'(3^3).
Calculate each part and multiply.
-/
theorem ratio'_108 : ratio' 108 = 2 := by
  have h1 : 108 = 4 * 27 := by norm_num
  have h2 : Nat.Coprime 4 27 := by norm_num
  rw [h1, ratio'_is_multiplicative h2]
  have h3 : 4 = 2^2 := by norm_num
  have h4 : 27 = 3^3 := by norm_num
  rw [h3, h4]
  rw [ratio'_prime_pow (by norm_num) (by norm_num)]
  rw [ratio'_prime_pow (by norm_num) (by norm_num)]
  norm_num

/-
Define the powerful part of n as the product of prime factors with exponent >= 2.
-/
def powerfulPart (n : ℕ) : ℕ :=
  ∏ p ∈ n.primeFactors.filter (fun p => n.factorization p ≥ 2), p ^ (n.factorization p)

/-
Prove that the powerful part divides n.
-/
theorem powerfulPart_dvd (n : ℕ) : powerfulPart n ∣ n := by
  by_cases hn : n = 0;
  · simp +decide [ hn, powerfulPart ];
  · -- Since the product of the prime factors with exponents at least 2 is a divisor of n, we can conclude that powerfulPart n divides n.
    have h_prod_div : (∏ p ∈ n.primeFactors.filter (fun p => n.factorization p ≥ 2), p ^ (n.factorization p)) ∣ (∏ p ∈ n.primeFactors, p ^ (n.factorization p)) := by
      apply_rules [ Finset.prod_dvd_prod_of_subset, Finset.filter_subset ];
    convert h_prod_div using 1;
    exact Eq.symm ( Nat.factorization_prod_pow_eq_self hn )

/-
Prove ratio'(s) = 1 for squarefree s using Nat.recOnMul.
We use the motive `fun n => Squarefree n -> ratio' n = 1`.
The induction step handles `a * b` given hypotheses for `a` and `b`.
Note: `Nat.recOnMul` applies `mul` to `a` and `b` which are not necessarily coprime, but `Nat.recOnMul` constructs numbers from primes.
Actually `Nat.recOnMul` doesn't guarantee `a` and `b` are coprime or anything. It just says every number is built from 0, 1, primes, and multiplication.
Wait, `Nat.recOnMul` might not be the best induction principle if it doesn't enforce coprimality.
However, if `s` is squarefree and `s = a * b`, then `a` and `b` must be coprime.
So the proof strategy holds.
-/
theorem ratio_squarefree {s : ℕ} (hs : Squarefree s) : ratio' s = 1 := by
  unfold ratio';
  -- Since $s$ is squarefree, its unitary divisors are exactly its divisors.
  have h_unitary_divisors : unitaryDivisors' s = Nat.divisors s := by
    ext d
    simp [unitaryDivisors'];
    intro hd hs_ne_zero
    have h_coprime : Nat.gcd d (s / d) = 1 := by
      obtain ⟨ k, hk ⟩ := hd;
      simp_all +decide [ Nat.squarefree_mul_iff ]
    exact h_coprime;
  unfold usigma';
  simp_all +decide [ ArithmeticFunction.sigma ];
  rw [ div_self <| ne_of_gt <| Finset.sum_pos ( fun x hx => Nat.cast_pos.mpr <| Nat.pos_of_mem_divisors hx ) ⟨ 1, by aesop ⟩ ]

/-
Prove ratio'(n) = ratio'(powerfulPart n).
n = powerfulPart n * s.
powerfulPart n and s are coprime.
s is squarefree.
ratio'(n) = ratio'(powerfulPart n) * ratio'(s) = ratio'(powerfulPart n) * 1.
-/
theorem ratio_eq_powerfulPart (n : ℕ) (hn : n ≠ 0) : ratio' n = ratio' (powerfulPart n) := by
  -- Let $s$ be the squarefree part of $n$, so $n = powerfulPart n * s$.
  obtain ⟨s, hs⟩ : ∃ s, n = powerfulPart n * s ∧ Squarefree s := by
    -- Define s as the product of p^(e) where p is a prime factor of n and e is 1 if the exponent is 1, and 0 otherwise.
    set s := ∏ p ∈ n.primeFactors, p ^ (if n.factorization p = 1 then 1 else 0) with hs_def;
    have hs_squarefree : Squarefree s := by
      have hs_squarefree : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → Squarefree (∏ p ∈ S, p) := by
        intros S hS; induction S using Finset.induction <;> simp_all +decide [ Nat.squarefree_mul_iff ] ;
        exact ⟨ Nat.Coprime.prod_right fun p hp => hS.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.prime_dvd_prime_iff_eq hS.1 ( hS.2 p hp ) ; aesop, hS.1.squarefree ⟩;
      convert hs_squarefree fun p hp => ?_ using 1;
      any_goals exact n.primeFactors.filter fun p => n.factorization p = 1;
      · rw [ Finset.prod_filter ] ; exact Finset.prod_congr rfl fun x hx => by aesop;
      · exact Nat.prime_of_mem_primeFactors <| Finset.filter_subset _ _ hp
    have h_factor : n = powerfulPart n * s := by
      conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ];
      rw [ show powerfulPart n = ∏ p ∈ n.primeFactors, p ^ ( if n.factorization p ≥ 2 then n.factorization p else 0 ) from ?_, ← Finset.prod_mul_distrib ];
      · refine' Finset.prod_congr rfl fun p hp => _;
        rcases k : Nat.factorization n p with ( _ | _ | k ) <;> simp_all +decide [ pow_add ];
      · exact Finset.prod_filter _ _ |> Eq.trans <| Finset.prod_congr rfl fun x hx => by aesop;
    use s;
  rw [ hs.1, ratio'_is_multiplicative ];
  · rw [ ← hs.1, ratio_squarefree hs.2, mul_one ];
  · refine' Nat.coprime_of_dvd' _;
    intro k hk hk₁ hk₂;
    -- Since $k$ divides $s$ and $s$ is squarefree, $k$ must appear in the prime factorization of $s$ with exponent 1.
    have hk_exp_s : (Nat.factorization s) k = 1 := by
      exact Nat.factorization_eq_one_of_squarefree hs.2 hk hk₂;
    -- Since $k$ divides $powerfulPart n$, $k$ must appear in the prime factorization of $powerfulPart n$ with exponent at least 2.
    have hk_exp_powerful : (Nat.factorization (powerfulPart n)) k ≥ 2 := by
      have hk_exp_powerful : k ∈ n.primeFactors.filter (fun p => n.factorization p ≥ 2) := by
        simp +decide [ hk, hk₁, hk₂, hk_exp_s ];
        refine' ⟨ ⟨ _, hn ⟩, _ ⟩;
        · exact hs.1.symm ▸ dvd_mul_of_dvd_left hk₁ _;
        · rw [ hs.1, Nat.factorization_mul ] <;> norm_num [ hk₁, hk₂, hk_exp_s ];
          · exact Nat.succ_le_succ ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by { exact Nat.mem_primeFactors.mpr ⟨ hk, hk₁, by { intro t; simp_all +singlePass } ⟩ } ) ) );
          · exact Finset.prod_ne_zero_iff.mpr fun p hp => pow_ne_zero _ <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors <| Finset.mem_filter.mp hp |>.1;
          · rintro rfl; simp +decide at hk_exp_s;
      rw [ powerfulPart ] at *;
      rw [ Nat.factorization_prod ] <;> norm_num at *;
      · exact le_trans hk_exp_powerful.2 ( Finset.single_le_sum ( fun x hx => Nat.zero_le ( Nat.factorization n x * Nat.factorization x k ) ) ( Finset.mem_filter.mpr ⟨ Nat.mem_primeFactors.mpr ⟨ hk_exp_powerful.1.1, hk_exp_powerful.1.2.1, hk_exp_powerful.1.2.2 ⟩, hk_exp_powerful.2 ⟩ ) |> le_trans ( by simp +decide [ hk.factorization ] ) );
      · intros; subst_vars; contradiction;
    replace hs := congr_arg ( fun x => x.factorization k ) hs.1 ; simp +decide [ hk_exp_s, hk_exp_powerful ] at hs;
    rw [ Nat.factorization_mul ] at hs <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Nat.Prime.dvd_iff_one_le_factorization ];
    · unfold powerfulPart at hk_exp_powerful; simp_all +decide [ Nat.factorization_prod ] ;
      rw [ Finset.sum_eq_single k ] at hk_exp_powerful <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Nat.Prime.dvd_iff_one_le_factorization ];
      · unfold powerfulPart at *; simp_all +decide [ Nat.factorization_prod ] ;
        rw [ Finset.sum_eq_single k ] at hs <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Nat.Prime.dvd_iff_one_le_factorization ];
      · exact Finset.prod_ne_zero_iff.mpr fun p hp => pow_ne_zero _ <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors <| Finset.mem_filter.mp hp |>.1;
    · aesop;
    · aesop_cat

/-
Prove ratio'(s) = 1 for squarefree s.
Renamed to ratio_squarefree' to avoid conflict.
-/
theorem ratio_squarefree' {s : ℕ} (hs : Squarefree s) : ratio' s = 1 := by
  convert ratio_squarefree hs using 1

/-
Prove ratio'(n) = ratio'(powerfulPart n).
Renamed to ratio_eq_powerfulPart' to avoid conflict.
-/
theorem ratio_eq_powerfulPart' (n : ℕ) (hn : n ≠ 0) : ratio' n = ratio' (powerfulPart n) := by
  convert ratio_eq_powerfulPart n hn using 1

/-
Decomposition of n into powerful part and squarefree part.
n = powerfulPart n * s, where s is squarefree and coprime to powerfulPart n.
s is the product of prime factors with exponent 1.
-/
theorem n_eq_powerfulPart_mul_squarefree (n : ℕ) (hn : n ≠ 0) :
  ∃ s : ℕ, n = powerfulPart n * s ∧ Squarefree s ∧ (powerfulPart n).Coprime s := by
    -- Let $s$ be the product of the prime factors of $n$ with exponent 1.
    set s := ∏ p ∈ n.primeFactors.filter (fun p => n.factorization p = 1), p ^ (n.factorization p);
    refine' ⟨ s, _, _, _ ⟩;
    · conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ];
      rw [ Finsupp.prod_of_support_subset ];
      case s => exact n.primeFactors.filter ( fun p => n.factorization p ≥ 2 ) ∪ n.primeFactors.filter ( fun p => n.factorization p = 1 );
      · rw [ Finset.prod_union ];
        · congr! 1;
        · exact Finset.disjoint_filter.mpr fun _ _ _ _ => by linarith;
      · intro p hp; cases lt_or_eq_of_le ( Nat.succ_le_of_lt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) ) <;> aesop;
      · grind;
    · -- Since $s$ is the product of primes raised to the power of 1, it is squarefree.
      have hs_squarefree : ∀ p ∈ n.primeFactors.filter (fun p => n.factorization p = 1), Nat.Prime p := by
        exact fun p hp => Nat.prime_of_mem_primeFactors <| Finset.filter_subset _ _ hp;
      have hs_squarefree : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → Squarefree (∏ p ∈ S, p) := by
        intros S hS; induction S using Finset.induction <;> simp_all +decide [ Nat.squarefree_mul_iff ] ;
        exact ⟨ Nat.Coprime.prod_right fun p hp => hS.1.coprime_iff_not_dvd.mpr fun h => ‹¬_› <| by have := Nat.prime_dvd_prime_iff_eq hS.1 ( hS.2 p hp ) ; aesop, hS.1.squarefree ⟩;
      convert hs_squarefree ‹_› using 1;
      exact Finset.prod_congr rfl fun x hx => by aesop;
    · refine' Nat.Coprime.prod_right fun p hp => Nat.Coprime.prod_left fun q hq => _;
      exact Nat.coprime_pow_primes _ _ ( by aesop ) ( by aesop ) ( by aesop )

/-
Define IsPowerful: all prime factors have exponent >= 2.
-/
def IsPowerful (n : ℕ) : Prop :=
  ∀ p ∈ n.primeFactors, n.factorization p ≥ 2

/-
Prove that powerfulPart n = n iff n is powerful.
-/
theorem powerfulPart_eq_self_iff (n : ℕ) (hn : n ≠ 0) : powerfulPart n = n ↔ IsPowerful n := by
  unfold IsPowerful powerfulPart;
  constructor <;> intro h;
  · intro p hp; contrapose! h; simp_all +decide [ Finset.prod_eq_prod_diff_singleton_mul hp ] ;
    refine' ne_of_lt ( lt_of_le_of_lt ( Finset.prod_le_prod_of_subset_of_one_le' ( show n.primeFactors.filter ( fun q => 2 ≤ n.factorization q ) ⊆ n.primeFactors \ { p } from fun q hq => _ ) fun q hq _ => Nat.one_le_iff_ne_zero.mpr <| by aesop ) _ );
    · grind;
    · have h_prod_lt_n : ∏ i ∈ n.primeFactors \ {p}, i ^ (n.factorization i) < ∏ i ∈ n.primeFactors, i ^ (n.factorization i) := by
        rw [ Finset.prod_eq_prod_diff_singleton_mul <| Nat.mem_primeFactors.mpr ⟨ hp.1, hp.2, hn ⟩ ];
        exact lt_mul_of_one_lt_right ( Finset.prod_pos fun q hq => pow_pos ( Nat.pos_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) _ ) ( one_lt_pow₀ hp.1.one_lt ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) ) ) ) );
      convert h_prod_lt_n using 1;
      exact Eq.symm ( Nat.factorization_prod_pow_eq_self hn );
  · conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ] ;
    exact Finset.prod_subset ( fun p hp => by aesop ) fun p hp => by aesop;

/-
Solve the Diophantine equation (2*2^a - 1)(3*3^b - 1) = 4(2^a + 1)(3^b + 1) for a, b >= 2.
The only solution is a=2, b=3.
Proof sketch:
Let X = 2^a, Y = 3^b.
Equation simplifies to 2XY - 6X - 7Y - 3 = 0.
2X(Y - 3) = 7Y + 3 = 7(Y - 3) + 24.
2X = 7 + 24/(Y - 3).
So Y - 3 divides 24.
3^b - 3 divides 24.
3(3^(b-1) - 1) divides 24.
3^(b-1) - 1 divides 8.
Possible values for 3^(b-1) - 1 are 1, 2, 4, 8.
Check b=2 and b=3.
b=2 => Y=9 => 2X = 11 => X=5.5 (impossible).
b=3 => Y=27 => 2X = 8 => X=4 => a=2.
b>=4 => 3^(b-1)-1 >= 26 > 8 (impossible).
-/
theorem diophantine_solution (a b : ℕ) (ha : a ≥ 2) (hb : b ≥ 2) :
  (2 * 2^a - 1) * (3 * 3^b - 1) = 4 * (2^a + 1) * (3^b + 1) ↔ a = 2 ∧ b = 3 := by
    zify [ ha, hb ];
    rcases a with ( _ | _ | _ | _ | a ) <;> rcases b with ( _ | _ | _ | _ | b ) <;> norm_num [ pow_succ' ] at *;
    · grind;
    · omega;
    · omega;
    · exact iff_of_false ( by linarith [ pow_pos ( by decide : 0 < 2 ) a ] ) ( by linarith );
    · exact iff_of_false ( by nlinarith [ pow_pos ( by decide : 0 < 2 ) a, pow_pos ( by decide : 0 < 3 ) b ] ) ( by intros h; linarith )

#check IsPowerful

/-
Calculate ratio' for specific powers of 2 and 3.
-/
theorem ratio_2_pow_2 : ratio' (2^2) = 7/5 := by
  rw [ratio'_prime_pow (by norm_num) (by norm_num)]
  norm_num

theorem ratio_2_pow_3 : ratio' (2^3) = 5/3 := by
  rw [ratio'_prime_pow (by norm_num) (by norm_num)]
  norm_num

theorem ratio_3_pow_3 : ratio' (3^3) = 10/7 := by
  rw [ratio'_prime_pow (by norm_num) (by norm_num)]
  norm_num

/-
ratio'(2^k) is increasing for k >= 1.
-/
theorem ratio_2_pow_increasing {a b : ℕ} (h : 1 ≤ a) (hab : a ≤ b) :
  ratio' (2^a) ≤ ratio' (2^b) := by
    -- By definition of ratio', we can rewrite the inequality as $2^{a+1} - 1 / (2^a + 1) \leq 2^{b+1} - 1 / (2^b + 1)$.
    suffices h_ratio_le : ((2 : ℚ) ^ (a + 1) - 1) / ((2 : ℚ) ^ a + 1) ≤ ((2 : ℚ) ^ (b + 1) - 1) / ((2 : ℚ) ^ b + 1) by
      convert h_ratio_le using 1;
      · convert ratio'_prime_pow ( by norm_num : Nat.Prime 2 ) h using 1;
        ring;
      · convert ratio'_prime_pow ( by norm_num : Nat.Prime 2 ) ( by linarith : b ≥ 1 ) using 1 ; norm_num [ ArithmeticFunction.sigma ];
    rw [ div_le_div_iff₀ ] ; ring;
    · nlinarith [ pow_pos ( by norm_num : ( 0 : ℚ ) < 2 ) a, pow_pos ( by norm_num : ( 0 : ℚ ) < 2 ) b, pow_le_pow_right₀ ( by norm_num : ( 1 : ℚ ) ≤ 2 ) h, pow_le_pow_right₀ ( by norm_num : ( 1 : ℚ ) ≤ 2 ) hab ];
    · positivity;
    · positivity

/-
ratio'(3^k) is increasing for k >= 1.
-/
theorem ratio_3_pow_increasing {a b : ℕ} (h : 1 ≤ a) (hab : a ≤ b) :
  ratio' (3^a) ≤ ratio' (3^b) := by
    -- By definition of $ratio'$, we have $ratio'(3^a) = \frac{3^{a+1} - 1}{2(3^a + 1)}$.
    have h_ratio_def : ∀ k : ℕ, 1 ≤ k → ratio' (3^k) = (3^(k+1) - 1 : ℚ) / (2 * (3^k + 1)) := by
      intro k hk; convert ratio'_prime_pow ( by norm_num : Nat.Prime 3 ) hk using 1 ; ring;
    rw [ h_ratio_def a h, h_ratio_def b ( by linarith ), div_le_div_iff₀ ] <;> ring;
    · linarith [ pow_pos ( by norm_num : ( 0 : ℚ ) < 3 ) a, pow_le_pow_right₀ ( by norm_num : ( 1 : ℚ ) ≤ 3 ) hab ];
    · positivity;
    · positivity

/-
Link the integer equation to the solution a=2, b=3.
-/
theorem solve_ratio_eq_two_integers (a b : ℕ) (ha : a ≥ 2) (hb : b ≥ 2) :
  (2 * 2^a - 1) * (3 * 3^b - 1) = 4 * (2^a + 1) * (3^b + 1) ↔ a = 2 ∧ b = 3 := by
  -- This is the integer equation derived from ratio'(2^a * 3^b) = 2.
  -- (2^(a+1)-1)/(2^a+1) * (3^(b+1)-1)/(2*(3^b+1)) = 2
  -- (2*2^a-1)/(2^a+1) * (3*3^b-1)/(2*(3^b+1)) = 2
  -- (2*2^a-1)(3*3^b-1) = 4(2^a+1)(3^b+1)
  apply diophantine_solution a b ha hb

/-
Prove solve_ratio_eq_two by reducing to the Diophantine equation.
-/
theorem solve_ratio_eq_two (a b : ℕ) (ha : a ≥ 2) (hb : b ≥ 2)
  (h : ratio' (2^a * 3^b) = 2) : a = 2 ∧ b = 3 := by
    -- Apply the multiplicative property of ratio' to get the equation for the product.
    have h_eq : ratio' (2 ^ a * 3 ^ b) = ((2 : ℚ) ^ (a + 1) - 1) / ((2 - 1) * (2 ^ a + 1)) * ((3 : ℚ) ^ (b + 1) - 1) / ((3 - 1) * (3 ^ b + 1)) := by
      convert ratio'_is_multiplicative _ using 1;
      · rw [ ratio'_prime_pow ( by norm_num ) ( by linarith ), ratio'_prime_pow ( by norm_num ) ( by linarith ) ] ; ring;
      · apply_mod_cast Nat.Coprime.pow ; norm_num;
    -- Substitute this into the equation and simplify to get the Diophantine equation.
    have h_diophantine : (2 * 2^a - 1 : ℚ) * (3 * 3^b - 1) = 4 * (2^a + 1) * (3^b + 1) := by
      grind;
    apply (diophantine_solution a b ha hb).mp;
    convert h_diophantine using 1 ; ring;
    norm_cast;
    rw [ Int.subNatNat_eq_coe, Int.subNatNat_eq_coe ] ; push_cast ; ring;
    constructor <;> intro <;> nlinarith only [ Nat.sub_add_cancel ( show 1 ≤ 2 ^ a * 2 from Nat.one_le_iff_ne_zero.mpr <| by positivity ), Nat.sub_add_cancel ( show 1 ≤ 3 ^ b * 3 from Nat.one_le_iff_ne_zero.mpr <| by positivity ), ‹_› ] ;

/-
ratio'(2^a * 3^b) >= 2 for a >= 2, b >= 3.
-/
theorem ratio_2_3_ge_2 (a b : ℕ) (ha : a ≥ 2) (hb : b ≥ 3) :
  ratio' (2^a * 3^b) ≥ 2 := by
    -- By definition of $ratio'$, we have $ratio'(2^a * 3^b) = ratio'(2^a) * ratio'(3^b)$.
    have h_ratio_mul : ratio' (2^a * 3^b) = ratio' (2^a) * ratio' (3^b) := by
      apply ratio'_is_multiplicative;
      apply_mod_cast Nat.Coprime.pow ; norm_num;
    -- By definition of $ratio'$, we have $ratio'(2^a) \geq ratio'(2^2)$ and $ratio'(3^b) \geq ratio'(3^3)$.
    have h_ratio_ge : ratio' (2^a) ≥ ratio' (2^2) ∧ ratio' (3^b) ≥ ratio' (3^3) := by
      exact ⟨ ratio_2_pow_increasing ( by linarith ) ( by linarith ), ratio_3_pow_increasing ( by linarith ) ( by linarith ) ⟩;
    exact h_ratio_mul.symm ▸ by rw [ show ratio' ( 2 ^ 2 ) = 7 / 5 by exact? ] at h_ratio_ge; rw [ show ratio' ( 3 ^ 3 ) = 10 / 7 by exact? ] at h_ratio_ge; nlinarith [ show ( 0 : ℚ ) ≤ ratio' ( 2 ^ a ) by exact le_trans ( by norm_num ) h_ratio_ge.1 ] ;

/-
Decomposition of a non-zero powerful number m into 2^a * k where k is odd and powerful, and a is either 0 or >= 2.
-/
theorem powerful_decomposition (m : ℕ) (hm0 : m ≠ 0) (hm : IsPowerful m) :
  ∃ a k, m = 2^a * k ∧ Odd k ∧ IsPowerful k ∧ (a = 0 ∨ a ≥ 2) := by
    refine' ⟨ Nat.factorization m 2, m / 2 ^ Nat.factorization m 2, Eq.symm <| Nat.mul_div_cancel' <| Nat.ordProj_dvd _ _, _, _, _ ⟩;
    · exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) ( Nat.not_dvd_ordCompl ( by norm_num ) ( by aesop ) ) );
    · intro p hp; have := hm p; simp_all +decide [ Nat.factorization_div ( Nat.ordProj_dvd _ _ ) ] ;
      by_cases h : p = 2 <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, Nat.dvd_div_iff_mul_dvd ];
      · exact absurd hp.1 ( Nat.not_dvd_ordCompl ( by norm_num ) ( by aesop ) );
      · exact this ( dvd_trans hp.2.1 ( Nat.div_dvd_of_dvd ( Nat.ordProj_dvd _ _ ) ) );
    · by_cases h₂ : m.factorization 2 = 0 <;> simp_all +decide [ IsPowerful ];
      exact hm 2 Nat.prime_two ( Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.dvd_trans ( pow_dvd_pow _ ( Nat.pos_of_ne_zero h₂ ) ) ( Nat.ordProj_dvd _ _ ) ) ) )

/-
ratio'(p^k) >= 1 for k >= 1.
-/
theorem ratio_prime_pow_ge_one {p k : ℕ} (hp : p.Prime) (hk : k ≥ 1) :
  ratio' (p ^ k) ≥ 1 := by
    -- By definition of $ratio'$, we have $ratio'(p^k) = \frac{\sigma(p^k)}{usigma'(p^k)}$.
    have h_ratio_def : ratio' (p ^ k) = (p ^ (k + 1) - 1) / ((p - 1) * (p ^ k + 1)) := by
      convert ratio'_prime_pow hp hk using 1;
    rcases p with ( _ | _ | p ) <;> simp_all +decide [ pow_succ' ];
    rw [ le_div_iff₀ ] <;> nlinarith [ pow_le_pow_right₀ ( by linarith : 1 ≤ ( p : ℚ ) + 1 + 1 ) hk ]

/-
ratio'(n) >= 1 for non-zero powerful n.
-/
theorem ratio_ge_one_of_powerful (n : ℕ) (hn0 : n ≠ 0) (hn : IsPowerful n) : ratio' n ≥ 1 := by
  -- n is powerful, so n = prod p^k with k >= 2.
  -- ratio' n = prod ratio'(p^k).
  -- ratio'(p^k) >= 1 for k >= 1.
  -- So ratio' n >= 1.
  rw [← Nat.factorization_prod_pow_eq_self hn0]
  -- We need to apply ratio' to the product.
  -- ratio' is multiplicative.
  -- The factors p^k are coprime.
  -- So ratio' (prod p^k) = prod ratio'(p^k).
  have h_ratio_prod : ∀ {S : Finset ℕ} {f : ℕ → ℕ}, (∀ p ∈ S, Nat.Prime p ∧ f p ≥ 1) → ratio' (∏ p ∈ S, p ^ f p) ≥ 1 := by
    intros S f hf
    induction' S using Finset.induction with p S hpS ih;
    · norm_num [ ratio' ];
      native_decide +revert;
    · rw [ Finset.prod_insert hpS ];
      rw [ ratio'_is_multiplicative ];
      · exact one_le_mul_of_one_le_of_one_le ( by simpa using ratio_prime_pow_ge_one ( hf p ( Finset.mem_insert_self p S ) |>.1 ) ( hf p ( Finset.mem_insert_self p S ) |>.2 ) ) ( ih fun q hq => hf q ( Finset.mem_insert_of_mem hq ) );
      · exact Nat.Coprime.prod_right fun q hq => Nat.Coprime.pow _ _ <| by have := Nat.coprime_primes ( hf p ( Finset.mem_insert_self p S ) |>.1 ) ( hf q ( Finset.mem_insert_of_mem hq ) |>.1 ) ; aesop;
  exact h_ratio_prod fun p hp => ⟨ Nat.prime_of_mem_primeFactors hp, Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ⟩

/-
ratio'(n) >= 1 for all n != 0.
-/
theorem ratio_ge_one (n : ℕ) (hn : n ≠ 0) : ratio' n ≥ 1 := by
  -- By definition of $ratio'$, we know that $ratio' n = ratio' (powerfulPart n)$ if $powerfulPart n \neq 0$.
  have h_ratio_eq : ratio' n = ratio' (powerfulPart n) := by
    exact?;
  by_cases h : powerfulPart n = 0 <;> simp_all +decide;
  · exact absurd h <| ne_of_gt <| Finset.prod_pos fun p hp => pow_pos ( Nat.pos_of_mem_primeFactors <| Finset.mem_filter.mp hp |>.1 ) _;
  · -- Since $powerfulPart n$ is powerful, we can apply the result that $ratio' n \geq 1$ for powerful $n$.
    apply ratio_ge_one_of_powerful; assumption;
    intro p hp; contrapose! h; simp_all +decide [ IsPowerful ] ;
    unfold powerfulPart at *; simp_all +decide [ Nat.factorization_prod ] ;
    -- Since $p$ divides the product, there must be some prime factor $q$ of $n$ such that $q = p$ and $q$ has an exponent of at least 2 in the factorization of $n$.
    obtain ⟨q, hq⟩ : ∃ q ∈ n.primeFactors, q = p ∧ 2 ≤ n.factorization q := by
      have h_prime_factor : p ∣ ∏ x ∈ n.primeFactors.filter (fun x => 2 ≤ n.factorization x), x ^ n.factorization x := by
        exact hp.2.1;
      haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Finset.prod_eq_zero_iff ] ;
      obtain ⟨ q, hq₁, hq₂, hq₃ ⟩ := h_prime_factor; rw [ ZMod.natCast_eq_zero_iff ] at *; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
    simp_all +decide [ Finset.sum_eq_single q ];
    exact h.not_le ( le_trans ( by aesop ) ( Finset.single_le_sum ( fun x _ => Nat.zero_le ( n.factorization x * x.factorization p ) ) ( Finset.mem_filter.mpr ⟨ Nat.mem_primeFactors.mpr ⟨ hq.1.1, hq.1.2, hn ⟩, hq.2.2 ⟩ ) ) )

/-
The factorization of the powerful part of n.
If p has exponent >= 2 in n, it has the same exponent in powerfulPart n.
Otherwise, it has exponent 0.
-/
theorem powerfulPart_factorization (n p : ℕ) :
  (powerfulPart n).factorization p = if n.factorization p ≥ 2 then n.factorization p else 0 := by
    -- We can split the factorization into two parts: the product over the prime factors with exponent ≥ 2 and the product over the prime factors with exponent < 2.
    have h_factorization_split : ∀ p, (powerfulPart n).factorization p = ∑ i ∈ n.primeFactors.filter (fun p => (Nat.factorization n p) ≥ 2), (if p = i then (Nat.factorization n p) else 0) := by
      have h_factorization_split : (powerfulPart n).factorization = ∑ i ∈ n.primeFactors.filter (fun p => Nat.factorization n p ≥ 2), (Nat.factorization n i) • Finsupp.single i 1 := by
        rw [ show powerfulPart n = ∏ i ∈ n.primeFactors.filter ( fun p => Nat.factorization n p ≥ 2 ), i ^ ( Nat.factorization n i ) from ?_ ];
        · rw [ Nat.factorization_prod ];
          · exact Finset.sum_congr rfl fun x hx => by rw [ Nat.factorization_pow ] ; aesop;
          · aesop;
        · exact?;
      intro p; rw [ h_factorization_split ] ; simp +decide [ Finsupp.single_apply ] ;
    by_cases h : n.factorization p ≥ 2 <;> simp_all +decide [ Finset.sum_ite ];
    · exact fun h' => absurd ( h' ( by contrapose! h; simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ] ) ( by contrapose! h; simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ] ) ) ( by aesop );
    · split_ifs <;> linarith

/-
powerfulPart n is always a powerful number.
-/
theorem powerfulPart_isPowerful (n : ℕ) : IsPowerful (powerfulPart n) := by
  -- By definition of powerfulPart, for any prime p in its prime factors, the exponent in the factorization of powerfulPart n is at least 2.
  intro p hp
  simp [powerfulPart] at hp;
  -- Since p is a prime factor of the product, there must be at least one x in the prime factors of n such that p divides x^(n.factorization x).
  obtain ⟨x, hx⟩ : ∃ x ∈ n.primeFactors.filter (fun p => 2 ≤ n.factorization p), p ∣ x ^ (n.factorization x) := by
    haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Finset.prod_eq_zero_iff ] ;
  -- Since p divides x^(n.factorization x) and x is a prime factor of n with exponent at least 2, p must be equal to x.
  have hp_eq_x : p = x := by
    exact ( Nat.prime_dvd_prime_iff_eq hp.1 ( Nat.prime_of_mem_primeFactors ( Finset.filter_subset _ _ hx.1 ) ) ) |>.1 ( hp.1.dvd_of_dvd_pow hx.2 ) ▸ rfl;
  simp_all +decide [ powerfulPart_factorization ]

/-
ratio'(n) >= 1 for non-zero powerful n.
Proof uses ratioAF multiplicativity and ratio'(p^k) >= 1.
-/
theorem ratio_ge_one_of_powerful' (n : ℕ) (hn0 : n ≠ 0) (hn : IsPowerful n) : ratio' n ≥ 1 := by
  convert ratio_ge_one n hn0 using 1

/-
ratio'(p^k) is increasing in k.
-/
theorem ratio_prime_pow_increasing {p k : ℕ} (hp : p.Prime) (hk : k ≥ 1) :
  ratio' (p ^ k) ≤ ratio' (p ^ (k + 1)) := by
    -- By simplifying, we can see that the inequality holds.
    have h_simplify : ((p : ℚ) ^ (k + 1) - 1) / ((p - 1) * ((p : ℚ) ^ k + 1)) ≤ ((p : ℚ) ^ (k + 2) - 1) / ((p - 1) * ((p : ℚ) ^ (k + 1) + 1)) := by
      rcases p with ( _ | _ | p ) <;> norm_num at *;
      rw [ div_le_div_iff₀ ] <;> ring <;> norm_cast <;> norm_num;
      grind;
    convert h_simplify using 1;
    · convert ratio'_prime_pow hp hk using 1;
    · convert ratio'_prime_pow hp ( by linarith : k + 1 ≥ 1 ) using 1

/-
ratio'(p^2) is decreasing in p.
-/
theorem ratio_prime_sq_decreasing {p q : ℕ} (hp : p.Prime) (hq : q.Prime) (hpq : p ≤ q) :
  ratio' (q ^ 2) ≤ ratio' (p ^ 2) := by
    -- Since ratio' (p^2) = (p^3 - 1) / ((p - 1) * (p^2 + 1)), we rewrite the goal using the formula.
    suffices h_suff : ((q : ℚ) ^ 3 - 1) / ((q - 1) * ((q : ℚ) ^ 2 + 1)) ≤ ((p : ℚ) ^ 3 - 1) / ((p - 1) * ((p : ℚ) ^ 2 + 1)) by
      convert h_suff using 1 <;> norm_num [ ratio' ];
      · convert ratio'_prime_pow hq ( show 2 ≥ 1 by norm_num ) using 1;
      · rw [ show ArithmeticFunction.sigma 1 ( p ^ 2 ) = ( p ^ 3 - 1 ) / ( p - 1 ) from ?_, show usigma' ( p ^ 2 ) = ( p ^ 2 + 1 ) from ?_ ];
        · rw [ Nat.cast_div ];
          · cases p <;> norm_num [ div_div ];
            contradiction;
          · exact?;
          · exact ne_of_gt <| Nat.cast_pos.mpr <| Nat.sub_pos_of_lt hp.one_lt;
        · convert usigma_prime_pow hp ( by decide : 1 ≤ 2 ) using 1 ; ring;
        · norm_num [ ArithmeticFunction.sigma_apply, Nat.div_eq_of_lt hp.one_lt ];
          norm_num [ Nat.divisors_prime_pow hp ];
          norm_num [ Finset.sum_range_succ, Nat.geomSum_eq hp.one_lt ];
    rcases p with ( _ | _ | p ) <;> rcases q with ( _ | _ | q ) <;> norm_num at *;
    rw [ div_le_div_iff₀ ] <;> ring <;> norm_cast <;> try positivity;
    nlinarith [ Nat.zero_le ( p * q ), Nat.zero_le ( p * q ^ 2 ), Nat.zero_le ( p ^ 2 * q ), Nat.zero_le ( p ^ 2 * q ^ 2 ), Nat.zero_le ( p ^ 3 * q ), Nat.zero_le ( p ^ 3 * q ^ 2 ), Nat.zero_le ( q ^ 3 * p ), Nat.zero_le ( q ^ 3 * p ^ 2 ), Nat.zero_le ( q ^ 3 * p ^ 3 ) ]

/-
If n is powerful and p divides n, then ratio' n >= ratio' (p^2).
Proof: ratio' n = ratio' (p^k) * ratio' (rest).
ratio' (rest) >= 1.
ratio' (p^k) >= ratio' (p^2) since k >= 2.
So ratio' n >= ratio' (p^2).
-/
theorem ratio_ge_prime_sq {n p : ℕ} (hn : IsPowerful n) (hp : p ∈ n.primeFactors) :
  ratio' n ≥ ratio' (p ^ 2) := by
    -- By multiplicativity, ratio' n = ratio' p^k * ratio' rest where rest is the product of other prime factors.
    obtain ⟨k, hk⟩ : ∃ k, n.factorization p = k ∧ k ≥ 2 := by
      exact ⟨ _, rfl, hn p hp ⟩
    obtain ⟨rest, hrest⟩ : ∃ rest, n = p ^ k * rest ∧ Nat.Coprime (p ^ k) rest := by
      use n / p^k
      generalize_proofs at *; (
      rw [ Nat.mul_div_cancel' ];
      · rw [ ← hk.1 ] ; exact ⟨ rfl, Nat.Coprime.pow_left _ <| Nat.Prime.coprime_iff_not_dvd ( Nat.prime_of_mem_primeFactors hp ) |>.2 <| Nat.not_dvd_ordCompl ( by aesop ) <| by aesop ⟩ ;
      · exact hk.1 ▸ Nat.ordProj_dvd _ _)
    have h_ratio : ratio' n = ratio' (p ^ k) * ratio' rest := by
      rw [ hrest.1, ratio'_is_multiplicative hrest.2 ]
    have h_ratio_rest : ratio' rest ≥ 1 := by
      by_cases hrest_zero : rest = 0 <;> simp_all +decide [ ratio_ge_one ]
    have h_ratio_k : ratio' (p ^ k) ≥ ratio' (p ^ 2) := by
      have h_ratio_k : ∀ {a b : ℕ}, 2 ≤ a → a ≤ b → ratio' (p ^ a) ≤ ratio' (p ^ b) := by
        intros a b ha hb
        induction' hb with b hb ih
        generalize_proofs at *; (
        norm_num +zetaDelta at *);
        exact le_trans ih ( ratio_prime_pow_increasing ( Nat.prime_of_mem_primeFactors hp ) ( by linarith [ Nat.succ_le_succ hb ] ) )
      generalize_proofs at *; (
      grind)
    have h_ratio_final : ratio' n ≥ ratio' (p ^ 2) := by
      exact h_ratio.symm ▸ le_trans h_ratio_k ( le_mul_of_one_le_right ( by exact le_of_not_gt fun h => by linarith [ show 0 ≤ ratio' ( p ^ k ) from by exact le_trans ( by norm_num ) ( ratio_prime_pow_ge_one ( Nat.prime_of_mem_primeFactors hp ) ( by linarith ) ) ] ) h_ratio_rest )
    exact h_ratio_final

/-
ratio'(p^k) is monotonically increasing for k >= 1.
-/
theorem ratio_prime_pow_le_of_le {p a b : ℕ} (hp : p.Prime) (ha : 1 ≤ a) (hab : a ≤ b) :
  ratio' (p ^ a) ≤ ratio' (p ^ b) := by
    -- By induction on $b - a$, we can show that ratio' (p^a) ≤ ratio' (p^b).
    induction' hab with b hb ih;
    · rfl;
    · exact le_trans ih ( ratio_prime_pow_increasing hp ( by linarith [ Nat.succ_le_succ hb ] ) )