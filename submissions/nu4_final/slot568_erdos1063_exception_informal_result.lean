/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4ca7fb9c-ec9a-4e98-ae4f-e4a35419786c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If p is a prime such that p ≤ k < 2p, then the p-adic valuation of k! is 1.
-/
theorem vp_factorial_of_le {p k : ℕ} (hp : p.Prime) (h_le : p ≤ k) (h_lt : k < 2 * p) :
    (Nat.factorial k).factorization p = 1 := by
  haveI := Fact.mk hp;
  rw [ Nat.factorization_def ];
  · rw [ padicValNat_factorial ];
    rotate_right;
    exact 2;
    · norm_num [ Finset.sum_Ico_succ_top ];
      nlinarith [ Nat.div_mul_le_self k p, Nat.div_add_mod k p, Nat.mod_lt k hp.pos ];
    · exact Nat.log_lt_of_lt_pow ( by linarith [ hp.pos ] ) ( by nlinarith [ Nat.pow_le_pow_left hp.two_le 2 ] );
  · exact hp

/-
If every n-i divides C(n,k), then for any prime p, v_p(k!) <= sum(v_p(n-i)) - max(v_p(n-i)).
-/
theorem valuation_contradiction_inequality {n k : ℕ} (hk : 1 ≤ k) (h_nk : k ≤ n)
    (h_div : ∀ i < k, n - i ∣ n.choose k) (p : ℕ) (hp : p.Prime) :
    (Nat.factorial k).factorization p ≤ (∑ i ∈ Finset.range k, (n - i).factorization p) - Finset.sup (Finset.range k) (fun i => (n - i).factorization p) := by
  -- By definition of $v_p$, we know that $v_p(k!) = \sum_{i=1}^{k-1} v_p(n-i) - v_p(C(n,k))$.
  have h_val : (Nat.factorial k).factorization p = (∑ i ∈ Finset.range k, (Nat.factorization (n - i)) p) - (Nat.factorization (Nat.choose n k)) p := by
    have h_vp_def : (Nat.factorization (Nat.choose n k * Nat.factorial k)) p = ∑ i ∈ Finset.range k, (Nat.factorization (n - i)) p := by
      have h_vp_def : Nat.choose n k * Nat.factorial k = ∏ i ∈ Finset.range k, (n - i) := by
        rw [ mul_comm, ← Nat.descFactorial_eq_factorial_mul_choose ];
        rw [ Nat.descFactorial_eq_prod_range ];
      rw [ h_vp_def, Nat.factorization_prod ];
      · rw [ Finset.sum_apply' ];
      · exact fun i hi => Nat.sub_ne_zero_of_lt <| by linarith [ Finset.mem_range.mp hi ] ;
    rw [ ← h_vp_def, Nat.factorization_mul ( Nat.ne_of_gt ( Nat.choose_pos h_nk ) ) ( Nat.ne_of_gt ( Nat.factorial_pos _ ) ) ] ; aesop;
  refine h_val ▸ Nat.sub_le_sub_left ?_ _;
  exact Finset.sup_le fun i hi => Nat.factorization_le_iff_dvd ( Nat.sub_ne_zero_of_lt <| by linarith [ Finset.mem_range.mp hi ] ) ( Nat.ne_of_gt <| Nat.choose_pos h_nk ) |>.2 ( h_div i <| Finset.mem_range.mp hi ) _ |> fun x => x.trans' <| by aesop;

/-
If there is exactly one multiple of p in the range, we get a contradiction.
-/
theorem one_multiple_contradiction {n k : ℕ} (hk : 1 ≤ k) (h_nk : k ≤ n)
    (h_div : ∀ i < k, n - i ∣ n.choose k) (p : ℕ) (hp : p.Prime)
    (hp_le : p ≤ k) (hp_gt : k < 2 * p)
    (h_count : ((Finset.range k).filter (fun i => p ∣ n - i)).card = 1) : False := by
  -- Then v_p(product(n-i)) = a. v_p(k!) = 1. v_p(C(n,k)) = a - 1.
  have h_valuations : (∑ i ∈ Finset.range k, (Nat.factorization (n - i)) p) = (Nat.factorization (n - (Classical.choose (Finset.card_pos.mp (by linarith))))) p ∧ (Nat.factorization (Nat.factorial k)) p = 1 := by
    have h_valuations : (∑ i ∈ Finset.range k, (Nat.factorization (n - i)) p) = (Nat.factorization (n - (Classical.choose (Finset.card_pos.mp (by linarith))))) p := by
      have h_valuations : ∀ i ∈ Finset.range k, i ≠ Classical.choose (Finset.card_pos.mp (by linarith)) → (Nat.factorization (n - i)) p = 0 := by
        intro i hi hne; rw [ Nat.factorization_eq_zero_of_not_dvd ] ; intro h; have := Classical.choose_spec ( Finset.card_pos.mp ( by linarith ) ) ; simp_all +decide [ Finset.mem_filter ] ;
        have := Finset.card_eq_one.mp h_count; obtain ⟨ x, hx ⟩ := this; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
        exact hne ( hx.2 _ this.1 ( by simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( show Classical.choose ( Finset.card_pos.mp ( by linarith ) ) ≤ n from by linarith ) ] using this.2 ) ▸ rfl );
      rw [ Finset.sum_eq_single ( Classical.choose ( Finset.card_pos.mp ( by linarith ) ) ) ] ; aesop;
      exact fun h => False.elim <| h <| Finset.mem_range.mpr <| Finset.mem_range.mp <| Classical.choose_spec ( Finset.card_pos.mp <| by linarith ) |> fun x => Finset.mem_filter.mp x |>.1;
    have h_factorial : (Nat.factorization (Nat.factorial k)) p = 1 := by
      convert vp_factorial_of_le hp hp_le hp_gt using 1
    exact ⟨h_valuations, h_factorial⟩;
  -- By hypothesis, n-j | C(n,k), so v_p(n-j) <= v_p(C(n,k)).
  have h_divides : (Nat.factorization (n - (Classical.choose (Finset.card_pos.mp (by linarith))))) p ≤ (Nat.factorization (Nat.choose n k)) p := by
    have h_divides : n - (Classical.choose (Finset.card_pos.mp (by linarith))) ∣ Nat.choose n k := by
      exact h_div _ ( Finset.mem_range.mp ( Classical.choose_spec ( Finset.card_pos.mp ( by linarith ) ) |> Finset.mem_filter.mp |>.1 ) );
    exact ( Nat.factorization_le_iff_dvd ( Nat.sub_ne_zero_of_lt <| by linarith [ Finset.mem_range.mp ( Classical.choose_spec ( Finset.card_pos.mp <| by linarith ) |> Finset.mem_filter.mp |>.1 ) ] ) ( Nat.ne_of_gt <| Nat.choose_pos h_nk ) ) |>.2 h_divides p;
  -- By definition of binomial coefficients, we know that $\binom{n}{k} = \frac{n(n-1)\cdots(n-k+1)}{k!}$.
  have h_binom : Nat.choose n k * Nat.factorial k = ∏ i ∈ Finset.range k, (n - i) := by
    rw [ mul_comm, ← Nat.descFactorial_eq_factorial_mul_choose ];
    rw [ Nat.descFactorial_eq_prod_range ];
  replace h_binom := congr_arg ( fun x => x.factorization p ) h_binom ; simp_all +decide [ Finset.prod_eq_zero_iff, Nat.factorial_ne_zero ] ;
  rw [ Nat.factorization_mul ] at h_binom <;> simp_all +decide [ Nat.factorial_ne_zero ];
  · rw [ Nat.factorization_prod ] at h_binom <;> simp_all +decide [ Finset.prod_eq_zero_iff, Nat.factorial_ne_zero ] ;
    · linarith;
    · exact fun i hi => Nat.sub_ne_zero_of_lt ( by linarith );
  · exact Nat.ne_of_gt <| Nat.choose_pos h_nk

/-
For any prime p, v_p(k!) + v_p(C(n,k)) <= count * v_p(C(n,k)).
-/
theorem valuation_contradiction_general {n k : ℕ} (hk : 1 ≤ k) (h_nk : k ≤ n)
    (h_div : ∀ i < k, n - i ∣ n.choose k) (p : ℕ) (hp : p.Prime) :
    (Nat.factorial k).factorization p + (Nat.choose n k).factorization p ≤
    ((Finset.range k).filter (fun i => p ∣ n - i)).card * (Nat.choose n k).factorization p := by
  -- By definition of $p$-adic valuation, we know that $v_p(k!) + v_p(n.choose k) = \sum_{i=0}^{k-1} v_p(n-i)$.
  have h_sum_val : ((Nat.factorial k).factorization p) + ((Nat.choose n k).factorization p) = (∑ i ∈ Finset.range k, (n - i).factorization p) := by
    -- The product of (n-i) for i from 0 to k-1 is equal to k! multiplied by (n choose k).
    have h_prod : ∏ i ∈ Finset.range k, (n - i) = Nat.factorial k * Nat.choose n k := by
      rw [ ← Nat.descFactorial_eq_factorial_mul_choose ];
      rw [ Nat.descFactorial_eq_prod_range ];
    have h_prod_val : (∏ i ∈ Finset.range k, (n - i)).factorization p = (∑ i ∈ Finset.range k, (n - i).factorization p) := by
      rw [ Nat.factorization_prod ];
      · rw [ Finset.sum_apply' ];
      · exact fun i hi => Nat.sub_ne_zero_of_lt <| Finset.mem_range.mp hi |> lt_of_lt_of_le <| h_nk;
    rw [ ← h_prod_val, h_prod, Nat.factorization_mul ( Nat.factorial_ne_zero _ ) ( Nat.ne_of_gt ( Nat.choose_pos h_nk ) ), Finsupp.add_apply ];
  -- Since $n-i \mid C(n,k)$ for all $i < k$, it follows that $v_p(n-i) \le v_p(C(n,k))$ for each $i$.
  have h_le_val : ∀ i ∈ Finset.range k, (Nat.factorization (n - i)) p ≤ (Nat.factorization (Nat.choose n k)) p := by
    exact fun i hi => Nat.factorization_le_iff_dvd ( Nat.sub_ne_zero_of_lt <| by linarith [ Finset.mem_range.mp hi, Nat.sub_add_cancel h_nk ] ) ( Nat.ne_of_gt <| Nat.choose_pos h_nk ) |>.2 ( h_div i <| Finset.mem_range.mp hi ) p;
  rw [ h_sum_val, Finset.sum_congr rfl fun i hi => show ( Nat.factorization ( n - i ) ) p = if p ∣ n - i then ( Nat.factorization ( n - i ) ) p else 0 from ?_ ];
  · rw [ Finset.card_filter ];
    rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_le_sum fun i hi => by aesop; ;
  · split_ifs <;> simp_all +decide [ Nat.factorization_eq_zero_iff ]

/-
For any prime p, v_p(k!) <= (k-1) * v_p(C(n,k)).
-/
theorem vp_factorial_le_k_minus_one_mul_vp_choose {n k : ℕ} (hk : 1 ≤ k) (h_nk : k ≤ n)
    (h_div : ∀ i < k, n - i ∣ n.choose k) (p : ℕ) (hp : p.Prime) :
    (Nat.factorial k).factorization p ≤ (k - 1) * (Nat.choose n k).factorization p := by
  -- By definition of valid pairs, we know that sum_{i=0}^{k-1} v_p(n-i) = v_p(k!) + v_p(C(n,k)).
  have h_sum_val : ∑ i ∈ Finset.range k, (Nat.factorization (n - i)) p = (Nat.factorial k).factorization p + (Nat.choose n k).factorization p := by
    have h_sum_val : (∏ i ∈ Finset.range k, (n - i)) = Nat.choose n k * Nat.factorial k := by
      rw [ mul_comm, ← Nat.descFactorial_eq_factorial_mul_choose ];
      rw [ Nat.descFactorial_eq_prod_range ];
    apply_fun fun x => x.factorization p at h_sum_val ; simp_all +decide [ add_comm, Nat.factorization_prod ];
    rw [ Nat.factorization_prod ] at h_sum_val;
    · rw [ Nat.factorization_mul ] at h_sum_val <;> simp_all +decide [ add_comm, Finset.sum_apply' ];
      · exact Nat.ne_of_gt <| Nat.choose_pos h_nk;
      · positivity;
    · exact fun i hi => Nat.sub_ne_zero_of_lt <| by linarith [ Finset.mem_range.mp hi ] ;
  -- Since $n-i \mid \binom{n}{k}$, we have $v_p(n-i) \leq v_p(\binom{n}{k})$ for each $i$.
  have h_val_le : ∀ i < k, (Nat.factorization (n - i)) p ≤ (Nat.choose n k).factorization p := by
    intro i hi; specialize h_div i hi; rcases eq_or_ne ( n.choose k ) 0 with h | h <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ] ;
    · exact absurd h <| Nat.ne_of_gt <| Nat.choose_pos h_nk;
    · exact ( Nat.factorization_le_iff_dvd ( Nat.sub_ne_zero_of_lt ( by linarith ) ) ( by positivity ) ) |>.2 h_div p;
  have := Finset.sum_le_sum fun i ( hi : i ∈ Finset.range k ) => h_val_le i ( Finset.mem_range.mp hi ) ; simp_all +decide [ Finset.sum_range_succ' ] ;
  cases k <;> norm_num at * ; linarith;

/-
If k is prime, we get a contradiction.
-/
theorem prime_k_implies_contradiction {n k : ℕ} (hk : k.Prime) (h_nk : k ≤ n)
    (h_div : ∀ i < k, n - i ∣ n.choose k) : False := by
  -- By Lemma 2, when k is prime, we have v_p(k!) = 1 and v_p(C(n,k)) < 1, leading to a contradiction.
  have h_prime_contradiction : (Nat.factorial k).factorization k + (Nat.choose n k).factorization k ≤ ((Finset.range k).filter (fun i => k ∣ n - i)).card * (Nat.choose n k).factorization k := by
    -- Apply the lemma `valuation_contradiction_general` with `p = k`.
    apply valuation_contradiction_general;
    · exact hk.pos;
    · exact?;
    · assumption;
    · assumption;
  -- Since $k$ is prime, we have $(Nat.factorial k).factorization k = 1$ and $(Nat.choose n k).factorization k < 1$.
  have h_prime_factorization : (Nat.factorial k).factorization k = 1 ∧ (Nat.choose n k).factorization k < 1 := by
    have h_prime_factorization : (Nat.factorial k).factorization k = 1 := by
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.factorial_succ ];
      rw [ Nat.factorization_mul ] <;> simp_all +decide [ Nat.factorial_ne_zero ];
      exact ⟨ Nat.factorization_eq_zero_of_not_dvd ( by simp +decide [ Nat.Prime.dvd_iff_not_coprime hk ] ), Nat.factorization_eq_zero_of_not_dvd ( by rw [ Nat.Prime.dvd_factorial hk ] ; linarith ) ⟩
    have h_prime_factorization_choose : (Nat.choose n k).factorization k < 1 := by
      have h_card : ((Finset.range k).filter (fun i => k ∣ n - i)).card ≤ 1 := by
        have h_card : ∀ i j : ℕ, i < k → j < k → k ∣ n - i → k ∣ n - j → i = j := by
          intros i j hi hj hi_div hj_div
          have h_diff : k ∣ Int.natAbs (i - j) := by
            cases le_total n i <;> cases le_total n j <;> simp_all +decide [ ← Int.natCast_dvd_natCast ];
            · linarith;
            · linarith [ hk.two_le ];
            · grind;
            · simpa using dvd_sub hj_div hi_div;
          cases abs_cases ( i - j : ℤ ) <;> exact Nat.le_antisymm ( Nat.le_of_not_lt fun hi' => by have := Nat.le_of_dvd ( by omega ) h_diff; omega ) ( Nat.le_of_not_lt fun hj' => by have := Nat.le_of_dvd ( by omega ) h_diff; omega );
        exact Finset.card_le_one.mpr fun i hi j hj => h_card i j ( Finset.mem_range.mp ( Finset.mem_filter.mp hi |>.1 ) ) ( Finset.mem_range.mp ( Finset.mem_filter.mp hj |>.1 ) ) ( Finset.mem_filter.mp hi |>.2 ) ( Finset.mem_filter.mp hj |>.2 );
      nlinarith
    exact ⟨h_prime_factorization, h_prime_factorization_choose⟩;
  aesop

/-
If there are exactly two multiples of p, they are of the form a*p and (a+1)*p.
-/
theorem two_multiples_structure {n k p : ℕ} (hk : 2 ≤ k) (h_nk : k ≤ n)
    (hp : p.Prime) (hp_le : p ≤ k) (hp_gt : k < 2 * p)
    (h_count : ((Finset.range k).filter (fun i => p ∣ n - i)).card = 2) :
    ∃ a : ℕ, a > 0 ∧ (n - (a + 1) * p) ∈ Finset.range k ∧ (n - a * p) ∈ Finset.range k ∧
    p ∣ n - (n - a * p) ∧ p ∣ n - (n - (a + 1) * p) := by
  -- Let's obtain the two multiples of p in the range.
  obtain ⟨i1, i2, hi1, hi2, h_distinct⟩ : ∃ i1 i2, i1 ∈ Finset.range k ∧ i2 ∈ Finset.range k ∧ p ∣ n - i1 ∧ p ∣ n - i2 ∧ i1 < i2 ∧ ∀ i ∈ Finset.range k, p ∣ n - i → i = i1 ∨ i = i2 := by
    rw [ Finset.card_eq_two ] at h_count;
    obtain ⟨ x, y, hxy, h ⟩ := h_count; cases lt_or_gt_of_ne hxy <;> [ exact ⟨ x, y, by rw [ Finset.ext_iff ] at h; specialize h x; aesop, by rw [ Finset.ext_iff ] at h; specialize h y; aesop, by rw [ Finset.ext_iff ] at h; specialize h x; aesop, by rw [ Finset.ext_iff ] at h; specialize h y; aesop, by linarith, fun i hi hi' => by rw [ Finset.ext_iff ] at h; specialize h i; aesop ⟩ ; exact ⟨ y, x, by rw [ Finset.ext_iff ] at h; specialize h y; aesop, by rw [ Finset.ext_iff ] at h; specialize h x; aesop, by rw [ Finset.ext_iff ] at h; specialize h y; aesop, by rw [ Finset.ext_iff ] at h; specialize h x; aesop, by linarith, fun i hi hi' => by rw [ Finset.ext_iff ] at h; specialize h i; aesop ⟩ ] ;
  -- Since $p$ divides both $n - i1$ and $n - i2$, we can write $n - i1 = ap$ and $n - i2 = (a+1)p$ for some integer $a$.
  obtain ⟨a, ha⟩ : ∃ a, n - i1 = a * p ∧ n - i2 = (a + 1) * p ∨ n - i1 = (a + 1) * p ∧ n - i2 = a * p := by
    obtain ⟨a, ha⟩ : ∃ a, n - i1 = a * p := by
      exact exists_eq_mul_left_of_dvd h_distinct.1
    obtain ⟨b, hb⟩ : ∃ b, n - i2 = b * p := by
      exact exists_eq_mul_left_of_dvd h_distinct.2.1
    have h_diff : |(a : ℤ) - b| = 1 := by
      have h_diff : |(a : ℤ) - b| * p = i2 - i1 := by
        rw [ abs_of_nonneg ] <;> nlinarith only [ Nat.sub_add_cancel ( show i1 ≤ n from by linarith [ Finset.mem_range.mp hi1 ] ), Nat.sub_add_cancel ( show i2 ≤ n from by linarith [ Finset.mem_range.mp hi2 ] ), ha, hb, h_distinct.2.2.1 ];
      nlinarith [ show i2 < k from Finset.mem_range.mp hi2, show i1 < k from Finset.mem_range.mp hi1, abs_nonneg ( a - b : ℤ ) ];
    cases abs_cases ( a - b : ℤ ) <;> first | exact ⟨ a, Or.inl ⟨ ha, by nlinarith ⟩ ⟩ | exact ⟨ b, Or.inr ⟨ by nlinarith, hb ⟩ ⟩ ;
  rcases ha with ( ⟨ ha₁, ha₂ ⟩ | ⟨ ha₁, ha₂ ⟩ ) <;> simp_all +decide [ Nat.mul_succ, Nat.dvd_add_right ];
  · grind;
  · refine' ⟨ a, _, _, _, _ ⟩ <;> try omega;
    · grind;
    · exact ⟨ by rw [ Nat.sub_sub_self ( by nlinarith only [ ha₂, Nat.sub_le n i2 ] ) ] ; norm_num, by rw [ Nat.sub_sub_self ( by nlinarith only [ ha₁, Nat.sub_le n i1 ] ) ] ; norm_num ⟩

/-
The number of multiples of m in the sequence n, n-1, ..., n-k+1.
-/
def multiples_count (n k m : ℕ) : ℕ :=
  ((Finset.range k).filter (fun i => m ∣ n - i)).card

/-
The number of multiples of m in the sequence n, n-1, ..., n-k+1 is at most k/m + 1, provided k <= n.
-/
theorem multiples_count_le {n k m : ℕ} (hm : m > 0) (h_nk : k ≤ n) :
    multiples_count n k m ≤ k / m + 1 := by
  refine' le_trans ( Finset.card_le_card _ ) _;
  exact Finset.image ( fun i => n - m * i ) ( Finset.Ico ( n / m - k / m ) ( n / m + 1 ) );
  · intro i hi;
    simp +zetaDelta at *;
    obtain ⟨ a, ha ⟩ := hi.2;
    refine' ⟨ a, ⟨ _, _ ⟩, _ ⟩;
    · rw [ Nat.div_le_iff_le_mul_add_pred hm ];
      nlinarith [ Nat.div_add_mod k m, Nat.mod_lt k hm, Nat.sub_add_cancel ( show i ≤ n from by linarith ), Nat.sub_add_cancel ( show 1 ≤ m from hm ) ];
    · exact Nat.lt_succ_of_le ( Nat.le_div_iff_mul_le hm |>.2 <| by linarith [ Nat.sub_add_cancel ( show i ≤ n from by linarith ) ] );
    · rw [ ← ha, Nat.sub_sub_self ( by linarith ) ];
  · exact Finset.card_image_le.trans ( by norm_num; omega )

/-
The sum of p-adic valuations is the sum of the counts of multiples of powers of p.
-/
theorem sum_valuations_eq_sum_multiples_count {n k p : ℕ} (hp : p.Prime) (h_nk : k ≤ n) :
    ∑ i ∈ Finset.range k, (n - i).factorization p =
    ∑ j ∈ Finset.Ico 1 (Nat.log p n + 1), multiples_count n k (p ^ j) := by
  -- By definition of factorization, we can rewrite the left-hand side as a sum of the counts of multiples of powers of $p$ less than or equal to $n - i$.
  have h_factorization : ∀ i ∈ Finset.range k, (Nat.factorization (n - i)) p = ∑ j ∈ Finset.Ico 1 (Nat.log p n + 1), (if p^j ∣ n - i then 1 else 0) := by
    intros i hi
    have h_factorization : (Nat.factorization (n - i)) p = ∑ j ∈ Finset.Ico 1 (Nat.log p (n - i) + 1), (if p^j ∣ n - i then 1 else 0) := by
      rcases eq_or_ne ( n - i ) 0 with h | h <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
      rw [ Finset.card_eq_of_bijective ];
      use fun x hx => x + 1;
      · norm_num +zetaDelta at *;
        exact fun a ha₁ ha₂ ha₃ => ⟨ a - 1, Nat.lt_of_lt_of_le ( Nat.sub_lt ha₁ zero_lt_one ) ( Nat.le_of_not_lt fun ha₄ => absurd ( Nat.dvd_trans ( pow_dvd_pow _ ha₄ ) ha₃ ) ( Nat.pow_succ_factorization_not_dvd h hp ) ), Nat.succ_pred_eq_of_pos ha₁ ⟩;
      · exact fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_Ico.mpr ⟨ by linarith, by linarith [ Nat.le_log_of_pow_le hp.one_lt ( show p ^ ( ( Nat.factorization ( n - i ) ) p ) ≤ n - i from Nat.le_of_dvd ( Nat.pos_of_ne_zero h ) ( Nat.ordProj_dvd _ _ ) ) ] ⟩, Nat.dvd_trans ( pow_dvd_pow _ ( by linarith ) ) ( Nat.ordProj_dvd _ _ ) ⟩;
      · grind;
    rw [ h_factorization, Finset.sum_subset ];
    · exact Finset.Ico_subset_Ico_right ( Nat.succ_le_succ ( Nat.log_mono_right ( Nat.sub_le _ _ ) ) );
    · simp +zetaDelta at *;
      intro x hx₁ hx₂ hx₃; specialize hx₃ hx₁; exact Nat.not_dvd_of_pos_of_lt ( Nat.sub_pos_of_lt ( by linarith ) ) ( Nat.lt_pow_of_log_lt hp.one_lt ( by linarith ) ) ;
  rw [ Finset.sum_congr rfl h_factorization, Finset.sum_comm ];
  exact Finset.sum_congr rfl fun _ _ => by unfold multiples_count; aesop;

/-
If p divides k, then the number of multiples of p in an interval of length k is exactly k/p.
-/
theorem multiples_count_eq_div {n k p : ℕ} (hp : p > 0) (h_div : p ∣ k) (h_nk : k ≤ n) :
    multiples_count n k p = k / p := by
  obtain ⟨ m, hm ⟩ := h_div;
  simp [multiples_count, hm];
  -- The set of indices $i$ such that $p \mid (n - i)$ is exactly the set of indices $i$ such that $i \equiv n \pmod{p}$.
  have h_set_eq : Finset.filter (fun i => p ∣ n - i) (Finset.range (p * m)) = Finset.image (fun i => n % p + p * i) (Finset.range m) := by
    -- To prove equality of finite sets, we show each set is a subset of the other.
    apply Finset.ext
    intro i
    simp [Finset.mem_image, Finset.mem_filter];
    constructor <;> intro hi;
    · -- Since $p \mid n - i$, we have $n \equiv i \pmod{p}$, thus $n \% p = i \% p$.
      have h_mod : n % p = i % p := by
        exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub <| show i ≤ n from by nlinarith ] using hi.2 );
      exact ⟨ i / p, Nat.div_lt_of_lt_mul <| by linarith, by linarith [ Nat.mod_add_div i p ] ⟩;
    · rcases hi with ⟨ a, ha, rfl ⟩ ; refine' ⟨ by nlinarith [ Nat.mod_lt n hp ], _ ⟩ ; rw [ ← Nat.mod_add_div n p ] ; simp +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] ;
      norm_num [ Nat.add_sub_add_left, ← mul_tsub ];
  rw [ h_set_eq, Finset.card_image_of_injective ] <;> aesop_cat

/-
The number of multiples of m in the range is at most k/m + 1.
-/
theorem multiples_count_le_floor_add_one {n k m : ℕ} (hm : m > 0) (h_nk : k ≤ n) :
    multiples_count n k m ≤ k / m + 1 := by
  exact multiples_count_le hm h_nk

/-
The p-adic valuation of k! is given by Legendre's formula.
-/
def legendre_term (k p j : ℕ) : ℕ := k / p ^ j

theorem legendre_sum_eq_vp_factorial {k p : ℕ} (hp : p.Prime) :
    (Nat.factorial k).factorization p = ∑ j ∈ Finset.Ico 1 (Nat.log p k + 1), legendre_term k p j := by
  rw [ Nat.factorization_def ];
  · haveI := Fact.mk hp; rw [ padicValNat_factorial ] ; aesop;
    grind;
  · assumption

/-
If n divides C(n,k), then k divides C(n-1, k-1).
-/
theorem n_dvd_choose_implies_k_dvd_choose {n k : ℕ} (hk : 1 ≤ k) (h_nk : k ≤ n)
    (h_div : n ∣ n.choose k) : k ∣ (n - 1).choose (k - 1) := by
  rcases n with ( _ | n ) <;> rcases k with ( _ | k ) <;> simp_all +decide [ Nat.succ_mul_choose_eq ];
  exact Exists.elim h_div fun x hx => ⟨ x, by nlinarith [ Nat.succ_mul_choose_eq n k ] ⟩