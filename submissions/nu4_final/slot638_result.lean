/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aa070798-0196-400b-929a-51292650526f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A number is powerful (squarefull) if every prime factor appears with exponent ≥ 2.
-/
def Powerful (n : ℕ) : Prop :=
  ∀ p : ℕ, p.Prime → p ∣ n → p ^ 2 ∣ n

/-
A number is a perfect cube if it is the cube of some integer.
-/
def IsCube (n : ℕ) : Prop :=
  ∃ m : ℕ, m ^ 3 = n

/-
If n, n+1, n+2 are powerful and n+1 is a cube m^3, then m is even.
-/
lemma m_even_of_powerful_triple_cube_center (n m : ℕ) (h1 : Powerful n) (h2 : Powerful (n + 1)) (h3 : Powerful (n + 2)) (hm : n + 1 = m ^ 3) : Even m := by
  -- If n, n+1, n+2 are powerful, then n must be congruent to 3 mod 4.
  have h_mod : n % 4 = 3 := by
    -- If n is even, then n must be divisible by 4. Let's consider the possible values of n modulo 4.
    by_cases h_even : Even n;
    · -- Since n is even, n must be divisible by 4.
      have h_div4 : 4 ∣ n := by
        have := h1 2 Nat.prime_two; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
        exact this ( Nat.even_iff.mp h_even );
      obtain ⟨ k, hk ⟩ := h_div4; specialize h3 2 Nat.prime_two; simp_all +decide [ Nat.dvd_add_right ] ;
      norm_num [ Nat.add_mod, Nat.mul_mod ] at h3;
    · -- Since n is odd, we can write n = 2k + 1 for some integer k.
      obtain ⟨k, rfl⟩ : ∃ k, n = 2 * k + 1 := by
        exact n.even_or_odd.resolve_left h_even;
      rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num at *;
      have := h2 2 Nat.prime_two; simp_all +decide [ Nat.dvd_add_right ] ;
      exact absurd ( this ( hm ▸ ⟨ k * 2 + 1, by ring ⟩ ) ) ( by omega );
  exact even_iff_two_dvd.mpr ( Nat.prime_two.dvd_of_dvd_pow ( by rw [ ← hm ] ; omega ) )

/-
If m ≡ 1 (mod 3), then m+1 and m^2-m+1 are coprime.
-/
lemma coprime_m_sq_sub_m_plus_one (m : ℕ) (h_mod : m % 3 = 1) : Nat.Coprime (m + 1) (m ^ 2 - m + 1) := by
  norm_num [ show m ^ 2 - m = m * ( m - 1 ) by rw [ Nat.pow_two, Nat.mul_sub_left_distrib, Nat.mul_one ] ];
  rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ Nat.succ_eq_add_one, Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
  norm_num [ ( by ring : ( m + 2 ) * ( m + 1 ) + 1 = ( m + 3 ) * ( m + 0 ) + 3 ) ];
  exact Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by omega )

/-
If m ≡ 2 (mod 3), then m-1 and m^2+m+1 are coprime.
-/
lemma coprime_m_sq_plus_m_plus_one (m : ℕ) (h_mod : m % 3 = 2) : Nat.Coprime (m - 1) (m ^ 2 + m + 1) := by
  rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ Nat.Coprime ];
  norm_num [ ( by ring : m + ( m + 2 ) ^ 2 + 3 = ( m + 1 ) * ( m + 4 ) + 3 ) ];
  exact Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by omega )

/-
If m ≡ 1 (mod 3), then m^2+m+1 is not divisible by 9.
-/
lemma not_dvd_nine_of_mod_three_eq_one (m : ℕ) (h : m % 3 = 1) : ¬ 9 ∣ m ^ 2 + m + 1 := by
  rw [ ← Nat.mod_add_div m 3, h ] ; ring_nf; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] ;

/-
If m ≡ 2 (mod 3), then m^2-m+1 is not divisible by 9.
-/
lemma not_dvd_nine_of_mod_three_eq_two (m : ℕ) (h : m % 3 = 2) : ¬ 9 ∣ m ^ 2 - m + 1 := by
  rw [ ← Nat.mod_add_div m 3, h ] ; ring_nf;
  exact fun h' => by obtain ⟨ k, hk ⟩ := h'; omega;

/-
If m ≡ 1 (mod 3) and m^3-1 is powerful, then (m^2+m+1)/3 is powerful.
-/
lemma powerful_div_three_of_mod_one (m : ℕ) (h_mod : m % 3 = 1) (h_pow : Powerful (m ^ 3 - 1)) : Powerful ((m ^ 2 + m + 1) / 3) := by
  -- Let $K = (m^2 + m + 1) / 3$.
  set K := (m^2 + m + 1) / 3;
  -- Since $n = m^3 - 1 = (m - 1) * 3 * K$ is powerful, and $\gcd(K, (m - 1) * 3) = 1$, $K$ must be powerful.
  have h_coprime : Nat.gcd K ((m - 1) * 3) = 1 := by
    -- Since $m \equiv 1 \pmod{3}$, we have $m - 1 \equiv 0 \pmod{3}$, so $m - 1 = 3k$ for some integer $k$.
    obtain ⟨k, hk⟩ : ∃ k, m - 1 = 3 * k := by
      exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div m 3, h_mod ] ; norm_num );
    -- Substitute $m = 3k + 1$ into $K$.
    have hK : K = 3 * k^2 + 3 * k + 1 := by
      exact Nat.div_eq_of_eq_mul_left zero_lt_three <| by nlinarith only [ Nat.sub_add_cancel ( show 1 ≤ m from Nat.pos_of_ne_zero ( by rintro rfl; contradiction ) ), hk ] ;
    simp_all +decide [ Nat.coprime_mul_iff_right, Nat.coprime_mul_iff_left ];
    norm_num [ show 3 * k ^ 2 + 3 * k + 1 = k * ( 3 * k + 3 ) + 1 by ring ];
    norm_num [ show k * ( 3 * k + 3 ) + 1 = 3 * ( k * ( k + 1 ) ) + 1 by ring ];
  -- Since $n = m^3 - 1 = (m - 1) * 3 * K$ is powerful, and $\gcd(K, (m - 1) * 3) = 1$, $K$ must be powerful by the lemma.
  have h_pow_K : Powerful ((m - 1) * 3 * K) := by
    convert h_pow using 1;
    rw [ ← Nat.mul_div_assoc ];
    · exact Nat.div_eq_of_eq_mul_left zero_lt_three ( by zify ; cases m <;> norm_num ; linarith );
    · exact Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, Nat.pow_mod, h_mod ] );
  intro p pp dp; specialize h_pow_K p pp; simp_all +decide [ Nat.Prime.dvd_mul ] ;
  refine' Nat.Coprime.dvd_of_dvd_mul_left _ h_pow_K;
  exact Nat.Coprime.pow_left 2 ( Nat.Coprime.coprime_dvd_left dp h_coprime )

/-
If m ≡ 2 (mod 3) and m^3+1 is powerful, then (m^2-m+1)/3 is powerful.
-/
lemma powerful_div_three_of_mod_two (m : ℕ) (h_mod : m % 3 = 2) (h_pow : Powerful (m ^ 3 + 1)) : Powerful ((m ^ 2 - m + 1) / 3) := by
  -- Let $K = (m^2 - m + 1) / 3$. We need to show that $K$ is powerful.
  set K : ℕ := (m ^ 2 - m + 1) / 3
  have hK : m^3 + 1 = (m + 1) * 3 * K := by
    zify [ K ];
    rw [ Nat.cast_sub ] <;> push_cast <;> repeat nlinarith;
    nlinarith [ Int.ediv_mul_cancel ( show 3 ∣ ( m : ℤ ) ^ 2 - m + 1 from Int.dvd_of_emod_eq_zero ( by norm_num [ sq, Int.add_emod, Int.sub_emod, Int.mul_emod ] ; norm_cast; have := Nat.mod_lt m zero_lt_three; interval_cases m % 3 <;> trivial ) ) ];
  -- Since $m^3 + 1$ is powerful, $K$ must be powerful.
  intro p hp hpK
  have hp3 : p ^ 2 ∣ (m ^ 3 + 1) := by
    exact h_pow p hp ( dvd_trans hpK ( hK.symm ▸ dvd_mul_left _ _ ) )
  have hp2 : p ^ 2 ∣ (m + 1) * 3 * K := by
    aesop
  have hp4 : p ^ 2 ∣ K := by
    -- Since $p$ is prime and $p \mid K$, it follows that $p \nmid (m + 1)$ and $p \nmid 3$.
    have hp_not_div_m1 : ¬(p ∣ (m + 1)) := by
      intro hpm1
      have hp_div_3 : p ∣ 3 := by
        have hp_div_3 : p ∣ (m ^ 2 - m + 1) := by
          convert hpK.mul_left 3 using 1;
          rw [ Nat.mul_div_cancel' ];
          rw [ ← Nat.mod_add_div ( m ^ 2 ) 3, ← Nat.mod_add_div m 3 ] ; norm_num [ Nat.pow_mod, h_mod ] ; ring_nf; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] ;
          omega;
        convert Nat.dvd_sub' hp_div_3 ( hpm1.mul_left ( m - 2 ) ) using 1 ; rw [ Nat.sub_eq_of_eq_add ] ; nlinarith only [ Nat.sub_add_cancel ( show 2 ≤ m from le_of_not_gt fun contra => by interval_cases m <;> trivial ), Nat.sub_add_cancel ( show m ≤ m^2 from Nat.le_self_pow ( by decide ) _ ) ] ;
      have := Nat.le_of_dvd ( by decide ) hp_div_3; interval_cases p <;> norm_num at *;
      -- Since $m \equiv 2 \pmod{3}$, we have $m^2 - m + 1 \equiv 2^2 - 2 + 1 \equiv 3 \pmod{9}$.
      have h_mod_9 : m^2 - m + 1 ≡ 3 [MOD 9] := by
        rw [ ← Nat.mod_add_div m 3, h_mod ] ; ring_nf; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] ;
        grind;
      rw [ Nat.ModEq ] at h_mod_9; omega;
    have hp_not_div_3 : ¬(p ∣ 3) := by
      intro h; have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
      omega;
    exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( p ^ 2 ) ( ( m + 1 ) * 3 ) from Nat.Coprime.pow_left 2 <| Nat.Coprime.mul_right ( hp.coprime_iff_not_dvd.mpr hp_not_div_m1 ) <| hp.coprime_iff_not_dvd.mpr hp_not_div_3 ) hp2 )
  exact hp4

/-
For m > 0, m^4+m^2+1 is not a perfect square.
-/
lemma not_isSquare_m_pow_four_plus_m_sq_plus_one (m : ℕ) (hm : m > 0) : ¬ IsSquare (m ^ 4 + m ^ 2 + 1) := by
  exact fun ⟨ k, hk ⟩ => by nlinarith [ show k = m ^ 2 + 1 by nlinarith ] ;

/-
If n, n+1, n+2 are powerful, then n mod 36 is 7, 27, or 35.
-/
lemma n_mod_36_of_consecutive_powerful (n : ℕ) (h1 : Powerful n) (h2 : Powerful (n + 1)) (h3 : Powerful (n + 2)) : n % 36 = 7 ∨ n % 36 = 27 ∨ n % 36 = 35 := by
  -- From Lemma 2, we know that $n \equiv 3 \pmod{4}$.
  have h_mod_four : n % 4 = 3 := by
    -- Since $n+1$ is powerful and even, it must be divisible by $4$. Hence, $n+1 \equiv 0 \pmod{4}$, which implies $n \equiv -1 \equiv 3 \pmod{4}$.
    have h4 : 4 ∣ n + 1 := by
      by_cases h_even : Even (n + 1);
      · exact h2 2 Nat.prime_two ( even_iff_two_dvd.mp h_even ) |> fun h => dvd_trans ( by decide ) h;
      · have := h1 2 Nat.prime_two; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
        obtain ⟨ k, hk ⟩ := this; specialize h3 2 Nat.prime_two; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
        norm_num [ Nat.dvd_add_right ] at h3
    have h_mod4 : n % 4 = 3 := by
      omega
    exact h_mod4;
  -- From Lemma 3, we know that $n \equiv 7 \pmod{9}$.
  have h_mod_nine : n % 9 = 7 ∨ n % 9 = 0 ∨ n % 9 = 8 := by
    have := h1 3 Nat.prime_three; ( have := h2 3 Nat.prime_three; ( have := h3 3 Nat.prime_three; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] at *; have := Nat.mod_lt n ( by decide : 0 < 9 ) ; interval_cases n % 9 <;> simp_all +decide only ; ) );
    all_goals rw [ ← Nat.mod_mod_of_dvd n ( by decide : 3 ∣ 9 ) ] at *; have := Nat.mod_lt n ( by decide : 0 < 9 ) ; interval_cases n % 9 <;> contradiction;
  grind

/-
Prime factors of m^2+m+1 are 3 or 1 mod 3.
-/
lemma prime_factors_of_m_sq_plus_m_plus_one (m : ℕ) (p : ℕ) (hp : p.Prime) (h : p ∣ m ^ 2 + m + 1) : p = 3 ∨ p % 3 = 1 := by
  by_cases h_mod : p % 3 = 2;
  · -- If $p \equiv 2 \pmod{3}$, then $(2m+1)^2 \equiv -3 \pmod{p}$ implies that $-3$ is a quadratic residue modulo $p$.
    have h_quad_res : (∃ x : ZMod p, x^2 = -3) := by
      use 2 * m + 1;
      haveI := Fact.mk hp; norm_num [ ← ZMod.natCast_eq_zero_iff ] at *; linear_combination' h * 4;
    -- By Euler's criterion, since $p \equiv 2 \pmod{3}$, we have $\left(\frac{-3}{p}\right) = \left(\frac{-1}{p}\right)\left(\frac{3}{p}\right)$.
    have h_euler : jacobiSym (-3) p = -1 := by
      rw [ jacobiSym.mod_right ];
      · have := Nat.mod_lt p ( by decide : 0 < 12 ) ; interval_cases _ : p % 12 <;> simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 12 ) ] ;
        · have := Nat.Prime.eq_two_or_odd hp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 12 ) ] ;
          simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
        · native_decide +revert;
        · have := Nat.Prime.eq_two_or_odd hp; omega;
        · native_decide;
      · exact hp.odd_of_ne_two <| by rintro rfl; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
    rw [ jacobiSym ] at h_euler;
    norm_num [ Nat.primeFactorsList_prime hp ] at h_euler;
    haveI := Fact.mk hp; simp_all +decide [ legendreSym.eq_neg_one_iff ] ;
    exact False.elim <| h_euler <| by obtain ⟨ x, hx ⟩ := h_quad_res; exact ⟨ x, by rw [ sq ] at hx; exact hx.symm ⟩ ;
  · have := Nat.mod_lt p three_pos; interval_cases _ : p % 3 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hp.dvd_iff_eq ] ;

/-
Prime factors of m^2-m+1 are 3 or 1 mod 3.
-/
lemma prime_factors_of_m_sq_sub_m_plus_one (m : ℕ) (p : ℕ) (hp : p.Prime) (h : p ∣ m ^ 2 - m + 1) : p = 3 ∨ p % 3 = 1 := by
  have h_div : (2 * m - 1) ^ 2 ≡ -3 [ZMOD p] := by
    exact Int.modEq_iff_dvd.mpr ( by obtain ⟨ k, hk ⟩ := h; use -k * 4; linarith [ Nat.sub_add_cancel ( show m ^ 2 ≥ m by nlinarith ) ] );
  -- If $p \neq 3$, then $-3$ is a quadratic residue modulo $p$, which implies that $\left(\frac{-3}{p}\right) = 1$.
  by_cases h3 : p = 3;
  · exact Or.inl h3;
  · have h_quad_res : jacobiSym (-3) p = 1 := by
      rw [ jacobiSym ];
      norm_num [ Nat.primeFactorsList_prime hp ];
      haveI := Fact.mk hp; rw [ legendreSym.eq_one_iff ] ;
      · exact ⟨ 2 * m - 1, by simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using h_div.symm ⟩;
      · simp +zetaDelta at *;
        erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by norm_num ) H; interval_cases p <;> trivial;
    rw [ jacobiSym.mod_right ] at h_quad_res;
    · have := Nat.mod_lt p ( by decide : 0 < 12 ) ; interval_cases _ : p % 12 <;> simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 12 ) ] ;
      all_goals have := Nat.Prime.eq_two_or_odd hp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 12 ) ];
      · exact absurd h ( by rw [ ← even_iff_two_dvd ] ; rw [ Nat.even_add, Nat.even_sub ] <;> norm_num [ parity_simps ] ; nlinarith );
      · norm_num at h_quad_res;
      · norm_num at h_quad_res;
      · norm_num at h_quad_res;
      · norm_num at h_quad_res;
    · exact hp.odd_of_ne_two <| by rintro rfl; exact absurd h <| by rw [ ← even_iff_two_dvd ] ; simp +arith +decide [ Nat.even_add, Nat.even_sub ( show m ≤ m^2 by nlinarith ), parity_simps ] ;

/-
For m > 0, m^2+m+1 is not a perfect square.
-/
lemma not_isSquare_m_sq_plus_m_plus_one (m : ℕ) (hm : m > 0) : ¬ IsSquare (m ^ 2 + m + 1) := by
  exact fun ⟨ k, hk ⟩ => by nlinarith [ show k = m + 1 by nlinarith ] ;

/-
If m is even, then m^2-m+1 and m^2+m+1 are coprime.
-/
lemma gcd_m_sq_sub_m_plus_one_m_sq_plus_m_plus_one (m : ℕ) (h_even : Even m) : Nat.Coprime (m ^ 2 - m + 1) (m ^ 2 + m + 1) := by
  norm_num [ show m ^ 2 + m + 1 = ( m ^ 2 - m + 1 ) + ( 2 * m ) by linarith [ Nat.sub_add_cancel ( show m ^ 2 ≥ m by nlinarith ) ] ];
  norm_num [ show m ^ 2 - m = m * ( m - 1 ) by rw [ Nat.pow_two, Nat.mul_sub_left_distrib, Nat.mul_one ] ];
  rcases m with ( _ | _ | m ) <;> simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ]