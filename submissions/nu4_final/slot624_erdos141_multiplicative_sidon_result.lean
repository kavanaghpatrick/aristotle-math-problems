/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f6967df4-eee2-41a6-a6a0-76dd966119bf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A set A is a Sidon set if all pairwise sums are distinct. Equivalently, if i1+i2 = j1+j2 for elements in A, then {i1,i2} = {j1,j2}.
-/
def IsSidon {M : Type*} [AddCommMonoid M] (A : Set M) : Prop :=
  ∀ i1 ∈ A, ∀ i2 ∈ A, ∀ j1 ∈ A, ∀ j2 ∈ A, i1 + i2 = j1 + j2 → ({i1, i2} : Set M) = {j1, j2}

/-
The set {1, 2, 4, 8, 13} is a Sidon set.
-/
theorem small_sidon_set : IsSidon ({1, 2, 4, 8, 13} : Set ℕ) := by
  intro i hi j hj k hk l hl h; simp_all +decide [ Set.Subset.antisymm_iff ];
  rcases hi with ( rfl | rfl | rfl | rfl | rfl ) <;> rcases hj with ( rfl | rfl | rfl | rfl | rfl ) <;> rcases hk with ( rfl | rfl | rfl | rfl | rfl ) <;> rcases hl with ( rfl | rfl | rfl | rfl | rfl ) <;> simp +decide at h ⊢;
  all_goals simp +decide [ Set.insert_subset_iff ] ;

/-
If A is a Sidon set, then A contains no 3-term arithmetic progression. Equivalently: for a, d with d > 0, if a, a+d, a+2d all in A, then False.
-/
theorem sidon_no_3ap {A : Set ℕ} (h : IsSidon A) : ∀ a d, d > 0 → a ∈ A → a + d ∈ A → a + 2 * d ∈ A → False := by
  -- Assume a, a+d, a+2d are in A. Then a + (a+2d) = (a+d) + (a+d). By IsSidon: {a, a+2d} = {a+d, a+d}, which forces a = a+d, contradicting d > 0.
  intros a d hd_pos ha ha_d ha_2d
  have h_eq : a + (a + 2 * d) = (a + d) + (a + d) := by ring
  have h_contra : ({a, a + 2 * d} : Set ℕ) = {a + d, a + d} := by
    exact h _ ha _ ha_2d _ ha_d _ ha_d h_eq;
  grind

/-
If A is a Sidon subset of {1, ..., N}, then |A|(|A|-1) <= 2(N-1).
-/
theorem sidon_card_le_sqrt_two_mul_n {N : ℕ} {A : Finset ℕ} (h_sidon : IsSidon (A : Set ℕ)) (h_subset : A ⊆ Finset.Icc 1 N) :
    A.card * (A.card - 1) ≤ 2 * (N - 1) := by
      -- Consider the set of differences D = {x - y | x, y ∈ A, x > y}.
      set D := Finset.image (fun (p : ℕ × ℕ) => p.1 - p.2) (Finset.filter (fun p => p.1 > p.2) (A ×ˢ A)) with hD;
      -- Since A is a Sidon set, all differences are distinct. Hence, the cardinality of D is at most N-1.
      have hD_card : D.card ≤ N - 1 := by
        have h_distinct_diffs : ∀ d ∈ D, 1 ≤ d ∧ d ≤ N - 1 := by
          simp +zetaDelta at *;
          exact fun d x y hx hy hxy hd => ⟨ hd ▸ Nat.sub_pos_of_lt hxy, hd ▸ Nat.sub_le_sub_right ( Finset.mem_Icc.mp ( h_subset hx ) |>.2 ) _ |> le_trans <| Nat.sub_le_sub_left ( Finset.mem_Icc.mp ( h_subset hy ) |>.1 ) _ ⟩;
        exact le_trans ( Finset.card_le_card fun x hx => Finset.mem_Icc.mpr ( h_distinct_diffs x hx ) ) ( by simpa );
      -- The number of pairs (x, y) with x > y is |A| * (|A| - 1) / 2.
      have h_pairs : (Finset.filter (fun p => p.1 > p.2) (A ×ˢ A)).card = A.card * (A.card - 1) / 2 := by
        -- The number of pairs (x, y) with x > y is equal to the number of ways to choose 2 elements from A, which is given by the binomial coefficient.
        have h_pairs : (Finset.filter (fun p => p.1 > p.2) (A ×ˢ A)).card = Finset.card (Finset.powersetCard 2 A) := by
          refine' Finset.card_bij ( fun p hp => { p.1, p.2 } ) _ _ _;
          · grind;
          · simp +contextual [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
            intros; omega;
          · intro b hb; rw [ Finset.mem_powersetCard ] at hb; rcases Finset.card_eq_two.mp hb.2 with ⟨ x, y, hxy ⟩ ; cases lt_trichotomy x y <;> aesop;
        rw [ h_pairs, Finset.card_powersetCard, Nat.choose_two_right ];
      have h_inj : Function.Injective (fun p : ℕ × ℕ => p.1 - p.2) ∨ ∀ x ∈ A, ∀ y ∈ A, x > y → ∀ z ∈ A, ∀ w ∈ A, z > w → x - y = z - w → x = z ∧ y = w := by
        right; intro x hx y hy hxy z hz w hw hzw h_diff; have := h_sidon x hx y hy z hz w hw; simp_all +decide [ Set.Subset.antisymm_iff, Set.subset_def ] ;
        have := h_sidon x hx w hw z hz y hy; simp_all +decide [ Set.Subset.antisymm_iff, Set.subset_def ] ;
        grind +ring;
      cases' h_inj with h_inj h_inj;
      · exact absurd ( @h_inj ( 0, 0 ) ( 1, 1 ) ) ( by decide );
      · contrapose! hD_card;
        rw [ Finset.card_image_of_injOn ];
        · linarith [ Nat.div_mul_cancel ( show 2 ∣ A.card * ( A.card - 1 ) from even_iff_two_dvd.mp ( Nat.even_mul_pred_self _ ) ) ];
        · intro p hp q hq; specialize h_inj p.1 ( Finset.mem_product.mp ( Finset.mem_filter.mp hp |>.1 ) |>.1 ) p.2 ( Finset.mem_product.mp ( Finset.mem_filter.mp hp |>.1 ) |>.2 ) ( Finset.mem_filter.mp hp |>.2 ) q.1 ( Finset.mem_product.mp ( Finset.mem_filter.mp hq |>.1 ) |>.1 ) q.2 ( Finset.mem_product.mp ( Finset.mem_filter.mp hq |>.1 ) |>.2 ) ( Finset.mem_filter.mp hq |>.2 ) ; aesop;

/-
The group of units of the Galois field GF(p^3) is cyclic.
-/
example (p : ℕ) [Fact (Nat.Prime p)] : IsCyclic (GaloisField p 3)ˣ := inferInstance

/-
The Singer set is the set of indices i in {0, ..., p^2+p} such that the trace of g^i is 0, where g is a generator of the multiplicative group of GF(p^3).
-/
noncomputable def SingerSet (p : ℕ) [Fact (Nat.Prime p)] : Finset ℕ :=
  let q := p^2 + p + 1
  let K := GaloisField p 3
  let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
  let tr := Algebra.trace (ZMod p) K
  (Finset.range q).filter (fun i => tr (g ^ i : Kˣ) = 0)

/-
The linear functionals Tr(x) and Tr(x * g^d) are linearly independent over F_p if d is not a multiple of p^2+p+1.
-/
theorem singer_linear_independence (p : ℕ) [Fact (Nat.Prime p)] (d : ℕ) (hd : d % (p^2 + p + 1) ≠ 0) :
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    let tr := Algebra.trace (ZMod p) K
    let L1 : K →ₗ[ZMod p] ZMod p := tr
    let L2 : K →ₗ[ZMod p] ZMod p := tr.comp (LinearMap.mulRight (ZMod p) (g ^ d : K))
    LinearIndependent (ZMod p) ![L1, L2] := by
      have h_linear_indep : ∀ (c1 c2 : ZMod p), (c1 • Algebra.trace (ZMod p) (GaloisField p 3) + c2 • (Algebra.trace (ZMod p) (GaloisField p 3) ∘ₗ LinearMap.mulRight (ZMod p) ((↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) ^ d))) = 0 → c1 = 0 ∧ c2 = 0 := by
        intro c1 c2 h;
        -- If $c_2 \neq 0$, then $g^d = -c_1 c_2^{-1} \in \mathbb{F}_p$.
        by_cases hc2 : c2 = 0;
        · have h_trace_nonzero : ∃ x : GaloisField p 3, Algebra.trace (ZMod p) (GaloisField p 3) x ≠ 0 := by
            have h_trace_nonzero : Function.Surjective (Algebra.trace (ZMod p) (GaloisField p 3)) := by
              exact?;
            exact Exists.elim ( h_trace_nonzero 1 ) fun x hx => ⟨ x, by simp +decide [ hx ] ⟩;
          obtain ⟨ x, hx ⟩ := h_trace_nonzero; replace h := congr_arg ( fun f => f x ) h; aesop;
        · -- If $c_2 \neq 0$, then $g^d = -c_1 c_2^{-1} \in \mathbb{F}_p$, which contradicts the assumption that $d$ is not a multiple of $p^2+p+1$.
          have h_contra : (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) ^ d ∈ Set.range (algebraMap (ZMod p) (GaloisField p 3)) := by
            have h_contra : ∀ x : GaloisField p 3, Algebra.trace (ZMod p) (GaloisField p 3) (x * (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) ^ d) = -c1 / c2 * Algebra.trace (ZMod p) (GaloisField p 3) x := by
              field_simp;
              intro x; replace h := congr_arg ( fun f => f x ) h; simp_all +decide [ mul_comm, add_eq_zero_iff_eq_neg ] ;
            -- Since the trace pairing is non-degenerate, this implies $c_1 + c_2 g^d = 0$.
            have h_nondeg : ∀ y : GaloisField p 3, (∀ x : GaloisField p 3, Algebra.trace (ZMod p) (GaloisField p 3) (x * y) = 0) → y = 0 := by
              intro y hy;
              contrapose! hy;
              have h_nondeg : Function.Surjective (Algebra.trace (ZMod p) (GaloisField p 3)) := by
                exact?;
              obtain ⟨ x, hx ⟩ := h_nondeg 1;
              exact ⟨ x / y, by simp +decide [ hx, hy ] ⟩;
            contrapose! h_nondeg;
            use (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) ^ d + (c1 / c2) • 1;
            simp_all +decide [ mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm ];
            simp_all +decide [ div_eq_mul_inv, add_eq_zero_iff_eq_neg ];
            exact fun h => h_nondeg ( - ( c1 * c2⁻¹ ) ) ( by simpa [ Algebra.smul_def ] using h.symm );
          -- If $g^d \in \mathbb{F}_p$, then $g^{d(p-1)} = 1$, which implies $p^3-1$ divides $d(p-1)$.
          have h_div : (p ^ 3 - 1 : ℕ) ∣ d * (p - 1) := by
            have h_div : (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) ^ (d * (p - 1)) = 1 := by
              obtain ⟨ x, hx ⟩ := h_contra;
              rw [ pow_mul, ← hx ];
              by_cases hx_zero : x = 0;
              · replace hx := congr_arg ( fun x => x ≠ 0 ) hx ; simp_all +decide [ pow_eq_zero_iff' ];
              · rw [ ← map_pow, ZMod.pow_card_sub_one_eq_one hx_zero, map_one ];
            have h_order : orderOf (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : GaloisField p 3) = p ^ 3 - 1 := by
              have h_order : orderOf (↑(Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) : (GaloisField p 3)ˣ) = p ^ 3 - 1 := by
                rw [ orderOf_eq_card_of_forall_mem_zpowers ];
                · rw [ Nat.card_units, GaloisField.card ] ; norm_num;
                · exact Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g );
              convert h_order using 1;
              rw [ orderOf_eq_orderOf_iff ];
              simp +decide [ Units.ext_iff ];
            exact h_order ▸ orderOf_dvd_iff_pow_eq_one.mpr h_div;
          -- Since $p^3 - 1 = (p - 1)(p^2 + p + 1)$, we have $p^2 + p + 1 \mid d$.
          have h_div_p2p1 : (p ^ 2 + p + 1 : ℕ) ∣ d := by
            have h_div_p2p1 : (p ^ 3 - 1 : ℕ) = (p - 1) * (p ^ 2 + p + 1) := by
              exact Nat.sub_eq_of_eq_add <| by nlinarith only [ Nat.sub_add_cancel <| show 1 ≤ p from Nat.Prime.pos Fact.out ] ;
            exact Exists.elim h_div fun k hk => ⟨ k, by nlinarith [ Nat.sub_pos_of_lt ( show 1 < p from Fact.out ) ] ⟩;
          exact False.elim <| hd <| Nat.mod_eq_zero_of_dvd h_div_p2p1;
      rw [ Fintype.linearIndependent_iff ];
      exact fun g hg i => by fin_cases i <;> simp +decide [ h_linear_indep _ _ <| by simpa [ Fin.sum_univ_succ ] using hg ] ;

/-
If f and g are linearly independent functionals on a finite-dimensional vector space V, then the dimension of the intersection of their kernels is dim(V) - 2.
-/
theorem finrank_ker_inter_of_linearIndependent {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V]
    (f g : V →ₗ[K] K) (h : LinearIndependent K ![f, g]) :
    Module.finrank K ↥(LinearMap.ker f ⊓ LinearMap.ker g) = Module.finrank K V - 2 := by
      -- Consider the linear map $L : V \to K \times K$ defined by $L(v) = (f(v), g(v))$.
      set L : V →ₗ[K] K × K := LinearMap.prod f g;
      -- Since $f$ and $g$ are linearly independent, $L$ is surjective.
      have hL_surjective : Function.Surjective L := by
        -- By the linear independence of $f$ and $g$, the map $L$ is surjective.
        have h_l_surjective : ∀ (a b : K), ∃ (v : V), f v = a ∧ g v = b := by
          intro a b;
          -- By the linear independence of $f$ and $g$, the map $L$ is surjective. Hence, for any $a, b \in K$, there exists $v \in V$ such that $L(v) = (a, b)$.
          have h_l_surjective : Function.Surjective L := by
            have h_l_injective : Function.Injective (LinearMap.dualMap L) := by
              intro x y hxy;
              -- Since $x$ and $y$ are linear functionals on $K \times K$, we can write them as $x = a \cdot \text{proj}_1 + b \cdot \text{proj}_2$ and $y = c \cdot \text{proj}_1 + d \cdot \text{proj}_2$ for some $a, b, c, d \in K$.
              obtain ⟨a, b, ha⟩ : ∃ a b : K, x = a • (LinearMap.fst K K K) + b • (LinearMap.snd K K K) := by
                use x (1, 0), x (0, 1);
                ext ⟨ a, b ⟩ ; simp +decide [ mul_comm ];
                simp +decide [ LinearMap.comp_apply, LinearMap.add_apply, LinearMap.smul_apply ]
              obtain ⟨c, d, hb⟩ : ∃ c d : K, y = c • (LinearMap.fst K K K) + d • (LinearMap.snd K K K) := by
                use y (1, 0), y (0, 1);
                ext ⟨ x, y ⟩ ; simp +decide [ mul_comm ];
                simp +decide [ LinearMap.comp_apply, LinearMap.add_apply, LinearMap.smul_apply ];
              simp_all +decide [ funext_iff, LinearMap.ext_iff ];
              have := h.eq_of_pair ( show a • f + b • g = c • f + d • g from by ext v; simpa using hxy v ) ; aesop;
            exact?;
          exact h_l_surjective ( a, b ) |> fun ⟨ v, hv ⟩ => ⟨ v, by simpa using congr_arg Prod.fst hv, by simpa using congr_arg Prod.snd hv ⟩;
        exact fun x => by obtain ⟨ v, hv₁, hv₂ ⟩ := h_l_surjective x.1 x.2; exact ⟨ v, by aesop ⟩ ;
      have := LinearMap.finrank_range_add_finrank_ker L;
      rw [ show LinearMap.ker L = LinearMap.ker f ⊓ LinearMap.ker g by ext; aesop ] at this;
      rw [ show LinearMap.range L = ⊤ from LinearMap.range_eq_top.mpr hL_surjective ] at this ; simp_all +decide;
      rw [ ← this, add_tsub_cancel_left ]

/-
GaloisField p 3 is finite dimensional over ZMod p.
-/
instance (p : ℕ) [Fact (Nat.Prime p)] : FiniteDimensional (ZMod p) (GaloisField p 3) :=
  FiniteDimensional.of_finrank_eq_succ (n := 2) (by rw [GaloisField.finrank]; norm_num)

/-
The intersection of the kernels of the two linearly independent functionals has dimension 1.
-/
theorem singer_kernel_intersection_dim (p : ℕ) [Fact (Nat.Prime p)] (d : ℕ) (hd : d % (p^2 + p + 1) ≠ 0) :
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    let tr := Algebra.trace (ZMod p) K
    let L1 : K →ₗ[ZMod p] ZMod p := tr
    let L2 : K →ₗ[ZMod p] ZMod p := tr.comp (LinearMap.mulRight (ZMod p) (g ^ d : K))
    Module.finrank (ZMod p) ↥(LinearMap.ker L1 ⊓ LinearMap.ker L2) = 1 := by
      convert finrank_ker_inter_of_linearIndependent _ _ ( singer_linear_independence p d hd ) using 1;
      rw [ GaloisField.finrank ] ; norm_num

/-
The intersection of the kernels of the two linearly independent functionals has dimension 1.
-/
theorem singer_kernel_intersection_dim_aux (p : ℕ) [Fact (Nat.Prime p)] (d : ℕ) (hd : d % (p^2 + p + 1) ≠ 0) :
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    let tr := Algebra.trace (ZMod p) K
    let L1 : K →ₗ[ZMod p] ZMod p := tr
    let L2 : K →ₗ[ZMod p] ZMod p := tr.comp (LinearMap.mulRight (ZMod p) (g ^ d : K))
    Module.finrank (ZMod p) ↥(LinearMap.ker L1 ⊓ LinearMap.ker L2) = 1 := by
      convert finrank_ker_inter_of_linearIndependent _ _ _ using 1;
      · rw [ GaloisField.finrank ] ; norm_num;
      · infer_instance;
      · convert singer_linear_independence p d hd using 1

/-
In a cyclic group generated by g of order (p-1)q, g^a is in the subgroup generated by g^q iff a is a multiple of q.
-/
theorem cyclic_subgroup_coset_iff {G : Type*} [CommGroup G] (g : G) {p q : ℕ} (hp : p > 1) (hq : q > 0)
    (hg : orderOf g = (p - 1) * q) (a b : ℕ) :
    (g ^ a) ∈ Subgroup.zpowers (g ^ q) ↔ a ≡ 0 [MOD q] := by
      cases min_cases ( p - 1 ) q <;> simp_all +decide [ Nat.modEq_zero_iff_dvd ];
      · constructor <;> intro h;
        · obtain ⟨ k, hk ⟩ := h;
          -- Since $g$ has order $(p-1)q$, we have $g^{qk} = g^a$ implies $qk \equiv a \pmod{(p-1)q}$.
          have h_cong : q * k ≡ a [ZMOD (p - 1) * q] := by
            rw [ Int.modEq_iff_dvd ];
            have h_cong : g ^ (a - q * k) = 1 := by
              simp_all +decide [ zpow_sub, zpow_mul ];
            have := orderOf_dvd_iff_zpow_eq_one.mpr h_cong;
            cases p <;> aesop;
          exact Int.natCast_dvd_natCast.mp ( Int.dvd_of_emod_eq_zero ( h_cong.of_dvd ( dvd_mul_left _ _ ) ▸ by simp +decide ) );
        · obtain ⟨ k, rfl ⟩ := h; simp +decide [ pow_mul ] ;
      · constructor <;> intro hgia <;> obtain ⟨ k, hk ⟩ := hgia <;> simp_all +decide [ pow_mul, orderOf_dvd_iff_pow_eq_one ] ;
        -- Since $g$ has order $(p-1)q$, we have $g^{qk} = g^a$ implies $qk \equiv a \pmod{(p-1)q}$.
        have h_cong : q * k ≡ a [ZMOD (p - 1) * q] := by
          rw [ Int.modEq_iff_dvd ];
          have h_cong : g ^ (q * k) = g ^ a := by
            simpa [ zpow_mul ] using hk;
          have h_cong : g ^ (a - q * k : ℤ) = 1 := by
            simp_all +decide [ zpow_sub ];
          have := orderOf_dvd_iff_zpow_eq_one.mpr h_cong;
          cases p <;> aesop;
        exact Int.natCast_dvd_natCast.mp ( Int.dvd_of_emod_eq_zero ( h_cong.of_dvd ( dvd_mul_left _ _ ) ▸ by norm_num ) )

/-
The units of the base field F_p inside K = F_{p^3} are exactly the powers of g^q, where g is a generator of K* and q = p^2+p+1.
-/
theorem units_of_base_field_eq_powers_of_g_q (p : ℕ) [Fact (Nat.Prime p)] :
    let q := p^2 + p + 1
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    ∀ x : Kˣ, x ∈ Subgroup.zpowers (g ^ q) ↔ ∃ c : (ZMod p)ˣ, x = algebraMap (ZMod p) K c := by
      -- The subgroup generated by $g^q$ has order $p-1$.
      have h_subgroup_order : (Nat.card (Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)))) = p - 1 := by
        rw [ Nat.card_zpowers ];
        rw [ orderOf_pow' ] <;> norm_num [ Nat.Prime.pos Fact.out ];
        have h_order : orderOf (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) = p^3 - 1 := by
          convert orderOf_eq_card_of_forall_mem_zpowers _;
          · rw [ Nat.card_units, GaloisField.card ] ; norm_num;
          · exact Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g );
        rw [ h_order, show p ^ 3 - 1 = ( p - 1 ) * ( p ^ 2 + p + 1 ) by zify; cases p <;> norm_num ; linarith ] ; norm_num [ Nat.gcd_mul_left ];
      -- The subgroup generated by $g^q$ is exactly the image of $(\mathbb{Z}/p\mathbb{Z})^\times$ under the algebra map.
      have h_subgroup_image : Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) = Subgroup.map (Units.map (algebraMap (ZMod p) (GaloisField p 3))) (⊤ : Subgroup (ZMod p)ˣ) := by
        refine' Subgroup.eq_of_le_of_card_ge _ _;
        · simp +decide [ Subgroup.zpowers_le ];
          have h_subgroup_image : ∀ x : (GaloisField p 3)ˣ, x ^ (p - 1) = 1 → ∃ c : (ZMod p)ˣ, (algebraMap (ZMod p) (GaloisField p 3)) c = x := by
            intro x hx
            have h_poly : (x : GaloisField p 3) ^ (p - 1) = 1 := by
              simpa using congr_arg ( fun x : ( GaloisField p 3 ) ˣ => ( x : GaloisField p 3 ) ) hx;
            have h_poly : (x : GaloisField p 3) ∈ Set.range (algebraMap (ZMod p) (GaloisField p 3)) := by
              have h_poly : (x : GaloisField p 3) ^ p = (x : GaloisField p 3) := by
                cases p <;> simp_all +decide [ pow_succ' ];
                exact False.elim <| Nat.not_prime_zero Fact.out
              have h_poly : (x : GaloisField p 3) ∈ Set.range (algebraMap (ZMod p) (GaloisField p 3)) := by
                have h_poly : (x : GaloisField p 3) ∈ Polynomial.roots (Polynomial.X ^ p - Polynomial.X : Polynomial (GaloisField p 3)) := by
                  simp_all +decide [ sub_eq_iff_eq_add ];
                  exact ne_of_apply_ne Polynomial.natDegree ( by rw [ Polynomial.natDegree_X_pow, Polynomial.natDegree_X ] ; exact ne_of_gt ( Nat.Prime.one_lt Fact.out ) )
                have h_poly : (Polynomial.X ^ p - Polynomial.X : Polynomial (GaloisField p 3)) = ∏ c : ZMod p, (Polynomial.X - Polynomial.C (algebraMap (ZMod p) (GaloisField p 3) c)) := by
                  refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                  exact Finset.image ( fun c : ZMod p => algebraMap ( ZMod p ) ( GaloisField p 3 ) c ) Finset.univ;
                  · refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                    · rw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                      exact Nat.Prime.one_lt Fact.out;
                    · exact ne_of_apply_ne ( Polynomial.derivative ) ( by simp +decide [ Polynomial.derivative_pow, Nat.Prime.ne_zero Fact.out ] );
                    · norm_num [ Polynomial.leadingCoeff_prod ];
                      rw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num [ Nat.Prime.one_lt Fact.out ];
                    · rw [ Finset.card_image_of_injective _ fun a b h => by simpa using h ] ; simp +decide [ Polynomial.degree_sub_eq_left_of_degree_lt, Nat.Prime.one_lt Fact.out ];
                  · simp +decide [ Polynomial.eval_prod ];
                    intro a; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_univ a ] ; simp +decide [ sub_eq_iff_eq_add ] ;
                    exact_mod_cast ZMod.pow_card a;
                simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                tauto;
              exact h_poly;
            obtain ⟨ c, hc ⟩ := h_poly; use Units.mk0 c ( by
              rintro rfl; simp_all +decide [ Units.ext_iff ] ;
              exact absurd hc.symm ( Units.ne_zero _ ) ) ; aesop;
          have h_order : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) ^ ((p^2 + p + 1) * (p - 1)) = 1 := by
            have h_order : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) ^ (p^3 - 1) = 1 := by
              have h_order : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) ^ (Nat.card (GaloisField p 3)ˣ) = 1 := by
                exact?;
              convert h_order using 2;
              rw [ Nat.card_units, GaloisField.card ] ; norm_num;
            rwa [ show p ^ 3 - 1 = ( p ^ 2 + p + 1 ) * ( p - 1 ) by zify; cases p <;> norm_num ; linarith ] at h_order;
          have h_order : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) ^ (p - 1) = 1 := by
            rwa [ pow_mul ] at h_order;
          obtain ⟨ c, hc ⟩ := h_subgroup_image _ h_order; use c; aesop;
        · simp_all +decide [ Nat.card_eq_fintype_card, Fintype.card_subtype ];
          rw [ show { x : ( GaloisField p 3 ) ˣ // ∃ x_1 : ( ZMod p )ˣ, _ } = Set.range ( Units.map ( algebraMap ( ZMod p ) ( GaloisField p 3 ) ) ) by aesop, Nat.card_eq_fintype_card, Fintype.card_of_subtype ];
          rotate_left;
          exact Finset.image ( fun x : ( ZMod p ) ˣ => Units.map ( algebraMap ( ZMod p ) ( GaloisField p 3 ) ) x ) ( Finset.univ : Finset ( ZMod p ) ˣ );
          · aesop;
          · exact Finset.card_image_le.trans ( by simp +decide [ Nat.totient_prime Fact.out ] );
      aesop

/-
In the Singer construction, any 1-dimensional subspace of GF(p^3) contains exactly one power of the generator g (modulo q).
-/
theorem unique_power_in_one_dim_subspace (p : ℕ) [Fact (Nat.Prime p)] (V : Submodule (ZMod p) (GaloisField p 3))
    (hV : Module.finrank (ZMod p) V = 1) :
    let q := p^2 + p + 1
    let g : (GaloisField p 3)ˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)
    ∃! (j : ZMod q), (g ^ j.val : GaloisField p 3) ∈ V := by
      obtain ⟨ v, hv ⟩ := finrank_eq_one_iff'.mp hV;
      obtain ⟨c, hc⟩ : ∃ c : (GaloisField p 3)ˣ, (c : GaloisField p 3) = v := by
        exact ⟨ Units.mk0 _ ( by aesop ), rfl ⟩;
      -- By `units_of_base_field_eq_powers_of_g_q`, $\mathbb{F}_p^\times$ corresponds to the powers of $g^q$.
      have h_units : ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) ↔ ∃ c : (ZMod p)ˣ, x = algebraMap (ZMod p) (GaloisField p 3) c := by
        convert units_of_base_field_eq_powers_of_g_q p using 1;
      -- By `cyclic_subgroup_coset_iff`, $g^{j-k} \in \langle g^q \rangle$ if and only if $j-k \equiv 0 \pmod q$.
      have h_coset : ∀ j k : ℕ, (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (j - k : ℤ) : (GaloisField p 3)ˣ) ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) ↔ (j - k : ℤ) ≡ 0 [ZMOD (p^2 + p + 1)] := by
        intros j k
        have h_order : orderOf (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g)) = (p - 1) * (p^2 + p + 1) := by
          have h_order : orderOf (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g)) = Nat.card (GaloisField p 3)ˣ := by
            rw [ orderOf_eq_card_of_forall_mem_zpowers ];
            exact Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g );
          rw [ h_order, Nat.card_units ];
          rw [ GaloisField.card ] ; ring;
          · exact Nat.sub_eq_of_eq_add <| by nlinarith only [ Nat.sub_add_cancel <| show 1 ≤ p from Nat.Prime.pos Fact.out ] ;
          · norm_num;
        have h_coset : ∀ a : ℤ, (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ a : (GaloisField p 3)ˣ) ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) ↔ a ≡ 0 [ZMOD (p^2 + p + 1)] := by
          intros a
          apply Iff.intro;
          · rintro ⟨ k, hk ⟩;
            have h_exp : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g)) ^ (a - k * (p^2 + p + 1)) = 1 := by
              simp_all +decide [ zpow_sub, zpow_mul' ];
              norm_cast at * ; aesop;
            have h_exp : (p - 1) * (p^2 + p + 1) ∣ Int.natAbs (a - k * (p^2 + p + 1)) := by
              rw [ ← h_order ];
              rw [ orderOf_dvd_iff_pow_eq_one ];
              cases' Int.eq_nat_or_neg ( a - k * ( p ^ 2 + p + 1 ) ) with h h ; aesop;
            rw [ Int.modEq_zero_iff_dvd ];
            rw [ ← Int.natCast_dvd ] at *;
            rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.succ_eq_add_one, mul_add ];
            · exact ⟨ k, by linarith ⟩;
            · obtain ⟨ m, hm ⟩ := h_exp; exact ⟨ m * ( p + 1 ) + k, by nlinarith ⟩ ;
          · intro ha
            obtain ⟨k, hk⟩ : ∃ k : ℤ, a = k * (p^2 + p + 1) := by
              exact exists_eq_mul_left_of_dvd <| Int.modEq_zero_iff_dvd.mp ha;
            simp +decide [ hk, zpow_mul' ];
            norm_cast ; simp +decide [ pow_mul ];
        exact h_coset _;
      obtain ⟨k, hk⟩ : ∃ k : ℕ, (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ k : (GaloisField p 3)ˣ) = c := by
        have := Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g ) c;
        obtain ⟨ k, rfl ⟩ := this;
        use Int.toNat ( k % ( orderOf ( Classical.choose ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g ) ) ) );
        simp +decide [ ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ <| Int.natCast_ne_zero.mpr <| ne_of_gt <| orderOf_pos _ ) ];
        rw [ ← Int.emod_add_mul_ediv k ( orderOf ( Classical.choose ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x : ( GaloisField p 3 ) ˣ, x ∈ Subgroup.zpowers g ) ) ), zpow_add, zpow_mul ] ; norm_num [ pow_orderOf_eq_one ];
      refine' ⟨ ⟨ k % ( p ^ 2 + p + 1 ), Nat.mod_lt _ ( Nat.succ_pos _ ) ⟩, _, _ ⟩ <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      · have h_coset : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (k % (p^2 + p + 1) - k : ℤ) : (GaloisField p 3)ˣ) ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) := by
          rw [ h_units ];
          convert h_coset ( k % ( p ^ 2 + p + 1 ) ) k |>.2 _ using 1;
          · norm_cast;
          · exact Int.modEq_zero_iff_dvd.mpr ⟨ - ( k / ( p ^ 2 + p + 1 ) ), by push_cast; linarith [ Nat.mod_add_div k ( p ^ 2 + p + 1 ) ] ⟩;
        obtain ⟨ c, hc ⟩ := h_units _ |>.1 h_coset;
        have h_coset : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (k % (p^2 + p + 1) : ℕ) : (GaloisField p 3)ˣ) = (algebraMap (ZMod p) (GaloisField p 3) c) * (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ k : (GaloisField p 3)ˣ) := by
          simp_all +decide [ zpow_sub, zpow_add ];
          rw [ ← hc, mul_assoc, inv_mul_cancel₀ ( by aesop ), mul_one ] ; norm_cast;
        have h_coset : (algebraMap (ZMod p) (GaloisField p 3) c) * (v : GaloisField p 3) ∈ V := by
          convert V.smul_mem ( c : ZMod p ) v.2 using 1;
          simp +decide [ Algebra.smul_def ];
        convert h_coset using 1;
        aesop;
      · intro y hy; specialize h_coset y.val k; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        -- Since $y.cast - k \equiv 0 \pmod{p^2 + p + 1}$, we have $y.cast \equiv k \pmod{p^2 + p + 1}$.
        have h_cong : y.val ≡ k [MOD (p^2 + p + 1)] := by
          have h_cong : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (y.val - k : ℤ) : (GaloisField p 3)ˣ) ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (p^2 + p + 1)) := by
            obtain ⟨ c, hc ⟩ := hv.2 _ hy;
            have h_coset : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x : (GaloisField p 3)ˣ, x ∈ Subgroup.zpowers g) ^ (y.val - k : ℤ) : (GaloisField p 3)ˣ) = algebraMap (ZMod p) (GaloisField p 3) c := by
              replace hc := congr_arg Subtype.val hc; simp_all +decide [ zpow_sub, zpow_add ] ;
              convert congr_arg ( fun x : GaloisField p 3 => x * ( v : GaloisField p 3 ) ⁻¹ ) hc.symm using 1 ; ring;
              · rw [ mul_comm ] ; norm_cast;
              · simp +decide [ Algebra.smul_def, hv.1 ];
            by_cases hc : c = 0 <;> simp_all +decide [ Subgroup.mem_zpowers_iff ];
            exact absurd h_coset ( by exact zpow_ne_zero _ <| Units.ne_zero _ );
          simp_all +decide [ ← Int.natCast_modEq_iff ];
          simpa using h_cong.add_left k;
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        exact?

/-
For any non-zero difference d, there is a unique j in Z/qZ such that j and j+d are both in the Singer set.
-/
theorem singer_difference_uniqueness (p : ℕ) [Fact (Nat.Prime p)] (d : ℕ) (hd : d % (p^2 + p + 1) ≠ 0) :
    let q := p^2 + p + 1
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    let tr := Algebra.trace (ZMod p) K
    ∃! (j : ZMod q), tr (g ^ j.val : Kˣ) = 0 ∧ tr (g ^ (j.val + d) : Kˣ) = 0 := by
      -- Let $L_1(x) = \text{Tr}(x)$ and $L_2(x) = \text{Tr}(x g^d)$.
      let q := p^2 + p + 1
      let K := GaloisField p 3
      let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
      let tr := Algebra.trace (ZMod p) K
      let L1 : K →ₗ[ZMod p] ZMod p := tr
      let L2 : K →ₗ[ZMod p] ZMod p := tr.comp (LinearMap.mulRight (ZMod p) (g ^ d : K));
      -- Let $V = \ker L_1 \cap \ker L_2$.
      set V : Submodule (ZMod p) K := LinearMap.ker L1 ⊓ LinearMap.ker L2;
      have hV_dim : Module.finrank (ZMod p) V = 1 := by
        convert singer_kernel_intersection_dim_aux p d hd using 1;
      obtain ⟨ j, hj ⟩ := unique_power_in_one_dim_subspace p V hV_dim;
      use j;
      simp +zetaDelta at *;
      exact ⟨ ⟨ hj.1.1, by simpa only [ pow_add ] using hj.1.2 ⟩, fun y hy1 hy2 => hj.2 y hy1 ( by simpa only [ pow_add ] using hy2 ) ⟩

/-
If for every non-zero difference d, there is a unique element a in A such that a+d is also in A, then A is a Sidon set.
-/
theorem is_sidon_of_unique_difference {G : Type*} [AddCommGroup G] (A : Set G)
    (h : ∀ d ≠ 0, ∃! a, a ∈ A ∧ a + d ∈ A) : IsSidon A := by
      intro a ha b hb c hc d hd h_eq
      by_cases h_cases : a = c ∨ a = d
      generalize_proofs at *; (
      grind);
      -- Let $k = a - c$. Then $k \neq 0$.
      set k : G := a - c
      have hk_ne_zero : k ≠ 0 := by
        exact sub_ne_zero_of_ne <| by tauto;
      -- So $c \in A$ and $c+k \in A$, and $b \in A$ and $b+k \in A$.
      have hc_k : c + k ∈ A := by
        aesop
        skip
      have hb_k : b + k ∈ A := by
        convert hd using 1 ; rw [ ← eq_sub_iff_add_eq' ] at h_eq ; aesop;
      generalize_proofs at *; (
      -- By the uniqueness hypothesis for difference $k$, there is a unique $x$ such that $x \in A$ and $x+k \in A$.
      obtain ⟨x, hx⟩ : ∃! x : G, x ∈ A ∧ x + k ∈ A := by
        exact h k hk_ne_zero
      generalize_proofs at *; (
      grind +ring))

/-
An element x in Z/qZ is in the image of the Singer set if and only if the trace of g^(x.val) is 0.
-/
theorem mem_singer_image_iff (p : ℕ) [Fact (Nat.Prime p)] (x : ZMod (p^2 + p + 1)) :
    let q := p^2 + p + 1
    let K := GaloisField p 3
    let g : Kˣ := Classical.choose (IsCyclic.exists_generator : ∃ g : Kˣ, ∀ x, x ∈ Subgroup.zpowers g)
    let tr := Algebra.trace (ZMod p) K
    x ∈ (SingerSet p).image (fun x => (x : ZMod q)) ↔ tr (g ^ x.val : Kˣ) = 0 := by
      unfold SingerSet; simp +decide [ Finset.mem_image, Finset.mem_filter ] ;
      constructor;
      · rintro ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ; rw [ ZMod.val_cast_of_lt ha₁ ] ; aesop;
      · refine fun hx => ⟨ x.val, ⟨ x.val_lt, hx ⟩, by simp +decide [ ZMod.natCast_zmod_val ] ⟩

/-
The Singer set is a Sidon set.
-/
theorem singer_is_sidon_final (p : ℕ) [Fact (Nat.Prime p)] :
    IsSidon ((SingerSet p).image (fun x => (x : ZMod (p^2 + p + 1))) : Set (ZMod (p^2 + p + 1))) := by
      by_contra h_not_sidon;
      convert is_sidon_of_unique_difference _ _ using 1;
      rotate_left;
      exact ZMod ( p ^ 2 + p + 1 );
      exact inferInstance;
      exact { x : ZMod ( p ^ 2 + p + 1 ) | Algebra.trace ( ZMod p ) ( GaloisField p 3 ) ( Classical.choose ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x, x ∈ Subgroup.zpowers g ) ^ x.val : ( GaloisField p 3 ) ˣ ) = 0 };
      · intro d hd_nonzero
        obtain ⟨j, hj_unique⟩ : ∃! j : ZMod (p^2 + p + 1), (Algebra.trace (ZMod p) (GaloisField p 3)) (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ j.val : (GaloisField p 3)ˣ) = 0 ∧ (Algebra.trace (ZMod p) (GaloisField p 3)) (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ (j.val + d.val) : (GaloisField p 3)ˣ) = 0 := by
          convert singer_difference_uniqueness p d.val _ using 1;
          rw [ Nat.mod_eq_of_lt ] <;> norm_num [ ZMod.val_lt ] ; aesop;
        use j;
        convert hj_unique using 1;
        · simp +decide [ ZMod.val_add ];
          rw [ ← Nat.mod_add_div ( j.val + d.val ) ( p ^ 2 + p + 1 ), pow_add, pow_mul ] ; norm_num;
          have h_gq_in_base : (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g)) ^ (p ^ 2 + p + 1) ∈ Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator : ∃ g : (GaloisField p 3)ˣ, ∀ x, x ∈ Subgroup.zpowers g) ^ (p ^ 2 + p + 1)) := by
            exact Subgroup.mem_zpowers _;
          have := units_of_base_field_eq_powers_of_g_q p ( Classical.choose ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x, x ∈ Subgroup.zpowers g ) ^ ( p ^ 2 + p + 1 ) ) ; simp +decide [ h_gq_in_base ] at this ⊢;
          obtain ⟨ c, hc ⟩ := this; simp +decide [ hc ] ;
          have h_trace_mul : ∀ x : GaloisField p 3, ∀ c : ZMod p, Algebra.trace (ZMod p) (GaloisField p 3) (x * algebraMap (ZMod p) (GaloisField p 3) c) = c * Algebra.trace (ZMod p) (GaloisField p 3) x := by
            simp +decide [ mul_comm, Algebra.trace_apply ];
            intro x c; exact (by
            convert LinearMap.map_smul ( LinearMap.trace ( ZMod p ) ( GaloisField p 3 ) ) c ( LinearMap.mul ( ZMod p ) ( GaloisField p 3 ) x ) using 1;
            congr! 1;
            ext; simp +decide [ mul_comm, Algebra.smul_def ] ;
            ring);
          induction' ( j.val + d.val ) / ( p ^ 2 + p + 1 ) with k hk <;> simp +decide [ pow_succ, ← mul_assoc, h_trace_mul ] at * ; aesop ( simp_config := { singlePass := true } ) ;
        · simp +decide [ ZMod.val_add ];
          congr! 3;
          rw [ ← Nat.mod_add_div ( _ + _ ) ( p ^ 2 + p + 1 ) ] ; norm_num [ pow_add, pow_mul ] ;
          have := units_of_base_field_eq_powers_of_g_q p ( Classical.choose ( IsCyclic.exists_generator : ∃ g : ( GaloisField p 3 ) ˣ, ∀ x, x ∈ Subgroup.zpowers g ) ^ ( p ^ 2 + p + 1 ) ) ; simp +decide [ pow_add, pow_mul ] at this ⊢;
          obtain ⟨ c, hc ⟩ := this; simp +decide [ hc, Algebra.trace_eq_zero_of_not_exists_basis ] ;
          have h_trace_mul : ∀ (x : GaloisField p 3) (c : (ZMod p)ˣ), Algebra.trace (ZMod p) (GaloisField p 3) (x * algebraMap (ZMod p) (GaloisField p 3) c) = c * Algebra.trace (ZMod p) (GaloisField p 3) x := by
            intro x c; exact (by
            convert LinearMap.map_smul ( Algebra.trace ( ZMod p ) ( GaloisField p 3 ) ) ( c : ZMod p ) x using 1 ; ring;
            simp +decide [ mul_comm, Algebra.smul_def ]);
          induction' ( ( ‹_› : ZMod ( p ^ 2 + p + 1 ) ).val + d.val ) / ( p ^ 2 + p + 1 ) with k hk <;> simp +decide [ pow_succ, ← mul_assoc, h_trace_mul ] at * ; tauto;
      · constructor <;> intros <;> simp_all +decide [ IsSidon ];
        rename_i h;
        obtain ⟨ x, hx, y, hy, z, hz, w, hw, h₁, h₂ ⟩ := h_not_sidon;
        specialize h x (by
        convert Finset.mem_filter.mp hx |>.2 using 1;
        simp +decide [ ZMod.val_natCast ];
        rw [ Nat.mod_eq_of_lt ( show x < p ^ 2 + p + 1 from Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ) ) ]) y (by
        convert Finset.mem_filter.mp hy |>.2 using 1;
        norm_num [ ZMod.val_natCast ];
        rw [ Nat.mod_eq_of_lt ( Finset.mem_range.mp ( Finset.mem_filter.mp hy |>.1 ) ) ]) z (by
        convert Finset.mem_filter.mp hz |>.2 using 1;
        simp +decide [ ZMod.val_natCast ];
        rw [ Nat.mod_eq_of_lt ( Finset.mem_range.mp ( Finset.mem_filter.mp hz |>.1 ) ) ]) w (by
        convert Finset.mem_filter.mp hw |>.2 using 1
        generalize_proofs at *;
        norm_num [ ZMod.val_natCast ];
        rw [ Nat.mod_eq_of_lt ( Finset.mem_range.mp ( Finset.mem_filter.mp hw |>.1 ) ) ]) h₁;
        contradiction