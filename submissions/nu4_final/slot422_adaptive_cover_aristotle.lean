/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8fddcc2a-c84e-429a-a2ca-5960dc9cdecb
-/

/-
Formalized the definitions `isTrianglePacking`, `trianglesSharingEdge`, `S_e`, `S_e_edge` and the lemma `edge_in_sym2`. Proved the main theorem `exists_two_edges_cover_Se` by incorporating the assumed result `not_all_three_edge_types` as a hypothesis, as `axiom` is not permitted.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical
open Finset

def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

def trianglesSharingEdge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (e : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2)

def S_e {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G e).filter (fun t => t ≠ e ∧ ∀ f ∈ M, f ≠ e → (t ∩ f).card ≤ 1)

def S_e_edge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V))
    (a b c : V) : Finset (Finset V) :=
  (S_e G M {a, b, c}).filter (fun T => a ∈ T ∧ b ∈ T ∧ c ∉ T)

lemma edge_in_sym2 {V : Type*} [Fintype V] [DecidableEq V] (T : Finset V) (u v : V) (hu : u ∈ T) (hv : v ∈ T) :
    s(u, v) ∈ T.sym2 := by
  simp only [Finset.mk_mem_sym2_iff]
  exact ⟨hu, hv⟩

theorem exists_two_edges_cover_Se {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (hNu4 : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ 4)
    (a b c : V) (hE : {a, b, c} ∈ M) (hab : a ≠ b) (hbc : b ≠ c) (hac : a ≠ c)
    (hE_clq : {a, b, c} ∈ G.cliqueFinset 3)
    (B C D : Finset V) (hB : B ∈ M) (hC : C ∈ M) (hD : D ∈ M)
    (hB_ne : B ≠ {a, b, c}) (hC_ne : C ≠ {a, b, c}) (hD_ne : D ≠ {a, b, c})
    (hBC : B ≠ C) (hBD : B ≠ D) (hCD : C ≠ D)
    (hB_tri : B ∈ G.cliqueFinset 3) (hC_tri : C ∈ G.cliqueFinset 3) (hD_tri : D ∈ G.cliqueFinset 3)
    (h_not_all : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (hNu4 : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ 4)
    (a b c : V) (hE : {a, b, c} ∈ M) (hab : a ≠ b) (hbc : b ≠ c) (hac : a ≠ c)
    (B C D : Finset V) (hB : B ∈ M) (hC : C ∈ M) (hD : D ∈ M)
    (hB_ne : B ≠ {a, b, c}) (hC_ne : C ≠ {a, b, c}) (hD_ne : D ≠ {a, b, c})
    (hBC : B ≠ C) (hBD : B ≠ D) (hCD : C ≠ D)
    (hB_tri : B ∈ G.cliqueFinset 3) (hC_tri : C ∈ G.cliqueFinset 3) (hD_tri : D ∈ G.cliqueFinset 3),
    ¬((S_e_edge G M a b c).Nonempty ∧
      (S_e_edge G M b c a).Nonempty ∧
      (S_e_edge G M a c b).Nonempty)) :
    ∃ (e₁ e₂ : Sym2 V), e₁ ∈ G.edgeFinset ∧ e₂ ∈ G.edgeFinset ∧
      -- Cover element E
      (e₁ ∈ ({a,b,c} : Finset V).sym2 ∨ e₂ ∈ ({a,b,c} : Finset V).sym2) ∧
      -- Cover all S_e externals
      (∀ T ∈ S_e G M {a, b, c}, e₁ ∈ T.sym2 ∨ e₂ ∈ T.sym2) := by
        by_cases h1 : (S_e_edge G M a b c).Nonempty;
        · simp +zetaDelta at *;
          by_cases h2 : (S_e_edge G M b c a).Nonempty;
          · have h3 : ¬(S_e_edge G M a c b).Nonempty := by
              exact fun h => by have := h_not_all G M hM hNu4 a b c hE hab hbc hac B C D hB hC hD hB_ne hC_ne hD_ne hBC hBD hCD hB_tri hC_tri hD_tri h1 h2; exact absurd h (by simp [this]) ;
            refine' ⟨ s(a, b), _, s(b, c), _, _, _ ⟩ <;> simp +decide [ *, SimpleGraph.mem_edgeSet ];
            · rw [ SimpleGraph.isNClique_iff ] at hE_clq ; aesop;
            · exact hE_clq.1 ( by simp +decide ) ( by simp +decide ) hbc;
            · intro T hT; simp only [S_e, trianglesSharingEdge, mem_filter] at hT; obtain ⟨⟨hT_tri, hT_inter⟩, hT_ne, hT_disjoint⟩ := hT; (
              by_cases ha : a ∈ T <;> by_cases hb : b ∈ T <;> by_cases hc : c ∈ T <;> simp +decide [ *, Finset.inter_comm ] at hT_inter ⊢;
              exact h3 ⟨ T, by
                simp +decide [ S_e_edge, S_e, trianglesSharingEdge, hT_tri, hT_ne, hT_disjoint, ha, hb, hc ];
                exact ⟨ by rw [ Finset.card_insert_of_notMem, Finset.card_singleton ] ; aesop, by rintro rfl; exact hb ( by simp +decide ), fun f hf hf' => hT_disjoint f hf ( by rintro rfl; exact hf' ( by ext; simp +decide [ *, or_comm, or_left_comm, or_assoc ] ) ) ⟩ ⟩);
          · refine' ⟨ Sym2.mk ( a, b ), _, Sym2.mk ( a, c ), _, _, _ ⟩;
            · rw [ SimpleGraph.isNClique_iff ] at hE_clq ; aesop;
            · simp_all +decide [ SimpleGraph.isNClique_iff ];
            · exact Or.inl fun x hx => by rcases Sym2.mem_iff.mp hx with ( rfl | rfl ) <;> simp +decide ;
            · simp +decide [ S_e, trianglesSharingEdge ];
              intro T hT hT_inter hT_ne hT_disjoint
              by_cases ha : a ∈ T;
              · by_cases hb : b ∈ T <;> by_cases hc : c ∈ T <;> simp_all +decide [ Finset.inter_comm ];
              · have hbc_sub : b ∈ T ∧ c ∈ T := by
                  have hbc_sub : b ∈ T ∧ c ∈ T := by
                    have hbc_sub : T ∩ {a, b, c} ⊆ {b, c} := by
                      simp +decide [ Finset.subset_iff, ha ]
                    have := Finset.eq_of_subset_of_card_le hbc_sub ; simp_all +decide;
                    exact ⟨ this ( Finset.mem_insert_self _ _ ), this ( Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ) ⟩;
                  exact hbc_sub;
                have hT_type2 : T ∈ S_e_edge G M b c a := by
                  simp +decide [ S_e_edge, S_e, trianglesSharingEdge, hT, hT_inter, hT_ne, hT_disjoint ];
                  simp_all +decide [ Finset.inter_comm, Finset.inter_left_comm, Finset.inter_assoc ];
                  exact ⟨ by rintro rfl; exact ha ( by simp +decide ), fun f hf hf_ne => hT_disjoint f hf ( by rintro rfl; exact hf_ne ( by ext x; simp +decide [ or_comm, or_left_comm, or_assoc ] ) ) ⟩;
                exact False.elim ( h2 ⟨ T, hT_type2 ⟩ );
        · -- Since S_e_edge G M a b c is empty, any element of S_e G M {a, b, c} must be in S_e_edge G M b c a or S_e_edge G M a c b.
          have h_subset : ∀ T ∈ S_e G M {a, b, c}, T ∈ S_e_edge G M b c a ∨ T ∈ S_e_edge G M a c b := by
            intro T hT
            simp [S_e_edge] at *;
            by_cases ha : a ∈ T <;> by_cases hb : b ∈ T <;> by_cases hc : c ∈ T <;> simp +decide [ ha, hb, hc ] at hT ⊢;
            all_goals simp +decide [ S_e, trianglesSharingEdge ] at hT;
            all_goals have := hT.1.2; simp +decide [ Finset.inter_comm, ha, hb, hc ] at this;
            · have := hT.1.1.2; simp_all +decide [ Finset.subset_iff ] ;
              have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset ha ( Finset.insert_subset hb ( Finset.singleton_subset_iff.mpr hc ) ) ) ; simp_all +decide ;
            · exact absurd ( h1 ( show T ∈ S_e G M { a, b, c } from by
                                    simp +decide [ S_e, trianglesSharingEdge, hT ];
                                    exact hT.2.2 ) ha hb ) hc;
            · simp +decide [ S_e, trianglesSharingEdge ];
              simp +decide [ Finset.inter_comm, Finset.inter_left_comm, Finset.inter_assoc, ha, hb, hc ] at hT ⊢;
              exact ⟨ hT.1, by rintro rfl; exact hb ( by simp +decide ), fun f hf hf' => hT.2.2 f hf ( by rintro rfl; exact hf' ( by simp +decide [ Finset.pair_comm ] ) ) ⟩;
            · simp +decide [ S_e, trianglesSharingEdge, Finset.inter_comm, Finset.inter_assoc, Finset.inter_left_comm, ha, hb, hc ] at hT ⊢;
              exact ⟨ hT.1, by rintro rfl; exact ha ( by simp +decide ), fun f hf hf' => hT.2.2 f hf ( by rintro rfl; exact hf' ( by ext; simp +decide [ or_comm, or_left_comm, or_assoc ] ) ) ⟩;
          refine' ⟨ s(b, c), s(a, c), _, _, _, _ ⟩;
          · simp +zetaDelta at *;
            exact hE_clq.1 ( by simp +decide ) ( by simp +decide ) hbc;
          · simp +zetaDelta at *;
            exact hE_clq.1 ( by simp +decide ) ( by simp +decide ) hac;
          · simp +decide [ Sym2.mem_iff ];
          · intro T hT; specialize h_subset T hT; simp +decide [ S_e_edge ] at h_subset ⊢;
            grind