/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6fe024dc-8665-46f9-b086-f7a733b7910a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This file proves that the dihedral group of order 2n is a Leinster group if and only if n is an odd perfect number. The main theorem is `dihedral_is_leinster_iff_odd_perfect`. It relies on classifying the normal subgroups of the dihedral group for both odd and even n. For odd n, the normal subgroups are the cyclic subgroups generated by `r^d` where `d|n`, plus the whole group. For even n, there are additional normal subgroups of index 2, which prevents the Leinster condition from holding.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped Classical

def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

def LeinsterGroup.rotations (n : ℕ) : Subgroup (DihedralGroup n) := Subgroup.zpowers (DihedralGroup.r 1)

lemma LeinsterGroup.rotations_normal {n : ℕ} [NeZero n] : (LeinsterGroup.rotations n).Normal := by
  constructor;
  rintro _ ⟨ k, rfl ⟩ g;
  rcases g with ( _ | _ ) <;> simp +decide [ zpow_mul ];
  · exact ⟨ k, by aesop ⟩;
  · exact ⟨ -k, by simp +decide ⟩

lemma LeinsterGroup.subgroup_of_rotations_is_normal {n : ℕ} [NeZero n] (H : Subgroup (DihedralGroup n)) (h : H ≤ LeinsterGroup.rotations n) : H.Normal := by
  -- Since the rotations subgroup is cyclic and normal, any subgroup of it is also normal. Hence, $H$ is normal.
  have h_cyclic_normal : ∀ {H : Subgroup (DihedralGroup n)}, H ≤ LeinsterGroup.rotations n → H.Normal := by
    intro H hH
    have h_cyclic : ∀ {H : Subgroup (DihedralGroup n)}, H ≤ LeinsterGroup.rotations n → ∀ g : DihedralGroup n, ∀ h ∈ H, g * h * g⁻¹ ∈ H := by
      -- Since the rotations subgroup is normal, for any $g \in D_n$ and $h \in H$, we have $g * h * g⁻¹ \in H$.
      have h_normal : ∀ {H : Subgroup (DihedralGroup n)}, H ≤ LeinsterGroup.rotations n → ∀ g : DihedralGroup n, ∀ h ∈ H, g * h * g⁻¹ ∈ H := by
        intro H hH g h hh
        have h_rot : h ∈ LeinsterGroup.rotations n := hH hh
        obtain ⟨ k, rfl ⟩ := Subgroup.mem_zpowers_iff.mp h_rot;
        rcases g with ( _ | _ ) <;> simp_all +decide [ mul_assoc, zpow_neg, zpow_add ];
        convert H.inv_mem hh using 1;
      assumption
    constructor ; aesop;
  exact h_cyclic_normal h

lemma LeinsterGroup.normal_subgroup_contains_reflection_implies_top {n : ℕ} [NeZero n] (hn : Odd n) (H : Subgroup (DihedralGroup n))
    (hH : H.Normal) (h_not_le : ¬ H ≤ LeinsterGroup.rotations n) : H = ⊤ := by
  -- Since $H$ is not contained in the rotations subgroup, there exists an element $h \in H$ such that $h \notin \langle r \rangle$.
  obtain ⟨h, hhH, hh⟩ : ∃ h ∈ H, h ∉ LeinsterGroup.rotations n := by
    exact Set.not_subset.mp h_not_le;
  -- Since $h \notin \langle r \rangle$, we have $h = sr^k$ for some $k$.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, h = DihedralGroup.sr k := by
    -- Since $h \notin \langle r \rangle$, we have $h = sr^k$ for some $k$ by definition of the dihedral group.
    have h_form : ∃ k : ℕ, h = DihedralGroup.sr k := by
      have h_cases : ∀ h : DihedralGroup n, h ∈ LeinsterGroup.rotations n ∨ ∃ k : ℕ, h = DihedralGroup.sr k := by
        intro h
        cases' h with h h;
        · exact Or.inl <| Subgroup.mem_zpowers_iff.mpr ⟨ h.val, by aesop ⟩;
        · exact Or.inr ⟨ h.val, by simp +decide ⟩
      exact Or.resolve_left ( h_cases h ) hh;
    exact h_form;
  -- Since $H$ is normal, conjugating $sr^k$ by $r$ gives $sr^{k+2}$, which must also be in $H$.
  have h_conj : ∀ m : ℕ, DihedralGroup.sr (k + 2 * m : ZMod n) ∈ H := by
    intro m; induction m <;> simp_all +decide [ ← add_assoc, mul_add, ← pow_succ ] ;
    rename_i m hm; have := hH.conj_mem _ hm ( DihedralGroup.r 1 ) ; simp_all +decide [ mul_add, add_assoc ] ;
    convert H.mul_mem ( H.mul_mem ‹DihedralGroup.sr ( k + 2 * m : ZMod n ) ∈ H› ‹DihedralGroup.sr ( k + 2 * m - 1 + -1 : ZMod n ) ∈ H› ) ‹DihedralGroup.sr ( k + 2 * m : ZMod n ) ∈ H› using 1 ; ring;
    simp +decide [ DihedralGroup.sr, add_comm, add_left_comm, add_assoc ];
  -- Since $n$ is odd, we can choose $m$ such that $k + 2m \equiv 0 \pmod{n}$.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, (k + 2 * m : ZMod n) = 0 := by
    -- Since $n$ is odd, we can find $m$ such that $2m \equiv -k \pmod{n}$.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, 2 * m ≡ -k [ZMOD n] := by
      -- Since $n$ is odd, we can find $m$ such that $2m \equiv -k \pmod{n}$ by using the fact that $2$ has a multiplicative inverse modulo $n$.
      obtain ⟨m, hm⟩ : ∃ m : ℤ, 2 * m ≡ -k [ZMOD n] := by
        -- Since $n$ is odd, we can find $m$ such that $2m \equiv 1 \pmod{n}$.
        obtain ⟨m, hm⟩ : ∃ m : ℤ, 2 * m ≡ 1 [ZMOD n] := by
          exact ⟨ ( n + 1 ) / 2, by rw [ mul_comm, Int.ediv_mul_cancel <| even_iff_two_dvd.mp <| by simpa [ parity_simps ] using hn ] ; norm_num [ Int.ModEq ] ⟩;
        exact ⟨ m * -k, by simpa [ mul_assoc ] using hm.mul_right ( -k ) ⟩;
      exact ⟨ Int.toNat ( m % n ), by simpa [ Int.ModEq, Int.mul_emod, Int.emod_nonneg _ ( NeZero.ne _ ) ] using hm ⟩;
    exact ⟨ m, by simpa [ ← ZMod.intCast_eq_intCast_iff ] using hm.add_left ( k : ℤ ) ⟩;
  -- Since $sr^{k+2m} = sr^0 = s$, we have $s \in H$.
  have h_s : DihedralGroup.sr 0 ∈ H := by
    simpa [ hm ] using h_conj m;
  -- Since $s \in H$, we have $r \in H$ because $H$ is normal.
  have h_r : DihedralGroup.r 1 ∈ H := by
    have := hH.conj_mem _ h_s ( DihedralGroup.sr 1 ) ; simp_all +decide [ DihedralGroup.sr ] ;
    -- Since $H$ contains $sr 2$ and $s$, and $H$ is closed under multiplication, we have $r 2 \in H$.
    have h_r2 : DihedralGroup.r 2 ∈ H := by
      convert H.mul_mem h_s this using 1 ; simp +decide [ DihedralGroup.sr ];
      norm_num;
    -- Since $n$ is odd, we can find an integer $m$ such that $2m \equiv 1 \pmod{n}$.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, 2 * m ≡ 1 [MOD n] := by
      exact ⟨ ( n + 1 ) / 2, by rw [ mul_comm, Nat.div_mul_cancel ( even_iff_two_dvd.mp ( by simpa [ parity_simps ] using hn ) ) ] ; simp +decide [ Nat.ModEq ] ⟩;
    convert H.pow_mem h_r2 m using 1 ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
  refine' eq_top_iff.mpr fun x hx => _;
  rcases x with ( _ | _ ) <;> simp_all +decide [ Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ];
  · rename_i x; exact Subgroup.mem_zpowers_iff.mp ( show DihedralGroup.r x ∈ Subgroup.zpowers ( DihedralGroup.r 1 ) from ⟨ x.val, by aesop ⟩ ) |> fun ⟨ k, hk ⟩ => hk.symm ▸ Subgroup.zpow_mem _ h_r _;
  · convert H.mul_mem h_s ( H.pow_mem h_r ( ‹ZMod n›.val ) ) using 1 ; simp +decide [ pow_succ, mul_assoc ]

lemma LeinsterGroup.normal_subgroups_eq_rotations_subgroups_union_top {n : ℕ} [NeZero n] (hn : Odd n) :
    {H : Subgroup (DihedralGroup n) | H.Normal} =
    {H : Subgroup (DihedralGroup n) | H ≤ LeinsterGroup.rotations n} ∪ {⊤} := by
  -- To prove equality of sets, we show each set is a subset of the other.
  apply Set.ext
  intro H
  simp [Set.mem_union, Set.mem_setOf_eq];
  -- If $H$ is normal and not less than or equal to the rotations, then it must be the top subgroup.
  apply Iff.intro
  intro hH_normal
  by_cases hH_le : H ≤ LeinsterGroup.rotations n
  · exact Or.inr hH_le
  · exact Or.inl (LeinsterGroup.normal_subgroup_contains_reflection_implies_top hn H hH_normal (by tauto));
  -- If $H$ is the top subgroup, then it is normal.
  intro hH
  cases' hH with hH_top hH_le
  · exact (by
    exact hH_top ▸ by infer_instance;;)
  · exact (by
    -- Since the rotations are normal in the dihedral group, any subgroup of the rotations must also be normal.
    apply LeinsterGroup.subgroup_of_rotations_is_normal; assumption)

lemma LeinsterGroup.rotations_isCyclic {n : ℕ} [NeZero n] : IsCyclic (LeinsterGroup.rotations n) := by
  -- The subgroup of rotations is generated by the element $r$, so it is cyclic.
  have h_cyclic : ∃ g : DihedralGroup n, LeinsterGroup.rotations n = Subgroup.zpowers g := by
    exact?;
  -- Since the subgroup of rotations is generated by a single element, it is cyclic.
  obtain ⟨g, hg⟩ := h_cyclic;
  have h_cyclic_subgroup : IsCyclic (↥(Subgroup.zpowers g)) := by
    exact ⟨ ⟨ g, Subgroup.mem_zpowers g ⟩, fun x => by obtain ⟨ k, hk ⟩ := Subgroup.mem_zpowers_iff.mp x.2; exact ⟨ k, Subtype.ext hk ⟩ ⟩;
  exact hg ▸ h_cyclic_subgroup

lemma LeinsterGroup.card_rotations {n : ℕ} [NeZero n] : Nat.card (LeinsterGroup.rotations n) = n := by
  -- The rotations subgroup is generated by the rotation by 1, which has order n.
  have h_order : orderOf (DihedralGroup.r 1 : DihedralGroup n) = n := by
    simp +decide [ orderOf_eq_iff ];
  -- The cardinality of the subgroup generated by an element is equal to the order of that element.
  have h_card : Nat.card (Subgroup.zpowers (DihedralGroup.r 1 : DihedralGroup n)) = orderOf (DihedralGroup.r 1 : DihedralGroup n) := by
    -- The cardinality of the subgroup generated by an element is equal to the order of that element, by definition of the order.
    apply Nat.card_zpowers;
  exact h_card.trans h_order

/-
In a finite cyclic group G, for every divisor d of |G|, there exists a unique subgroup of order d.
-/
lemma LeinsterGroup.exists_unique_subgroup_of_card {G : Type*} [Group G] [Fintype G] [IsCyclic G]
    {d : ℕ} (hd : d ∣ Fintype.card G) : ∃! H : Subgroup G, Nat.card H = d := by
  obtain ⟨g, hg⟩ : ∃ g : G, (orderOf g) = Fintype.card G := by
    obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := G );
    use g;
    rw [ orderOf_eq_card_of_forall_mem_zpowers hg ];
    rw [ Nat.card_eq_fintype_card ];
  -- Let $H$ be the subgroup generated by $g^{\frac{|G|}{d}}$.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, k * d = Fintype.card G := by
    exact ⟨ _, Nat.div_mul_cancel hd ⟩
  set H := Subgroup.zpowers (g ^ k);
  -- We need to show that $H$ has order $d$.
  have hH_order : Nat.card H = d := by
    -- The order of $g^k$ is $\frac{|G|}{\gcd(k, |G|)}$.
    have h_order_gk : orderOf (g ^ k) = Fintype.card G / Nat.gcd k (Fintype.card G) := by
      rw [ orderOf_pow, hg ];
      rw [ Nat.gcd_comm ];
    rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers, h_order_gk ];
    rw [ ← hk, Nat.gcd_eq_left ( dvd_mul_right _ _ ), Nat.mul_div_cancel_left _ ( Nat.pos_of_ne_zero ( by rintro rfl; linarith [ Fintype.card_pos_iff.mpr ⟨ g ⟩ ] ) ) ];
  refine' ⟨ H, hH_order, fun K hK => _ ⟩;
  -- Since $K$ is a subgroup of $G$ with order $d$, it must be cyclic and generated by some element of order $d$.
  obtain ⟨h, hh⟩ : ∃ h : G, orderOf h = d ∧ K = Subgroup.zpowers h := by
    have hK_cyclic : IsCyclic K := by
      exact?;
    obtain ⟨ x, hx ⟩ := hK_cyclic.exists_generator;
    refine' ⟨ x, _, _ ⟩;
    · have := orderOf_eq_card_of_forall_mem_zpowers hx; aesop;
    · ext y;
      exact ⟨ fun hy => by obtain ⟨ n, hn ⟩ := hx ⟨ y, hy ⟩ ; exact ⟨ n, by simpa [ Subtype.ext_iff ] using hn ⟩, fun hy => by obtain ⟨ n, hn ⟩ := hy; exact hn.symm ▸ Subgroup.zpow_mem _ x.2 _ ⟩;
  -- Since $h$ has order $d$, we can write $h = g^m$ for some integer $m$.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, h = g ^ m := by
    have h_gen : ∀ x : G, x ∈ Subgroup.zpowers g := by
      have h_gen : Fintype.card (Subgroup.zpowers g) = Fintype.card G := by
        rw [ Fintype.card_zpowers, hg ];
      have := Subgroup.card_mul_index ( Subgroup.zpowers g ) ; aesop;
    obtain ⟨ m, rfl ⟩ := h_gen h; use Int.toNat ( m % ( orderOf g ) ) ; simp +decide [ ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ ( by linarith [ orderOf_pos g ] : ( orderOf g : ℤ ) ≠ 0 ) ), zpow_mod_orderOf ] ;
  -- Since $h = g^m$ and $orderOf h = d$, we have $g^{md} = 1$. Therefore, $md$ is a multiple of $|G|$, which implies $m$ is a multiple of $k$.
  have hm_mul_k : k ∣ m := by
    have hm_mul_k : g ^ (m * d) = 1 := by
      simp +decide [ ← hh.1, hm, pow_mul ];
    have := orderOf_dvd_iff_pow_eq_one.mpr hm_mul_k;
    exact Exists.elim this fun x hx => ⟨ x, by nlinarith [ Nat.pos_of_dvd_of_pos hd ( Fintype.card_pos ) ] ⟩;
  -- Since $m$ is a multiple of $k$, we have $h = g^m = (g^k)^{m/k}$, which implies $h \in H$.
  have h_in_H : h ∈ H := by
    obtain ⟨ c, rfl ⟩ := hm_mul_k; simp +decide [ hm, pow_mul ] ;
    exact Subgroup.pow_mem _ ( Subgroup.mem_zpowers _ ) _;
  have hK_le_H : K ≤ H := by
    aesop;
  exact SetLike.ext' ( Set.eq_of_subset_of_card_le hK_le_H ( by aesop ) )

/-
The sum of the orders of all subgroups of a finite cyclic group G is equal to the sum of the divisors of |G|.
-/
lemma LeinsterGroup.sum_card_subgroups_cyclic {G : Type*} [Group G] [Fintype G] [IsCyclic G] :
    ∑ H : Subgroup G, Nat.card H = ∑ d ∈ Nat.divisors (Fintype.card G), d := by
  -- By definition of cyclic groups, each subgroup of $G$ corresponds to a divisor of $|G|$.
  have h_subgroups : ∀ d ∈ Nat.divisors (Fintype.card G), ∃! H : Subgroup G, Nat.card H = d := by
    have := @LeinsterGroup.exists_unique_subgroup_of_card G; aesop;
  choose! f hf₁ hf₂ using h_subgroups;
  -- By definition of $f$, we know that every subgroup of $G$ is of the form $f(d)$ for some divisor $d$ of $|G|$.
  have h_all_subgroups : ∀ H : Subgroup G, ∃ d ∈ Nat.divisors (Fintype.card G), H = f d := by
    intro H
    obtain ⟨d, hd⟩ : ∃ d ∈ Nat.divisors (Fintype.card G), Nat.card H = d := by
      simpa using Subgroup.card_subgroup_dvd_card H;
    exact ⟨ d, hd.1, hf₂ d hd.1 H hd.2 ⟩;
  rw [ show ( Finset.univ : Finset ( Subgroup G ) ) = Finset.image f ( Nat.divisors ( Fintype.card G ) ) from ?_, Finset.sum_image ];
  · exact Finset.sum_congr rfl fun x hx => hf₁ x hx;
  · exact fun x hx y hy hxy => by have := hf₁ x hx; have := hf₁ y hy; aesop;
  · ext H; specialize h_all_subgroups H; aesop;

/-
For odd n, the sum of orders of normal subgroups of DihedralGroup n is σ(n) + 2n.
-/
lemma LeinsterGroup.sum_normal_subgroups_odd {n : ℕ} [NeZero n] (hn : Odd n) :
    ∑ H : {H : Subgroup (DihedralGroup n) // H.Normal}, Nat.card H = (∑ d ∈ n.divisors, d) + 2 * n := by
  -- By the provided solution steps:
  -- 1. The set of normal subgroups is `S_rot ∪ {⊤}`, where `S_rot` are subgroups of `rotations n`.
  -- 2. These sets are disjoint.
  -- 3. The sum splits into sum over `S_rot` and sum over `{⊤}`.
  have h_normal_subgroups : {H : Subgroup (DihedralGroup n) | H.Normal} = {H : Subgroup (DihedralGroup n) | (H ≤ (LeinsterGroup.rotations n))} ∪ {⊤} := by
    exact?;
  -- Since these sets are disjoint, we can split the sum.
  have h_split_sum : ∑ H : Subgroup (DihedralGroup n), (if H.Normal then Nat.card H else 0) = (∑ H : Subgroup (DihedralGroup n), (if H ≤ (LeinsterGroup.rotations n) then Nat.card H else 0)) + (Nat.card (⊤ : Subgroup (DihedralGroup n))) := by
    simp_all +decide [ Set.ext_iff ];
    simp +decide [ Finset.sum_ite, Finset.filter_or, Finset.filter_eq' ];
    rw [ Finset.sum_union ];
    · simp +decide [ add_comm, Fintype.card_subtype ];
      rw [ add_comm, Finset.sum_eq_single ⊤ ] <;> aesop;
    · simp +contextual [ Finset.disjoint_left ];
      simp +decide [ Subgroup.eq_top_iff' ];
      use DihedralGroup.sr 0;
      rintro ⟨ k, hk ⟩;
      simp_all +decide [ zpow_eq_pow ];
  -- The sum over `S_rot` is sum of orders of subgroups of `rotations n`.
  have h_sum_S_rot : ∑ H : Subgroup (DihedralGroup n), (if H ≤ (LeinsterGroup.rotations n) then Nat.card H else 0) = ∑ H : Subgroup (LeinsterGroup.rotations n), Nat.card H := by
    have h_sum_S_rot : Finset.filter (fun H => H ≤ (LeinsterGroup.rotations n)) (Finset.univ : Finset (Subgroup (DihedralGroup n))) = Finset.image (fun H : Subgroup (LeinsterGroup.rotations n) => Subgroup.map (LeinsterGroup.rotations n).subtype H) (Finset.univ : Finset (Subgroup (LeinsterGroup.rotations n))) := by
      ext; simp [Finset.mem_image];
      constructor;
      · intro h;
        use Subgroup.comap (LeinsterGroup.rotations n).subtype ‹_›;
        simp +decide [ Subgroup.map_comap_eq, h ];
      · rintro ⟨ a, rfl ⟩ ; exact Subgroup.map_subtype_le _;
    rw [ ← Finset.sum_filter, h_sum_S_rot, Finset.sum_image ];
    · refine' Finset.sum_congr rfl fun H _ => _;
      exact?;
    · intro H₁ hH₁ H₂ hH₂ h_eq; simp_all +decide [ Subgroup.ext_iff ] ;
      exact fun x hx => by simpa [ hx ] using h_eq x;
  -- By `sum_card_subgroups_cyclic`, this sum is `∑ d | n, d`.
  have h_sum_card_subgroups_cyclic : ∑ H : Subgroup (LeinsterGroup.rotations n), Nat.card H = ∑ d ∈ Nat.divisors (Nat.card (LeinsterGroup.rotations n)), d := by
    convert LeinsterGroup.sum_card_subgroups_cyclic using 1;
    · rw [ Nat.card_eq_fintype_card ];
    · exact?;
  -- By `card_rotations`, we know that `Nat.card (LeinsterGroup.rotations n) = n`.
  have h_card_rotations : Nat.card (LeinsterGroup.rotations n) = n := by
    convert LeinsterGroup.card_rotations;
    infer_instance;
  convert h_split_sum using 1;
  · rw [ ← Finset.sum_filter ];
    refine' Finset.sum_bij ( fun x hx => x.val ) _ _ _ _ <;> simp +decide;
  · simp_all +decide [ Fintype.card_subtype ];
    exact?

def LeinsterGroup.H1 {n : ℕ} [NeZero n] : Subgroup (DihedralGroup n) :=
  Subgroup.closure {DihedralGroup.r 2, DihedralGroup.sr 0}

def LeinsterGroup.H2 {n : ℕ} [NeZero n] : Subgroup (DihedralGroup n) :=
  Subgroup.closure {DihedralGroup.r 2, DihedralGroup.sr 1}

def LeinsterGroup.R2 (n : ℕ) : Subgroup (DihedralGroup n) := Subgroup.zpowers (DihedralGroup.r 2)

/-
If n is even, the subgroup generated by r^2 has order n/2.
-/
lemma LeinsterGroup.R2_card {n : ℕ} [NeZero n] (hn : Even n) : Nat.card (LeinsterGroup.R2 n) = n / 2 := by
  -- Let $r$ be a generator of the cyclic group of order $n$.
  obtain ⟨r, hr⟩ : ∃ r : DihedralGroup n, (orderOf r) = n ∧ r = DihedralGroup.r 1 := by
    simp +decide [ orderOf_eq_iff ];
  -- The order of $r^2$ is $n / \gcd(2, n)$.
  have h_order_r2 : orderOf (r^2) = n / Nat.gcd 2 n := by
    rw [ orderOf_pow, hr.1 ];
    rw [ Nat.gcd_comm ];
  have h_card_r2 : Nat.card (Subgroup.zpowers (r^2)) = orderOf (r^2) := by
    rw [ Nat.card_zpowers ];
  convert h_card_r2 using 1 ; aesop;
  rw [ h_order_r2, Nat.gcd_eq_left ( even_iff_two_dvd.mp hn ) ]

/-
If n is even, the subgroup generated by r^2 is normal in DihedralGroup n.
-/
lemma LeinsterGroup.R2_normal {n : ℕ} [NeZero n] (hn : Even n) : (LeinsterGroup.R2 n).Normal := by
  refine' ⟨ fun g hg => _ ⟩;
  rcases hg with ⟨ k, rfl ⟩;
  rintro ⟨ ⟩ <;> simp +decide [ zpow_mul ];
  · exact Subgroup.mem_zpowers_iff.mpr ⟨ k, by aesop ⟩;
  · exact ⟨ -k, by simp +decide [ mul_comm ] ⟩

def LeinsterGroup.S {n : ℕ} [NeZero n] : Subgroup (DihedralGroup n) := Subgroup.zpowers (DihedralGroup.sr 0)

def LeinsterGroup.SR {n : ℕ} [NeZero n] : Subgroup (DihedralGroup n) := Subgroup.zpowers (DihedralGroup.sr 1)

/-
H1 is the join of R2 and S.
-/
lemma LeinsterGroup.H1_eq_R2_mul_S {n : ℕ} [NeZero n] (hn : Even n) :
    LeinsterGroup.H1 (n := n) = LeinsterGroup.R2 n ⊔ LeinsterGroup.S := by
  refine' le_antisymm _ _ <;> simp +decide [ LeinsterGroup.H1, LeinsterGroup.R2, LeinsterGroup.S ];
  · rintro x ( rfl | rfl ) <;> [ exact Subgroup.mem_sup_left ( Subgroup.mem_zpowers _ ) ; exact Subgroup.mem_sup_right ( Subgroup.mem_zpowers _ ) ];
  · exact ⟨ Subgroup.subset_closure ( Set.mem_insert _ _ ), Subgroup.subset_closure ( Set.mem_insert_of_mem _ ( Set.mem_singleton _ ) ) ⟩

/-
H2 is the join of R2 and SR.
-/
lemma LeinsterGroup.H2_eq_R2_mul_SR {n : ℕ} [NeZero n] (hn : Even n) :
    LeinsterGroup.H2 (n := n) = LeinsterGroup.R2 n ⊔ LeinsterGroup.SR := by
  refine' le_antisymm _ _ <;> simp [LeinsterGroup.H2, LeinsterGroup.R2, LeinsterGroup.SR];
  · rintro x ( rfl | rfl ) <;> [ exact Subgroup.mem_sup_left ( Subgroup.mem_zpowers _ ) ; exact Subgroup.mem_sup_right ( Subgroup.mem_zpowers _ ) ];
  · exact ⟨ Subgroup.subset_closure ( Set.mem_insert _ _ ), Subgroup.subset_closure ( Set.mem_insert_of_mem _ ( Set.mem_singleton _ ) ) ⟩

/-
The subgroup S generated by s has order 2.
-/
lemma LeinsterGroup.S_card {n : ℕ} [NeZero n] : Nat.card (LeinsterGroup.S (n := n)) = 2 := by
  convert Nat.card_zpowers ( DihedralGroup.sr 0 : DihedralGroup n ) ; aesop

/-
The subgroup SR generated by sr has order 2.
-/
lemma LeinsterGroup.SR_card {n : ℕ} [NeZero n] : Nat.card (LeinsterGroup.SR (n := n)) = 2 := by
  convert Nat.card_zpowers ( DihedralGroup.sr 1 : DihedralGroup n ) ; aesop

/-
R2 and S are disjoint.
-/
lemma LeinsterGroup.R2_disjoint_S {n : ℕ} [NeZero n] (hn : Even n) : Disjoint (LeinsterGroup.R2 n) (LeinsterGroup.S) := by
  rw [ disjoint_iff ];
  simp +decide [ Subgroup.eq_bot_iff_forall ];
  intro x hx₁ hx₂; obtain ⟨ k, rfl ⟩ := Subgroup.mem_zpowers_iff.mp hx₁; obtain ⟨ l, hl ⟩ := Subgroup.mem_zpowers_iff.mp hx₂; simp_all +decide [ DihedralGroup.sr, DihedralGroup.r ] ;
  rcases Int.even_or_odd' l with ⟨ m, rfl | rfl ⟩ <;> norm_num [ zpow_add, zpow_mul ] at *;
  · simp_all +decide [ zpow_two ];
  · simp_all +decide [ zpow_two, DihedralGroup.sr ]

/-
R2 and SR are disjoint.
-/
lemma LeinsterGroup.R2_disjoint_SR {n : ℕ} [NeZero n] (hn : Even n) : Disjoint (LeinsterGroup.R2 n) (LeinsterGroup.SR) := by
  simp +decide [ Subgroup.disjoint_def ];
  rintro x ⟨ k, rfl ⟩ ⟨ l, hl ⟩;
  rcases Int.even_or_odd' l with ⟨ c, rfl | rfl ⟩ <;> rcases Int.even_or_odd' k with ⟨ d, rfl | rfl ⟩ <;> simp_all +decide [ zpow_add, zpow_mul ];
  · simp_all +decide [ zpow_two ];
  · simp_all +decide [ zpow_two ];
  · simp_all +decide [ zpow_two ];
  · simp_all +decide [ zpow_two, DihedralGroup.sr ]

/-
If n is even, the subgroup H1 generated by r^2 and s has order n.
-/
lemma LeinsterGroup.H1_card {n : ℕ} [NeZero n] (hn : Even n) : Nat.card (LeinsterGroup.H1 (n := n)) = n := by
  -- By definition of $H1$, we have $H1 = R2 ⊔ S$.
  have hH1 : LeinsterGroup.H1 (n := n) = LeinsterGroup.R2 n ⊔ LeinsterGroup.S := by
    exact?;
  rw [ hH1, Nat.card_eq_fintype_card, Fintype.card_subtype ];
  -- Since $R2$ and $S$ are disjoint and their product is $H1$, the cardinality of $H1$ is the product of the cardinalities of $R2$ and $S$.
  have h_card_prod : Finset.card (Finset.image (fun p : DihedralGroup n × DihedralGroup n => p.1 * p.2) (Finset.product (Finset.filter (fun x => x ∈ LeinsterGroup.R2 n) (Finset.univ : Finset (DihedralGroup n))) (Finset.filter (fun x => x ∈ LeinsterGroup.S) (Finset.univ : Finset (DihedralGroup n))))) = n := by
    rw [ Finset.card_image_of_injOn ];
    · have h_card_R2 : Finset.card (Finset.filter (fun x => x ∈ LeinsterGroup.R2 n) (Finset.univ : Finset (DihedralGroup n))) = n / 2 := by
        convert LeinsterGroup.R2_card hn using 1;
        rw [ Nat.card_eq_fintype_card, Fintype.card_of_subtype ] ; aesop
      have h_card_S : Finset.card (Finset.filter (fun x => x ∈ LeinsterGroup.S) (Finset.univ : Finset (DihedralGroup n))) = 2 := by
        convert LeinsterGroup.S_card ( n := n ) using 1;
        rw [ Nat.card_eq_fintype_card, Fintype.card_of_subtype ] ; aesop
      simp_all +decide [ Finset.card_product ];
      rw [ Nat.div_mul_cancel ( even_iff_two_dvd.mp hn ) ];
    · intro p hp q hq h_eq; simp_all +decide [ Set.InjOn ] ;
      -- Since $p.1 \in R2$ and $q.1 \in R2$, and $R2$ is normal, we have $p.1 = q.1$.
      have hp1_eq_q1 : p.1 = q.1 := by
        have hp1_eq_q1 : p.1⁻¹ * q.1 ∈ LeinsterGroup.S := by
          have hp1_eq_q1 : p.1⁻¹ * q.1 = p.2 * q.2⁻¹ := by
            rw [ inv_mul_eq_iff_eq_mul ];
            simp +decide [ ← mul_assoc, h_eq ];
          exact hp1_eq_q1.symm ▸ Subgroup.mul_mem _ hp.2 ( Subgroup.inv_mem _ hq.2 );
        have hp1_eq_q1 : p.1⁻¹ * q.1 ∈ LeinsterGroup.R2 n := by
          exact Subgroup.mul_mem _ ( Subgroup.inv_mem _ hp.1 ) hq.1;
        have hp1_eq_q1 : p.1⁻¹ * q.1 = 1 := by
          have hp1_eq_q1 : Disjoint (LeinsterGroup.R2 n) (LeinsterGroup.S) := by
            exact?;
          exact hp1_eq_q1.le_bot ⟨ by assumption, by assumption ⟩;
        simpa using eq_inv_of_mul_eq_one_left hp1_eq_q1;
      aesop;
  convert h_card_prod using 2;
  ext; simp [Subgroup.mem_sup];
  rw [ Subgroup.sup_eq_closure ];
  constructor;
  · refine' Subgroup.closure_induction _ _ _ _;
    · rintro x ( hx | hx ) <;> [ exact ⟨ x, 1, ⟨ hx, Subgroup.one_mem _ ⟩, by simp +decide ⟩ ; exact ⟨ 1, x, ⟨ Subgroup.one_mem _, hx ⟩, by simp +decide ⟩ ];
    · exact ⟨ 1, 1, ⟨ Subgroup.one_mem _, Subgroup.one_mem _ ⟩, by simp +decide ⟩;
    · rintro x y hx hy ⟨ a, b, ⟨ ha, hb ⟩, rfl ⟩ ⟨ c, d, ⟨ hc, hd ⟩, rfl ⟩;
      -- Since $R2$ is normal, we have $b * c * b⁻¹ \in R2$.
      have h_bc_b_inv : b * c * b⁻¹ ∈ LeinsterGroup.R2 n := by
        have h_bc_b_inv : ∀ b : DihedralGroup n, ∀ c ∈ LeinsterGroup.R2 n, b * c * b⁻¹ ∈ LeinsterGroup.R2 n := by
          exact fun b c hc => by simpa [ mul_assoc ] using LeinsterGroup.R2_normal ( hn := hn ) |> fun h => h.conj_mem _ hc b;
        exact h_bc_b_inv b c hc;
      use a * (b * c * b⁻¹), b * d;
      exact ⟨ ⟨ Subgroup.mul_mem _ ha h_bc_b_inv, Subgroup.mul_mem _ hb hd ⟩, by group ⟩;
    · rintro x hx ⟨ a, b, ⟨ ha, hb ⟩, rfl ⟩;
      refine' ⟨ b⁻¹ * a⁻¹ * b, b⁻¹, _, _ ⟩ <;> simp_all +decide [ Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ];
      -- Since $R2$ is normal, conjugation by any element of the group keeps it in $R2$.
      have h_normal : ∀ g : DihedralGroup n, ∀ h ∈ LeinsterGroup.R2 n, g⁻¹ * h * g ∈ LeinsterGroup.R2 n := by
        exact fun g h hh => by simpa [ mul_assoc ] using LeinsterGroup.R2_normal hn |>.conj_mem _ hh g⁻¹;
      simpa [ mul_assoc ] using h_normal b a⁻¹ ( Subgroup.inv_mem _ ha );
  · rintro ⟨ a, b, ⟨ ha, hb ⟩, rfl ⟩ ; exact Subgroup.mul_mem _ ( Subgroup.subset_closure <| Set.mem_union_left _ ha ) ( Subgroup.subset_closure <| Set.mem_union_right _ hb )

/-
If n is even, the subgroup H2 generated by r^2 and sr has order n.
-/
lemma LeinsterGroup.H2_card {n : ℕ} [NeZero n] (hn : Even n) : Nat.card (LeinsterGroup.H2 (n := n)) = n := by
  -- The subgroup generated by $r^2$ and $sr$ is exactly the group $Dier(n)$, so its order is $n$.
  have hH2_eq : LeinsterGroup.H2 = Subgroup.closure ({DihedralGroup.r 2, DihedralGroup.sr 1} : Set (DihedralGroup n)) := by
    rfl;
  have h_card : Nat.card (↥(Subgroup.closure {DihedralGroup.r 2, DihedralGroup.sr 1} : Subgroup (DihedralGroup n))) = Nat.card (↥(Subgroup.closure {DihedralGroup.r 2} : Subgroup (DihedralGroup n))) * Nat.card (↥(Subgroup.closure {DihedralGroup.sr 1} : Subgroup (DihedralGroup n))) := by
    have h_normal : (Subgroup.closure {DihedralGroup.r 2} : Subgroup (DihedralGroup n)).Normal := by
      have h_normal : (Subgroup.zpowers (DihedralGroup.r 2) : Subgroup (DihedralGroup n)).Normal := by
        convert LeinsterGroup.R2_normal hn using 1;
      convert h_normal using 1;
      simp +decide [ Subgroup.zpowers_eq_closure ]
    have h_disjoint : Disjoint (Subgroup.closure {DihedralGroup.r 2} : Subgroup (DihedralGroup n)) (Subgroup.closure {DihedralGroup.sr 1} : Subgroup (DihedralGroup n)) := by
      simp +decide [ Subgroup.disjoint_def, Subgroup.mem_closure_singleton ];
      intro a x hx; rcases Int.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> simp_all +decide [ zpow_add, zpow_mul ] ;
      · simp_all +decide [ zpow_two ];
      · simp_all +decide [ zpow_two ]
    rw [ ← Nat.card_prod ];
    refine' Nat.card_congr _;
    symm;
    refine' Equiv.ofBijective ( fun x => ⟨ x.1.val * x.2.val, _ ⟩ ) ⟨ fun x y hxy => _, fun x => _ ⟩;
    exact Subgroup.mul_mem _ ( Subgroup.closure_mono ( by simp +decide ) x.1.2 ) ( Subgroup.closure_mono ( by simp +decide ) x.2.2 );
    · simp_all +decide [ Subgroup.disjoint_def ];
      have h_eq : (x.1 : DihedralGroup n)⁻¹ * (y.1 : DihedralGroup n) = (x.2 : DihedralGroup n) * (y.2 : DihedralGroup n)⁻¹ := by
        rw [ inv_mul_eq_iff_eq_mul ];
        simp +decide [ ← mul_assoc, hxy ];
      have h_eq : (x.1 : DihedralGroup n)⁻¹ * (y.1 : DihedralGroup n) = 1 := by
        apply h_disjoint;
        · exact Subgroup.mul_mem _ ( Subgroup.inv_mem _ x.1.2 ) y.1.2;
        · exact h_eq.symm ▸ Subgroup.mul_mem _ ( Subgroup.closure_mono ( by simp +decide ) x.2.2 ) ( Subgroup.inv_mem _ ( Subgroup.closure_mono ( by simp +decide ) y.2.2 ) );
      have h_eq : (x.2 : DihedralGroup n) * (y.2 : DihedralGroup n)⁻¹ = 1 := by
        grind +ring;
      simp_all +decide [ mul_eq_one_iff_eq_inv ];
      grind;
    · have h_decomp : ∀ x ∈ Subgroup.closure ({DihedralGroup.r 2, DihedralGroup.sr 1} : Set (DihedralGroup n)), ∃ a ∈ Subgroup.closure {DihedralGroup.r 2}, ∃ b ∈ Subgroup.closure {DihedralGroup.sr 1}, x = a * b := by
        intro x hx;
        induction hx using Subgroup.closure_induction;
        · rename_i x hx;
          rcases hx with ( rfl | rfl ) <;> [ exact ⟨ DihedralGroup.r 2, Subgroup.subset_closure rfl, 1, Subgroup.one_mem _, by simp +decide ⟩ ; exact ⟨ 1, Subgroup.one_mem _, DihedralGroup.sr 1, Subgroup.subset_closure rfl, by simp +decide ⟩ ];
        · exact ⟨ 1, Subgroup.one_mem _, 1, Subgroup.one_mem _, by simp +decide ⟩;
        · rename_i hx hy;
          obtain ⟨ a, ha, b, hb, rfl ⟩ := hx; obtain ⟨ c, hc, d, hd, rfl ⟩ := hy; simp_all +decide [ mul_assoc, Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ] ;
          -- Since $b$ is in the subgroup generated by $sr 1$, we have $b * c * b⁻¹ \in \langle r^2 \rangle$.
          have h_bc_b_inv : b * c * b⁻¹ ∈ Subgroup.closure {DihedralGroup.r 2} := by
            exact h_normal.conj_mem _ hc b;
          exact ⟨ a * ( b * c * b⁻¹ ), Subgroup.mul_mem _ ha h_bc_b_inv, b * d, Subgroup.mul_mem _ hb hd, by group ⟩;
        · rcases ‹_› with ⟨ a, ha, b, hb, rfl ⟩;
          -- Since $a \in \langle r^2 \rangle$ and $b \in \langle sr \rangle$, we have $a^{-1} \in \langle r^2 \rangle$ and $b^{-1} \in \langle sr \rangle$.
          have ha_inv : a⁻¹ ∈ Subgroup.closure {DihedralGroup.r 2} := by
            exact Subgroup.inv_mem _ ha
          have hb_inv : b⁻¹ ∈ Subgroup.closure {DihedralGroup.sr 1} := by
            exact Subgroup.inv_mem _ hb;
          have := h_normal.conj_mem _ ha_inv ( b⁻¹ ) ; simp_all +decide [ mul_assoc ] ;
          exact ⟨ b⁻¹ * ( a⁻¹ * b ), this, b⁻¹, by simpa using Subgroup.inv_mem _ hb, by group ⟩;
      obtain ⟨ a, ha, b, hb, hx ⟩ := h_decomp x x.2; exact ⟨ ⟨ ⟨ a, ha ⟩, ⟨ b, hb ⟩ ⟩, Subtype.ext hx.symm ⟩ ;
  have h_card_r2 : Nat.card (↥(Subgroup.closure {DihedralGroup.r 2} : Subgroup (DihedralGroup n))) = n / 2 := by
    convert LeinsterGroup.R2_card hn using 1;
    congr! 2;
    ext; simp [LeinsterGroup.R2];
    simp +decide [ Subgroup.mem_closure_singleton ];
    exact ⟨ fun ⟨ k, hk ⟩ => ⟨ k, by simpa [ mul_comm ] using hk ⟩, fun ⟨ k, hk ⟩ => ⟨ k, by simpa [ mul_comm ] using hk ⟩ ⟩
  have h_card_sr1 : Nat.card (↥(Subgroup.closure {DihedralGroup.sr 1} : Subgroup (DihedralGroup n))) = 2 := by
    have h_card_sr1 : Nat.card (↥(Subgroup.zpowers (DihedralGroup.sr 1) : Subgroup (DihedralGroup n))) = 2 := by
      rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers ] ; aesop;
    convert h_card_sr1 using 1;
    simp +decide [ Subgroup.zpowers_eq_closure ]
  rw [hH2_eq, h_card, h_card_r2, h_card_sr1]
  skip
  exact (by
  rw [ Nat.div_mul_cancel ( even_iff_two_dvd.mp hn ) ])

/-
If H is normal, then the set product HK is equal to the join H ⊔ K.
-/
lemma LeinsterGroup.mul_eq_sup_of_normal {G : Type*} [Group G] (H K : Subgroup G) (hH : H.Normal) :
    (H * K : Set G) = (H ⊔ K : Subgroup G) := by
  exact?

/-
If H is normal and disjoint from K, then |H ⊔ K| = |H| * |K|.
-/
lemma LeinsterGroup.card_sup_eq_mul_of_normal_disjoint {G : Type*} [Group G] [Fintype G]
    (H K : Subgroup G) (hH : H.Normal) (h_disjoint : Disjoint H K) :
    Nat.card ↥(H ⊔ K) = Nat.card H * Nat.card K := by
  -- Since $H$ is normal and disjoint from $K$, the set product $H * K$ is equal to the join $H ⊔ K$.
  have h_set_product : (H * K : Set G) = (H ⊔ K : Subgroup G) := by
    exact?;
  -- Since $H$ and $K$ are disjoint, the map $f : H × K → H * K$ defined by $(h, k) ↦ h * k$ is injective.
  have h_inj : Function.Injective (fun p : ↥H × ↥K => p.1 * p.2 : ↥H × ↥K → G) := by
    intro p q h_eq
    have h_eq' : (p.1 : G)⁻¹ * q.1 = p.2 * (q.2 : G)⁻¹ := by
      simp_all +decide [ mul_assoc, eq_mul_inv_of_mul_eq h_eq ];
    have h_eq'' : (p.1 : G)⁻¹ * q.1 ∈ H ∧ (p.2 : G) * (q.2 : G)⁻¹ ∈ K := by
      exact ⟨ H.mul_mem ( H.inv_mem p.1.2 ) q.1.2, K.mul_mem p.2.2 ( K.inv_mem q.2.2 ) ⟩;
    simp_all +decide [ Subgroup.disjoint_def ];
    simp_all +decide [ mul_eq_one_iff_eq_inv ];
    grind;
  -- Since $H$ and $K$ are disjoint, the map $f : H × K → H * K$ defined by $(h, k) ↦ h * k$ is surjective.
  have h_surj : Set.range (fun p : ↥H × ↥K => p.1 * p.2 : ↥H × ↥K → G) = (H * K : Set G) := by
    simp +decide [ Set.ext_iff, Set.mem_mul ];
  have h_card : Nat.card (↥(H ⊔ K)) = Nat.card (↥H × ↥K) := by
    have h_card : Nat.card (↥(H ⊔ K)) = Nat.card (Set.range (fun p : ↥H × ↥K => p.1 * p.2 : ↥H × ↥K → G)) := by
      rw [h_surj, h_set_product];
      convert rfl;
    rw [ h_card, Nat.card_congr ( Equiv.ofInjective _ h_inj ) ];
  aesop

/-
If H is normal, then the set product HK is equal to the join H ⊔ K.
-/
lemma LeinsterGroup.mul_eq_sup_of_normal' {G : Type*} [Group G] (H K : Subgroup G) (hH : H.Normal) :
    (H * K : Set G) = (H ⊔ K : Subgroup G) := by
  -- Apply the lemma that states if H and K are subgroups and H is normal, then their product as a set is equal to their join as a subgroup.
  apply LeinsterGroup.mul_eq_sup_of_normal H K hH

lemma LeinsterGroup.H1_index {n : ℕ} [NeZero n] (hn : Even n) : (LeinsterGroup.H1 (n := n)).index = 2 := by
  -- Since $H1$ has order $n$ and $DihedralGroup n$ has order $2n$, the index of $H1$ in $DihedralGroup n$ is $2$.
  have h_index : (LeinsterGroup.H1 : Subgroup (DihedralGroup n)).index = (Nat.card (DihedralGroup n)) / (Nat.card (LeinsterGroup.H1 : Subgroup (DihedralGroup n))) := by
    rw [ Subgroup.index_eq_card ];
    have := Subgroup.card_eq_card_quotient_mul_card_subgroup ( LeinsterGroup.H1 : Subgroup ( DihedralGroup n ) );
    rw [ this, Nat.mul_div_cancel _ ( Nat.card_pos ) ];
  -- Substitute the known values of the cardinalities into the index formula.
  have h_card : Nat.card (DihedralGroup n) = 2 * n ∧ Nat.card (LeinsterGroup.H1 : Subgroup (DihedralGroup n)) = n := by
    -- The cardinality of the dihedral group $D_n$ is $2n$.
    have h_card_Dn : Nat.card (DihedralGroup n) = 2 * n := by
      exact?;
    exact ⟨ h_card_Dn, by simpa using LeinsterGroup.H1_card hn ⟩;
  rw [ h_index, h_card.1, h_card.2, Nat.mul_div_cancel _ ( NeZero.pos n ) ]

lemma LeinsterGroup.H2_index {n : ℕ} [NeZero n] (hn : Even n) : (LeinsterGroup.H2 (n := n)).index = 2 := by
  -- Since the index of $H1$ is $2$, and $H2$ is also a subgroup of $D_n$ with $n$ elements, its index must be $2$ as well.
  have h_index : (LeinsterGroup.H2 (n := n)).index = (Fintype.card (DihedralGroup n)) / (Nat.card (LeinsterGroup.H2 (n := n))) := by
    rw [ Nat.div_eq_of_eq_mul_left ];
    · exact Nat.card_pos;
    · have := Subgroup.index_mul_card ( LeinsterGroup.H2 ( n := n ) );
      aesop;
  rw [ h_index, LeinsterGroup.H2_card hn ];
  rw [ show Fintype.card ( DihedralGroup n ) = 2 * n by exact? ] ; rw [ Nat.mul_div_cancel _ ( NeZero.pos n ) ]

lemma LeinsterGroup.H1_ne_rotations {n : ℕ} [NeZero n] (hn : Even n) : LeinsterGroup.H1 (n := n) ≠ LeinsterGroup.rotations n := by
  intro h
  have h_s : DihedralGroup.sr 0 ∈ LeinsterGroup.H1 (n := n) := Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))
  rw [h] at h_s
  have h_s_rot : DihedralGroup.sr 0 ∈ LeinsterGroup.rotations n := h_s
  rw [LeinsterGroup.rotations, Subgroup.mem_zpowers_iff] at h_s_rot
  obtain ⟨k, hk⟩ := h_s_rot
  simp [DihedralGroup.sr, DihedralGroup.r] at hk

lemma LeinsterGroup.H2_ne_rotations {n : ℕ} [NeZero n] (hn : Even n) : LeinsterGroup.H2 (n := n) ≠ LeinsterGroup.rotations n := by
  intro h
  have h_sr : DihedralGroup.sr 1 ∈ LeinsterGroup.H2 (n := n) := Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))
  rw [h] at h_sr
  have h_sr_rot : DihedralGroup.sr 1 ∈ LeinsterGroup.rotations n := h_sr
  rw [LeinsterGroup.rotations, Subgroup.mem_zpowers_iff] at h_sr_rot
  obtain ⟨k, hk⟩ := h_sr_rot
  simp [DihedralGroup.sr, DihedralGroup.r] at hk

lemma LeinsterGroup.H1_normal {n : ℕ} [NeZero n] (hn : Even n) : (LeinsterGroup.H1 (n := n)).Normal := by
  apply Subgroup.normal_of_index_eq_two
  exact LeinsterGroup.H1_index hn

lemma LeinsterGroup.H2_normal {n : ℕ} [NeZero n] (hn : Even n) : (LeinsterGroup.H2 (n := n)).Normal := by
  apply Subgroup.normal_of_index_eq_two
  exact LeinsterGroup.H2_index hn

lemma LeinsterGroup.s_notin_H2 {n : ℕ} [NeZero n] (hn : Even n) :
    DihedralGroup.sr 0 ∉ LeinsterGroup.H2 (n := n) := by
      -- By definition of $H2$, we know that $sr0 \notin H2$ because $sr0$ is not of the form $r^k$ or $sr^k$ for any $k$.
      intro h
      have h_form : ∃ k : ℤ, DihedralGroup.sr 0 = (DihedralGroup.r 2 : DihedralGroup n) ^ k ∨ DihedralGroup.sr 0 = (DihedralGroup.r 2 : DihedralGroup n) ^ k * DihedralGroup.sr 1 := by
        have h_form : ∀ x ∈ LeinsterGroup.H2, ∃ k : ℤ, x = (DihedralGroup.r 2 : DihedralGroup n) ^ k ∨ x = (DihedralGroup.r 2 : DihedralGroup n) ^ k * DihedralGroup.sr 1 := by
          intro x hx
          induction' hx using Subgroup.closure_induction with x hx ih;
          · rcases hx with ( rfl | rfl ) <;> [ exact ⟨ 1, Or.inl <| by simp +decide ⟩ ; exact ⟨ 0, Or.inr <| by simp +decide ⟩ ];
          · exact ⟨ 0, Or.inl rfl ⟩;
          · rename_i hx hy ihx ihy; rcases ihx with ⟨ k₁, rfl | rfl ⟩ <;> rcases ihy with ⟨ k₂, rfl | rfl ⟩ <;> simp +decide [ ← mul_assoc, ← zpow_add ] ; ring_nf ;
            · exact ⟨ k₁ + k₂, by push_cast; ring ⟩;
            · exact ⟨ k₁ + k₂, by push_cast; ring ⟩;
            · exact ⟨ k₁ - k₂, by push_cast; ring ⟩;
            · exact ⟨ k₁ - k₂, by push_cast; ring ⟩;
          · rcases ‹∃ k : ℤ, _› with ⟨ k, rfl | rfl ⟩ <;> simp_all +decide [ zpow_neg, zpow_add ];
            exact ⟨ -k, by push_cast; ring ⟩;
        exact h_form _ h;
      rcases h_form with ⟨ k, hk | hk ⟩ <;> simp_all +decide [ DihedralGroup.sr, DihedralGroup.r ];
      rw [ eq_sub_iff_add_eq ] at hk ; norm_cast at hk ; replace hk := congr_arg Even hk ; simp_all +decide [ parity_simps ];
      cases n <;> simp_all +decide [ ZMod, Even ];
      · exact NeZero.ne 0 rfl;
      · obtain ⟨ r, hr ⟩ := hk; replace hr := congr_arg ( fun x : Fin ( _ + 1 ) => x.val ) hr; simp_all +decide [ Fin.val_add, Fin.val_mul ] ;
        have := congr_arg ( · % 2 ) hr; norm_num [ Nat.add_mod, Nat.mul_mod ] at this;
        rcases hn with ⟨ s, hs ⟩ ; norm_num [ ← two_mul, Nat.add_mod, Nat.mul_mod, hs ] at this

lemma LeinsterGroup.one_ne_two_mul_zmod {n : ℕ} [NeZero n] (hn : Even n) (k : ZMod n) :
    (1 : ZMod n) ≠ 2 * k := by
      -- Since $n$ is even, $k$ can be either even or odd. In either case, $2k$ is even, and $1$ is odd, so $1 \neq 2k$.
      have h_even_odd : ∀ k : ZMod n, Even (2 * k) := by
        exact fun k => ⟨ k, by ring ⟩;
      -- Since $n$ is even, $1$ is not even, hence $1 \neq 2k$.
      have h_not_even : ¬Even (1 : ZMod n) := by
        rintro ⟨ k, hk ⟩;
        replace hk := congr_arg ( fun x => x.val ) hk ; norm_num [ ZMod.val_add, ZMod.val_mul ] at hk;
        replace hk := congr_arg Even hk ; simp_all +decide [ ← two_mul, Nat.even_iff, Nat.add_mod, Nat.mul_mod ];
        rcases n with ( _ | _ | _ | n ) <;> simp_all +decide [ ZMod.val ];
        norm_num [ Nat.mod_mod_of_dvd _ ( Nat.dvd_of_mod_eq_zero hn ) ] at hk;
      exact fun h => h_not_even <| h.symm ▸ h_even_odd k

/-
H1 is not equal to H2.
-/
lemma LeinsterGroup.H1_ne_H2 {n : ℕ} [NeZero n] (hn : Even n) : LeinsterGroup.H1 (n := n) ≠ LeinsterGroup.H2 (n := n) := by
  intro h
  have h_s : DihedralGroup.sr 0 ∈ LeinsterGroup.H1 (n := n) := Subgroup.subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))
  rw [h] at h_s
  have h_notin := LeinsterGroup.s_notin_H2 hn
  contradiction

lemma LeinsterGroup.not_leinster_of_even {n : ℕ} [NeZero n] (hn : Even n) : ¬ IsLeinster (DihedralGroup n) := by
  -- By definition of $IsLeinster$, we know that if $D_{2n}$ is Leinster, then the sum of the orders of its normal subgroups must be twice its order.
  unfold IsLeinster;
  -- Let's calculate the sum of the orders of the normal subgroups of $D_{2n}$.
  have h_sum_normal_subgroups : ∑ H : {H : Subgroup (DihedralGroup n) // H.Normal}, Nat.card H ≥ ∑ H ∈ ({⊤, LeinsterGroup.rotations n, LeinsterGroup.H1 (n := n), LeinsterGroup.H2 (n := n)} : Finset (Subgroup (DihedralGroup n))), Nat.card H := by
                                                                                                          have h_normal_subgroups : ({⊤, LeinsterGroup.rotations n, LeinsterGroup.H1 (n := n), LeinsterGroup.H2 (n := n)} : Finset (Subgroup (DihedralGroup n))) ⊆ Finset.image (fun H : {H : Subgroup (DihedralGroup n) // H.Normal} => H.val) (Finset.univ : Finset {H : Subgroup (DihedralGroup n) // H.Normal}) := by
                                                                                                                                        simp +decide [ Finset.insert_subset_iff ];
                                                                                                                                        exact ⟨ by infer_instance, by exact? , by exact? , by exact? ⟩;
                                                                                                          refine' le_trans ( Finset.sum_le_sum_of_subset h_normal_subgroups ) _;
                                                                                                          rw [ Finset.sum_image ] ; aesop;
  rw [ Finset.sum_insert, Finset.sum_insert, Finset.sum_insert ] at h_sum_normal_subgroups <;> norm_num at *;
  · have h_card_rotations : Fintype.card (LeinsterGroup.rotations n) = n := by
      convert LeinsterGroup.card_rotations;
      · rw [ Nat.card_eq_fintype_card ];
      · infer_instance
    have h_card_H1 : Fintype.card (LeinsterGroup.H1 (n := n)) = n := by
      convert LeinsterGroup.H1_card hn using 1;
      rw [ Nat.card_eq_fintype_card ]
    have h_card_H2 : Fintype.card (LeinsterGroup.H2 (n := n)) = n := by
      convert LeinsterGroup.H2_card hn;
      rw [ Nat.card_eq_fintype_card ]
    have h_card_Dihedral : Fintype.card (DihedralGroup n) = 2 * n := by
      exact?;
    linarith [ NeZero.pos n ];
  · exact?;
  · exact ⟨ Ne.symm <| LeinsterGroup.H1_ne_rotations hn, Ne.symm <| LeinsterGroup.H2_ne_rotations hn ⟩;
  · constructor;
    · rw [ eq_comm ];
      intro h;
      have h_contra : ∀ g : DihedralGroup n, g ∈ LeinsterGroup.rotations n := by
        aesop;
      obtain ⟨ k, hk ⟩ := h_contra ( DihedralGroup.sr 0 );
      replace hk := congr_arg ( fun x => x = DihedralGroup.sr 0 ) hk ; simp_all +decide [ zpow_mul ];
    · constructor <;> intro h <;> have := Fintype.card_congr ( Equiv.Set.univ ( DihedralGroup n ) ) <;> simp_all +decide [ Fintype.card_subtype ];
      · rw [ eq_comm ] at h;
        have := LeinsterGroup.H1_card ( n := n ) hn; simp_all +decide [ Fintype.card_subtype ] ;
        exact absurd this ( by rw [ DihedralGroup.card ] ; linarith [ NeZero.pos n ] );
      · rw [ eq_comm ] at h;
        simp_all +decide [ Subgroup.eq_top_iff' ];
        exact absurd ( h ( DihedralGroup.sr 0 ) ) ( by exact fun h' => by exact absurd ( LeinsterGroup.s_notin_H2 ( by assumption ) ) ( by aesop ) )

/-
The dihedral group DihedralGroup n is Leinster if and only if n is an odd perfect number.
-/
theorem dihedral_is_leinster_iff_odd_perfect (n : ℕ) [NeZero n] :
    IsLeinster (DihedralGroup n) ↔ Nat.Perfect n ∧ Odd n := by
  constructor <;> intro h;
  · by_cases hn : Even n;
    · exact absurd h ( LeinsterGroup.not_leinster_of_even hn );
    · -- Since $n$ is odd, we can apply the lemma that states the sum of the normal subgroups of $D_n$ is $\sigma(n) + 2n$.
      have h_sum : ∑ H : {H : Subgroup (DihedralGroup n) // H.Normal}, Nat.card H = (∑ d ∈ n.divisors, d) + 2 * n := by
        convert LeinsterGroup.sum_normal_subgroups_odd ( by simpa using hn ) using 1;
      have h_card : Fintype.card (DihedralGroup n) = 2 * n := by
        exact?;
      unfold IsLeinster at h;
      simp_all +decide [ Nat.Perfect ];
      exact ⟨ by rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self ] at h_sum; linarith, NeZero.pos n ⟩;
  · convert LeinsterGroup.sum_normal_subgroups_odd h.2 using 1;
    unfold IsLeinster; simp +decide [ h, Nat.Perfect ] ;
    rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self, h.1.1 ] ; simp +decide [ DihedralGroup.card ] ; ring;

/-
For non-zero n, sum of divisors + 2n = 4n iff n is perfect.
-/
lemma Nat.perfect_iff_sum_divisors_add_two_mul_eq_four_mul {n : ℕ} (hn : n ≠ 0) :
    (∑ d ∈ n.divisors, d) + 2 * n = 4 * n ↔ Nat.Perfect n := by
  simp +decide [ Nat.Perfect, Nat.sum_divisors_eq_sum_properDivisors_add_self ];
  exact ⟨ fun h => ⟨ by linarith, Nat.pos_of_ne_zero hn ⟩, fun h => by linarith ⟩