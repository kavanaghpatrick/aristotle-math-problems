/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8a583ed2-7749-44c6-8065-3096d2951601

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Erdős Problem 137 for k=3 and provided bounded verification.

Key results:
1. `Nat.Powerful`: Definition of powerful numbers.
2. `erdos_137_bounded_k3`: Verified that for n < 10000, the product of 3 consecutive integers is not powerful.
3. `erdos_137_k3_structure_even` and `erdos_137_k3_structure_odd`: Structural lemmas decomposing the problem for k=3.
4. `no_two_even_powerful_gap_2`: Proved that no two even powerful numbers differ by 2.
5. `erdos_137_k3_prime_middle`: Proved that if n+2 is prime, the product is not powerful.
6. `unique_multiple_of_3_in_consecutive_3`: Proved that exactly one multiple of 3 exists in any 3 consecutive integers.
7. Computational checks for structural conditions.

The structural lemmas show that if a counterexample exists for k=3, then either:
- n+2 is even, which requires n+1 and n+3 to be powerful odd numbers (impossible if they are even, and we proved no two even powerfuls differ by 2).
- n+2 is odd, which requires n+2 to be powerful and n+1 = 2x where x and x+1 are PowerfulOdd. We computationally verified this does not happen for small x.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A natural number n is powerful if for every prime p dividing n, p^2 also divides n.
-/
def Nat.Powerful (n : ℕ) : Prop := ∀ p : ℕ, p.Prime → p ∣ n → p ^ 2 ∣ n

/-
Consecutive integers are coprime.
-/
lemma coprime_consecutive (n : ℕ) : Nat.Coprime n (n + 1) := by
  norm_num [ Nat.Coprime ]

/-
The greatest common divisor of n and n+2 divides 2.
-/
lemma gcd_consecutive_succ (n : ℕ) : Nat.gcd n (n + 2) ∣ 2 := by
  convert Nat.dvd_sub' ( Nat.gcd_dvd_right _ _ ) ( Nat.gcd_dvd_left _ _ ) using 1 ; rw [ Nat.sub_eq_of_eq_add ] ; ring

/-
A number n is powerful if and only if for every prime factor p of n, p^2 divides n.
-/
theorem powerful_iff_primeFactors_pow_dvd (n : ℕ) (hn : n ≠ 0) :
  Nat.Powerful n ↔ ∀ p ∈ n.primeFactors, p ^ 2 ∣ n := by
    constructor <;> intro h p hp <;> specialize h p <;> aesop

/-
Nat.Powerful is a decidable predicate.
-/
instance (n : ℕ) : Decidable (Nat.Powerful n) :=
  if hn : n = 0 then
    isTrue (by simp [Nat.Powerful, hn])
  else
    decidable_of_iff (∀ p ∈ n.primeFactors, p ^ 2 ∣ n) (powerful_iff_primeFactors_pow_dvd n hn).symm

/-
For all n < 10000, the product (n+1)(n+2)(n+3) is not powerful.
-/
theorem erdos_137_bounded_k3 : ∀ n < 10000, ¬ Nat.Powerful ((n + 1) * (n + 2) * (n + 3)) := by
  native_decide

/-
For k ≥ 3, there exists a prime p such that k/2 < p ≤ k.
-/
lemma exists_prime_in_range (k : ℕ) (hk : 3 ≤ k) : ∃ p, p.Prime ∧ k / 2 < p ∧ p ≤ k := by
  exact Nat.exists_prime_lt_and_le_two_mul ( k / 2 ) ( by omega ) |> fun ⟨ p, hp₁, hp₂ ⟩ => ⟨ p, hp₁, by omega, by omega ⟩

/-
We verify computationally that for all n < 10000, the product (n+1)(n+2)(n+3) is not powerful.
-/
def check_erdos_137_upto (limit : ℕ) : Bool :=
  (List.range limit).all fun n =>
    let prod := (n + 1) * (n + 2) * (n + 3)
    ¬ Nat.Powerful prod

theorem erdos_137_bounded_k3_verified : check_erdos_137_upto 10000 = true := by
  native_decide +revert

theorem erdos_137_bounded_k3_correct : ∀ n < 10000, ¬ Nat.Powerful ((n + 1) * (n + 2) * (n + 3)) := by
  -- Apply the lemma that states for all n < 10000, the product (n+1)(n+2)(n+3) is not powerful.
  apply erdos_137_bounded_k3

/-
For a prime p in (k/2, k], there are at most 2 multiples in (n, n+k].
-/
lemma multiples_of_large_prime_card (n k p : ℕ) (hp : p.Prime) (hk : 3 ≤ k) (hp_range : k / 2 < p ∧ p ≤ k) :
  ((Finset.Ioc n (n + k)).filter (fun x => p ∣ x)).card ≤ 2 := by
    -- Since $p > k / 2$, the multiples of $p$ in the interval $(n, n + k]$ are at most $\lfloor (n + k) / p \rfloor - \lfloor n / p \rfloor$.
    have h_mult_count : Finset.card (Finset.filter (fun x => p ∣ x) (Finset.Ioc n (n + k))) ≤ Finset.card (Finset.Icc (n / p + 1) (n / p + 2)) := by
      -- Each element in the set {x ∈ Finset.Ioc n (n + k) | p ∣ x} is of the form p * m for some integer m in the interval [n / p + 1, n / p + 2].
      have h_mult_form : ∀ x ∈ Finset.filter (fun x => p ∣ x) (Finset.Ioc n (n + k)), ∃ m ∈ Finset.Icc (n / p + 1) (n / p + 2), x = p * m := by
        intros x hx
        obtain ⟨m, hm⟩ : ∃ m, x = p * m := by
          aesop;
        simp +zetaDelta at *;
        exact ⟨ m, ⟨ Nat.succ_le_of_lt ( Nat.div_lt_of_lt_mul <| by linarith ), by nlinarith [ Nat.div_add_mod n p, Nat.mod_lt n hp.pos, Nat.div_add_mod k 2, Nat.mod_lt k two_pos ] ⟩, hm ⟩;
      have h_mult_form : Finset.filter (fun x => p ∣ x) (Finset.Ioc n (n + k)) ⊆ Finset.image (fun m => p * m) (Finset.Icc (n / p + 1) (n / p + 2)) := by
        intro x hx; obtain ⟨ m, hm₁, rfl ⟩ := h_mult_form x hx; exact Finset.mem_image_of_mem _ hm₁;
      exact le_trans ( Finset.card_le_card h_mult_form ) ( Finset.card_image_le );
    exact h_mult_count.trans ( by simp +arith +decide )

/-
If there are two multiples of a prime p in (k/2, k] within (n, n+k], they are separated by p.
-/
lemma multiples_of_large_prime_structure (n k p : ℕ) (hp : p.Prime) (hk : 3 ≤ k) (hp_range : k / 2 < p ∧ p ≤ k) :
  ∀ x y, x ∈ Finset.Ioc n (n + k) → y ∈ Finset.Ioc n (n + k) → p ∣ x → p ∣ y → x < y → y = x + p := by
    -- Since $p$ divides both $x$ and $y$, and $x < y$, the difference $y - x$ must be a multiple of $p$. Given that $p > k/2$ and $x, y \in (n, n+k]$, the only possible multiple is $p$ itself.
    intros x y hx hy hx_div hy_div hxy
    have h_diff : ∃ m : ℕ, y = x + m * p := by
      exact ⟨ ( y - x ) / p, by rw [ Nat.div_mul_cancel ( Nat.dvd_sub' hy_div hx_div ), add_tsub_cancel_of_le hxy.le ] ⟩;
    rcases h_diff with ⟨ m, rfl ⟩ ; rcases m with ( _ | _ | m ) <;> simp_all +arith +decide;
    nlinarith [ Nat.div_add_mod k 2, Nat.mod_lt k two_pos ]

/-
If a prime p > k is in the sequence (n, n+k], the product is not powerful.
-/
lemma prime_in_sequence_implies_not_powerful (n k p : ℕ) (hp : p.Prime) (hk : k < p) (hin : p ∈ Finset.Ioc n (n + k)) :
  ¬ Nat.Powerful (∏ x ∈ Finset.Ioc n (n + k), x) := by
    -- Since there's only one multiple of $p$ in $(n, n+k]$, $p$ divides the product exactly once.
    have h_div : p ∣ ∏ x ∈ Finset.Ioc n (n + k), x ∧ ¬(p^2 ∣ ∏ x ∈ Finset.Ioc n (n + k), x) := by
      -- Since there's only one multiple of $p$ in $(n, n+k]$, $p$ divides the product exactly once. Hence, $p^2$ does not divide the product.
      have h_div : p ∣ ∏ x ∈ Finset.Ioc n (n + k), x := by
        exact Finset.dvd_prod_of_mem _ hin
      have h_not_div : ¬(p^2 ∣ ∏ x ∈ Finset.Ioc n (n + k), x) := by
        -- Since there's only one multiple of $p$ in $(n, n+k]$, $p$ divides the product exactly once. Hence, $p^2$ does not divide the product. We can use the fact that $p$ is prime and greater than $k$ to show that $p^2$ cannot divide the product.
        have h_not_div : ¬(p^2 ∣ (∏ x ∈ Finset.Ioc n (n + k) \ {p}, x) * p) := by
          rw [ sq, mul_dvd_mul_iff_right hp.ne_zero ];
          simp_all +decide [ Nat.Prime.dvd_iff_not_coprime hp, Nat.coprime_prod_right_iff ];
          exact fun x hx₁ hx₂ hx₃ => hp.coprime_iff_not_dvd.mpr fun hx₄ => hx₃ <| by obtain ⟨ q, hq ⟩ := hx₄; nlinarith [ show q = 1 by nlinarith ] ;
        rwa [ Finset.prod_eq_prod_diff_singleton_mul hin ] at *;
      exact ⟨h_div, h_not_div⟩;
    exact fun h => h_div.2 <| h p hp h_div.1 |> fun h' => h'.trans <| by simp +decide [ pow_succ ] ;

/-
If a and b are coprime and their product is powerful, then both a and b are powerful.
-/
lemma powerful_mul_coprime {a b : ℕ} (hab : Nat.Coprime a b) (h : Nat.Powerful (a * b)) : Nat.Powerful a ∧ Nat.Powerful b := by
  refine' ⟨ fun p hp hp' => _, fun p hp hp' => _ ⟩;
  · -- Since $p$ divides $a$, we have $p \mid a * b$.
    have h_div : p ∣ a * b := by
      exact dvd_mul_of_dvd_left hp' _;
    -- Since $p$ divides $a * b$, we have $p^2 \mid a * b$.
    have h_div_sq : p^2 ∣ a * b := by
      exact h p hp h_div;
    exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( p ^ 2 ) b from by simpa using hab.coprime_dvd_left hp' ) h_div_sq );
  · have := h p hp ( dvd_mul_of_dvd_right hp' a );
    exact ( Nat.Coprime.pow_left 2 <| hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.dvd_gcd h hp'; aesop ) |> fun x => x.dvd_of_dvd_mul_left this

/-
If n+2 is even and the product (n+1)(n+2)(n+3) is powerful, then each factor is powerful.
-/
lemma erdos_137_k3_structure_even (n : ℕ) (h_even : Even (n + 2)) :
  Nat.Powerful ((n + 1) * (n + 2) * (n + 3)) →
  Nat.Powerful (n + 1) ∧ Nat.Powerful (n + 2) ∧ Nat.Powerful (n + 3) := by
    intro h
    have h1 : Nat.Coprime ((n + 1) * (n + 3)) (n + 2) := by
      norm_num [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      norm_num [ ( by ring : n + 3 = n + 2 + 1 ) ];
      norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ]
    have h2 : Nat.Powerful ((n + 1) * (n + 3)) ∧ Nat.Powerful (n + 2) := by
      convert powerful_mul_coprime h1 _ using 1
      generalize_proofs at *; (
      grind)
    generalize_proofs at *; (
    -- Since $n+1$ and $n+3$ are coprime and their product is powerful, each must be powerful.
    have h3 : Nat.Coprime (n + 1) (n + 3) := by
      norm_num [ ( by ring : n + 3 = n + 1 + 2 ) ];
      simpa [ parity_simps ] using h_even
    have h4 : Nat.Powerful (n + 1) ∧ Nat.Powerful (n + 3) := by
      exact powerful_mul_coprime h3 h2.1 |> fun h => ⟨ h.1, h.2 ⟩ ;
    exact ⟨h4.left, h2.right, h4.right⟩)

/-
If n+2 is odd, it is coprime to (n+1)(n+3).
-/
lemma coprime_odd_neighbors (n : ℕ) (h_odd : Odd (n + 2)) :
  Nat.Coprime (n + 2) ((n + 1) * (n + 3)) := by
    norm_num [ Nat.coprime_mul_iff_right, Nat.coprime_mul_iff_left ];
    norm_num [ ( by ring : n + 3 = n + 2 + 1 ) ];
    norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ]

/-
A number is PowerfulOdd if every odd prime factor appears with exponent at least 2.
-/
def Nat.PowerfulOdd (n : ℕ) : Prop := ∀ p : ℕ, p.Prime → p ≠ 2 → p ∣ n → p ^ 2 ∣ n

/-
If 4m is powerful, then m is powerful at all odd primes.
-/
lemma powerfulOdd_of_powerful_mul_four (m : ℕ) : Nat.Powerful (4 * m) → Nat.PowerfulOdd m := by
  intro h_p4m
  intro p hp_prime hp_ne_two hp_div_m
  have hp2_div_4m : p^2 ∣ 4 * m := by
    exact h_p4m p hp_prime ( dvd_mul_of_dvd_right hp_div_m _ );
  exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( p ^ 2 ) 4 from by simpa [ hp_prime.ne_zero, hp_prime.ne_one, hp_ne_two ] using hp_prime.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial ) hp2_div_4m )

/-
If n+2 is odd and the product (n+1)(n+2)(n+3) is powerful, then n+2 is powerful and n+1 = 2x where x and x+1 are PowerfulOdd.
-/
lemma erdos_137_k3_structure_odd (n : ℕ) (h_odd : Odd (n + 2)) :
  Nat.Powerful ((n + 1) * (n + 2) * (n + 3)) →
  Nat.Powerful (n + 2) ∧ ∃ x, n + 1 = 2 * x ∧ Nat.PowerfulOdd x ∧ Nat.PowerfulOdd (x + 1) := by
    -- Since $n+2$ is odd and coprime to $(n+1)(n+3)$, it must be powerful.
    intro h
    have h_coprime : Nat.Coprime (n + 2) ((n + 1) * (n + 3)) := by
      exact?
    have h_powerful : Nat.Powerful (n + 2) := by
      convert powerful_mul_coprime h_coprime ( show Nat.Powerful ( ( n + 2 ) * ( ( n + 1 ) * ( n + 3 ) ) ) from by convert h using 1; ring ) |> And.left using 1;
    -- Since $n+1$ and $n+3$ are consecutive even numbers, we can write $n+1 = 2x$ and $n+3 = 2(x+1)$ for some $x$.
    obtain ⟨x, hx⟩ : ∃ x, n + 1 = 2 * x := by
      exact even_iff_two_dvd.mp ( by simpa [ parity_simps ] using h_odd )
    have hx1 : n + 3 = 2 * (x + 1) := by
      grind
    have hx_powerful : Nat.PowerfulOdd x ∧ Nat.PowerfulOdd (x + 1) := by
      have hx_powerful : Nat.Powerful (4 * x * (x + 1)) := by
        have h_powerful : Nat.Powerful (4 * x * (x + 1) * (n + 2)) := by
          convert h using 1 ; rw [ hx, hx1 ] ; ring;
        have := powerful_mul_coprime ( show Nat.Coprime ( 4 * x * ( x + 1 ) ) ( n + 2 ) from ?_ ) h_powerful; aesop;
        simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
        exact ⟨ ⟨ Nat.Coprime.pow_left 2 ( Nat.prime_two.coprime_iff_not_dvd.mpr <| by simpa [ ← even_iff_two_dvd, parity_simps ] using h_odd ), h_coprime.1.symm ⟩, h_coprime.2.symm ⟩
      have hx_powerful_odd : Nat.PowerfulOdd (x * (x + 1)) := by
        have hx_powerful_odd : Nat.Powerful (4 * x * (x + 1)) → Nat.PowerfulOdd (x * (x + 1)) := by
          convert powerfulOdd_of_powerful_mul_four ( x * ( x + 1 ) ) using 1 ; ring;
        exact hx_powerful_odd hx_powerful
      have hx_powerful_odd_x : Nat.PowerfulOdd x := by
        intro p hp hp_ne_two hp_div_x
        have hp_div_x1 : p ∣ x * (x + 1) := by
          exact dvd_mul_of_dvd_left hp_div_x _
        have hp_div_x2 : p ^ 2 ∣ x * (x + 1) := by
          exact hx_powerful_odd p hp hp_ne_two hp_div_x1
        have hp_div_x3 : p ^ 2 ∣ x := by
          exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( p ^ 2 ) ( x + 1 ) from by simpa using hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.dvd_gcd hp_div_x h; aesop ) hp_div_x2 )
        exact hp_div_x3
      have hx_powerful_odd_x1 : Nat.PowerfulOdd (x + 1) := by
        intro p hp hp2 hp3; specialize hx_powerful_odd p hp hp2; simp_all +decide [ Nat.Prime.dvd_mul ] ;
        exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( p ^ 2 ) x from Nat.Coprime.pow_left 2 <| hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.dvd_gcd h hp3; simp_all +decide [ Nat.Coprime, Nat.Coprime.gcd_eq_one ] ) hx_powerful_odd )
      exact ⟨hx_powerful_odd_x, hx_powerful_odd_x1⟩
    exact ⟨h_powerful, x, hx, hx_powerful⟩

/-
The only powerful number m < 10000 such that m+2 is also powerful is 25.
-/
def find_powerful_pairs_gap_2 (limit : ℕ) : List ℕ :=
  (List.range limit).filter fun m => Nat.Powerful m ∧ Nat.Powerful (m + 2)

theorem powerful_pairs_gap_2_upto_10000 :
  find_powerful_pairs_gap_2 10000 = [25] := by
  native_decide

/-
If n+2 is prime, then the product (n+1)(n+2)(n+3) is not powerful.
-/
theorem erdos_137_k3_prime_middle (n : ℕ) (h : (n + 2).Prime) :
  ¬ Nat.Powerful ((n + 1) * (n + 2) * (n + 3)) := by
    intro H;
    -- Since $n+2$ is prime, it must divide either $n+1$ or $n+3$.
    have h_div : n + 2 ∣ n + 1 ∨ n + 2 ∣ n + 3 := by
      have := H ( n + 2 ) h ( by norm_num [ dvd_mul_of_dvd_left ] );
      exact h.dvd_mul.mp ( by obtain ⟨ k, hk ⟩ := this; exact ⟨ k, by nlinarith ⟩ );
    rcases h_div with ( h_div | h_div ) <;> have := Nat.le_of_dvd ( Nat.succ_pos _ ) h_div <;> simp_all +arith +decide;
    obtain ⟨ k, hk ⟩ := h_div; nlinarith [ show k = 1 by nlinarith ] ;

/-
There are no two even powerful numbers differing by 2.
-/
lemma no_two_even_powerful_gap_2 (n : ℕ) :
  Even n → Nat.Powerful n → Nat.Powerful (n + 2) → False := by
    intro hn h_powerful h_powerful';
    -- If $n+2$ is even and powerful, then $n+2 = 4m$ for some $m$.
    obtain ⟨m, hm⟩ : ∃ m, n + 2 = 4 * m := by
      have := h_powerful' 2 Nat.prime_two; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
      exact this;
    -- If $n$ is even and powerful, then $n = 4x$ for some $x$.
    obtain ⟨x, hx⟩ : ∃ x, n = 4 * x := by
      exact h_powerful 2 Nat.prime_two ( even_iff_two_dvd.mp hn );
    omega

/-
Among any 3 consecutive integers, exactly one is divisible by 3.
-/
lemma unique_multiple_of_3_in_consecutive_3 (n : ℕ) :
  ∃! x ∈ Finset.Ioc n (n + 3), 3 ∣ x := by
    -- By the pigeonhole principle, among any three consecutive integers, exactly one is divisible by 3.
    have h_div3 : ∀ n : ℕ, ∃ x ∈ Finset.Ioc n (n + 3), 3 ∣ x := by
      exact fun n => ⟨ 3 * ( n / 3 + 1 ), Finset.mem_Ioc.mpr ⟨ by linarith [ Nat.div_add_mod n 3, Nat.mod_lt n zero_lt_three ], by linarith [ Nat.div_mul_le_self n 3 ] ⟩, by norm_num ⟩ ;
    generalize_proofs at *; simp_all +decide [ Finset.mem_Ioc ] ; (
    obtain ⟨ x, hx₁, hx₂ ⟩ := h_div3 n; exact ⟨ x, ⟨ hx₁, hx₂ ⟩, fun y ⟨ hy₁, hy₂ ⟩ => by obtain ⟨ k₁, hk₁ ⟩ := hx₂; obtain ⟨ k₂, hk₂ ⟩ := hy₂; omega ⟩ ;)

/-
The only odd powerful number m < 10000 such that m+2 is also powerful is 25.
-/
def find_odd_powerful_pairs_gap_2 (limit : ℕ) : List ℕ :=
  (List.range limit).filter fun m => m % 2 = 1 ∧ Nat.Powerful m ∧ Nat.Powerful (m + 2)

theorem odd_powerful_pairs_gap_2_upto_10000 :
  find_odd_powerful_pairs_gap_2 10000 = [25] := by
  native_decide

/-
A number is PowerfulOdd iff for every prime factor p != 2, p^2 divides n.
-/
theorem powerfulOdd_iff_primeFactors (n : ℕ) (hn : n ≠ 0) :
  Nat.PowerfulOdd n ↔ ∀ p ∈ n.primeFactors, p ≠ 2 → p ^ 2 ∣ n := by
    -- By definition of `Nat.PowerfulOdd`, we have that `Nat.PowerfulOdd n` holds if and only if for every prime `p` dividing `n`, if `p` is not 2, then `p^2` divides `n`.
    simp [Nat.PowerfulOdd];
    aesop

/-
Nat.PowerfulOdd is a decidable predicate.
-/
instance (n : ℕ) : Decidable (Nat.PowerfulOdd n) :=
  if hn : n = 0 then
    isTrue (by simp [Nat.PowerfulOdd, hn])
  else
    decidable_of_iff (∀ p ∈ n.primeFactors, p ≠ 2 → p ^ 2 ∣ n) (powerfulOdd_iff_primeFactors n hn).symm

#check Nat.primeFactorsList

/-
We find the values of x < 10000 that satisfy the structural condition.
-/
def isPowerful_bool (n : ℕ) : Bool :=
  if n == 0 then true else
  n.primeFactorsList.all fun p => n % (p * p) == 0

def isPowerfulOdd_bool (n : ℕ) : Bool :=
  if n == 0 then true else
  n.primeFactorsList.all fun p =>
    if p == 2 then true else
    n % (p * p) == 0

def find_counterexample_odd (limit : ℕ) : List ℕ :=
  (List.range limit).filter fun x =>
    let c1 := isPowerfulOdd_bool x
    let c2 := isPowerfulOdd_bool (x + 1)
    let c3 := isPowerful_bool (2 * x + 1)
    c1 && c2 && c3

#eval find_counterexample_odd 10000

/-
We verify computationally that for 1 <= x < 10000, it is not the case that x and x+1 are PowerfulOdd and 2x+1 is Powerful.
-/
def check_structural_condition_odd_pos_bool (limit : ℕ) : Bool :=
  (List.range limit).all fun x =>
    if x == 0 then true else
    let c1 := isPowerfulOdd_bool x
    let c2 := isPowerfulOdd_bool (x + 1)
    let c3 := isPowerful_bool (2 * x + 1)
    not (c1 && c2 && c3)

theorem structural_condition_odd_pos_verified_bool : check_structural_condition_odd_pos_bool 10000 = true := by
  native_decide

/-
We find the positive values of x < 10000 that satisfy the structural condition.
-/
#eval (find_counterexample_odd 10000).filter (fun x => x > 0)

/-
We evaluate the boolean check function directly.
-/
#eval check_structural_condition_odd_pos_bool 10000