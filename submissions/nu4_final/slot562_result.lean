/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9f94f48e-edf2-4362-a687-f19c6b9d07cb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a Leinster group as a finite group where the sum of the orders of its normal subgroups equals twice the order of the group. We then prove that any cyclic group whose order is a perfect number is a Leinster group. This involves showing that in a cyclic group, all subgroups are normal and are in one-to-one correspondence with the divisors of the group's order.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If G is a finite cyclic group whose order is a perfect number, then G is a Leinster group (the sum of the orders of all its normal subgroups equals twice the group's order).
-/
def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

theorem cyclic_of_perfect_is_leinster (G : Type*) [Group G] [Fintype G]
    [IsCyclic G] (h_perfect : Nat.Perfect (Fintype.card G)) :
    IsLeinster G := by
      -- Since G is cyclic, every subgroup of G is normal. Therefore, the set of normal subgroups of G is exactly the set of all its subgroups.
      have h_normal_subgroups : {H : (Subgroup G) | H.Normal} = Set.univ := by
        ext H;
        simp +decide [ Subgroup.Normal ];
        obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := G );
        constructor;
        intro n hn g; obtain ⟨ k, rfl ⟩ := hg g; obtain ⟨ l, rfl ⟩ := hg n; group; aesop;
      -- We need to show that the sum of the orders of all subgroups of G is equal to twice the order of G.
      have h_sum : ∑ H ∈ Finset.univ.filter (fun H : Subgroup G => H.Normal), Fintype.card H = ∑ d ∈ Nat.divisors (Fintype.card G), d := by
        -- Since G is cyclic, every subgroup of G is generated by some element of G. Therefore, the set of subgroups of G is in bijection with the set of divisors of the order of G.
        have h_bijection : Finset.image (fun d => Subgroup.zpowers (Classical.choose (IsCyclic.exists_generator (α := G)) ^ (Fintype.card G / d))) (Nat.divisors (Fintype.card G)) = Finset.univ.filter (fun H : Subgroup G => H.Normal) := by
          ext H
          simp [h_normal_subgroups];
          constructor <;> intro hH
          all_goals generalize_proofs at *;
          · exact h_normal_subgroups.symm.subset ( Set.mem_univ H );
          · -- Since $H$ is a subgroup of $G$, it is generated by some element $g$ of $G$.
            obtain ⟨g, hg⟩ : ∃ g : G, H = Subgroup.zpowers g := by
              have h_cyclic : IsCyclic H := by
                exact?
              generalize_proofs at *;
              obtain ⟨ g, hg ⟩ := h_cyclic.exists_generator
              generalize_proofs at *;
              refine' ⟨ g, le_antisymm _ _ ⟩ <;> intro x hx <;> simp_all +decide [ Subgroup.mem_zpowers_iff ];
              · exact Exists.elim ( hg x hx ) fun k hk => ⟨ k, by simpa [ Subtype.ext_iff ] using hk ⟩;
              · exact hx.elim fun k hk => hk ▸ Subgroup.zpow_mem _ g.2 _;
            -- Since $g$ is an element of $G$, we can write it as $g = x^k$ for some integer $k$, where $x$ is a generator of $G$.
            obtain ⟨k, hk⟩ : ∃ k : ℕ, g = (Classical.choose (IsCyclic.exists_generator (α := G))) ^ k := by
              have := Classical.choose_spec ( ‹∀ a : ℕ, ∃ x : G, ∀ x_1 : G, x_1 ∈ Subgroup.zpowers x› 0 ) g
              generalize_proofs at *; (
              obtain ⟨ k, rfl ⟩ := this; use Int.toNat ( k % Fintype.card G ) ; simp +decide [ ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ <| Nat.cast_ne_zero.mpr <| Fintype.card_ne_zero ), zpow_mod_orderOf ] ;)
            generalize_proofs at *;
            simp_all +decide [ Subgroup.zpowers_eq_closure ] ;
            refine' ⟨ Fintype.card G / Nat.gcd k ( Fintype.card G ), Nat.div_dvd_of_dvd ( Nat.gcd_dvd_right _ _ ), _ ⟩
            generalize_proofs at *;
            rw [ Nat.div_div_self ] <;> norm_num [ Nat.gcd_dvd_left, Nat.gcd_dvd_right ];
            refine' le_antisymm _ _ <;> simp +decide [ Subgroup.mem_closure_singleton ];
            · have := Nat.gcd_eq_gcd_ab k ( Fintype.card G );
              simp +decide [ ← zpow_natCast, ← zpow_mul, this ];
              simp +decide [ zpow_add, zpow_mul ];
            · -- By definition of exponentiation, we know that $(x^{\gcd(k, n)})^m = x^{k}$ for some integer $m$.
              obtain ⟨m, hm⟩ : ∃ m : ℤ, k = Nat.gcd k (Fintype.card G) * m := by
                exact Int.natCast_dvd_natCast.mpr ( Nat.gcd_dvd_left _ _ )
              generalize_proofs at *;
              use m;
              generalize_proofs at *;
              skip
              generalize_proofs at *;
              rw [ ← zpow_natCast, ← zpow_mul, ← hm, zpow_natCast ];
        -- Since the function that maps a divisor $d$ to the subgroup generated by $g^{n/d}$ is injective, the sum over the subgroups is equal to the sum over the divisors.
        have h_inj : ∀ d1 d2 : ℕ, d1 ∈ Nat.divisors (Fintype.card G) → d2 ∈ Nat.divisors (Fintype.card G) → Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d1)) = Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d2)) → d1 = d2 := by
          intro d1 d2 hd1 hd2 h_eq
          have h_order : Fintype.card (Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d1))) = d1 ∧ Fintype.card (Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d2))) = d2 := by
            simp +decide [ Fintype.card_zpowers, orderOf_pow ];
            have h_order : orderOf (Classical.choose (IsCyclic.exists_generator (α := G))) = Fintype.card G := by
              rw [ orderOf_eq_card_of_forall_mem_zpowers ] ; aesop;
              exact fun x => Classical.choose_spec ( IsCyclic.exists_generator ( α := G ) ) x;
            simp +decide [ h_order, Nat.gcd_eq_right ( Nat.div_dvd_of_dvd ( Nat.dvd_of_mem_divisors hd1 ) ), Nat.gcd_eq_right ( Nat.div_dvd_of_dvd ( Nat.dvd_of_mem_divisors hd2 ) ) ];
            exact ⟨ Nat.div_div_self ( Nat.dvd_of_mem_divisors hd1 ) ( by aesop ), Nat.div_div_self ( Nat.dvd_of_mem_divisors hd2 ) ( by aesop ) ⟩;
          aesop;
        have h_sum_eq : ∑ H ∈ Finset.image (fun d => Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d))) (Nat.divisors (Fintype.card G)), Fintype.card H = ∑ d ∈ Nat.divisors (Fintype.card G), Fintype.card (Subgroup.zpowers ((Classical.choose (IsCyclic.exists_generator (α := G))) ^ (Fintype.card G / d))) := by
          exact Finset.sum_image <| fun d hd d' hd' h => h_inj d d' hd hd' h;
        convert h_sum_eq using 2;
        · exact h_bijection.symm;
        · rw [ Fintype.card_zpowers ];
          rw [ orderOf_pow ];
          rw [ Classical.choose_spec ( IsCyclic.exists_generator ( α := G ) ) |> fun h => orderOf_eq_card_of_forall_mem_zpowers h ];
          simp +decide [ Nat.gcd_eq_right ( Nat.div_dvd_of_dvd ( Nat.dvd_of_mem_divisors ‹_› ) ) ];
          rw [ Nat.div_div_self ( Nat.dvd_of_mem_divisors ‹_› ) ( by aesop ) ];
      simp_all +decide [ IsLeinster ];
      convert h_sum using 1;
      · refine' Finset.sum_bij ( fun x _ => x ) _ _ _ _ <;> aesop;
      · rw [ Nat.sum_divisors_eq_sum_properDivisors_add_self, two_mul, h_perfect.1 ]