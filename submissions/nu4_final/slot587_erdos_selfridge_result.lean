/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d54d6d06-6ad0-4c02-83ac-540acd42d353

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The product of two consecutive positive integers is never a perfect power (l ≥ 2).
-/
theorem product_consecutive_two_not_perfect_power (n : ℕ) (hn : 0 < n) (x l : ℕ) (hl : 2 ≤ l) : n * (n + 1) ≠ x ^ l := by
  -- Assume $\binom{x}{i}  n x^{r-1} = x^b$. Then $x$ must be divisible by $r$.
  by_contra h
  obtain ⟨a, b, ha⟩ : ∃ a b : ℕ, n = a^l ∧ n + 1 = b^l := by
    -- Since $n$ and $n+1$ are consecutive integers, they are coprime, and thus both must be perfect $l$-th powers.
    have h_coprime : Nat.gcd n (n + 1) = 1 := by
      norm_num [ Nat.gcd_comm ]
    have h_power : ∀ {m k : ℕ}, m * k = x ^ l → Nat.gcd m k = 1 → ∃ a : ℕ, m = a ^ l := by
      intro m k hmk hgcd; exact exists_eq_pow_of_mul_eq_pow ( by aesop ) hmk;
    obtain ⟨a, ha⟩ := h_power (by
    exact h : n * (n + 1) = x ^ l) h_coprime
    obtain ⟨b, hb⟩ := h_power (by
    linarith : (n + 1) * n = x ^ l) (by
    rwa [ Nat.gcd_comm ] : Nat.gcd (n + 1) n = 1)
    use a, b;
  -- Then $b^l - a^l = 1$, which implies $(b-a)(b^{l-1} + b^{l-2}a + \cdots + a^{l-1}) = 1$.
  have h_diff : (b - a) * (∑ i ∈ Finset.range l, b^i * a^(l-1-i)) = 1 := by
    zify [ ha ];
    rw [ Nat.cast_sub ( le_of_not_ge fun h => by linarith [ pow_le_pow_left' h l ] ) ] ; linarith [ geom_sum₂_mul ( b : ℤ ) a l ];
  rcases l with ( _ | _ | l ) <;> simp_all +decide [ Finset.sum_range_succ' ];
  rcases a with ( _ | _ | a ) <;> simp_all +decide [ Finset.sum_range_succ', pow_succ' ];
  exact absurd h_diff.2 ( by exact ne_of_gt <| lt_add_of_pos_of_le ( add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => by positivity ) <| by exact mul_pos ( Nat.pos_of_ne_zero <| by aesop_cat ) <| pow_pos ( Nat.succ_pos _ ) _ ) <| Nat.one_le_iff_ne_zero.mpr <| by positivity )

/-
If the product of k consecutive integers is a square, then the square-free part of each integer has only prime factors ≤ k.
-/
theorem prime_factors_of_squarefree_part_le_k (n k : ℕ) (h_prod : ∃ x, ∏ i ∈ Finset.Ioc n (n + k), i = x ^ 2) (i : ℕ) (hi : i ∈ Finset.Ioc n (n + k)) : ∃ a b, i = a * b ^ 2 ∧ Squarefree a ∧ ∀ p, Nat.Prime p → p ∣ a → p ≤ k := by
  -- Let's obtain the square-free part of $i$.
  obtain ⟨a, b, hi_eq, ha_sqfree⟩ : ∃ a b : ℕ, i = a * b^2 ∧ Squarefree a := by
    obtain ⟨ a, ha ⟩ := Nat.sq_mul_squarefree i;
    exact ⟨ a, ha.choose, by linarith [ ha.choose_spec ], ha.choose_spec.2 ⟩;
  -- Suppose $p$ is a prime dividing $a$. Then $v_p(a) = 1$ (since $a$ is square-free).
  by_contra h_contra
  obtain ⟨p, hp_prime, hp_div_a, hp_gt_k⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ a ∧ p > k := by
    grind;
  -- Since $p$ divides $a$, it divides $i$, and thus $v_p(i)$ is odd.
  have hp_div_i : p ∣ i := by
    exact hi_eq.symm ▸ dvd_mul_of_dvd_left hp_div_a _
  have hp_odd_vp : Odd (Nat.factorization (∏ i ∈ Finset.Ioc n (n + k), i) p) := by
    have hp_odd_vp : ∀ j ∈ Finset.Ioc n (n + k), j ≠ i → ¬(p ∣ j) := by
      intros j hj_mem hj_ne_i hj_div_p
      have h_diff : |(j : ℤ) - i| < p := by
        exact abs_sub_lt_iff.mpr ⟨ by linarith [ Finset.mem_Ioc.mp hi, Finset.mem_Ioc.mp hj_mem ], by linarith [ Finset.mem_Ioc.mp hi, Finset.mem_Ioc.mp hj_mem ] ⟩;
      exact h_diff.not_le ( Int.le_of_dvd ( abs_pos.mpr ( sub_ne_zero.mpr <| mod_cast hj_ne_i ) ) <| by simpa using dvd_sub ( Int.natCast_dvd_natCast.mpr hj_div_p ) ( Int.natCast_dvd_natCast.mpr hp_div_i ) );
    rw [ Nat.factorization_prod ] <;> norm_num;
    · rw [ Finset.sum_eq_single i ] <;> norm_num;
      · rw [ hi_eq, Nat.factorization_mul ] <;> norm_num [ hp_prime.ne_zero ];
        · rw [ Nat.factorization_eq_one_of_squarefree ] <;> aesop;
        · rintro rfl; simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ];
        · rintro rfl; simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ];
      · exact fun j hj₁ hj₂ hj₃ => Nat.factorization_eq_zero_of_not_dvd fun hj₄ => hp_odd_vp j ( Finset.mem_Ioc.mpr ⟨ hj₁, hj₂ ⟩ ) hj₃ hj₄;
      · exact fun h => False.elim <| h ( Finset.mem_Ioc.mp hi |>.1 ) |> not_lt_of_ge ( Finset.mem_Ioc.mp hi |>.2 );
    · intros; linarith;
  obtain ⟨ x, hx ⟩ := h_prod; simp_all +decide [ Nat.factorization_pow ] ;
  grind

/-
The product of 3 consecutive integers is never a perfect square.
-/
theorem product_three_consecutive_not_square (n : ℕ) (hn : 0 < n) (x : ℕ) : n * (n + 1) * (n + 2) ≠ x ^ 2 := by
  -- Since $n+1$ is coprime to the rest, $n+1$ must be a square.
  by_contra h
  obtain ⟨y, hy⟩ : ∃ y, n + 1 = y^2 := by
    have h_coprime : Nat.gcd (n + 1) (n * (n + 2)) = 1 := by
      norm_num [ Nat.coprime_mul_iff_right, Nat.coprime_mul_iff_left ];
      norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ];
    exact exists_eq_pow_of_mul_eq_pow ( by aesop ) ( by linarith );
  -- Then $n(n+2) = (y^2 - 1)(y^2 + 1) = y^4 - 1$ must also be a square.
  obtain ⟨z, hz⟩ : ∃ z, n * (n + 2) = z^2 := by
    use x / y;
    rw [ Nat.div_pow ];
    · rw [ ← hy, ← h, Nat.div_eq_of_eq_mul_left ] <;> nlinarith [ hn ];
    · exact Nat.pow_dvd_pow_iff two_ne_zero |>.1 ⟨ n * ( n + 2 ), by nlinarith ⟩;
  nlinarith only [ show z = n + 1 by nlinarith only [ hn, hz ], hn, hz ]

/-
If n < k, the product of k consecutive integers starting at n+1 is not a perfect square.
-/
theorem product_consecutive_not_square_of_n_lt_k (n k : ℕ) (hk : 2 ≤ k) (hn : 0 < n) (hnk : n < k) (x : ℕ) : (∏ i ∈ Finset.Ioc n (n + k), i) ≠ x ^ 2 := by
  by_contra htra;
  -- Let $M = n + k$. Since $n < k$, we have $n < M/2$. By Bertrand's postulate, there exists a prime $p$ such that $M/2 < p \leq M$.
  obtain ⟨p, hp_prime, hp_bounds⟩ : ∃ p, Nat.Prime p ∧ (n + k) / 2 < p ∧ p ≤ n + k := by
    exact Nat.exists_prime_lt_and_le_two_mul ( ( n + k ) / 2 ) ( by omega ) |> fun ⟨ p, hp₁, hp₂ ⟩ => ⟨ p, hp₁, by omega, by omega ⟩ ;
  -- Since $p > M/2 > n$, $p$ is in the interval $(n, M]$. Thus $p$ divides the product.
  have hp_div : p ∣ ∏ i ∈ Finset.Ioc n (n + k), i := by
    exact Finset.dvd_prod_of_mem _ ( Finset.mem_Ioc.mpr ⟨ by omega, by omega ⟩ );
  -- Since $p > M/2$, $2p > M$. So $p$ divides exactly one number in the interval $(n, M]$. Let this number be $m$. Since $p | m$ and $m \leq M < 2p$, we must have $m = p$.
  have hp_unique : ∃ m ∈ Finset.Ioc n (n + k), p ∣ m ∧ ∀ j ∈ Finset.Ioc n (n + k), p ∣ j → j = m := by
    -- Since $p > M/2$, $2p > M$. So $p$ divides exactly one number in the interval $(n, M]$.
    have hp_unique : ∀ j ∈ Finset.Ioc n (n + k), p ∣ j → j = p := by
      intros j hj_mem hj_div
      obtain ⟨m, hm⟩ : ∃ m, j = p * m := hj_div
      have hm_bounds : m ≤ 1 := by
        nlinarith [ Finset.mem_Ioc.mp hj_mem, Nat.div_add_mod ( n + k ) 2, Nat.mod_lt ( n + k ) two_pos ];
      interval_cases m <;> aesop;
    -- Since $p$ divides the product and $p$ is prime, $p$ must divide at least one of the factors in the product.
    obtain ⟨m, hm⟩ : ∃ m ∈ Finset.Ioc n (n + k), p ∣ m := by
      haveI := Fact.mk hp_prime; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Finset.prod_eq_zero_iff ] ;
      replace htra := congr_arg ( ( ↑ ) : ℕ → ZMod p ) htra ; simp_all +decide [ Finset.prod_eq_zero_iff ] ;
    exact ⟨ m, hm.1, hm.2, fun j hj hj' => hp_unique j hj hj' ▸ hp_unique m hm.1 hm.2 ▸ rfl ⟩;
  -- Thus $v_p(\prod_{i=n+1}^{n+k} i) = v_p(m) = 1$.
  obtain ⟨m, hm_mem, hm_div, hm_unique⟩ := hp_unique
  have hp_val : Nat.factorization (∏ i ∈ Finset.Ioc n (n + k), i) p = 1 := by
    rw [ Nat.factorization_prod ] <;> norm_num;
    · rw [ Finset.sum_eq_single m ] <;> norm_num;
      · -- Since $p$ divides $m$ and $m \leq n + k < 2p$, we must have $m = p$.
        have hm_eq_p : m = p := by
          obtain ⟨ q, rfl ⟩ := hm_div;
          rcases q with ( _ | _ | q ) <;> norm_num at * ; nlinarith [ Nat.div_add_mod ( n + k ) 2, Nat.mod_lt ( n + k ) two_pos ];
        rw [ hm_eq_p, hp_prime.factorization_self ];
      · exact fun j hj₁ hj₂ hj₃ => Nat.factorization_eq_zero_of_not_dvd fun hj₄ => hj₃ <| hm_unique j ( Finset.mem_Ioc.mpr ⟨ hj₁, hj₂ ⟩ ) hj₄;
      · exact fun h => absurd ( h ( Finset.mem_Ioc.mp hm_mem |>.1 ) ) ( by linarith [ Finset.mem_Ioc.mp hm_mem |>.2 ] );
    · intros; linarith;
  rw [ htra, Nat.factorization_pow ] at hp_val ; aesop

/-
The square-free part of a natural number n.
-/
noncomputable def squarefreePart (n : ℕ) : ℕ :=
  if h : n = 0 then 1 else (Nat.sq_mul_squarefree n).choose

/-
The square-free part of n satisfies n = squarefreePart n * y^2 for some y, and is square-free.
-/
theorem squarefreePart_spec (n : ℕ) (hn : n ≠ 0) :
    ∃ y, n = squarefreePart n * y ^ 2 ∧ Squarefree (squarefreePart n) := by
      -- By definition of $squarefreePart$, there exists $y$ such that $n = squarefreePart(n) * y^2$ and $squarefreePart(n)$ is square-free.
      obtain ⟨y, hy⟩ : ∃ y, n = squarefreePart n * y^2 ∧ Squarefree (squarefreePart n) := by
        have h_def : ∃ b, n = (Nat.sq_mul_squarefree n).choose * b^2 ∧ Squarefree (Nat.sq_mul_squarefree n).choose := by
          have := Nat.sq_mul_squarefree n;
          exact ⟨ _, this.choose_spec.choose_spec.1.symm.trans ( by ring ), this.choose_spec.choose_spec.2 ⟩
        obtain ⟨ y, hy₁, hy₂ ⟩ := h_def; exact ⟨ y, by simpa [ squarefreePart, hn ] using hy₁, by simpa [ squarefreePart, hn ] using hy₂ ⟩ ;
      use y

/-
The square-free part of n is less than or equal to n.
-/
theorem squarefreePart_le (n : ℕ) (hn : n ≠ 0) : squarefreePart n ≤ n := by
  exact Nat.le_of_dvd ( Nat.pos_of_ne_zero hn ) ( by have := squarefreePart_spec n hn; rcases this with ⟨ y, hy₁, hy₂ ⟩ ; exact dvd_of_mul_right_eq _ hy₁.symm )

/-
If n >= k^2, the square-free parts of integers in (n, n+k] are distinct.
-/
theorem squarefreePart_distinct_of_n_ge_k_sq (n k : ℕ) (hk : 2 ≤ k) (hn : k ^ 2 ≤ n) (i j : ℕ) (hi : i ∈ Finset.Ioc n (n + k)) (hj : j ∈ Finset.Ioc n (n + k)) (hij : i < j) : squarefreePart i ≠ squarefreePart j := by
  -- Assume squarefreePart i = squarefreePart j = a. Then i = a * x^2, j = a * y^2 with x < y.
  by_contra h_eq
  obtain ⟨a, x, y, hx, hy, hxy⟩ : ∃ a x y : ℕ, squarefreePart i = a ∧ squarefreePart j = a ∧ i = a * x ^ 2 ∧ j = a * y ^ 2 ∧ x < y := by
    -- By definition of squarefreePart, there exist x and y such that i = squarefreePart i * x^2 and j = squarefreePart j * y^2.
    obtain ⟨x, hx⟩ : ∃ x, i = squarefreePart i * x ^ 2 := by
      exact squarefreePart_spec i ( by linarith [ Finset.mem_Ioc.mp hi ] ) |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁ ⟩
    obtain ⟨y, hy⟩ : ∃ y, j = squarefreePart j * y ^ 2 := by
      exact squarefreePart_spec j ( by linarith [ Finset.mem_Ioc.mp hj ] ) |> fun ⟨ y, hy₁, hy₂ ⟩ => ⟨ y, hy₁ ⟩;
    refine' ⟨ squarefreePart i, x, y, rfl, h_eq.symm, hx, by simpa only [ h_eq ] using hy, _ ⟩;
    exact not_le.mp fun h => hij.not_le <| by rw [ hx, hy, h_eq ] ; gcongr;
  -- Since $i > n \geq k^2$, we have $a * x^2 \geq k^2$. So $x \geq \sqrt{k^2/a} = k / \sqrt{a}$.
  have hx_ge : x ≥ k / Real.sqrt a := by
    have hx_ge : a * x ^ 2 ≥ k ^ 2 := by
      linarith [ Finset.mem_Ioc.mp hi ];
    rw [ ge_iff_le, div_le_iff₀ ] <;> norm_cast;
    · nlinarith only [ show 0 ≤ ( x : ℝ ) * Real.sqrt a by positivity, Real.mul_self_sqrt ( Nat.cast_nonneg a ), ( by norm_cast : ( a : ℝ ) * x ^ 2 ≥ k ^ 2 ) ];
    · exact Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by rintro rfl; nlinarith ) ) );
  -- Then $j - i = a(y^2 - x^2) \geq a(2x + 1) \geq a(2(k/\sqrt{a}) + 1) = 2k\sqrt{a} + a$.
  have h_diff_ge : (j - i : ℝ) ≥ 2 * k * Real.sqrt a + a := by
    have h_diff_ge : (j - i : ℝ) ≥ a * (2 * x + 1) := by
      exact le_tsub_of_add_le_left ( mod_cast by nlinarith only [ hxy.1, hxy.2.1, hxy.2.2, Nat.pow_le_pow_left hxy.2.2 2 ] );
    rw [ ge_iff_le, div_le_iff₀ ] at hx_ge <;> nlinarith [ Real.sqrt_nonneg a, Real.sq_sqrt <| Nat.cast_nonneg a, show ( a :ℝ ) > 0 from Nat.cast_pos.mpr <| Nat.pos_of_ne_zero <| by rintro rfl; linarith [ Finset.mem_Ioc.mp hi, Finset.mem_Ioc.mp hj ] ];
  -- Since $a \geq 1$, we have $2k\sqrt{a} + a \geq 2k + 1 > k$.
  have h_diff_gt_k : (j - i : ℝ) > k := by
    nlinarith only [ show ( k : ℝ ) ≥ 2 by norm_cast, Real.sqrt_nonneg a, Real.sq_sqrt <| Nat.cast_nonneg a, h_diff_ge, show ( a : ℝ ) ≥ 1 by exact_mod_cast Nat.pos_of_ne_zero <| by rintro rfl; simp_all +singlePass ];
  norm_num +zetaDelta at *;
  rw [ lt_sub_iff_add_lt ] at h_diff_gt_k ; norm_cast at * ; linarith

/-
The product of 4 consecutive integers is never a perfect square.
-/
theorem product_four_consecutive_not_square (n : ℕ) (hn : 0 < n) (x : ℕ) : n * (n + 1) * (n + 2) * (n + 3) ≠ x ^ 2 := by
  exact fun h => by nlinarith [ show x = n ^ 2 + 3 * n + 1 by nlinarith ] ;

/-
If the product of k consecutive integers is a square and n+k < (k+1)^2, then all prime factors of the product are <= k.
-/
theorem not_square_of_no_prime_gt_k (n k : ℕ) (hk : 2 ≤ k) (hn : n + k < (k + 1) ^ 2) (h_prod : ∃ x, ∏ i ∈ Finset.Ioc n (n + k), i = x ^ 2) : ∀ p, Nat.Prime p → p ∣ ∏ i ∈ Finset.Ioc n (n + k), i → p ≤ k := by
  intro p pp dp
  by_contra h_contra
  have h_p_ge_k1 : p ≥ k + 1 := by
    exact not_le.mp h_contra;
  -- Since p > k, p divides at most one factor n+i in the interval (n, n+k].
  obtain ⟨i, hi⟩ : ∃ i ∈ Finset.Ioc n (n + k), p ∣ i ∧ ∀ j ∈ Finset.Ioc n (n + k), j ≠ i → ¬p ∣ j := by
    -- Since p > k, p divides at most one factor n+i in the interval (n, n+k]. Let's find such an i.
    obtain ⟨i, hi⟩ : ∃ i ∈ Finset.Ioc n (n + k), p ∣ i := by
      haveI := Fact.mk pp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Finset.prod_eq_zero_iff ] ;
    refine' ⟨ i, hi.1, hi.2, fun j hj₁ hj₂ hj₃ => _ ⟩;
    exact hj₂ ( by obtain ⟨ q, hq ⟩ := hi.2; obtain ⟨ r, hr ⟩ := hj₃; nlinarith [ show q = r by nlinarith [ Finset.mem_Ioc.mp hi.1, Finset.mem_Ioc.mp hj₁ ] ] );
  -- Since product is a square, v_p(n+i) is even.
  obtain ⟨x, hx⟩ := h_prod
  have h_vp_even : Even (Nat.factorization (∏ i ∈ Finset.Ioc n (n + k), i) p) := by
    aesop;
  rw [ Nat.factorization_prod ] at h_vp_even <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Finset.prod_eq_zero_iff ];
  · rw [ Finset.sum_eq_single i ] at h_vp_even <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Nat.Prime.dvd_iff_not_coprime ];
    -- Since $p$ divides $i$, we have $p^2 \mid i$.
    have h_p2_div_i : p ^ 2 ∣ i := by
      have h_p2_div_i : p ∣ i := by
        exact pp.dvd_iff_not_coprime.mpr hi.2.1;
      exact dvd_trans ( pow_dvd_pow p ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) ) ) ( even_iff_two_dvd.mp h_vp_even ) ) ) ( Nat.ordProj_dvd _ _ );
    nlinarith only [ Nat.le_of_dvd ( by linarith ) h_p2_div_i, hi.1.2, hn, h_p_ge_k1 ];
  · intros; linarith;

/-
Assuming Sylvester-Schur theorem, the product of k consecutive integers is not a square for small n (n+k < (k+1)^2).
-/
def SylvesterSchurProp : Prop :=
  ∀ n k, n ≥ k → ∃ p, Nat.Prime p ∧ p > k ∧ p ∣ ∏ i ∈ Finset.Ioc n (n + k), i

theorem product_consecutive_not_square_of_sylvester_schur (h_ss : SylvesterSchurProp) (n k : ℕ) (hk : 2 ≤ k) (hn : 0 < n) (h_bound : n + k < (k + 1) ^ 2) (x : ℕ) :
    (∏ i ∈ Finset.Ioc n (n + k), i) ≠ x ^ 2 := by
      -- Assume that the product is a square, then derive a contradiction using the Sylvester-Schur theorem.
      by_contra h_contra
      have h_prime : ∃ p, Nat.Prime p ∧ k < p ∧ p ∣ ∏ i ∈ Finset.Ioc n (n + k), i := by
        by_cases h_ge : k ≤ n;
        · exact?;
        · exact absurd h_contra ( product_consecutive_not_square_of_n_lt_k n k hk hn ( by linarith ) x );
      -- Apply the lemma that states if the product is a square and n+k < (k+1)^2, then all primes dividing the product are ≤ k.
      have h_all_primes_le_k : ∀ p, Nat.Prime p → p ∣ ∏ i ∈ Finset.Ioc n (n + k), i → p ≤ k := by
        apply not_square_of_no_prime_gt_k n k hk h_bound ⟨ x, h_contra ⟩;
      exact not_lt_of_ge ( h_all_primes_le_k _ h_prime.choose_spec.1 h_prime.choose_spec.2.2 ) h_prime.choose_spec.2.1

/-
The product of k consecutive integers is never a perfect square (assuming Sylvester-Schur and LargeNProp).
-/
def LargeNProp : Prop :=
  ∀ n k, k ≥ 2 → n ≥ k ^ 2 → ∀ x, (∏ i ∈ Finset.Ioc n (n + k), i) ≠ x ^ 2

theorem product_consecutive_not_square_full (h_ss : SylvesterSchurProp) (h_large : LargeNProp) (n k : ℕ) (hk : 2 ≤ k) (hn : 0 < n) (x : ℕ) :
    (∏ i ∈ Finset.Ioc n (n + k), i) ≠ x ^ 2 := by
      by_cases h_large_case : n ≥ k^2;
      · exact h_large n k hk h_large_case x;
      · by_cases h_large_case : n < k;
        · exact?;
        · -- Since $k \leq n < k^2$, we can use Sylvester-Schur (h_ss) to find a prime $p > k$ dividing the product.
          obtain ⟨p, hp_prime, hp_gt_k, hp_div⟩ : ∃ p, Nat.Prime p ∧ p > k ∧ p ∣ ∏ i ∈ Finset.Ioc n (n + k), i := by
            exact h_ss n k ( le_of_not_gt h_large_case ) |> fun ⟨ p, hp₁, hp₂, hp₃ ⟩ => ⟨ p, hp₁, hp₂, hp₃ ⟩;
          contrapose! hp_gt_k;
          have := not_square_of_no_prime_gt_k n k hk ( by linarith ) ⟨ x, hp_gt_k ⟩ p hp_prime hp_div; aesop;

/-
The product of 3 consecutive integers is never a perfect power (l ≥ 2).
-/
theorem product_three_consecutive_not_perfect_power (n : ℕ) (hn : 0 < n) (x l : ℕ) (hl : 2 ≤ l) : n * (n + 1) * (n + 2) ≠ x ^ l := by
  by_contra h_contra
  obtain ⟨y, hy⟩ : ∃ y, n + 1 = y ^ l := by
    -- Since $n+1$ is coprime to $n(n+2)$, and their product is a perfect power, each factor must itself be a perfect power.
    have h_coprime : Nat.gcd (n + 1) (n * (n + 2)) = 1 := by
      norm_num [ Nat.coprime_mul_iff_right, Nat.coprime_mul_iff_left ];
      norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ];
    exact exists_eq_pow_of_mul_eq_pow ( by aesop ) ( by linarith );
  -- Then n(n+2) must also be an l-th power, say z^l.
  obtain ⟨z, hz⟩ : ∃ z, n * (n + 2) = z ^ l := by
    use x / y;
    rw [ Nat.div_pow ];
    · rw [ ← h_contra, ← hy, Nat.div_eq_of_eq_mul_left ] <;> nlinarith;
    · exact Nat.pow_dvd_pow_iff ( by linarith ) |>.1 ( hy ▸ h_contra ▸ dvd_mul_of_dvd_left ( dvd_mul_left _ _ ) _ );
  -- So y^{2l} - z^l = 1.
  have h_diff : y ^ (2 * l) - z ^ l = 1 := by
    exact Nat.sub_eq_of_eq_add <| by rw [ pow_mul' ] ; nlinarith;
  -- This is a difference of two l-th powers equal to 1. Since l >= 2, the only solution in non-negative integers is consecutive powers 1 and 0.
  have h_consecutive : (y ^ 2) ^ l - z ^ l = 1 → (y ^ 2 = 1 ∧ z = 0) ∨ (y ^ 2 = 0 ∧ z = 1) := by
    intro h_diff
    have h_factor : (y ^ 2 - z) * (∑ i ∈ Finset.range l, (y ^ 2) ^ i * z ^ (l - 1 - i)) = 1 := by
      zify at *;
      cases le_total ( y ^ 2 ) z <;> simp_all +decide [ Nat.pow_le_pow_left ];
      rw [ ← h_diff, mul_comm, geom_sum₂_mul ];
    rcases l with ( _ | _ | l ) <;> simp_all +decide [ Finset.sum_range_succ' ];
    rcases y with ( _ | _ | y ) <;> rcases z with ( _ | _ | z ) <;> simp_all +decide [ Finset.sum_range_succ', pow_succ' ];
    exact absurd h_factor.2 ( by exact ne_of_gt <| lt_add_of_pos_of_le ( add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => by positivity ) <| by positivity ) <| Nat.one_le_iff_ne_zero.mpr <| by positivity );
  simp_all +decide [ pow_mul' ];
  cases h_consecutive ( by simpa only [ pow_right_comm ] using h_diff ) <;> aesop

/-
If the product of 5 consecutive integers is a square, then 5 does not divide the square-free part of any of them.
-/
theorem squarefree_part_not_dvd_five_of_product_square (n : ℕ) (x : ℕ) (h_prod : ∏ i ∈ Finset.Ioc n (n + 5), i = x ^ 2) (i : ℕ) (hi : i ∈ Finset.Ioc n (n + 5)) : ¬ 5 ∣ squarefreePart i := by
  -- Assume there exists $i \in \{n+1, ..., n+5\}$ such that $5 \mid \text{squarefreePart}(i)$.
  by_contra h_contra
  obtain ⟨i, hi, h_div⟩ : ∃ i ∈ Finset.Ioc n (n + 5), 5 ∣ squarefreePart i := by
    exact?;
  -- Since $5 \mid \text{squarefreePart}(i)$, we have $v_5(i)$ is odd.
  have h_odd : Odd (Nat.factorization i 5) := by
    have h_odd : ∃ y, i = squarefreePart i * y^2 ∧ Squarefree (squarefreePart i) := by
      apply squarefreePart_spec i (by
      linarith [ Finset.mem_Ioc.mp hi ]);
    rcases h_odd with ⟨ y, hy₁, hy₂ ⟩ ; rw [ hy₁, Nat.factorization_mul ] <;> norm_num;
    · rw [ Nat.factorization_eq_one_of_squarefree ] <;> norm_num;
      · assumption;
      · assumption;
    · intro H; simp_all +singlePass ;
    · rintro rfl; simp +decide at hy₁; linarith [ Finset.mem_Ioc.mp hi ];
  -- Since $5$ is prime and length is $5$, $5$ divides exactly one term in the product.
  have h_div_one : ∀ j ∈ Finset.Ioc n (n + 5), j ≠ i → ¬(5 ∣ j) := by
    intro j hj_mem hj_ne_i hj_div
    have h_div_i : 5 ∣ i := by
      exact Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by by_contra h; simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ] );
    norm_num [ Finset.mem_Ioc ] at *;
    grind;
  -- Since $5 \mid \text{squarefreePart}(i)$, we have $v_5(\prod_{j=n+1}^{n+5} j) = v_5(i)$.
  have h_prod_odd : Odd (Nat.factorization (∏ j ∈ Finset.Ioc n (n + 5), j) 5) := by
    rw [ Nat.factorization_prod ] <;> simp_all +decide [ Finset.prod_eq_zero_iff ];
    · rw [ Finset.sum_eq_single i ] <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ];
    · grind;
  simp_all +decide [ Nat.factorization_pow ];
  exact absurd h_prod_odd ( by simp +decide [ parity_simps ] )

/-
A square-free number with prime factors <= 5 and not divisible by 5 must be in {1, 2, 3, 6}.
-/
theorem squarefree_supported_on_2_3 (a : ℕ) (ha : Squarefree a) (h_factors : ∀ p, Nat.Prime p → p ∣ a → p ≤ 5) (h_no_5 : ¬ 5 ∣ a) : a ∈ ({1, 2, 3, 6} : Finset ℕ) := by
  -- Since $a$ is square-free and has no prime factors greater than 5, it must be of the form $2^x * 3^y$ where $x$ and $y$ are 0 or 1.
  have h_form : ∃ x y : ℕ, x ≤ 1 ∧ y ≤ 1 ∧ a = 2^x * 3^y := by
    -- Since $a$ is square-free and has no prime factors greater than 5, it must be of the form $2^x * 3^y$ where $x$ and $y$ are 0 or 1. We can prove this by considering the prime factorization of $a$.
    have h_prime_factors : ∀ p, Nat.Prime p → p ∣ a → p = 2 ∨ p = 3 := by
      intro p pp dp; specialize h_factors p pp dp; interval_cases p <;> simp_all +decide ;
    rw [ ← Nat.factorization_prod_pow_eq_self ( show a ≠ 0 by rintro rfl; specialize h_prime_factors 5; norm_num at h_prime_factors ) ];
    rw [ Finsupp.prod_of_support_subset ];
    case s => exact { 2, 3 };
    · exact ⟨ a.factorization 2, a.factorization 3, Nat.le_of_not_lt fun h => absurd ( ha.natFactorization_le_one 2 ) ( by norm_num; linarith ), Nat.le_of_not_lt fun h => absurd ( ha.natFactorization_le_one 3 ) ( by norm_num; linarith ), by norm_num ⟩;
    · intro p hp; specialize h_prime_factors p; aesop;
    · norm_num;
  rcases h_form with ⟨ x, y, hx, hy, rfl ⟩ ; interval_cases x <;> interval_cases y <;> simp +decide ;

/-
If k <= 7 and n >= k, the square-free parts of k consecutive integers are distinct.
-/
theorem squarefreePart_distinct_of_k_le_7 (n k : ℕ) (hk : 2 ≤ k) (hk7 : k ≤ 7) (hn : k ≤ n) (i j : ℕ) (hi : i ∈ Finset.Ioc n (n + k)) (hj : j ∈ Finset.Ioc n (n + k)) (hij : i < j) : squarefreePart i ≠ squarefreePart j := by
  -- Assume squarefreePart i = squarefreePart j = a. Then i = a * x^2, j = a * y^2 with x < y.
  by_contra h_eq
  obtain ⟨a, x, y, hx, hy, hxy⟩ : ∃ a x y : ℕ, squarefreePart i = a ∧ squarefreePart j = a ∧ i = a * x^2 ∧ j = a * y^2 ∧ x < y := by
    -- By definition of squarefreePart, we know that there exist x and y such that i = squarefreePart i * x^2 and j = squarefreePart j * y^2.
    obtain ⟨x, hx⟩ : ∃ x, i = squarefreePart i * x^2 := by
      exact squarefreePart_spec i ( by linarith [ Finset.mem_Ioc.mp hi ] ) |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁ ⟩
    obtain ⟨y, hy⟩ : ∃ y, j = squarefreePart j * y^2 := by
      exact squarefreePart_spec j ( by linarith [ Finset.mem_Ioc.mp hj ] ) |> fun ⟨ y, hy, hy' ⟩ => ⟨ y, hy ⟩;
    refine' ⟨ squarefreePart i, x, y, rfl, h_eq.symm, hx, hy ▸ h_eq ▸ rfl, _ ⟩;
    exact not_le.mp fun h => hij.not_le <| by rw [ hx, hy, h_eq ] ; gcongr;
  -- Then $j - i = a(y^2 - x^2) \geq a(2x + 1)$.
  have h_diff : j - i ≥ a * (2 * x + 1) := by
    exact le_tsub_of_add_le_left ( by nlinarith only [ hxy, Nat.pow_le_pow_left hxy.2.2 2 ] );
  -- Since $i, j \in (n, n+k]$, $j - i < k$. So $k > a(2x + 1)$.
  have h_bound : k > a * (2 * x + 1) := by
    exact h_diff.trans_lt ( by rw [ tsub_lt_iff_left hij.le ] ; linarith [ Finset.mem_Ioc.mp hi, Finset.mem_Ioc.mp hj ] );
  -- Also $i > n \geq k$, so $a * x^2 > k$.
  have h_i_gt_k : a * x^2 > k := by
    linarith [ Finset.mem_Ioc.mp hi ];
  interval_cases k <;> rcases x with ( _ | _ | x ) <;> simp_all +arith +decide only;
  all_goals nlinarith only [ h_bound, h_i_gt_k, show a > 0 from Nat.pos_of_ne_zero ( by aesop_cat ) ]

/-
The square-free part is unique for non-zero n.
-/
theorem squarefreePart_eq (n a b : ℕ) (hn : n ≠ 0) (h : n = a * b ^ 2) (ha : Squarefree a) : squarefreePart n = a := by
  -- By definition of $squarefreePart$, there exists some $y$ such that $n = squarefreePart n * y^2$ and $squarefreePart n$ is squarefree.
  obtain ⟨y, hy⟩ : ∃ y, n = squarefreePart n * y^2 ∧ Squarefree (squarefreePart n) := by
    exact?;
  -- Since $a$ and $squarefreePart n$ are both square-free and $n = a * b^2$ and $n = squarefreePart n * y^2$, we can equate the square-free parts: $a = squarefreePart n$.
  have h_eq : a * b^2 = squarefreePart n * y^2 := by
    linarith [ hy.1 ];
  apply_fun fun z => z.factorization at h_eq;
  rw [ Nat.factorization_mul, Nat.factorization_mul ] at h_eq <;> norm_num at *;
  · -- Since $a$ and $squarefreePart n$ are both square-free, their factorizations contain only 0s and 1s.
    have h_factorization : ∀ p, Nat.factorization a p ≤ 1 ∧ Nat.factorization (squarefreePart n) p ≤ 1 := by
      exact fun p => ⟨ Nat.le_of_not_lt fun h => absurd ( ha.natFactorization_le_one p ) ( by linarith ), Nat.le_of_not_lt fun h => absurd ( hy.2.natFactorization_le_one p ) ( by linarith ) ⟩;
    refine' Nat.factorization_inj _ _ _ <;> norm_num at *;
    · intro H; simp_all +singlePass ;
    · rintro rfl; simp_all +singlePass ;
    · ext p; specialize h_factorization p; replace h_eq := congr_arg ( fun z => z p ) h_eq; norm_num at *; omega;
  · intro H; simp_all +singlePass ;
  · rintro rfl; simp_all +singlePass;
  · rintro rfl; simp_all +singlePass;
  · rintro rfl; simp_all +singlePass

/-
If the product of 5 consecutive integers is a square, the square-free part of each integer is in {1, 2, 3, 6}.
-/
theorem squarefreePart_subset_1236 (n : ℕ) (x : ℕ) (h_prod : ∏ i ∈ Finset.Ioc n (n + 5), i = x ^ 2) :
    ∀ i ∈ Finset.Ioc n (n + 5), squarefreePart i ∈ ({1, 2, 3, 6} : Finset ℕ) := by
      -- By prime_factors_of_squarefree_part_le_k, we know that for each i in the interval, the square-free part of i is a product of primes ≤ 5.
      intro i hi
      have h_prime_factors : ∀ p, Nat.Prime p → p ∣ squarefreePart i → p ≤ 5 := by
        -- Apply the hypothesis that the product is a square to get that the square-free part of each integer in the interval is supported on {2, 3, 5}.
        have h_squarefree_parts : ∃ a b, i = a * b ^ 2 ∧ Squarefree a ∧ ∀ p, Nat.Prime p → p ∣ a → p ≤ 5 := by
          have := @prime_factors_of_squarefree_part_le_k n 5 ?_ i hi;
          · exact this;
          · use x;
        obtain ⟨ a, b, hi, ha, hb ⟩ := h_squarefree_parts; rw [ show squarefreePart i = a from ?_ ] ; aesop;
        convert squarefreePart_eq i a b _ hi ha using 1 ; aesop;
      apply squarefree_supported_on_2_3; exact (by
      convert ( squarefreePart_spec i ( by linarith [ Finset.mem_Ioc.mp hi ] ) ) |> Classical.choose_spec |> And.right using 1
      skip); exact (by
      assumption); exact (by
      apply squarefree_part_not_dvd_five_of_product_square n x h_prod i hi);

/-
The product of 5 consecutive integers (starting at n+1) is never a perfect square.
-/
theorem product_five_consecutive_not_square_Ioc (n : ℕ) (hn : 0 < n) (x : ℕ) : (∏ i ∈ Finset.Ioc n (n + 5), i) ≠ x ^ 2 := by
  -- Case n < 5
  by_cases h_lt : n < 5
  · apply product_consecutive_not_square_of_n_lt_k n 5 (by norm_num) hn h_lt x
  -- Case n >= 5
  · push_neg at h_lt
    by_contra h_sq
    -- Define the set of square-free parts
    let S := Finset.image squarefreePart (Finset.Ioc n (n + 5))
    -- S is a subset of {1, 2, 3, 6}
    have h_sub : S ⊆ {1, 2, 3, 6} := by
      intros s hs
      rw [Finset.mem_image] at hs
      obtain ⟨i, hi, rfl⟩ := hs
      apply squarefreePart_subset_1236 n x h_sq i hi
    -- Cardinality of S is 5
    have h_card : S.card = 5 := by
      rw [Finset.card_image_of_injOn]
      · rw [Nat.card_Ioc]; simp
      · intros i hi j hj heq
        by_contra h_ne
        have h_lt_or_gt : i < j ∨ j < i := ne_iff_lt_or_gt.mp h_ne
        cases h_lt_or_gt with
        | inl h_lt_ij => exact squarefreePart_distinct_of_k_le_7 n 5 (by norm_num) (by norm_num) h_lt i j hi hj h_lt_ij heq
        | inr h_gt_ij => exact squarefreePart_distinct_of_k_le_7 n 5 (by norm_num) (by norm_num) h_lt j i hj hi h_gt_ij heq.symm
    -- Contradiction
    have h_le : S.card ≤ ({1, 2, 3, 6} : Finset ℕ).card := Finset.card_le_card h_sub
    rw [h_card] at h_le
    norm_num at h_le
    done

/-
The cardinality of {1, 2, 3, 6} is 4.
-/
theorem card_S_1236 : ({1, 2, 3, 6} : Finset ℕ).card = 4 := by decide

/-
No subset of size 6 from {1, 2, 3, 5, 6, 10, 15, 30} has a square product.
-/
theorem no_subset_of_size_6_has_square_product :
  ∀ s ∈ Finset.powersetCard 6 {1, 2, 3, 5, 6, 10, 15, 30}, (Nat.sqrt (s.prod (fun x => x)))^2 ≠ s.prod (fun x => x) := by native_decide

/-
The product of 5 consecutive integers is never a perfect square.
-/
theorem product_five_consecutive_not_square (n : ℕ) (hn : 0 < n) (x : ℕ) : n * (n + 1) * (n + 2) * (n + 3) * (n + 4) ≠ x ^ 2 := by
  by_contra htra;
  -- Apply the theorem that states the product of 5 consecutive integers starting at n+1 is not a perfect square.
  have := @product_five_consecutive_not_square_Ioc (n - 1) ?_ x <;> rcases n with ( _ | _ | n ) <;> simp_all +decide [ Finset.prod_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
  nlinarith [ show x ≤ 10 by nlinarith ]

/-
The product of 5 consecutive integers is never a perfect square.
-/
theorem product_five_consecutive_not_square_v2 (n : ℕ) (hn : 0 < n) (x : ℕ) : n * (n + 1) * (n + 2) * (n + 3) * (n + 4) ≠ x ^ 2 := by
  -- Apply the lemma that states the product of 5 consecutive integers is never a perfect square.
  apply product_five_consecutive_not_square n hn x

/-
If n < k, the product of k consecutive integers is not a perfect power.
-/
theorem product_consecutive_not_perfect_power_of_n_lt_k (n k : ℕ) (hk : 2 ≤ k) (hn : 0 < n) (hnk : n < k) (x l : ℕ) (hl : 2 ≤ l) : (∏ i ∈ Finset.Ioc n (n + k), i) ≠ x ^ l := by
  -- Let M = n + k. Since n < k, n < M/2. By Bertrand's postulate, there is a prime p such that M/2 < p ≤ M.
  obtain ⟨p, hp_prime, hp_gt, hp_le⟩ : ∃ p, Nat.Prime p ∧ (n + k) / 2 < p ∧ p ≤ n + k := by
    exact Nat.exists_prime_lt_and_le_two_mul ( ( n + k ) / 2 ) ( by omega ) |> fun ⟨ p, hp₁, hp₂ ⟩ => ⟨ p, hp₁, by omega, by omega ⟩;
  -- Since p > n, p is in the interval (n, M]. p > M/2 implies 2p > M, so p divides exactly one number in the interval.
  have hp_div : ∃ m ∈ Finset.Ioc n (n + k), p ∣ m ∧ ∀ i ∈ Finset.Ioc n (n + k), i ≠ m → ¬(p ∣ i) := by
    obtain ⟨m, hm₁, hm₂⟩ : ∃ m ∈ Finset.Ioc n (n + k), p ∣ m := by
      exact ⟨ p, Finset.mem_Ioc.mpr ⟨ by omega, by omega ⟩, dvd_rfl ⟩
      skip;
    refine' ⟨ m, hm₁, hm₂, fun i hi hi' hi'' => _ ⟩;
    obtain ⟨ a, ha ⟩ := hm₂; obtain ⟨ b, hb ⟩ := hi''; simp_all +decide [ Nat.prime_mul_iff ] ;
    rcases a with ( _ | _ | a ) <;> rcases b with ( _ | _ | b ) <;> norm_num at * <;> nlinarith only [ hm₁, hi, hp_gt, hp_le, Nat.div_add_mod ( n + k ) 2, Nat.mod_lt ( n + k ) two_pos ] ;
  -- Let m be that number. v_p(product) = v_p(m).
  obtain ⟨m, hm_mem, hm_div, hm_unique⟩ := hp_div
  have h_vp : Nat.factorization (∏ i ∈ Finset.Ioc n (n + k), i) p = Nat.factorization m p := by
    rw [ Finset.prod_eq_prod_diff_singleton_mul hm_mem ];
    rw [ Nat.factorization_mul ] <;> simp_all +decide [ Nat.factorization_eq_zero_iff, Finset.prod_eq_zero_iff ];
    · simp_all +decide [ Nat.Prime.dvd_iff_not_coprime hp_prime, Nat.coprime_prod_right_iff ];
    · linarith;
  -- Since m ≤ M < 2p, v_p(m) = 1.
  have h_vp_m : Nat.factorization m p = 1 := by
    have h_vp_m : m < 2 * p := by
      linarith [ Finset.mem_Ioc.mp hm_mem, Nat.div_add_mod ( n + k ) 2, Nat.mod_lt ( n + k ) two_pos ];
    obtain ⟨ q, rfl ⟩ := hm_div;
    rcases q with ( _ | _ | q ) <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, Nat.Prime.dvd_mul ];
    nlinarith only [ h_vp_m, hp_prime.two_le ];
  intro H; have := congr_arg ( fun z => z.factorization p ) H; norm_num at this; simp_all +decide [ Nat.factorization_pow ] ;