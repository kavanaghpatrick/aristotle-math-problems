/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e4503a3d-ff4c-440a-915e-77abbf2ee09c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalized the TWO_TWO_VW Phase 2 graph construction for Tuza's conjecture (ν=4 case). Defined the graph on Fin 14 with 4 M-triangles (A, B, C, D) and 4 external triangles (E1, E2, E3, E4). Proved that the pairs {A,B} and {C,D} are vertex-disjoint and that no inter-pair bridges exist. Constructed a cover of size 8 and verified that it hits all triangles, confirming τ ≤ 8 = 2ν. All properties were verified using native_decide.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

abbrev V := Fin 14

/-- Shared vertex for pair {A, B} -/
def v : V := 0

/-- Shared vertex for pair {C, D} -/
def w : V := 5

/-- Triangle A: first of pair 1, contains v -/
def A : Finset V := {0, 1, 2}

/-- Triangle B: second of pair 1, contains v -/
def B : Finset V := {0, 3, 4}

/-- Triangle C: first of pair 2, contains w -/
def C : Finset V := {5, 6, 7}

/-- Triangle D: second of pair 2, contains w -/
def D : Finset V := {5, 8, 9}

/-- The maximal packing M = {A, B, C, D} -/
def M : Finset (Finset V) := {A, B, C, D}

/-- Vertices of pair 1: {A, B} -/
def pair1_vertices : Finset V := {0, 1, 2, 3, 4}

/-- Vertices of pair 2: {C, D} -/
def pair2_vertices : Finset V := {5, 6, 7, 8, 9}

/-- External E1: shares base edge {1,2} with A -/
def E1 : Finset V := {1, 2, 10}

/-- External E2: shares base edge {3,4} with B -/
def E2 : Finset V := {3, 4, 11}

/-- External E3: shares base edge {6,7} with C -/
def E3 : Finset V := {6, 7, 12}

/-- External E4: shares base edge {8,9} with D -/
def E4 : Finset V := {8, 9, 13}

/-- All externals -/
def externals : Finset (Finset V) := {E1, E2, E3, E4}

/-- Adjacency: distinct vertices in same triangle (M or external) -/
def twoTwoAdj (x y : V) : Prop :=
  x ≠ y ∧ ((x ∈ A ∧ y ∈ A) ∨ (x ∈ B ∧ y ∈ B) ∨ (x ∈ C ∧ y ∈ C) ∨ (x ∈ D ∧ y ∈ D) ∨
           (x ∈ E1 ∧ y ∈ E1) ∨ (x ∈ E2 ∧ y ∈ E2) ∨ (x ∈ E3 ∧ y ∈ E3) ∨ (x ∈ E4 ∧ y ∈ E4))

instance : DecidableRel twoTwoAdj := fun x y => by
  unfold twoTwoAdj
  infer_instance

/-- The two_two_vw graph G with externals -/
def G : SimpleGraph V where
  Adj := twoTwoAdj
  symm := by intro x y ⟨hne, h⟩; exact ⟨hne.symm, by tauto⟩
  loopless := by intro x ⟨hne, _⟩; exact hne rfl

instance : DecidableRel G.Adj := inferInstanceAs (DecidableRel twoTwoAdj)

def isCliqueInG (s : Finset V) : Prop :=
  ∀ x ∈ s, ∀ y ∈ s, x ≠ y → G.Adj x y

instance (s : Finset V) : Decidable (isCliqueInG s) := by
  unfold isCliqueInG; infer_instance

def isTriangleInG (T : Finset V) : Prop :=
  T.card = 3 ∧ isCliqueInG T

instance (T : Finset V) : Decidable (isTriangleInG T) := by
  unfold isTriangleInG; infer_instance

def trianglesInG : Finset (Finset V) :=
  (Finset.univ : Finset V).powerset.filter isTriangleInG

-- ══════════════════════════════════════════════════════════════════════════════
-- SECTION 6: Scaffolding Lemmas (10+ helpers)
-- ══════════════════════════════════════════════════════════════════════════════

lemma A_card : A.card = 3 := by native_decide
lemma B_card : B.card = 3 := by native_decide
lemma C_card : C.card = 3 := by native_decide
lemma D_card : D.card = 3 := by native_decide
lemma M_card : M.card = 4 := by native_decide

lemma E1_card : E1.card = 3 := by native_decide
lemma E2_card : E2.card = 3 := by native_decide
lemma E3_card : E3.card = 3 := by native_decide
lemma E4_card : E4.card = 3 := by native_decide

/-- v is in A and B -/
lemma v_in_A : v ∈ A := by native_decide
lemma v_in_B : v ∈ B := by native_decide

/-- w is in C and D -/
lemma w_in_C : w ∈ C := by native_decide
lemma w_in_D : w ∈ D := by native_decide

/-- A and B share exactly v -/
lemma A_inter_B : (A ∩ B).card = 1 := by native_decide
lemma A_inter_B_eq : A ∩ B = {v} := by native_decide

/-- C and D share exactly w -/
lemma C_inter_D : (C ∩ D).card = 1 := by native_decide
lemma C_inter_D_eq : C ∩ D = {w} := by native_decide

/-- Pairs are vertex-disjoint (KEY PROPERTY!) -/
lemma A_inter_C : (A ∩ C).card = 0 := by native_decide
lemma A_inter_D : (A ∩ D).card = 0 := by native_decide
lemma B_inter_C : (B ∩ C).card = 0 := by native_decide
lemma B_inter_D : (B ∩ D).card = 0 := by native_decide

/-- Pair vertices are disjoint -/
lemma pairs_disjoint : (pair1_vertices ∩ pair2_vertices).card = 0 := by native_decide

/-- M is a valid packing -/
lemma M_packing : ∀ X ∈ M, ∀ Y ∈ M, X ≠ Y → (X ∩ Y).card ≤ 1 := by
  -- By examining each pair of triangles in M, we can verify that their intersection has at most one element.
  intros X hX Y hY hXY
  fin_cases hX <;> fin_cases hY <;> simp +decide [ * ] at hXY ⊢

/-- Externals share edges with M-elements -/
lemma E1_inter_A : (E1 ∩ A).card = 2 := by
  native_decide +revert
lemma E2_inter_B : (E2 ∩ B).card = 2 := by
  -- By definition of $E2$ and $B$, we know that $E2 ∩ B = {3, 4}$ because these are the only common elements.
  simp [E2, B]
lemma E3_inter_C : (E3 ∩ C).card = 2 := by
  -- By definition of $E3$ and $C$, we know that $E3 ∩ C = {6, 7}$.
  simp +decide [E3, C]
lemma E4_inter_D : (E4 ∩ D).card = 2 := by
  decide +kernel

/-- Externals share nothing with other M-elements -/
lemma E1_inter_B : (E1 ∩ B).card = 0 := by
  exact?
lemma E1_inter_C : (E1 ∩ C).card = 0 := by
  exact?
lemma E1_inter_D : (E1 ∩ D).card = 0 := by
  decide +kernel

lemma E2_inter_A : (E2 ∩ A).card = 0 := by
  -- By definition of $E2$, we know that $E2 = \{3, 4, 11\}$.
  simp [E2, A]
lemma E2_inter_C : (E2 ∩ C).card = 0 := by
  -- Since E2 and C are distinct triangles, their intersection is empty.
  simp [E2, C]
lemma E2_inter_D : (E2 ∩ D).card = 0 := by
  decide +revert

lemma E3_inter_A : (E3 ∩ A).card = 0 := by
  exact?
lemma E3_inter_B : (E3 ∩ B).card = 0 := by
  -- By definition of $E3$ and $B$, we can see that they have no common elements.
  simp [E3, B]
lemma E3_inter_D : (E3 ∩ D).card = 0 := by
  decide +revert

lemma E4_inter_A : (E4 ∩ A).card = 0 := by
  native_decide +revert
lemma E4_inter_B : (E4 ∩ B).card = 0 := by
  -- Since E4 and B have no common vertices, their intersection is empty.
  simp [E4, B]
lemma E4_inter_C : (E4 ∩ C).card = 0 := by
  -- To prove the intersection is empty, we can show that no vertex is in both E4 and C.
  simp [E4, C]

-- ══════════════════════════════════════════════════════════════════════════════
-- SECTION 7: Clique Verification
-- ══════════════════════════════════════════════════════════════════════════════

lemma A_is_clique : isCliqueInG A := by
  decide +kernel
lemma B_is_clique : isCliqueInG B := by
  decide +revert
lemma C_is_clique : isCliqueInG C := by
  native_decide +revert
lemma D_is_clique : isCliqueInG D := by
  decide +kernel
lemma E1_is_clique : isCliqueInG E1 := by
  decide +revert
lemma E2_is_clique : isCliqueInG E2 := by
  decide +revert
lemma E3_is_clique : isCliqueInG E3 := by
  -- By definition of E3, we know that every pair of distinct vertices in E3 is adjacent in G.
  unfold isCliqueInG
  simp [E3];
  -- By definition of $G$, we know that $6$, $7$, and $12$ are adjacent because they are part of the external triangle $E3$.
  simp [G, twoTwoAdj];
  -- By definition of $E3$, we know that $6$, $7$, and $12$ are connected in $G$ because they are part of the external triangle $E3$.
  simp [E3]
lemma E4_is_clique : isCliqueInG E4 := by
  native_decide +revert

lemma A_is_triangle : isTriangleInG A := by
  decide +revert
lemma B_is_triangle : isTriangleInG B := by
  decide +revert
lemma C_is_triangle : isTriangleInG C := by
  native_decide +revert
lemma D_is_triangle : isTriangleInG D := by
  decide +revert
lemma E1_is_triangle : isTriangleInG E1 := by
  decide +kernel
lemma E2_is_triangle : isTriangleInG E2 := by
  native_decide +revert
lemma E3_is_triangle : isTriangleInG E3 := by
  decide +kernel
lemma E4_is_triangle : isTriangleInG E4 := by
  native_decide +revert

/-- The triangles in G are exactly M ∪ externals -/
lemma triangles_eq : trianglesInG = M ∪ externals := by
  native_decide +revert

/-- The 8-edge cover:
    Pair 1 (A,B): spokes {0,1}, {0,3} + bases {1,2}, {3,4}
    Pair 2 (C,D): spokes {5,6}, {5,8} + bases {6,7}, {8,9}
-/
def cover : Finset (Finset V) :=
  { {0, 1},   -- spoke from v, hits A
    {0, 3},   -- spoke from v, hits B
    {1, 2},   -- base of A, hits E1
    {3, 4},   -- base of B, hits E2
    {5, 6},   -- spoke from w, hits C
    {5, 8},   -- spoke from w, hits D
    {6, 7},   -- base of C, hits E3
    {8, 9} }  -- base of D, hits E4

lemma cover_card : cover.card = 8 := by
  decide +kernel

lemma cover_all_edges : ∀ e ∈ cover, e.card = 2 := by
  -- By definition of `cover`, each edge in `cover` is of the form `{v}` for some `v` in `M`.
  simp [cover]

lemma edge_01_in_A : {(0 : V), 1} ⊆ A := by native_decide
lemma edge_03_in_B : {(0 : V), 3} ⊆ B := by native_decide
lemma edge_56_in_C : {(5 : V), 6} ⊆ C := by native_decide
lemma edge_58_in_D : {(5 : V), 8} ⊆ D := by native_decide

lemma edge_12_in_E1 : {(1 : V), 2} ⊆ E1 := by native_decide
lemma edge_34_in_E2 : {(3 : V), 4} ⊆ E2 := by native_decide
lemma edge_67_in_E3 : {(6 : V), 7} ⊆ E3 := by native_decide
lemma edge_89_in_E4 : {(8 : V), 9} ⊆ E4 := by native_decide

lemma cover_hits_A : ∃ e ∈ cover, e ⊆ A := ⟨{0, 1}, by native_decide, edge_01_in_A⟩
lemma cover_hits_B : ∃ e ∈ cover, e ⊆ B := ⟨{0, 3}, by native_decide, edge_03_in_B⟩
lemma cover_hits_C : ∃ e ∈ cover, e ⊆ C := ⟨{5, 6}, by native_decide, edge_56_in_C⟩
lemma cover_hits_D : ∃ e ∈ cover, e ⊆ D := ⟨{5, 8}, by native_decide, edge_58_in_D⟩

lemma cover_hits_E1 : ∃ e ∈ cover, e ⊆ E1 := ⟨{1, 2}, by native_decide, edge_12_in_E1⟩
lemma cover_hits_E2 : ∃ e ∈ cover, e ⊆ E2 := ⟨{3, 4}, by native_decide, edge_34_in_E2⟩
lemma cover_hits_E3 : ∃ e ∈ cover, e ⊆ E3 := ⟨{6, 7}, by native_decide, edge_67_in_E3⟩
lemma cover_hits_E4 : ∃ e ∈ cover, e ⊆ E4 := ⟨{8, 9}, by native_decide, edge_89_in_E4⟩

/-- Cover hits all triangles in G -/
theorem cover_hits_all_triangles : ∀ T ∈ trianglesInG, ∃ e ∈ cover, e ⊆ T := by
  native_decide +revert

/-- TWO_TWO_VW Phase 2: τ ≤ 8 = 2ν (Tuza's bound achieved) -/
theorem two_two_vw_phase2_tau_le_8 :
    ∃ E : Finset (Finset V),
      E.card ≤ 8 ∧
      (∀ e ∈ E, e.card = 2) ∧
      (∀ T ∈ trianglesInG, ∃ e ∈ E, e ⊆ T) := by
  use cover
  refine ⟨?_, cover_all_edges, cover_hits_all_triangles⟩
  simp only [cover_card, le_refl]

/-- The packing is valid (4 edge-disjoint triangles) -/
theorem packing_is_valid : M.card = 4 ∧ ∀ T ∈ M, isTriangleInG T := by
  -- We can verify that M has 4 elements and that each element is a triangle in G.
  apply And.intro;
  · -- By definition of $M$, we know that its cardinality is 4.
    apply M_card;
  · -- By definition of $M$, we know that every element in $M$ is a triangle in $G$.
    simp [M, A_is_triangle, B_is_triangle, C_is_triangle, D_is_triangle]

open Finset

/-- Key property: No inter-pair bridges exist -/
theorem no_inter_pair_bridges :
    ∀ T ∈ externals,
      -- T shares edge with at most one of {A,B}
      ((T ∩ A).card = 2 → (T ∩ B).card = 0) ∧
      ((T ∩ B).card = 2 → (T ∩ A).card = 0) ∧
      -- T shares edge with at most one of {C,D}
      ((T ∩ C).card = 2 → (T ∩ D).card = 0) ∧
      ((T ∩ D).card = 2 → (T ∩ C).card = 0) ∧
      -- T doesn't bridge across pairs
      ((T ∩ A).card = 2 ∨ (T ∩ B).card = 2 → (T ∩ C).card = 0 ∧ (T ∩ D).card = 0) ∧
      ((T ∩ C).card = 2 ∨ (T ∩ D).card = 2 → (T ∩ A).card = 0 ∧ (T ∩ B).card = 0) := by
        native_decide +revert

/-- Summary: Two_two_vw Phase 2 achieves τ ≤ 8 = 2ν -/
theorem two_two_vw_summary :
    M.card = 4 ∧
    trianglesInG.card = 8 ∧  -- 4 M-triangles + 4 externals
    cover.card = 8 ∧
    (∀ T ∈ trianglesInG, ∃ e ∈ cover, e ⊆ T) := by
  refine ⟨M_card, ?_, cover_card, cover_hits_all_triangles⟩
  rw [triangles_eq]
  native_decide