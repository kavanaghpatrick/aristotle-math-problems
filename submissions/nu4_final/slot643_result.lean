/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e1d9e3c7-bdfa-4126-bfbe-861f960b26ae

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Sierpinski conjecture states that for all n ≥ 2, 5/n = 1/x + 1/y + 1/z has a solution in positive integers.
-/
def SierpinskiSolvable (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
A number k has all prime factors congruent to 1 modulo 4 if for every prime factor p of k, p ≡ 1 (mod 4).
-/
def AllPrimeFactors1Mod4 (k : ℕ) : Prop :=
  ∀ p : ℕ, p.Prime → p ∣ k → p % 4 = 1

/-
If n is even and n ≥ 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_div_2 (n : ℕ) (h_ge : n ≥ 2) (h : 2 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use m, m, 2 * m
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

/-
If n is divisible by 3 and n ≥ 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_div_3 (n : ℕ) (h_ge : n ≥ 2) (h : 3 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use m, 2 * m, 6 * m
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

/-
If n is divisible by 5 and n ≥ 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_div_5 (n : ℕ) (h_ge : n ≥ 2) (h : 5 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use 2 * m, 3 * m, 6 * m
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

/-
If n = 5q + 4, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_4 (q : ℕ) : SierpinskiSolvable (5 * q + 4) := by
  -- We can choose $x = q + 2$, $y = (q + 1)(q + 2)$, and $z = (q + 1)(5q + 4)$.
  use q + 2, (q + 1) * (q + 2), (q + 1) * (5 * q + 4);
  exact ⟨ Nat.succ_pos _, Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ), Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ), by push_cast; rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> ring <;> positivity ⟩

/-
If n = 5q + 3, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_3 (q : ℕ) : SierpinskiSolvable (5 * q + 3) := by
  -- Let's choose $x = q + 1$, $y = (q + 1)(5q + 3)$, and $z = (q + 1)(5q + 3)$.
  use (q + 1), (q + 1) * (5 * q + 3), (q + 1) * (5 * q + 3);
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  grind

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  -- Set $x = q + 1$, $y = (q + 1)(5q + 2) / 2$, and $z = (q + 1)(5q + 2)$.
  use q + 1, (q + 1) * (5 * q + 2) / 2, (q + 1) * (5 * q + 2);
  rw [ Nat.cast_div ] <;> norm_num;
  · field_simp
    ring;
    exact ⟨ by nlinarith, trivial ⟩;
  · norm_num [ ← even_iff_two_dvd, mul_add, parity_simps ];
    exact Nat.even_or_odd q |> Or.symm

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_new (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  exact?

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v2 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  exact?

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v3 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  convert sierpinski_mod_5_2_v2 q using 1

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v4 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  exact?

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v5 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  convert sierpinski_mod_5_2_v4 q using 1

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v6 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  convert sierpinski_mod_5_2_v5 q using 1

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v7 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  convert sierpinski_mod_5_2_v5 q using 1

/-
If n = 5q + 2, then 5/n = 1/x + 1/y + 1/z has a solution.
-/
lemma sierpinski_mod_5_2_v8 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  exact?

/-
Algebraic identity for the n = 5q+2 case.
-/
lemma sierpinski_mod_5_2_identity (q : ℕ) :
  let n := 5 * q + 2
  let M := (q + 1) * n
  (5 : ℚ) / n = 1 / (q + 1) + 1 / (M / 2) + 1 / M := by
    -- Combine the fractions on the right-hand side.
    field_simp
    ring;
    norm_cast; ring;

/-
Definitions of the polynomials p1, p2, p3 used in the parametric cascade.
-/
def poly1 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y - 1) - y) - x
def poly2 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y - 1) - y) - y
def poly3 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y + 1) + y) - x

/-
Checking the identity for small values.
-/
def check_identity (x y z : ℕ) : Bool :=
  let n := (z : ℚ) * ((x : ℚ) * (5 * y - 1) - y) - x
  let rhs := 1 / ((x : ℚ) * y * z) + 1 / ((y : ℚ) * z * (5 * y - 1)) + 1 / ((x : ℚ) * z * ((x : ℚ) * (5 * y - 1) - y))
  n > 0 ∧ 5 / n == rhs

#eval check_identity 1 1 1
#eval check_identity 1 2 1
#eval check_identity 2 1 1
#eval check_identity 2 2 2

/-
Checking the 3-term identity for small values.
-/
def check_identity_3term (x y z : ℕ) : Bool :=
  let n := (z : ℚ) * ((x : ℚ) * (5 * y - 1) - y) - x
  let rhs := 1 / ((x : ℚ) * y * z) + 1 / ((y : ℚ) * z * (5 * y - 1)) + 1 / ((x : ℚ) * z * ((x : ℚ) * (5 * y - 1) - y))
  n > 0 ∧ 5 / n == rhs

#eval check_identity_3term 1 1 1
#eval check_identity_3term 1 2 1
#eval check_identity_3term 2 1 1
#eval check_identity_3term 2 2 2

/-
A 4-term decomposition identity for the polynomial p1.
-/
lemma poly1_identity_4term (x y z : ℕ) (h_pos : poly1 x y z > 0)
    (hx : x > 0) (hy : y > 0) (hz : z > 0) :
    let n := (poly1 x y z).natAbs
    (5 : ℚ) / n = 1 / (x * y * z) + 1 / (n * y) + 1 / (n * x) + 1 / (n * y * z) := by
      field_simp;
      norm_cast;
      rw [ ← Int.natCast_inj ] ; push_cast ; ring!;
      rw [ abs_of_pos h_pos ] ; unfold poly1 ; ring;