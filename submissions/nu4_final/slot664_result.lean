/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 037a37e2-aefb-495d-b145-c32879339791

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For any prime p, the sum of i^(p-1) for 0 < i < p is congruent to -1 modulo p.
-/
def Composite (n : ℕ) : Prop := 1 < n ∧ ¬ n.Prime

def AgohGiugaSum (n : ℕ) : Prop := (∑ i ∈ Finset.Ioo 0 n, i^(n-1)) ≡ n-1 [MOD n]

def IsCarmichael (n : ℕ) : Prop := Composite n ∧ ∀ a, n.Coprime a → a^(n-1) ≡ 1 [MOD n]

def IsWeakGiuga (n : ℕ) : Prop := Composite n ∧ (∑ i ∈ Finset.Ioo 0 n, i^(n.totient)) ≡ n-1 [MOD n]

def IsStrongGiuga (n : ℕ) : Prop := Composite n ∧ AgohGiugaSum n

theorem agoh_giuga_easy (p : ℕ) (hp : p.Prime) :
    p ∣ 1 + ∑ i ∈ Finset.Ioo 0 p, i^(p - 1) := by
      -- By Fermat's Little Theorem, we know that $i^{p-1} \equiv 1 \pmod{p}$ for all $1 \leq i \leq p-1$.
      have h_flt : ∀ i ∈ Finset.Ioo 0 p, i^(p-1) ≡ 1 [MOD p] := by
        haveI := Fact.mk hp ; simp +decide [ ← ZMod.natCast_eq_natCast_iff ];
        exact fun i hi₁ hi₂ => ZMod.pow_card_sub_one_eq_one ( by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt hi₁ hi₂ );
      simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
      norm_num [ Finset.sum_nat_mod, Finset.sum_congr rfl fun i hi => h_flt i ( Finset.mem_Ioo.mp hi |>.1 ) ( Finset.mem_Ioo.mp hi |>.2 ), Nat.add_mod, hp.pos ];
      rcases p with ( _ | _ | p ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ]

/-
The Agoh-Giuga conjecture condition: n * B_{n-1} + 1 is an integer divisible by n.
-/
def AgohGiugaCongr (n : ℕ) : Prop :=
  let val := (n : ℚ) * bernoulli (n-1) + 1
  val.den = 1 ∧ (val.num : ℤ) % n = 0

/-
For a prime p dividing n, the sum of i^phi(n) modulo p is congruent to n - n/p.
-/
lemma sum_pow_totient_mod_prime (n : ℕ) (p : ℕ) (hp : p.Prime) (h_dvd : p ∣ n) :
    ∑ i ∈ Finset.Ioo 0 n, i^(n.totient) ≡ (n - n / p) [MOD p] := by
      -- We split the sum into two parts: one over multiples of p and one over non-multiples of p.
      have h_split : (∑ i ∈ Finset.Ioo 0 n, i ^ (Nat.totient n)) ≡ (∑ i ∈ Finset.Icc 1 (n - 1), if p ∣ i then 0 else 1) [MOD p] := by
        -- By Fermat's Little Theorem, we know that $i^{\phi(n)} \equiv 1 \pmod p$ for any $i$ not divisible by $p$.
        have h_fermat : ∀ i ∈ Finset.Icc 1 (n - 1), p ∣ i → i ^ (Nat.totient n) ≡ 0 [MOD p] := by
          exact fun i hi hi' => Nat.modEq_zero_iff_dvd.mpr ( dvd_pow hi' ( Nat.ne_of_gt ( Nat.totient_pos.mpr ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ) );
        -- By Fermat's Little Theorem, we know that $i^{\phi(n)} \equiv 1 \pmod p$ for any $i$ not divisible by $p$. Hence, the sum modulo $p$ is the same as the sum of the indicator function for divisibility by $p$.
        have h_indicator : ∀ i ∈ Finset.Icc 1 (n - 1), i ^ Nat.totient n ≡ if p ∣ i then 0 else 1 [MOD p] := by
          intro i hi; split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          -- By Euler's theorem, since $p$ is prime and $i$ is not divisible by $p$, we have $i^{\phi(p)} \equiv 1 \pmod{p}$.
          have h_euler : (i : ZMod p) ^ Nat.totient p = 1 := by
            simpa [ ← ZMod.natCast_eq_natCast_iff ] using Nat.ModEq.pow_totient <| Nat.coprime_comm.mp <| hp.coprime_iff_not_dvd.mpr ‹_›;
          rw [ ← Nat.mul_div_cancel' ( Nat.totient_dvd_of_dvd h_dvd ), pow_mul, h_euler, one_pow ];
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        exact Finset.sum_congr rfl fun x hx => h_indicator x ( Finset.mem_Icc.mp hx |>.1 ) ( Finset.mem_Icc.mp hx |>.2 );
      -- The number of non-multiples of p in the range 0 to n-1 is (n-1) - (n/p - 1) = n - n/p.
      have h_count : (Finset.filter (fun i => ¬p ∣ i) (Finset.Icc 1 (n - 1))).card = n - n / p := by
        rw [ Finset.filter_not, Finset.card_sdiff ];
        -- The number of multiples of $p$ in the range $0$ to $n-1$ is $\frac{n}{p}$.
        have h_multiples : (Finset.filter (fun i => p ∣ i) (Finset.Icc 1 (n - 1))).card = n / p - 1 := by
          rw [ show { i ∈ Finset.Icc 1 ( n - 1 ) | p ∣ i } = Finset.image ( fun i => p * i ) ( Finset.Icc 1 ( ( n - 1 ) / p ) ) from ?_, Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ hp.ne_zero hxy ];
          · rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.succ_div ];
          · ext;
            simp +zetaDelta at *;
            exact ⟨ fun h => ⟨ ‹_› / p, ⟨ Nat.div_pos ( Nat.le_of_dvd ( by linarith ) h.2 ) hp.pos, Nat.div_le_div_right ( by linarith ) ⟩, Nat.mul_div_cancel' h.2 ⟩, by rintro ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ; exact ⟨ ⟨ by nlinarith [ hp.two_le ], by nlinarith [ Nat.div_mul_le_self ( n - 1 ) p ] ⟩, by simp +decide ⟩ ⟩;
        rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.succ_div ];
        rw [ ← h_multiples, Finset.inter_eq_left.mpr ( Finset.filter_subset _ _ ) ];
      simp_all +decide [ Finset.sum_ite ]

/-
A composite number n is a weak Giuga number if and only if for every prime factor p of n, p divides (n/p - 1).
-/
theorem isWeakGiuga_iff (n : ℕ) (hn : Composite n) :
    IsWeakGiuga n ↔ ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
      constructor;
      · intro h p hp
        have h_cong : (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ (n - n / p) [MOD p] := by
          convert sum_pow_totient_mod_prime n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) using 1
        have h_cong_mod : (n - 1) ≡ (n - n / p) [MOD p] := by
          have := h.2;
          exact this.symm.of_dvd ( Nat.dvd_of_mem_primeFactors hp ) |> Nat.ModEq.trans <| h_cong
        have h_div : p ∣ (n / p - 1) := by
          have h_div : p ∣ (n - 1) - (n - n / p) := by
            rw [ ← Nat.modEq_zero_iff_dvd ];
            cases le_total ( n - 1 ) ( n - n / p ) <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
          convert h_div using 1;
          rw [ tsub_right_comm, tsub_tsub_cancel_of_le ( Nat.div_le_self _ _ ) ]
        exact h_div;
      · -- Assume that for every prime factor p of n, p divides (n/p - 1).
        intro h
        have h_squarefree : Squarefree n := by
          refine' Nat.squarefree_iff_prime_squarefree.mpr _;
          intro p pp dp;
          have := h p ( Nat.mem_primeFactors.mpr ⟨ pp, Nat.dvd_trans ( dvd_mul_left _ _ ) dp, by linarith [ hn.1 ] ⟩ );
          have := Nat.dvd_sub' ( Nat.dvd_div_of_mul_dvd dp ) this;
          rw [ Nat.sub_sub_self ( Nat.div_pos ( Nat.le_of_dvd hn.1.le ( dvd_of_mul_left_dvd dp ) ) pp.pos ) ] at this ; aesop;
        -- Since $n$ is squarefree, it suffices to show the congruence modulo each prime factor $p$.
        have h_cong_prime : ∀ p ∈ n.primeFactors, ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ -1 [ZMOD p] := by
          -- By `sum_pow_totient_mod_prime`, the sum is $\equiv n - n/p \pmod p$.
          have h_sum_mod_prime : ∀ p ∈ n.primeFactors, ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ n - n / p [ZMOD p] := by
            intro p hp
            have h_sum_mod_prime_step : ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ n - n / p [ZMOD p] := by
              have h_cong_prime_step : ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ n - n / p [MOD p] := by
                convert sum_pow_totient_mod_prime n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) using 1;
              norm_cast;
              rw [ Int.subNatNat_of_le ( Nat.div_le_self _ _ ) ] ; exact Int.natCast_modEq_iff.mpr h_cong_prime_step;
            exact h_sum_mod_prime_step;
          intro p hp; specialize h_sum_mod_prime p hp; specialize h p hp; rcases k : n / p with ( _ | k ) <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          · exact absurd ( k.resolve_left hp.1.ne_zero ) ( not_lt_of_ge ( Nat.le_of_dvd hn.1.le hp.2.1 ) );
          · haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
            norm_cast at * ; aesop;
        -- Since $n$ is squarefree, it suffices to show the congruence modulo $n$.
        have h_cong_n : ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ -1 [ZMOD n] := by
          -- By the Chinese Remainder Theorem, since the congruences hold modulo each prime factor $p$ of $n$, they hold modulo $n$.
          have h_crt : ∀ ps : Finset ℕ, (∀ p ∈ ps, Nat.Prime p) → (∀ p ∈ ps, ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ -1 [ZMOD p]) → ∑ i ∈ Finset.Ico 1 n, i^(Nat.totient n) ≡ -1 [ZMOD (∏ p ∈ ps, p)] := by
            intros ps hps h_cong_prime_ps
            induction' ps using Finset.induction with p ps hps ih;
            · norm_num [ Int.ModEq ];
            · rw [ Finset.prod_insert ‹p ∉ ps› ];
              rw [ ← Int.modEq_and_modEq_iff_modEq_mul ];
              · exact ⟨ h_cong_prime_ps p ( Finset.mem_insert_self _ _ ), ih ( fun q hq => hps q ( Finset.mem_insert_of_mem hq ) ) ( fun q hq => h_cong_prime_ps q ( Finset.mem_insert_of_mem hq ) ) ⟩;
              · norm_cast;
                rw [ Int.natAbs_eq_iff.mpr ];
                any_goals exact ∏ x ∈ ps, x;
                · exact Nat.Coprime.prod_right fun q hq => by have := Nat.coprime_primes ( hps p ( Finset.mem_insert_self p ps ) ) ( hps q ( Finset.mem_insert_of_mem hq ) ) ; aesop;
                · exact Or.inl <| by push_cast; rfl;
          convert h_crt n.primeFactors ( fun p hp => Nat.prime_of_mem_primeFactors hp ) h_cong_prime;
          rw [ ← Nat.cast_prod, Nat.prod_primeFactors_of_squarefree h_squarefree ];
        refine' ⟨ hn, _ ⟩;
        simp_all +decide [ ← Int.natCast_modEq_iff ];
        rw [ Nat.cast_pred hn.1.le ];
        simpa [ ← ZMod.intCast_eq_intCast_iff ] using h_cong_n

/-
If n is a strong Giuga number and p is a prime factor of n, then p-1 divides n-1.
-/
lemma strong_giuga_implies_carmichael_condition (n : ℕ) (hn : IsStrongGiuga n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p - 1 ∣ n - 1 := by
      -- Assume $p-1 \nmid n-1$. Then there exists a primitive root $g$ modulo $p$ such that $g^{n-1} \not\equiv 1 \pmod p$.
      by_contra h_not_div
      obtain ⟨g, hg⟩ : ∃ g, Nat.gcd g p = 1 ∧ ¬(g^(n-1) ≡ 1 [MOD p]) := by
        -- By definition of primitive roots, such a $g$ exists.
        obtain ⟨g, hg⟩ : ∃ g, Nat.gcd g p = 1 ∧ orderOf (g : ZMod p) = p - 1 := by
          have := Fact.mk ( Nat.prime_of_mem_primeFactors hp );
          obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := ( ZMod p )ˣ );
          refine' ⟨ g.val.val, _, _ ⟩;
          · exact Nat.coprime_comm.mp ( this.1.coprime_iff_not_dvd.mpr <| by rw [ ← ZMod.natCast_eq_zero_iff ] ; aesop );
          · simp +decide [ orderOf_units, orderOf_eq_card_of_forall_mem_zpowers hg, Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ];
        refine' ⟨ g, hg.1, _ ⟩ ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ; intro h; have := orderOf_dvd_iff_pow_eq_one.mpr h; aesop;
      -- The sum $\sum_{x=1}^{p-1} x^{n-1} \pmod p$ is then 0.
      have h_sum_zero : ∑ x ∈ Finset.range p, x^(n-1) ≡ 0 [MOD p] := by
        -- By multiplying each term in the sum by $g^{n-1}$, we obtain the same sum modulo $p$.
        have h_mul_g : ∑ x ∈ Finset.range p, (g * x)^(n-1) ≡ ∑ x ∈ Finset.range p, x^(n-1) [MOD p] := by
          have h_mul_g : Finset.image (fun x => g * x % p) (Finset.range p) = Finset.range p := by
            refine Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => Finset.mem_range.mpr <| Nat.mod_lt _ <| Nat.pos_of_mem_primeFactors hp ) ?_;
            rw [ Finset.card_image_of_injOn ];
            intros x hx y hy hxy; haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hp ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ] ;
            exact Nat.mod_eq_of_lt hx ▸ Nat.mod_eq_of_lt hy ▸ by simpa [ ← ZMod.natCast_eq_natCast_iff' ] using hxy.resolve_right ( by rw [ ZMod.natCast_eq_zero_iff ] ; exact fun h => by have := Nat.gcd_eq_right h; aesop ) ;
          have h_mul_g : ∑ x ∈ Finset.range p, (g * x)^(n-1) ≡ ∑ x ∈ Finset.image (fun x => g * x % p) (Finset.range p), x^(n-1) [MOD p] := by
            rw [ Finset.sum_image ];
            · simp +decide [ ← ZMod.natCast_eq_natCast_iff ];
            · exact?;
          aesop;
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, mul_pow, Finset.mul_sum _ _ _ ];
        rw [ ← Finset.mul_sum _ _ _ ] at h_mul_g;
        by_cases h : ∑ x ∈ Finset.range p, ( x : ZMod p ) ^ ( n - 1 ) = 0 <;> simp_all +decide;
        haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
      -- Since $p \mid n$, the sum $\sum_{i=1}^{n-1} i^{n-1} \pmod p$ splits into $n/p$ blocks of length $p$.
      have h_sum_blocks : ∑ i ∈ Finset.Ico 1 n, i^(n-1) ≡ (n / p) * ∑ x ∈ Finset.range p, x^(n-1) [MOD p] := by
        have h_sum_blocks : ∑ i ∈ Finset.range n, i^(n-1) ≡ (n / p) * ∑ x ∈ Finset.range p, x^(n-1) [MOD p] := by
          -- We can split the sum $\sum_{i=0}^{n-1} i^{n-1}$ into $n/p$ blocks of length $p$.
          have h_split_sum : ∑ i ∈ Finset.range (p * (n / p)), i^(n-1) ≡ (n / p) * ∑ x ∈ Finset.range p, x^(n-1) [MOD p] := by
            induction' n / p with k hk;
            · norm_num;
              rfl;
            · simp_all +decide [ Nat.mul_succ, ← ZMod.natCast_eq_natCast_iff, Finset.sum_range_add ];
          rwa [ Nat.mul_div_cancel' ( Nat.dvd_of_mem_primeFactors hp ) ] at h_split_sum;
        rcases n <;> simp_all +decide [ Finset.sum_range_succ', Nat.ModEq ];
        rw [ Finset.sum_Ico_eq_sum_range ] ; cases ‹ℕ› <;> simp_all +decide [ add_comm, Finset.sum_range_succ' ];
      -- But IsStrongGiuga n implies the sum is $-1 \pmod n$, so $-1 \pmod p$.
      have h_sum_neg_one : ∑ i ∈ Finset.Ico 1 n, i^(n-1) ≡ n - 1 [MOD p] := by
        have := hn.2;
        exact this.of_dvd <| Nat.dvd_of_mem_primeFactors hp;
      simp_all +decide [ Nat.ModEq ];
      rcases hp.2.1 with ⟨ q, rfl ⟩ ; simp_all +decide [ Nat.mul_mod ];
      rcases p with ( _ | _ | p ) <;> rcases q with ( _ | _ | q ) <;> norm_num [ Nat.add_mod, Nat.mul_succ ] at *;
      norm_num [ Nat.mod_one ] at *

/-
If n is a strong Giuga number and p is a prime factor of n, then p divides n/p - 1.
-/
lemma strong_giuga_implies_weak_giuga_condition (n : ℕ) (hn : IsStrongGiuga n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p ∣ (n / p - 1) := by
      -- By definition of strong Giuga numbers, we know that $p \mid n$ and $p - 1 \mid n - 1$.
      have h_div_p : p ∣ n := by
        exact Nat.dvd_of_mem_primeFactors hp
      have h_div_p_minus_one : p - 1 ∣ n - 1 := by
        exact?;
      obtain ⟨ k, hk ⟩ := h_div_p; simp_all +decide [ Nat.pow_succ', Nat.mul_assoc ] ;
      have h_sum : ∑ i ∈ Finset.Ico 1 (p * k), i^(p * k - 1) ≡ (p * k - k) [MOD p] := by
        have h_sum : ∑ i ∈ Finset.Ico 1 (p * k), i^(p * k - 1) ≡ ∑ i ∈ Finset.Ico 1 (p * k), if p ∣ i then 0 else 1 [MOD p] := by
          have h_sum : ∀ i ∈ Finset.Ico 1 (p * k), i^(p * k - 1) ≡ if p ∣ i then 0 else 1 [MOD p] := by
            intro i hi; split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
            · cases p <;> cases k <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
              rw [ zero_pow ( Nat.sub_ne_zero_of_lt ( by nlinarith ) ) ];
            · -- Since $p$ is prime and $i$ is not divisible by $p$, we have $i^{p-1} \equiv 1 \pmod{p}$ by Fermat's Little Theorem.
              have h_fermat : i^(p - 1) ≡ 1 [MOD p] := by
                exact Nat.totient_prime hp.1 ▸ Nat.ModEq.pow_totient ( Nat.coprime_comm.mp <| hp.1.coprime_iff_not_dvd.mpr ‹_› );
              obtain ⟨ m, hm ⟩ := h_div_p_minus_one; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_mul ] ;
          simp_all +decide only [← ZMod.natCast_eq_natCast_iff, Nat.cast_sum];
        simp_all +decide [ Finset.sum_ite ];
        convert h_sum using 2;
        rw [ show Finset.filter ( fun x => ¬p ∣ x ) ( Finset.Ico 1 ( p * k ) ) = Finset.Ico 1 ( p * k ) \ Finset.image ( fun x => p * x ) ( Finset.Ico 1 k ) from ?_, Finset.card_sdiff ] <;> norm_num [ Finset.card_image_of_injective, Function.Injective, hp.1.ne_zero ];
        · rw [ show Finset.image ( fun x => p * x ) ( Finset.Ico 1 k ) ∩ Finset.Ico 1 ( p * k ) = Finset.image ( fun x => p * x ) ( Finset.Ico 1 k ) from Finset.inter_eq_left.mpr <| Finset.image_subset_iff.mpr fun x hx => Finset.mem_Ico.mpr ⟨ by nlinarith [ Finset.mem_Ico.mp hx, hp.1.two_le ], by nlinarith [ Finset.mem_Ico.mp hx, hp.1.two_le ] ⟩ ] ; rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ hp.1.ne_zero hxy ] ; simp +decide [ Nat.sub_sub ] ;
          rw [ Nat.add_sub_cancel' ( Nat.one_le_iff_ne_zero.mpr hp.2.2 ) ];
        · ext; simp [Finset.mem_sdiff, Finset.mem_image];
          exact fun _ _ => ⟨ fun h x hx₁ hx₂ hx₃ => h <| hx₃ ▸ dvd_mul_right _ _, fun h => fun ⟨ x, hx ⟩ => h x ( by nlinarith [ hp.1.two_le ] ) ( by nlinarith [ hp.1.two_le ] ) <| by linarith ⟩;
      have h_cong : (p * k - k) ≡ (p * k - 1) [MOD p] := by
        have h_cong : (∑ i ∈ Finset.Ico 1 (p * k), i^(p * k - 1)) ≡ (p * k - 1) [MOD p] := by
          convert hn.2.of_dvd ( dvd_mul_right p k ) using 1;
        exact h_sum.symm.trans h_cong;
      haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      cases k <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
      simp_all +decide [ Nat.cast_sub ( show 1 ≤ p * ( _ + 1 ) from Nat.mul_pos hp.1.pos ( Nat.succ_pos _ ) ), Nat.cast_sub ( show ( _ + 1 ) ≤ p * ( _ + 1 ) from Nat.le_mul_of_pos_left _ hp.1.pos ) ]

/-
Every strong Giuga number is squarefree.
-/
lemma strong_giuga_implies_squarefree (n : ℕ) (hn : IsStrongGiuga n) : Squarefree n := by
  -- Suppose $n$ is not squarefree. Then there exists a prime $p$ such that $p^2 \mid n$.
  by_contra h_not_squarefree
  obtain ⟨p, hp_prime, hp_sq⟩ : ∃ p, Nat.Prime p ∧ p^2 ∣ n := by
    simpa only [ sq ] using by rw [ Nat.squarefree_iff_prime_squarefree ] at h_not_squarefree; aesop;
  -- Since $p$ divides $n/p - 1$, we have $n/p \equiv 1 \pmod{p}$.
  have h_cong : n / p ≡ 1 [MOD p] := by
    have h_div : p ∣ n / p - 1 := by
      apply strong_giuga_implies_weak_giuga_condition n hn p (by
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.primeFactors_pow ];
      · cases hn.1.1;
      · exact dvd_of_mul_left_dvd hp_sq);
    refine Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
    simpa [ Nat.cast_sub ( show 1 ≤ n / p from Nat.div_pos ( Nat.le_of_dvd hn.1.1.le ( dvd_of_mul_left_dvd hp_sq ) ) hp_prime.pos ) ] using Int.natCast_dvd_natCast.mpr h_div;
  obtain ⟨ k, hk ⟩ := hp_sq; simp_all +decide [ Nat.ModEq, Nat.pow_succ', Nat.mul_mod_mul_left ] ;
  rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.mul_assoc, Nat.mul_div_assoc ]

/-
If n is a squarefree Carmichael number and p is a prime factor of n, then p-1 divides n-1.
-/
lemma carmichael_squarefree_implies_local (n : ℕ) (hc : IsCarmichael n) (hsq : Squarefree n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p - 1 ∣ n - 1 := by
      -- Let $g$ be a primitive root modulo $p$.
      obtain ⟨g, hg⟩ : ∃ g, Nat.gcd g p = 1 ∧ orderOf (g : ZMod p) = p - 1 := by
        haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hp );
        obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := ( ZMod p )ˣ );
        refine' ⟨ g.val.val, _, _ ⟩;
        · exact Nat.coprime_comm.mp ( this.1.coprime_iff_not_dvd.mpr <| by rw [ ← ZMod.natCast_eq_zero_iff ] ; aesop );
        · simp +decide [ orderOf_units, orderOf_eq_card_of_forall_mem_zpowers hg, Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ];
      rw [ ← hg.2, orderOf_dvd_iff_pow_eq_one ];
      -- By the Chinese Remainder Theorem, there exists an integer $a$ such that $a \equiv g \pmod{p}$ and $a \equiv 1 \pmod{q}$ for all prime factors $q$ of $n$ with $q \neq p$.
      obtain ⟨a, ha⟩ : ∃ a, a ≡ g [MOD p] ∧ ∀ q ∈ n.primeFactors, q ≠ p → a ≡ 1 [MOD q] := by
        -- By the Chinese Remainder Theorem, such an $a$ exists because $p$ and the other prime factors of $n$ are pairwise coprime.
        have h_crt : Nat.gcd p (∏ q ∈ n.primeFactors \ {p}, q) = 1 := by
          exact Nat.Coprime.prod_right fun q hq => Nat.coprime_iff_gcd_eq_one.mp <| by have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ; aesop;
        have := Nat.chineseRemainder h_crt;
        obtain ⟨ a, ha₁, ha₂ ⟩ := this g 1;
        exact ⟨ a, ha₁, fun q hq hqp => ha₂.of_dvd <| Finset.dvd_prod_of_mem _ <| by aesop ⟩;
      -- Since $a$ is coprime to $n$, by the Carmichael property, $a^{n-1} \equiv 1 \pmod{n}$.
      have ha_carmichael : a ^ (n - 1) ≡ 1 [MOD n] := by
        have ha_coprime : Nat.Coprime a n := by
          refine' Nat.coprime_of_dvd' _;
          intro q hq hqa hqn; by_cases hqp : q = p <;> simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ] ;
          have := Nat.dvd_gcd ( Nat.dvd_of_mod_eq_zero hqa ) ( Nat.dvd_refl p ) ; aesop;
        generalize_proofs at *; (
        exact hc.2 a ha_coprime.symm);
      have := ha_carmichael.of_dvd ( Nat.dvd_of_mem_primeFactors hp ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;

/-
Every weak Giuga number is squarefree.
-/
lemma weak_giuga_implies_squarefree (n : ℕ) (hn : Composite n) (h : IsWeakGiuga n) : Squarefree n := by
  -- By `isWeakGiuga_iff`, we have $\forall p \in \text{primeFactors}(n), p \mid (n/p - 1)$.
  have h_div : ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
    exact isWeakGiuga_iff n hn |>.1 h;
  refine' Nat.squarefree_iff_prime_squarefree.mpr _;
  intro p pp dp;
  have := h_div p ?_ <;> simp_all +decide [ Nat.squarefree_iff_prime_squarefree ];
  · have := Nat.dvd_sub' ( Nat.dvd_div_of_mul_dvd dp ) this;
    rw [ Nat.sub_sub_self ( Nat.div_pos ( Nat.le_of_dvd hn.1.le ( dvd_of_mul_left_dvd dp ) ) pp.pos ) ] at this ; aesop;
  · exact ⟨ dvd_of_mul_left_dvd dp, hn.1.ne_bot ⟩

/-
If n is composite, p is a prime factor of n such that p-1 divides n-1 and p divides n/p - 1, then the sum of i^(n-1) modulo p is -1.
-/
lemma strong_giuga_local_condition (n p : ℕ) (hn : Composite n) (hp : p.Prime) (h_div_n : p ∣ n) (h_carmichael : p - 1 ∣ n - 1) (h_weak : p ∣ n / p - 1) :
    ∑ i ∈ Finset.Ioo 0 n, (i : ZMod p)^(n-1) = -1 := by
      -- Write the sum as $\sum_{i=1}^{p-1} i^{n-1} k$ where $k = n/p$.
      obtain ⟨k, rfl⟩ : ∃ k, n = p * k := h_div_n
      have h_sum_mod_p : ∑ i ∈ Finset.Ioo 0 (p * k), (i : ℕ) ^ (p * k - 1) ≡ ∑ i ∈ Finset.Ioo 0 (p * k), if p ∣ i then 0 else 1 [MOD p] := by
        have h_sum_mod_p : ∀ i ∈ Finset.Ioo 0 (p * k), i ^ (p * k - 1) ≡ if p ∣ i then 0 else 1 [MOD p] := by
          intro i hi; split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          · cases p <;> cases k <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
            rw [ zero_pow ( Nat.sub_ne_zero_of_lt ( by nlinarith [ hp.two_le ] ) ) ];
          · haveI := Fact.mk hp; rw [ ← Nat.mul_div_cancel' h_carmichael ] ; simp +decide [ pow_mul, ZMod.pow_card_sub_one_eq_one ( show ( i : ZMod p ) ≠ 0 from by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; aesop ) ] ;
        simp_all +decide only [← ZMod.natCast_eq_natCast_iff, Nat.cast_sum];
      -- The number of terms in $\{1, \dots, p*k-1\}$ not divisible by $p$ is $(p*k-1) - (k-1) = p*k - k = k*(p-1)$.
      have h_count_not_div_p : ∑ i ∈ Finset.Ioo 0 (p * k), (if p ∣ i then 0 else 1) = k * (p - 1) := by
        have h_count_not_div_p : ∑ i ∈ Finset.Ioo 0 (p * k), (if p ∣ i then 0 else 1) = ∑ i ∈ Finset.Ico 1 (p * k), (if p ∣ i then 0 else 1) := by
          rfl;
        have h_count_not_div_p : Finset.filter (fun i => ¬p ∣ i) (Finset.Ico 1 (p * k)) = Finset.Ico 1 (p * k) \ Finset.image (fun i => p * i) (Finset.Ico 1 k) := by
          ext; simp [Finset.mem_sdiff, Finset.mem_image];
          exact fun _ _ => ⟨ fun h x hx₁ hx₂ => fun hx₃ => h <| hx₃ ▸ dvd_mul_right _ _, fun h => fun ⟨ x, hx ⟩ => h x ( Nat.pos_of_ne_zero <| by aesop ) ( by nlinarith [ hp.two_le ] ) <| by linarith ⟩;
        have h_count_not_div_p : Finset.card (Finset.filter (fun i => ¬p ∣ i) (Finset.Ico 1 (p * k))) = (p * k - 1) - (k - 1) := by
          rw [ h_count_not_div_p, Finset.card_sdiff ] ; norm_num [ Finset.card_image_of_injective, Function.Injective, hp.ne_zero ];
          rw [ show Finset.image ( fun i => p * i ) ( Finset.Ico 1 k ) ∩ Finset.Ico 1 ( p * k ) = Finset.image ( fun i => p * i ) ( Finset.Ico 1 k ) from Finset.inter_eq_left.mpr <| Finset.image_subset_iff.mpr fun i hi => Finset.mem_Ico.mpr ⟨ by nlinarith [ Finset.mem_Ico.mp hi, hp.two_le ], by nlinarith [ Finset.mem_Ico.mp hi, hp.two_le ] ⟩ ] ; rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ hp.ne_zero hxy ] ; aesop;
        rcases p with ( _ | _ | p ) <;> rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.mul_succ, Finset.sum_ite ];
        exact Nat.sub_eq_of_eq_add <| by ring;
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub hp.pos ];
      rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.mul_succ ];
      cases k <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      cases hn.1

/-
If n is both a Carmichael number and a weak Giuga number, then it is a strong Giuga number.
-/
lemma strong_giuga_of_carmichael_weak (n : ℕ) (hn : Composite n) (hc : IsCarmichael n) (hw : IsWeakGiuga n) : IsStrongGiuga n := by
  -- By definition of strong Giuga, we need to show that for every prime factor p of n, n is congruent to -1 modulo p.
  have h_strong : ∀ p ∈ n.primeFactors, (∑ i ∈ Finset.Ioo 0 n, (i : ZMod p)^(n-1)) = -1 := by
    intro p hp
    apply strong_giuga_local_condition n p hn (Nat.prime_of_mem_primeFactors hp) (Nat.dvd_of_mem_primeFactors hp) (carmichael_squarefree_implies_local n hc (weak_giuga_implies_squarefree n hn hw) p hp) (isWeakGiuga_iff n hn |>.1 hw p hp);
  -- By the Chinese Remainder Theorem, since the congruence holds modulo each prime factor of n, it holds modulo n.
  have h_crt : (∑ i ∈ Finset.Ioo 0 n, (i : ℤ)^(n-1)) ≡ -1 [ZMOD n] := by
    have h_crt : (∏ p ∈ n.primeFactors, p : ℤ) ∣ (∑ i ∈ Finset.Ioo 0 n, (i : ℤ)^(n-1) + 1) := by
      refine' Finset.prod_dvd_of_coprime _ _;
      · intro p hp q hq hpq; have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors hq ) ; aesop;
      · intro p hp; specialize h_strong p hp; erw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
    have h_crt : (∏ p ∈ n.primeFactors, p : ℤ) = n := by
      rw [ ← Nat.cast_prod, Nat.prod_primeFactors_of_squarefree ];
      exact?;
    exact Eq.symm <| Int.modEq_of_dvd <| by aesop;
  refine' ⟨ hn, _ ⟩;
  convert h_crt using 1;
  norm_num [ ← Int.natCast_modEq_iff, AgohGiugaSum ];
  rw [ Nat.cast_pred ( Nat.one_le_iff_ne_zero.mpr hn.1.ne_bot ) ] ; norm_num [ Int.ModEq ] ;

/-
If n is squarefree and a is congruent to b modulo every prime factor of n, then a is congruent to b modulo n.
-/
lemma zmod_congr_of_squarefree_prime_factors (n : ℕ) (hn : Squarefree n) (a b : ℤ) (h : ∀ p ∈ n.primeFactors, a ≡ b [ZMOD p]) :
    a ≡ b [ZMOD n] := by
      rw [ ← Nat.factorization_prod_pow_eq_self ( by aesop_cat : n ≠ 0 ) ];
      simp_all +decide [ Int.modEq_iff_dvd, Finsupp.prod ];
      rw [ Finset.prod_congr rfl fun p hp => by rw [ Nat.factorization_eq_one_of_squarefree ( hn ) ( by aesop ) ( by aesop ) ] ] ; simpa using Finset.prod_dvd_of_coprime ( fun p hp q hq hpq => by have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors hq ) ; aesop ) fun p hp => h p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) ( by aesop ) ;

/-
A composite number is a strong Giuga number if and only if it is both a Carmichael number and a weak Giuga number.
-/
theorem isStrongGiuga_iff (n : ℕ) (hn : Composite n) :
    IsStrongGiuga n ↔ IsCarmichael n ∧ IsWeakGiuga n := by
      refine' ⟨ fun h => _, fun h => _ ⟩;
      · have h_weak_giuga : IsWeakGiuga n := by
          convert isWeakGiuga_iff n hn |>.2 _;
          exact?
        have h_carmichael : IsCarmichael n := by
          -- Since n is squarefree, it suffices to show that for each prime factor p of n, a^(n-1) ≡ 1 (mod p).
          have h_carmichael_mod_p : ∀ p ∈ n.primeFactors, ∀ a, Nat.Coprime a n → a^(n-1) ≡ 1 [MOD p] := by
            -- By Fermat's Little Theorem, we know that $a^{p-1} \equiv 1 \pmod{p}$ for any integer $a$ coprime to $p$.
            intros p hp a ha_coprime
            have h_fermat : a^(p - 1) ≡ 1 [MOD p] := by
              exact Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ▸ Nat.ModEq.pow_totient ( Nat.Coprime.coprime_dvd_right ( Nat.dvd_of_mem_primeFactors hp ) ha_coprime );
            -- Since $p-1$ divides $n-1$, we can write $n-1 = k(p-1)$ for some integer $k$.
            obtain ⟨k, hk⟩ : ∃ k, n - 1 = k * (p - 1) := by
              exact exists_eq_mul_left_of_dvd ( strong_giuga_implies_carmichael_condition n h p hp );
            simpa [ hk, pow_mul' ] using h_fermat.pow k;
          refine' ⟨ hn, _ ⟩;
          intro a ha_coprime
          have h_carmichael_mod_n : a^(n-1) ≡ 1 [ZMOD n] := by
            have h_carmichael_mod_n : ∀ p ∈ n.primeFactors, a^(n-1) ≡ 1 [ZMOD p] := by
              exact fun p hp => by simpa [ ← Int.natCast_modEq_iff ] using h_carmichael_mod_p p hp a ha_coprime.symm;
            convert zmod_congr_of_squarefree_prime_factors n _ _ _ _;
            · exact?;
            · assumption;
          simpa [ ← Int.natCast_modEq_iff ] using h_carmichael_mod_n
        exact ⟨h_carmichael, h_weak_giuga⟩;
      · apply strong_giuga_of_carmichael_weak n hn h.1 h.2

/-
The difference between the sum of powers and n * B_{n-1} is equal to a sum of terms involving lower Bernoulli numbers.
-/
lemma sum_pow_sub_bernoulli_correct (n : ℕ) (hn : 2 ≤ n) :
    (∑ i ∈ Finset.range n, (i : ℚ)^(n-1)) - n * bernoulli (n-1) = ∑ k ∈ Finset.range (n-1), (n.choose k : ℚ) * bernoulli k * n^(n-1-k) := by
      -- We start with the identity $(p+1) \sum_{i=0}^{n-1} i^p = \sum_{k=0}^p \binom{p+1}{k} B_k n^{p+1-k}$.
      have h_identity : ∀ p : ℕ, p ≥ 1 → (p + 1) * ∑ i ∈ Finset.range n, (i : ℚ) ^ p = ∑ k ∈ Finset.range (p + 1), Nat.choose (p + 1) k * bernoulli k * (n : ℚ) ^ (p + 1 - k) := by
        intro p hp; have := @sum_range_pow ( n : ℕ ) p; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ; (
        rw [ Finset.mul_sum _ _ _, Finset.sum_congr rfl fun _ _ => mul_div_cancel₀ _ <| by positivity ]);
      specialize h_identity ( n - 1 ) ( Nat.sub_pos_of_lt hn ) ; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Finset.sum_range_succ ] ;
      simp_all +decide [ Nat.succ_sub, pow_succ, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ];
      rw [ show ( ∑ x ∈ Finset.range n, bernoulli x * ( Nat.choose ( n + 1 + 1 ) x * ( n + 1 + 1 : ℚ ) ^ ( n + 1 + 1 - x ) ) ) = ( ∑ x ∈ Finset.range n, bernoulli x * ( Nat.choose ( n + 1 + 1 ) x * ( n + 1 + 1 : ℚ ) ^ ( n + 1 - x ) ) ) * ( n + 1 + 1 ) from ?_ ] at h_identity;
      · nlinarith;
      · rw [ Finset.sum_mul _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ show n + 1 + 1 - x = n + 1 - x + 1 by rw [ tsub_add_eq_add_tsub ( by linarith [ Finset.mem_range.mp hx ] ) ] ] ; ring;

/-
For even n >= 4, the Agoh-Giuga congruence condition is false.
-/
lemma agoh_giuga_congr_false_of_even (n : ℕ) (h : Even n) (hn : 4 ≤ n) : ¬ AgohGiugaCongr n := by
  -- By `bernoulli_odd_eq_zero`, $B_{n-1} = 0$.
  have h_bernoulli : bernoulli (n-1) = 0 := by
    rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide [ bernoulli_eq_bernoulli'_of_ne_one ];
    rw [ bernoulli'_odd_eq_zero ] ; simp_all +arith +decide [ parity_simps ];
    linarith;
  unfold AgohGiugaCongr;
  norm_num [ h_bernoulli ];
  exact_mod_cast Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by linarith )

/-
For even n >= 4, the Agoh-Giuga sum condition is false.
-/
lemma agoh_giuga_sum_false_of_even (n : ℕ) (h : Even n) (hn : 4 ≤ n) : ¬ AgohGiugaSum n := by
  -- Since $n$ is even and $n \geq 4$, we know that $n$ is not a strong Giuga number.
  have hn_not_strong_giuga : ¬IsStrongGiuga n := by
    have h_not_carmichael : ¬IsCarmichael n := by
      rintro ⟨ hn₁, hn₂ ⟩;
      -- Let's choose $a = n - 1$. Since $n$ is even and $n \geq 4$, $n - 1$ is odd and coprime to $n$.
      have h_a : (n - 1) ^ (n - 1) ≡ 1 [MOD n] := by
        exact hn₂ _ ( by simp +decide [ Nat.one_le_iff_ne_zero, show n ≠ 0 by linarith ] );
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      erw [ show ( n : ZMod ( n + 1 + 1 ) ) = -2 by { exact eq_neg_of_add_eq_zero_left <| by norm_cast; simp +decide [ add_assoc ] } ] at h_a ; ring_nf at h_a;
      simp_all +decide [ parity_simps ];
      rw [ neg_eq_iff_add_eq_zero ] at h_a;
      rcases n with ( _ | _ | _ | n ) <;> cases h_a ; contradiction;
    rw [ isStrongGiuga_iff ];
    · aesop;
    · exact ⟨ by linarith, by rintro H; exact absurd ( H.eq_two_or_odd'.resolve_left ( by linarith ) ) ( by simpa using h ) ⟩;
  contrapose! hn_not_strong_giuga;
  refine' ⟨ _, hn_not_strong_giuga ⟩;
  exact ⟨ by linarith, by rintro H; exact absurd ( H.eq_two_or_odd'.resolve_left ( by linarith ) ) ( by simpa using h ) ⟩

/-
Definitions for rational congruence modulo n and the Agoh-Giuga conjecture formulation using rational numbers.
-/
def Rat.CoprimeDenom (n : ℕ) (q : ℚ) : Prop := q.den.Coprime n

def Rat.IsIntMod (n : ℕ) (q : ℚ) : Prop := Rat.CoprimeDenom n q ∧ (q.num : ℤ) % n = 0

def AgohGiugaCongrRat (n : ℕ) : Prop := Rat.IsIntMod n ((n : ℚ) * bernoulli (n-1) + 1)

/-
For even n >= 4, the rational Agoh-Giuga congruence condition is false.
-/
lemma agoh_giuga_congr_rat_false_of_even (n : ℕ) (h : Even n) (hn : 4 ≤ n) : ¬ AgohGiugaCongrRat n := by
  obtain ⟨ k, hk ⟩ := h;
  unfold AgohGiugaCongrRat;
  rcases k with ( _ | _ | k ) <;> simp_all +arith +decide;
  -- By definition of Bernoulli numbers, we know that $B_{2k+3} = 0$ for $k \geq 1$.
  have h_bernoulli : bernoulli (2 * k + 3) = 0 := by
    rw [ bernoulli_eq_bernoulli'_of_ne_one ];
    · rw [ bernoulli'_odd_eq_zero ];
      · simp +arith +decide [ parity_simps ];
      · linarith;
    · linarith;
  unfold Rat.IsIntMod; norm_num [ h_bernoulli ] ;
  exact fun _ => mod_cast Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by linarith )