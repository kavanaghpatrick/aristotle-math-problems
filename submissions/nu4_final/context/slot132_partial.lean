/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 87d3e442-c180-4164-b9b9-e8cf8ab34b1f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

/-- M-edges incident to vertex v -/
def M_edges_at (M : Finset (Finset V)) (v : V) : Finset (Sym2 V) :=
  M.biUnion (fun X => X.sym2.filter (fun e => v ∈ e))

/-- Triangles that share an M-edge containing v -/
def trianglesSharingMEdgeAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => ∃ e ∈ M_edges_at M v, e ∈ t.sym2)

def externalTrianglesAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  trianglesSharingMEdgeAt G M v \ M

/-- Triangle covering number -/
noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  sInf { n | ∃ E : Finset (Sym2 V), E.card = n ∧ E ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E, e ∈ t.sym2 }

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A
  h_diag_AC : (A ∩ C).card ≤ 1
  h_diag_BD : (B ∩ D).card ≤ 1
  h_vab_ne_vbc : v_ab ≠ v_bc
  h_vbc_ne_vcd : v_bc ≠ v_cd
  h_vcd_ne_vda : v_cd ≠ v_da
  h_vda_ne_vab : v_da ≠ v_ab

lemma triangle_card_eq_3 (G : SimpleGraph V) [DecidableRel G.Adj]
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) : t.card = 3 := by
      -- By definition of $G.cliqueFinset$, we know that every element in this set is a 3-clique.
      simp [SimpleGraph.cliqueFinset] at ht;
      -- By definition of IsNClique, we know that t is a clique of size 3.
      apply ht.2

lemma packing_element_is_triangle (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M) (X : Finset V) (hX : X ∈ M) :
    X ∈ G.cliqueFinset 3 := by
      -- Since $M$ is a subset of the cliqueFinset, and $X \in M$, it follows that $X \in G.cliqueFinset 3$.
      apply hM.left hX

/-- The 4 edges covering M-elements -/
def M_cover_edges (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, cfg.v_da), s(cfg.v_ab, cfg.v_bc), s(cfg.v_bc, cfg.v_cd), s(cfg.v_cd, cfg.v_da)}

lemma M_cover_edges_card (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (cfg : Cycle4 G M) :
    (M_cover_edges G M cfg).card ≤ 4 := by
      -- Since $E$ is a subset of the four edges $(v_ab, v_bc)$, $(v_bc, v_cd)$, $(v_cd, v_da)$, and $(v_da, v_ab)$, its cardinality is at most 4.
      have hE_subset : M_cover_edges G M cfg ⊆ {Sym2.mk (cfg.v_ab, cfg.v_bc), Sym2.mk (cfg.v_bc, cfg.v_cd), Sym2.mk (cfg.v_cd, cfg.v_da), Sym2.mk (cfg.v_da, cfg.v_ab)} := by
        simp +decide [ M_cover_edges ];
        -- Since these are all the same edges, just listed in a different order, the subset relation holds.
        simp [Finset.subset_iff];
      exact le_trans ( Finset.card_le_card hE_subset ) ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _ )

lemma M_cover_covers_M (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (X : Finset V) (hX : X ∈ M) :
    ∃ e ∈ M_cover_edges G M cfg, e ∈ X.sym2 := by
      rcases cfg with ⟨ A, B, C, D, hA, hB, hC, hD, hM_eq, v_ab, v_bc, v_cd, v_da, hAB, hBC, hCD, hDA, h_vab_A, h_vab_B, h_vbc_B, h_vbc_C, h_vcd_C, h_vcd_D, h_vda_D, h_vda_A, h_diag_AC, h_diag_BD, h_vab_ne_vbc, h_vbc_ne_vcd, h_vcd_ne_vda, h_vda_ne_vab ⟩ ; simp_all +decide [ M_cover_edges ] ;
      rcases hX with ( rfl | rfl | rfl | rfl ) <;> simp +decide [ * ]

section AxiomsAsVariables

variable (cycle4_all_triangles_contain_shared : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3),
    cfg.v_ab ∈ t ∨ cfg.v_bc ∈ t ∨ cfg.v_cd ∈ t ∨ cfg.v_da ∈ t)

variable (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t)

/-- Get external vertex for each shared vertex -/
noncomputable def get_x_ab (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_ab (Or.inl rfl)).choose

noncomputable def get_x_bc (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_bc (Or.inr (Or.inl rfl))).choose

noncomputable def get_x_cd (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_cd (Or.inr (Or.inr (Or.inl rfl)))).choose

noncomputable def get_x_da (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_da (Or.inr (Or.inr (Or.inr rfl)))).choose

/-- The 4 edges covering external triangles -/
noncomputable def external_cover_edges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, get_x_ab external_share_common_vertex G M hM cfg),
   s(cfg.v_bc, get_x_bc external_share_common_vertex G M hM cfg),
   s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg),
   s(cfg.v_da, get_x_da external_share_common_vertex G M hM cfg)}

lemma external_cover_edges_card (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) :
    (external_cover_edges external_share_common_vertex G M hM cfg).card ≤ 4 := by
      exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _

end AxiomsAsVariables

lemma external_triangle_contains_v (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (t : Finset V)
    (ht : t ∈ externalTrianglesAt G M v) : v ∈ t := by
      -- By definition of externalTrianglesAt, if t is in externalTrianglesAt G M v, then there exists an edge e in M_edges_at M v such that e is in t's sym2.
      obtain ⟨e, heM, he⟩ : ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
        have h_def : t ∈ externalTrianglesAt G M v := ht
        unfold externalTrianglesAt at h_def;
        unfold trianglesSharingMEdgeAt at h_def; aesop;
      unfold M_edges_at at heM; aesop;

section Proofs

variable (cycle4_all_triangles_contain_shared : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3),
    cfg.v_ab ∈ t ∨ cfg.v_bc ∈ t ∨ cfg.v_cd ∈ t ∨ cfg.v_da ∈ t)

variable (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t)

lemma external_cover_covers_vab (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_ab) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      unfold external_cover_edges; simp +decide [ Finset.mem_biUnion ] ;
      -- Since $t$ is in externalTrianglesAt $G$ $M$ $cfg.v_ab$, it must contain $cfg.v_ab$ and some element from the set of external triangles. The get_x_ab is the common vertex for the external triangles at $cfg.v_ab$. So, $t$ must contain $cfg.v_ab$ and get_x_ab.
      left
      exact ⟨external_triangle_contains_v G M cfg.v_ab t ht, (external_share_common_vertex G M hM cfg cfg.v_ab (Or.inl rfl)).choose_spec.2 t ht⟩

lemma external_cover_covers_vbc (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_bc) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- By definition of $external_cover_edges$, we know that each triangle in $externalTrianglesAt$ contains an edge from $external_cover_edges$ incident to $v$.
      have h_ext_cover : cfg.v_bc ∈ t ∧ (get_x_bc external_share_common_vertex G M hM cfg) ∈ t := by
        -- By definition of `external_share_common_vertex`, we know that `get_x_bc` is in every external triangle at `cfg.v_bc`.
        have h_get_x_bc_in_t : get_x_bc external_share_common_vertex G M hM cfg ∈ t := by
          apply (external_share_common_vertex G M hM cfg cfg.v_bc (Or.inr (Or.inl rfl))).choose_spec.2 t ht;
        exact ⟨ external_triangle_contains_v G M cfg.v_bc t ht, h_get_x_bc_in_t ⟩;
      unfold external_cover_edges; aesop;

lemma external_cover_covers_vcd (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_cd) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      refine' ⟨ s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg), _, _ ⟩ <;> simp +decide [ *, external_cover_edges ];
      -- Since $t$ is in the external triangles at $cfg.v_cd$, by definition, $cfg.v_cd$ is in $t$.
      have h_v_cd : cfg.v_cd ∈ t := by
        exact?;
      exact ⟨ h_v_cd, external_share_common_vertex G M hM cfg cfg.v_cd ( Or.inr ( Or.inr ( Or.inl rfl ) ) ) |> Exists.choose_spec |> And.right |> fun h => h t ht ⟩

lemma external_cover_covers_vda (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_da) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- By definition of $external_cover_edges$, we know that $s(cfg.v_da, get_x_da)$ is in the set and covers $t$.
      use s(cfg.v_da, get_x_da external_share_common_vertex G M hM cfg);
      -- Since $t$ is in the external triangles at $cfg.v_da$, by the definition of $external_share_common_vertex$, the chosen $x$ for $cfg.v_da$ must be in $t$.
      have h_x_in_t : get_x_da external_share_common_vertex G M hM cfg ∈ t := by
        -- By definition of `get_x_da`, since `t` is in the external triangles at `cfg.v_da`, `get_x_da` must be in `t`.
        have h_get_x_da_in_t : ∀ t ∈ externalTrianglesAt G M cfg.v_da, get_x_da external_share_common_vertex G M hM cfg ∈ t := by
          exact ( external_share_common_vertex G M hM cfg cfg.v_da ( Or.inr ( Or.inr ( Or.inr rfl ) ) ) ) |> fun h => h.choose_spec.2;
        exact h_get_x_da_in_t t ht;
      unfold external_cover_edges;
      simp [h_x_in_t];
      exact?

end Proofs

/-- The full cover: M edges + external edges -/
noncomputable def full_cover (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t) : Finset (Sym2 V) :=
  M_cover_edges G M cfg ∪ external_cover_edges external_share_common_vertex G M hM cfg

/-- Full cover has at most 8 edges -/
theorem full_cover_card_le_8 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t) :
    (full_cover G M hM cfg external_share_common_vertex).card ≤ 8 := by
  unfold full_cover
  calc (M_cover_edges G M cfg ∪ external_cover_edges external_share_common_vertex G M hM cfg).card
    ≤ (M_cover_edges G M cfg).card + (external_cover_edges external_share_common_vertex G M hM cfg).card := Finset.card_union_le _ _
    _ ≤ 4 + 4 := Nat.add_le_add (M_cover_edges_card G M cfg) (external_cover_edges_card external_share_common_vertex G M hM cfg)
    _ = 8 := rfl

lemma shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_notin_M : t ∉ M) :
    ∃ X ∈ M, 1 < (t ∩ X).card := by
      -- Since $t$ is not in $M$, adding $t$ to $M$ would create a new packing with a larger cardinality, contradicting the maximality of $M$.
      have h_contradiction : ¬(M ∪ {t} ⊆ G.cliqueFinset 3 ∧ Set.Pairwise (M ∪ {t} : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)) := by
        have h_contradiction : ∀ S : Finset (Finset V), S ⊆ G.cliqueFinset 3 → Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1) → S.card ≤ M.card := by
          have h_max : ∀ S : Finset (Finset V), S ⊆ G.cliqueFinset 3 → Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1) → S.card ≤ trianglePackingNumber G := by
            unfold trianglePackingNumber;
            intro S hS_sub hS_pairwise
            have hS_card : S.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
              exact Finset.mem_image.mpr ⟨ S, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hS_sub, hS_sub, hS_pairwise ⟩, rfl ⟩;
            have := Finset.le_max hS_card;
            cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
          exact fun S hS hS' => le_trans ( h_max S hS hS' ) hM.2.ge;
        contrapose! h_contradiction;
        exact ⟨ M ∪ { t }, h_contradiction.1, by simpa [ ht_notin_M ] using h_contradiction.2, by rw [ Finset.card_union ] ; aesop ⟩;
      contrapose! h_contradiction; simp_all +decide [ Finset.union_subset_iff, Set.Pairwise ] ;
      have := hM.1;
      rcases this with ⟨ h₁, h₂ ⟩ ; simp_all +decide [ Finset.subset_iff, Set.Pairwise ] ;
      exact fun x hx hx' => by simpa only [ Finset.inter_comm ] using h_contradiction x hx;

lemma shares_edge_with_packing_v2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_notin_M : t ∉ M) :
    ∃ X ∈ M, 1 < (t ∩ X).card := by
      -- Apply the lemma `shares_edge_with_packing` to obtain the existence of such an X.
      apply shares_edge_with_packing G M hM t ht ht_notin_M

lemma pair_intersects_subset_of_size_3 {V : Type*} [DecidableEq V]
    (S : Finset V) (hS : S.card = 3)
    (u v : V) (hu : u ∈ S) (hv : v ∈ S) (huv : u ≠ v)
    (x y : V) (hx : x ∈ S) (hy : y ∈ S) (hxy : x ≠ y) :
    u ∈ ({x, y} : Finset V) ∨ v ∈ ({x, y} : Finset V) := by
      -- Since $S$ has exactly three elements and $u \neq v$, and $x \neq y$, the only way for both $u$ and $v$ to not be in $\{x, y\}$ is if $u$ and $v$ are the third element of $S$, which contradicts the fact that $S$ has three elements.
      by_contra h_contra
      have h_third : u ≠ x ∧ u ≠ y ∧ v ≠ x ∧ v ≠ y := by
        grind;
      have h_third : S = {u, v, x} := by
        rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ hu, Finset.insert_subset_iff.mpr ⟨ hv, Finset.singleton_subset_iff.mpr hx ⟩ ⟩ ) ] ; aesop;
      aesop

#check pair_intersects_subset_of_size_3