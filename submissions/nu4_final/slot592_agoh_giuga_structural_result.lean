/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dc07c084-7844-4edf-b81e-622284186bd4

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A number is composite if it is greater than 1 and not prime.
-/
def Nat.Composite (n : ℕ) : Prop := 1 < n ∧ ¬ n.Prime

/-
A weak Giuga number is a composite number n such that n divides 1 + sum_{i=1}^{n-1} i^{phi(n)}.
-/
def IsWeakGiuga (n : ℕ) : Prop :=
  n.Composite ∧ n ∣ 1 + ∑ i ∈ Finset.Ioo 0 n, i ^ n.totient

/-
A strong Giuga number is a composite number n such that n divides 1 + sum_{i=1}^{n-1} i^{n-1}.
-/
def IsStrongGiuga (n : ℕ) : Prop :=
  n.Composite ∧ n ∣ 1 + ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1)

/-
A Carmichael number is a composite number n such that b^n ≡ b (mod n) for all b coprime to n. Note: The user's definition omits the composite condition in the formal statement but mentions it in the comment. I will follow the formal statement provided by the user, but I should be careful. Wait, the user wrote: "def IsCarmichael (n : ℕ) : Prop := ∀ b ≥ 1, n.Coprime b → n.FermatPsp b". The comment says "composite n with...". Usually Carmichael numbers are defined as composite. However, the user's code snippet defines it as the property itself. I will stick to the user's code snippet for the definition. But wait, the user's text says "Carmichael number: composite n with...". The code `def IsCarmichael` doesn't include `n.Composite`. I will stick to the code provided in the prompt for the definition body, as `IsStrongGiuga` and `IsWeakGiuga` explicitly included `n.Composite` in their bodies, but `IsCarmichael` did not in the user's snippet. Wait, looking closely at the user's snippet:
```lean
-- Carmichael number: composite n with b^n ≡ b (mod n) for all b coprime to n
def IsCarmichael (n : ℕ) : Prop :=
  ∀ b ≥ 1, n.Coprime b → n.FermatPsp b
```
The comment says "composite n", but the code doesn't enforce it. I will define it exactly as the code says. Later theorems might assume composite or prove it. Actually, Theorem 5 says "Strong Giuga implies Carmichael". If Strong Giuga includes Composite, and Carmichael doesn't, that's fine. If Carmichael is supposed to include Composite, then the user's code is slightly off compared to standard math, or `IsCarmichael` just checks the congruence property. Given the user provided code, I will use the code.
-/
def IsCarmichael (n : ℕ) : Prop :=
  ∀ b ≥ 1, n.Coprime b → n.FermatPsp b

/-
If p is prime, then sum_{i=1}^{p-1} i^{p-1} is congruent to -1 modulo p.
-/
theorem agoh_giuga_forward (p : ℕ) (hp : p.Prime) :
  p ∣ 1 + ∑ i ∈ Finset.Ioo 0 p, i ^ (p - 1) := by
    -- By Fermat's Little Theorem, for each $i$ in the range $1$ to $p-1$, we have $i^{p-1} \equiv 1 \pmod{p}$.
    have h_fermat : ∀ i ∈ Finset.Ioo 0 p, i ^ (p - 1) ≡ 1 [MOD p] := by
      exact fun i hi => Nat.totient_prime hp ▸ Nat.ModEq.pow_totient ( Nat.coprime_comm.mp ( hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith [ Finset.mem_Ioo.mp hi ] ) h; linarith [ Finset.mem_Ioo.mp hi ] ) );
    rw [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Finset.sum_nat_mod ];
    rw [ Finset.sum_congr rfl h_fermat ] ; norm_num [ Nat.mod_eq_of_lt hp.one_lt ];
    rw [ add_tsub_cancel_of_le hp.one_lt.le, Nat.mod_self ]

/-
For a prime factor p of n, the sum of i^phi(n) for i from 1 to n-1 is congruent to n - n/p modulo p.
-/
theorem sum_pow_totient_mod_p {n p : ℕ} (hp : p ∈ n.primeFactors) :
  (∑ i ∈ Finset.Ioo 0 n, i ^ n.totient) ≡ n - n / p [MOD p] := by
    -- For each $i$ in the range $1$ to $n-1$, if $p \mid i$, then $i^{n.totient} \equiv 0 \pmod{p}$.
    -- Otherwise, by Euler's theorem, $i^{n.totient} \equiv 1 \pmod{p}$.
    have h_cases : ∀ i ∈ Finset.Ioo 0 n, i ^ n.totient ≡ if p ∣ i then 0 else 1 [MOD p] := by
      intro i hi; split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      · cases ‹p ∣ i› ; aesop;
      · -- By Euler's theorem, since $p$ is prime and $i$ is not divisible by $p$, we have $i^{\phi(p)} \equiv 1 \pmod{p}$.
        have h_euler : i ^ Nat.totient p ≡ 1 [MOD p] := by
          exact Nat.ModEq.pow_totient <| Nat.coprime_comm.mp <| hp.1.coprime_iff_not_dvd.mpr ‹_›;
        -- Since $p$ is prime and $i$ is not divisible by $p$, we have $i^{\phi(n)} \equiv 1 \pmod{p}$ by Euler's theorem.
        have h_euler : i ^ Nat.totient n ≡ 1 [MOD p] := by
          have h_euler : Nat.totient p ∣ Nat.totient n := by
            exact Nat.totient_dvd_of_dvd hp.2.1;
          obtain ⟨ k, hk ⟩ := h_euler; simpa [ pow_mul, hk ] using Nat.ModEq.pow _ ‹i ^ p.totient ≡ 1 [MOD p]›;
        simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_euler;
    -- The sum of $i^{n.totient}$ modulo $p$ is the sum of $(n - n/p)$ terms, each congruent to $1 \mod p$.
    have h_sum : ∑ i ∈ Finset.Ioo 0 n, (if p ∣ i then 0 else 1) ≡ n - n / p [MOD p] := by
      -- The set of integers from 1 to n-1 that are not divisible by p is exactly the set of integers from 1 to n-1 minus the set of integers from 1 to n-1 that are divisible by p.
      have h_not_div : Finset.filter (fun i => ¬p ∣ i) (Finset.Ioo 0 n) = Finset.Ioo 0 n \ Finset.image (fun i => p * i) (Finset.Ico 1 (n / p)) := by
        simp +decide [ Finset.ext_iff ];
        exact fun a ha₁ ha₂ => ⟨ fun ha₃ x hx₁ hx₂ => fun hx₃ => ha₃ <| hx₃ ▸ dvd_mul_right _ _, fun ha₃ => fun ha₄ => ha₃ ( a / p ) ( Nat.div_pos ( Nat.le_of_dvd ha₁ ha₄ ) ( Nat.pos_of_mem_primeFactors hp ) ) ( Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.div_mul_cancel ( Nat.dvd_of_mem_primeFactors hp ) ] ) <| by rw [ mul_comm, Nat.div_mul_cancel ha₄ ] ⟩;
      rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.succ_mul ];
      simp_all +decide [ Finset.sum_ite ];
      rw [ Finset.card_sdiff ] ; norm_num [ Finset.card_image_of_injective, Function.Injective, * ];
      rw [ show Finset.image ( fun i => p * i + i + i ) ( Finset.Ico 1 ( n / ( p + 1 + 1 ) ) ) ∩ Finset.Ioo 0 n = Finset.image ( fun i => p * i + i + i ) ( Finset.Ico 1 ( n / ( p + 1 + 1 ) ) ) from ?_ ];
      · rw [ Finset.card_image_of_injective ] <;> norm_num [ Function.Injective ];
        · rw [ Nat.sub_sub, add_comm ];
          rw [ add_tsub_cancel_of_le ( Nat.succ_le_of_lt ( Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) ( by simpa [ add_comm, add_left_comm ] using hp.2.1 ) ) ( by linarith ) ) ) ];
        · exact fun a₁ a₂ h => by nlinarith;
      · norm_num +zetaDelta at *;
        exact Finset.image_subset_iff.mpr fun i hi => Finset.mem_Ioo.mpr ⟨ by nlinarith [ Finset.mem_Ico.mp hi ], by nlinarith [ Finset.mem_Ico.mp hi, Nat.div_mul_le_self n ( p + 1 + 1 ) ] ⟩;
    simp_all +decide only [← ZMod.natCast_eq_natCast_iff];
    rw [ ← h_sum, Nat.cast_sum, Finset.sum_congr rfl h_cases ];
    norm_cast

/-
n is weak Giuga if and only if for all prime factors p of n, p divides (n/p - 1).
-/
theorem isWeakGiuga_iff_prime_dvd (n : ℕ) (hn : n.Composite) :
  IsWeakGiuga n ↔ ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
    unfold IsWeakGiuga;
    constructor;
    · intro h p hp;
      -- By the lemma sum_pow_totient_mod_p, we have that $\sum_{i=1}^{n-1} i^{\phi(n)} \equiv n - n/p \pmod{p}$.
      have h_sum_mod_p : (∑ i ∈ Finset.Ioo 0 n, i ^ n.totient) ≡ n - n / p [MOD p] := by
        exact?;
      -- Since $n$ divides $1 + \sum_{i=1}^{n-1} i^{\phi(n)}$, we have $1 + \sum_{i=1}^{n-1} i^{\phi(n)} \equiv 0 \pmod{p}$.
      have h_cong : 1 + ∑ i ∈ Finset.Ioo 0 n, i ^ n.totient ≡ 0 [MOD p] := by
        exact Nat.modEq_zero_iff_dvd.mpr ( dvd_trans ( Nat.dvd_of_mem_primeFactors hp ) h.2 );
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      rw [ Nat.cast_sub ( Nat.div_le_self _ _ ) ] at h_cong; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
      cases k : n / p <;> simp_all +decide [ add_eq_zero_iff_eq_neg ];
    · -- Assume that for all prime factors p of n, p divides (n/p - 1).
      intro h
      -- We need to show that n divides 1 + ∑ i ∈ Finset.Ioo 0 n, i ^ n.totient.
      have h_div : ∀ p ∈ n.primeFactors, p ∣ (1 + ∑ i ∈ Finset.Ioo 0 n, i ^ n.totient) := by
        intro p hp
        have h_sum_mod_p : (∑ i ∈ Finset.Ioo 0 n, i ^ n.totient) ≡ n - n / p [MOD p] := by
          exact?;
        -- Since $p \mid (n / p - 1)$, we have $n / p \equiv 1 \pmod{p}$.
        have h_n_div_p_mod_p : n / p ≡ 1 [MOD p] := by
          refine Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
          simpa [ Nat.cast_sub ( show 1 ≤ n / p from Nat.div_pos ( Nat.le_of_dvd hn.1.le ( Nat.dvd_of_mem_primeFactors hp ) ) ( Nat.pos_of_mem_primeFactors hp ) ) ] using Int.natCast_dvd_natCast.mpr ( h p hp );
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show n / p ≤ n from Nat.div_le_self _ _ ) ];
      -- Since $n$ is squarefree, we can apply the Chinese Remainder Theorem to conclude that $n \mid 1 + \sum_{i=1}^{n-1} i^{\phi(n)}$.
      have h_crt : (∏ p ∈ n.primeFactors, p) ∣ (1 + ∑ i ∈ Finset.Ioo 0 n, i ^ n.totient) := by
        refine' Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ );
        apply_rules [ Finset.prod_dvd_prod_of_subset ];
        intro p hp; specialize h_div p hp; aesop;
      -- Since $n$ is squarefree, we have $n = \prod_{p \in n.primeFactors} p$.
      have h_squarefree : Squarefree n := by
        refine' Nat.squarefree_iff_prime_squarefree.mpr _;
        intro p pp dp; specialize h p; simp_all +decide [ Nat.dvd_add_right, Nat.dvd_add_left, Nat.Prime.dvd_mul ] ;
        have := h ( dvd_of_mul_left_dvd dp ) hn.1.ne_bot;
        have := Nat.dvd_sub ( show p ∣ n / p from Nat.dvd_div_of_mul_dvd dp ) this;
        rw [ Nat.sub_sub_self ( Nat.div_pos ( Nat.le_of_dvd hn.1.le ( dvd_of_mul_left_dvd dp ) ) pp.pos ) ] at this ; aesop;
      rw [ Nat.prod_primeFactors_of_squarefree h_squarefree ] at h_crt ; aesop

/-
If n is a weak Giuga number, then n is squarefree.
-/
theorem weak_giuga_squarefree (n : ℕ) (h : IsWeakGiuga n) : Squarefree n := by
  -- If p^2 divides n, then n/p ≡ 0 (mod p), so n/p - 1 ≡ -1 (mod p).
  by_contra h_not_squarefree
  obtain ⟨p, hp_prime, hp_sq⟩ : ∃ p, Nat.Prime p ∧ p^2 ∣ n := by
    simpa only [ pow_two ] using by rw [ Nat.squarefree_iff_prime_squarefree ] at h_not_squarefree; aesop;
  -- By the characterization of weak Giuga numbers, we know that p divides (n/p - 1).
  have h_div : p ∣ (n / p - 1) := by
    convert isWeakGiuga_iff_prime_dvd n h.1 |>.1 h p _ using 1;
    exact Nat.mem_primeFactors.mpr ⟨ hp_prime, dvd_of_mul_left_dvd hp_sq, by rintro rfl; exact absurd h.1 ( by unfold Nat.Composite; aesop ) ⟩;
  -- Since $p^2 \mid n$, we have $n/p \equiv 0 \pmod{p}$.
  have h_n_div_p_mod_p : n / p ≡ 0 [MOD p] := by
    exact Nat.modEq_zero_iff_dvd.mpr ( Nat.dvd_div_of_mul_dvd ( by simpa only [ sq ] using hp_sq ) );
  rcases k : n / p with ( _ | _ | k ) <;> simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
  · exact absurd ( k.resolve_left hp_prime.ne_zero ) ( not_lt_of_ge ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by rintro rfl; exact absurd h.1 ( by unfold Nat.Composite; aesop ) ) ) ( Nat.dvd_of_mod_eq_zero ( show n % p = 0 from Nat.mod_eq_zero_of_dvd <| dvd_of_mul_left_dvd <| Nat.dvd_of_mod_eq_zero hp_sq ) ) ) );
  · have := Nat.dvd_gcd ( Nat.dvd_of_mod_eq_zero h_div ) ( Nat.dvd_of_mod_eq_zero h_n_div_p_mod_p ) ; aesop;

/-
For n > 1, the sum of reciprocals of prime factors minus 1/n is an integer if and only if the sum of n/p is congruent to 1 modulo n.
-/
theorem sum_recip_iff_sum_div_congr {n : ℕ} (hn : 1 < n) :
  (∃ m : ℕ, ∑ p ∈ n.primeFactors, (1 / p : ℚ) - 1 / n = m) ↔ ∑ p ∈ n.primeFactors, n / p ≡ 1 [MOD n] := by
    -- Let's rewrite the sum of reciprocals as a single fraction.
    suffices h_sum_reciprocal : (∃ m : ℕ, (∑ p ∈ n.primeFactors, (n / p : ℚ) - 1 = m * n)) ↔ (∑ p ∈ n.primeFactors, (n / p : ℕ) ≡ 1 [MOD n]) by
      field_simp;
      convert h_sum_reciprocal using 4 ; norm_num [ div_eq_mul_inv, mul_comm, Finset.mul_sum _ _ _ ];
      ring;
    constructor;
    · intro h;
      -- By multiplying both sides of the equation by $n$, we obtain the desired result.
      have h_mul : ∑ p ∈ n.primeFactors, (n / p : ℕ) = h.choose * n + 1 := by
        have h_mul : ∑ p ∈ n.primeFactors, (n / p : ℚ) = h.choose * n + 1 := by
          linarith [ h.choose_spec ];
        rw [ ← @Nat.cast_inj ℚ ] ; push_cast ; rw [ ← h_mul ];
        exact Finset.sum_congr rfl fun p hp => by rw [ Nat.cast_div ( Nat.dvd_of_mem_primeFactors hp ) ( Nat.cast_ne_zero.mpr <| Nat.ne_of_gt <| Nat.pos_of_mem_primeFactors hp ) ] ;
      norm_num [ h_mul, Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
    · -- The congruence means there exists an integer m such that ∑ n/p - 1 = m * n.
      intro h_congr
      obtain ⟨m, hm⟩ : ∃ m : ℤ, (∑ p ∈ n.primeFactors, (n / p : ℤ)) - 1 = m * n := by
        exact exists_eq_mul_left_of_dvd <| by simpa using h_congr.symm.dvd;
      use m.natAbs;
      convert congr_arg ( ( ↑ ) : ℤ → ℚ ) hm using 1;
      · simp +zetaDelta at *;
        exact Finset.sum_congr rfl fun x hx => by rw [ Int.cast_div ( mod_cast Nat.dvd_of_mem_primeFactors hx ) ( by aesop ) ] ; push_cast; ring;
      · norm_num [ abs_of_nonneg ( show 0 ≤ m by nlinarith [ show 0 ≤ ∑ p ∈ n.primeFactors, ( n : ℤ ) / p from Finset.sum_nonneg fun _ _ => by positivity ] ) ]

/-
n is a weak Giuga number if and only if the sum of the reciprocals of its prime factors minus 1/n is a natural number.
-/
theorem isWeakGiuga_iff_sum (n : ℕ) (hn : n.Composite) :
  IsWeakGiuga n ↔ ∃ m : ℕ, ∑ p ∈ n.primeFactors, (1 / p : ℚ) - 1 / n = m := by
    -- We use the helper lemma `sum_recip_iff_sum_div_congr` to rewrite the RHS as `∑ p ∈ n.primeFactors, n / p ≡ 1 [MOD n]`.
    rw [isWeakGiuga_iff_prime_dvd n hn, sum_recip_iff_sum_div_congr];
    · constructor <;> intro h;
      · -- Since $n$ is squarefree, it suffices to show that for all $p \in n.primeFactors$, $p \mid S - 1$.
        have h_div : ∀ p ∈ n.primeFactors, p ∣ (∑ p ∈ n.primeFactors, n / p) - 1 := by
          intro p hp
          have h_div : p ∣ (∑ q ∈ n.primeFactors \ {p}, n / q) := by
            refine' Finset.dvd_sum fun q hq => Nat.dvd_div_of_mul_dvd _;
            exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by rw [ Nat.coprime_primes ] <;> aesop ) ( Nat.dvd_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ( Nat.dvd_of_mem_primeFactors hp );
          rw [ ← Finset.sum_sdiff ( Finset.singleton_subset_iff.mpr hp ) ];
          convert Nat.dvd_add h_div ( h p hp ) using 1 ; simp +decide [ Nat.add_sub_assoc ( show 1 ≤ n / p from Nat.div_pos ( Nat.le_of_dvd hn.1.le ( Nat.dvd_of_mem_primeFactors hp ) ) ( Nat.pos_of_mem_primeFactors hp ) ) ];
        have h_cong : ∑ p ∈ n.primeFactors, n / p - 1 ≡ 0 [MOD n] := by
          -- Since $n$ is squarefree, the prime factors of $n$ are pairwise coprime.
          have h_coprime : ∀ p q : ℕ, p ∈ n.primeFactors → q ∈ n.primeFactors → p ≠ q → Nat.gcd p q = 1 := by
            exact fun p q hp hq hpq => by have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors hq ) ; tauto;
          have h_cong : ∀ {S : Finset ℕ}, (∀ p ∈ S, p ∣ (∑ p ∈ n.primeFactors, n / p) - 1) → (∀ p q : ℕ, p ∈ S → q ∈ S → p ≠ q → Nat.gcd p q = 1) → (∏ p ∈ S, p) ∣ (∑ p ∈ n.primeFactors, n / p) - 1 := by
            intros S hS h_coprime; induction' S using Finset.induction with p S hpS ih; aesop;
            rw [ Finset.prod_insert hpS ];
            exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by exact Nat.Coprime.prod_right fun q hq => h_coprime p q ( Finset.mem_insert_self _ _ ) ( Finset.mem_insert_of_mem hq ) ( by aesop ) ) ( hS p ( Finset.mem_insert_self _ _ ) ) ( ih ( fun q hq => hS q ( Finset.mem_insert_of_mem hq ) ) ( fun q r hq hr hqr => h_coprime q r ( Finset.mem_insert_of_mem hq ) ( Finset.mem_insert_of_mem hr ) hqr ) );
          rw [ Nat.modEq_zero_iff_dvd ];
          convert h_cong h_div h_coprime using 1;
          rw [ Nat.prod_primeFactors_of_squarefree ];
          convert weak_giuga_squarefree n _;
          exact ⟨ hn, by
            convert isWeakGiuga_iff_prime_dvd n hn |>.2 h |>.2 using 1 ⟩;
        rcases k : ∑ p ∈ n.primeFactors, n / p with ( _ | _ | k ) <;> simp_all +decide [ Nat.modEq_iff_dvd ];
        rcases hn with ⟨ hn₁, hn₂ ⟩;
        contrapose! k;
        exact ⟨ Nat.minFac n, Nat.minFac_prime hn₁.ne', Nat.minFac_dvd n, by positivity, Nat.ne_of_gt ( Nat.minFac_pos n ), Nat.le_of_dvd hn₁.le ( Nat.minFac_dvd n ) ⟩;
      · intro p hp
        have h_div : p ∣ (∑ q ∈ n.primeFactors, n / q - 1) := by
          have := h.of_dvd ( Nat.dvd_of_mem_primeFactors hp );
          rw [ ← Nat.modEq_zero_iff_dvd ] ; cases le_total ( ∑ q ∈ n.primeFactors, n / q ) 1 <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
        have h_div : p ∣ (∑ q ∈ n.primeFactors \ {p}, n / q) := by
          refine' Finset.dvd_sum fun q hq => Nat.dvd_div_of_mul_dvd _;
          exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by rw [ Nat.coprime_primes ] <;> aesop ) ( Nat.dvd_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ( Nat.dvd_of_mem_primeFactors hp );
        simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( show 1 ≤ ∑ q ∈ n.primeFactors, n / q from Finset.sum_pos ( fun q hq => Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.dvd_of_mem_primeFactors hq ) ) ( Nat.pos_of_mem_primeFactors hq ) ) ⟨ p, hp ⟩ ) ];
        cases le_total ( n / p ) 1 <;> simp_all +decide [ sub_eq_iff_eq_add ];
    · exact hn.1

/-
For a prime p and integer k, if p-1 does not divide k, then the sum of i^k for i from 1 to p-1 is congruent to 0 modulo p.
-/
theorem sum_pow_mod_p_eq_zero {p k : ℕ} (hp : p.Prime) (hk : ¬ (p - 1) ∣ k) :
  ∑ i ∈ Finset.Ico 1 p, i ^ k ≡ 0 [MOD p] := by
    -- Let $g$ be a primitive root modulo $p$. Such a $g$ exists because $p$ is prime.
    obtain ⟨g, hg⟩ : ∃ g : ℕ, Nat.gcd g p = 1 ∧ orderOf (g : ZMod p) = p - 1 := by
      haveI := Fact.mk hp;
      obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := ( ZMod p )ˣ );
      refine' ⟨ g.val.val, _, _ ⟩;
      · exact Nat.coprime_comm.mp ( hp.coprime_iff_not_dvd.mpr fun h => by haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] );
      · simp +decide [ orderOf_units, orderOf_eq_card_of_forall_mem_zpowers hg, Nat.totient_prime hp ];
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    -- Consider the sum $S = \sum_{i=1}^{p-1} i^k$. Multiplying each term by $g^k$ gives $g^k S = \sum_{i=1}^{p-1} (gi)^k$.
    have h_mul : ∑ i ∈ Finset.Ico 1 p, (i : ZMod p) ^ k = ∑ i ∈ Finset.Ico 1 p, ((g * i) : ZMod p) ^ k := by
      have h_mul : Finset.image (fun i : ZMod p => (g * i : ZMod p)) (Finset.univ.erase 0) = Finset.univ.erase 0 := by
        refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
        · simp +decide [ hg.1, ZMod.natCast_eq_zero_iff ];
          exact fun x hx => ⟨ fun h => by have := Nat.gcd_eq_right h; aesop, hx ⟩;
        · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show ( g : ZMod p ) ≠ 0 from by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => by have := Nat.gcd_eq_right h; aesop ) hxy ];
      have h_mul : ∑ i ∈ Finset.univ.erase 0, (i : ZMod p) ^ k = ∑ i ∈ Finset.univ.erase 0, ((g * i) : ZMod p) ^ k := by
        conv_lhs => rw [ ← h_mul, Finset.sum_image ( Finset.card_image_iff.mp <| by aesop ) ] ;
      convert h_mul using 1 <;> rw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ Finset.sum_range, ZMod.natCast_eq_zero_iff ];
      · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Fin.sum_univ_succ, ZMod ];
      · exact hp.pos;
      · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Fin.sum_univ_succ, ZMod ];
      · exact hp.pos;
    -- Since $g^k \neq 1 \pmod{p}$, we can factor out $g^k$ from the sum.
    have h_factor : ∑ i ∈ Finset.Ico 1 p, ((g * i) : ZMod p) ^ k = (g : ZMod p) ^ k * ∑ i ∈ Finset.Ico 1 p, (i : ZMod p) ^ k := by
      simp +decide only [mul_pow, Finset.mul_sum _ _ _];
    by_cases h : ( ∑ i ∈ Finset.Ico 1 p, ( i : ZMod p ) ^ k ) = 0 <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
    exact absurd ( orderOf_dvd_iff_pow_eq_one.mpr h_mul ) ( by rw [ hg.2 ] ; exact fun h' => hk <| by rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.dvd_of_mod_eq_zero <| Nat.mod_eq_zero_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, hp.pos ] using h' )

/-
If p divides n and m > 0, then the sum of i^m for i from 1 to n-1 is congruent to (n/p) times the sum of j^m for j from 1 to p-1 modulo p.
-/
theorem sum_pow_mod_p_decomposition {n p m : ℕ} (hp : p ∣ n) (hm : m > 0) :
  ∑ i ∈ Finset.Ioo 0 n, i ^ m ≡ (n / p) * ∑ j ∈ Finset.Ioo 0 p, j ^ m [MOD p] := by
    obtain ⟨ k, rfl ⟩ := hp;
    -- We can split the sum over `range (p*k)` into `k` blocks of length `p`.
    have h_split : ∑ i ∈ Finset.range (p * k), i^m ≡ k * ∑ i ∈ Finset.range p, i^m [MOD p] := by
      induction' k with k ih;
      · norm_num;
        rfl;
      · simp_all +decide [ Nat.mul_succ, ← ZMod.natCast_eq_natCast_iff, Finset.sum_range_add ];
        ring;
    convert h_split using 1 <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Finset.sum_range_succ' ];
    · erw [ Finset.sum_Ico_eq_sum_range ];
      cases a : p * k <;> simp_all +decide [ add_comm, Finset.sum_range_succ' ];
    · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Finset.sum_range_succ' ];
      erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, add_assoc ];
      exact Or.inl ( by rw [ Finset.sum_range_succ' ] ; simp +arith +decide [ add_comm, add_left_comm, add_assoc ] )

/-
If n is a strong Giuga number, then for every prime factor p of n, p-1 divides n-1.
-/
theorem strong_giuga_prime_sub_one_dvd_n_sub_one (n : ℕ) (h : IsStrongGiuga n) :
  ∀ p ∈ n.primeFactors, p - 1 ∣ n - 1 := by
    -- Let p be a prime factor of n.
    intro p hp
    obtain ⟨hn_composite, hn_div⟩ := h;
    -- By `sum_pow_mod_p_decomposition` (with m = n-1), ∑_{i=1}^{n-1} i^{n-1} ≡ (n/p) * ∑_{j=1}^{p-1} j^{n-1} (mod p).
    have h_sum_mod_p : ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) ≡ (n / p) * ∑ j ∈ Finset.Ico 1 p, j ^ (n - 1) [MOD p] := by
      convert sum_pow_mod_p_decomposition ( Nat.dvd_of_mem_primeFactors hp ) ( Nat.sub_pos_of_lt ( show 1 < n from hn_composite.1 ) ) using 1;
    -- If p-1 does not divide n-1, then by `sum_pow_mod_p_eq_zero`, ∑_{j=1}^{p-1} j^{n-1} ≡ 0 (mod p).
    by_contra h_contra
    have h_sum_zero : ∑ j ∈ Finset.Ico 1 p, j ^ (n - 1) ≡ 0 [MOD p] := by
      convert sum_pow_mod_p_eq_zero ( Nat.prime_of_mem_primeFactors hp ) h_contra using 1;
    -- Then (n/p) * 0 ≡ 0 ≡ -1 (mod p), contradiction.
    have h_contradiction : 1 + ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) ≡ 1 [MOD p] := by
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
    exact absurd ( Nat.dvd_trans ( Nat.dvd_of_mem_primeFactors hp ) hn_div ) ( by rw [ Nat.dvd_iff_mod_eq_zero ] ; rw [ h_contradiction ] ; exact by rw [ Nat.mod_eq_of_lt ( Nat.Prime.one_lt ( Nat.prime_of_mem_primeFactors hp ) ) ] ; aesop )

/-
Every strong Giuga number is a Carmichael number.
-/
theorem strong_giuga_is_carmichael (n : ℕ) (h : IsStrongGiuga n) : IsCarmichael n := by
  obtain ⟨ hn, hn' ⟩ := h;
  -- For any $b \geq 1$ such that $\gcd(b, n) = 1$, we need to show that $b^n \equiv b \pmod{n}$.
  intro b hb hb_coprime
  have h_sum : ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) ≡ -1 [ZMOD n] := by
    exact Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ add_comm ] using Int.natCast_dvd_natCast.mpr hn';
  -- Since $\gcd(b, n) = 1$, we can apply the lemma `sum_pow_mod_p_decomposition` to rewrite the sum modulo $n$.
  have h_sum_mod : ∑ i ∈ Finset.Ioo 0 n, (b * i) ^ (n - 1) ≡ ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) [ZMOD n] := by
    -- Since $\gcd(b, n) = 1$, multiplication by $b$ permutes the residues modulo $n$.
    have h_perm : Finset.image (fun i => b * i % n) (Finset.Ico 1 n) = Finset.Ico 1 n := by
      refine Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr ?_ ) ?_;
      · simp +zetaDelta at *;
        exact fun x hx₁ hx₂ => ⟨ Nat.pos_of_ne_zero fun hx₃ => by have := Nat.dvd_of_mod_eq_zero hx₃; exact absurd ( hb_coprime.dvd_of_dvd_mul_left this ) ( Nat.not_dvd_of_pos_of_lt hx₁ hx₂ ), Nat.mod_lt _ ( by linarith ) ⟩;
      · rw [ Finset.card_image_of_injOn ];
        intros x hx y hy hxy; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ] ;
        -- Since $b$ is coprime to $n$, we can divide both sides of the congruence $b * x ≡ b * y [MOD n]$ by $b$.
        have h_div : x ≡ y [MOD n] := by
          have h_div : b * x ≡ b * y [MOD n] := by
            simpa [ ← ZMod.natCast_eq_natCast_iff ] using hxy;
          exact?;
        exact Nat.mod_eq_of_lt hx.2 ▸ Nat.mod_eq_of_lt hy.2 ▸ h_div;
    -- Since multiplication by $b$ permutes the residues modulo $n$, the sums are congruent modulo $n$.
    have h_sum_cong : ∑ i ∈ Finset.Ico 1 n, (b * i) ^ (n - 1) ≡ ∑ i ∈ Finset.Ico 1 n, i ^ (n - 1) [ZMOD n] := by
      have h_sum_cong : ∑ i ∈ Finset.Ico 1 n, (b * i) ^ (n - 1) ≡ ∑ i ∈ Finset.image (fun i => b * i % n) (Finset.Ico 1 n), i ^ (n - 1) [ZMOD n] := by
        rw [ Finset.sum_image ];
        · simp +decide [ ← ZMod.intCast_eq_intCast_iff ];
        · intro x hx y hy; have := Finset.card_image_iff.mp ( by aesop : Finset.card ( Finset.image ( fun i => b * i % n ) ( Finset.Ico 1 n ) ) = Finset.card ( Finset.Ico 1 n ) ) ; aesop;
      grind;
    convert h_sum_cong using 1;
  -- Since $\gcd(b, n) = 1$, we can simplify the expression to $b^{n-1} \cdot \sum_{i=1}^{n-1} i^{n-1} \equiv \sum_{i=1}^{n-1} i^{n-1} \pmod{n}$.
  have h_simplified : b ^ (n - 1) * ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) ≡ ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) [ZMOD n] := by
    simpa [ mul_pow, Finset.mul_sum _ _ _ ] using h_sum_mod;
  -- Since $\gcd(b, n) = 1$, we can divide both sides of the congruence by $\sum_{i=1}^{n-1} i^{n-1}$.
  have h_div : b ^ (n - 1) ≡ 1 [ZMOD n] := by
    simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
  refine' ⟨ _, _ ⟩;
  · rw [ Nat.ProbablePrime ];
    simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( Nat.one_le_pow _ _ hb ) ] using h_div.symm.dvd;
  · exact ⟨ hn.2, hn.1 ⟩

/-
Every strong Giuga number is a weak Giuga number.
-/
theorem strong_giuga_implies_weak_giuga (n : ℕ) (h : IsStrongGiuga n) : IsWeakGiuga n := by
  -- By definition of strong Giuga, we know that for all prime factors p of n, p divides (n/p - 1).
  have h_div : ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
    -- By definition of IsStrongGiuga, we know that for every prime factor p of n, p divides 1 + sum_{i=1}^{n-1} i^{n-1}.
    have h_div : ∀ p ∈ n.primeFactors, p ∣ 1 + ∑ i ∈ Finset.Ico 1 n, i ^ (n - 1) := by
      exact fun p hp => dvd_trans ( Nat.dvd_of_mem_primeFactors hp ) h.2;
    -- By definition of sum_pow_mod_p_decomposition, we know that $\sum_{i=1}^{n-1} i^{n-1} \equiv (n/p) \sum_{j=1}^{p-1} j^{n-1} \pmod{p}$.
    have h_sum_mod : ∀ p ∈ n.primeFactors, ∑ i ∈ Finset.Ico 1 n, i ^ (n - 1) ≡ (n / p) * ∑ j ∈ Finset.Ico 1 p, j ^ (n - 1) [MOD p] := by
      intros p hp
      apply sum_pow_mod_p_decomposition; unfold IsStrongGiuga at h; aesop;
      exact Nat.sub_pos_of_lt ( Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨ by aesop_cat, by aesop_cat ⟩ );
    -- By definition of sum_pow_mod_p_eq_zero, we know that $\sum_{j=1}^{p-1} j^{n-1} \equiv -1 \pmod{p}$.
    have h_sum_mod_zero : ∀ p ∈ n.primeFactors, ∑ j ∈ Finset.Ico 1 p, j ^ (n - 1) ≡ -1 [ZMOD p] := by
      intro p hp
      have h_sum_mod_zero : ∑ j ∈ Finset.Ico 1 p, j ^ (n - 1) ≡ ∑ j ∈ Finset.Ico 1 p, j ^ (p - 1) [MOD p] := by
        have h_sum_mod_zero : ∀ j ∈ Finset.Ico 1 p, j ^ (n - 1) ≡ j ^ (p - 1) [MOD p] := by
          intro j hj
          have h_div : p - 1 ∣ n - 1 := by
            exact?;
          obtain ⟨ k, hk ⟩ := h_div; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_mul ] ;
          haveI := Fact.mk hp.1; rw [ ZMod.pow_card_sub_one_eq_one ( by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt hj.1 hj.2 ) ] ; norm_num;
        simp_all +decide only [← ZMod.natCast_eq_natCast_iff, Nat.cast_sum];
      have h_sum_mod_zero : ∑ j ∈ Finset.Ico 1 p, j ^ (p - 1) ≡ -1 [ZMOD p] := by
        haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hp ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        rw [ Finset.sum_congr rfl fun x hx => by rw [ ZMod.pow_card_sub_one_eq_one ( by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( Finset.mem_Ico.mp hx |>.1 ) ( Finset.mem_Ico.mp hx |>.2 ) ) ] ] ; norm_num [ Nat.cast_sub ( show 1 ≤ p from Nat.Prime.pos ( Nat.prime_of_mem_primeFactors hp ) ) ];
      simp_all +decide [ ← Int.natCast_modEq_iff ];
      exact Eq.trans ‹_› h_sum_mod_zero;
    intro p hp; specialize h_div p hp; specialize h_sum_mod p hp; specialize h_sum_mod_zero p hp; simp_all +decide [ ← Int.natCast_dvd_natCast, ← ZMod.intCast_zmod_eq_zero_iff_dvd, ← ZMod.natCast_eq_natCast_iff ] ;
    simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
    cases le_total ( n / p ) 1 <;> simp_all +decide [ Nat.cast_sub ];
    linear_combination' -h_div
  -- We need to show that n is a weak Giuga number, which means that for all prime factors p of n, p divides (n/p - 1).
  exact (isWeakGiuga_iff_prime_dvd n h.left).mpr h_div

/-
If n is a weak Giuga number, then the sum of the reciprocals of its prime factors is greater than 1.
-/
theorem weak_giuga_sum_recip_gt_one (n : ℕ) (h : IsWeakGiuga n) :
  ∑ p ∈ n.primeFactors, (1 / p : ℚ) > 1 := by
    -- By definition of weak Giuga numbers, there exists an integer m such that ∑ 1/p - 1/n = m.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, ∑ p ∈ n.primeFactors, (1 / p : ℚ) - 1 / n = m := by
      convert isWeakGiuga_iff_sum n h.1 |>.1 h using 1;
    rcases m with ( _ | m ) <;> norm_num at *;
    · rw [ sub_eq_zero ] at hm;
      contrapose! hm;
      refine' ne_of_gt ( lt_of_lt_of_le _ ( Finset.sum_le_sum_of_subset_of_nonneg ( show n.primeFactors ⊇ { Nat.minFac n } from _ ) fun _ _ _ => by positivity ) ) <;> norm_num;
      · gcongr;
        · exact Nat.cast_pos.mpr ( Nat.minFac_pos _ );
        · refine' Nat.lt_of_le_of_ne ( Nat.minFac_le ( Nat.pos_of_ne_zero _ ) ) fun con => _;
          · cases h ; aesop;
          · have := h.1; simp_all +decide [ Nat.Composite ] ;
            exact this.2 ( con ▸ Nat.minFac_prime this.1.ne' );
      · exact ⟨ by rintro rfl; exact absurd h.1 ( by unfold Nat.Composite; norm_num ), Nat.minFac_dvd n, by rintro rfl; exact absurd h.1 ( by unfold Nat.Composite; norm_num ) ⟩;
    · linarith [ inv_pos.mpr ( show 0 < ( n : ℚ ) by norm_cast; exact Nat.pos_of_ne_zero ( by rintro rfl; exact absurd h.1 ( by unfold Nat.Composite; aesop ) ) ) ]

/-
Every composite Carmichael number is odd.
-/
theorem carmichael_composite_odd (n : ℕ) (h : IsCarmichael n) (hc : n.Composite) : Odd n := by
  -- Let's choose any prime factor p of n.
  by_contra h_even
  obtain ⟨p, hp⟩ : ∃ p, Nat.Prime p ∧ p ∣ n ∧ p = 2 := by
    exact ⟨ 2, Nat.prime_two, even_iff_two_dvd.mp ( by simpa using h_even ), rfl ⟩;
  -- By the Carmichael property, $(n-1)^n \equiv n-1 \pmod{n}$.
  have h_carmichael : (n - 1) ^ n ≡ n - 1 [MOD n] := by
    have := h ( n - 1 ) ?_ ?_ <;> rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.modEq_iff_dvd ];
    · have := this.2; simp_all +decide [ Nat.FermatPsp ] ;
      convert dvd_neg.mpr ( Int.natCast_dvd_natCast.mpr ‹n + 1 + 1 ∣ ( n + 1 ) ^ ( n + 1 ) - 1› ) |> fun x => x.mul_left ( n + 1 ) using 1 ; simp +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, pow_succ' ] ; ring;
    · cases hc.1;
    · exact absurd hc ( by unfold Nat.Composite; decide );
  -- Since $n$ is even, we have $(n-1)^n \equiv (-1)^n \equiv 1 \pmod{n}$.
  have h_even_pow : (n - 1) ^ n ≡ 1 [MOD n] := by
    have h_even_pow : (n - 1) ^ n ≡ (-1) ^ n [ZMOD n] := by
      exact Int.ModEq.pow _ ( Int.modEq_iff_dvd.mpr ⟨ -1, by ring ⟩ );
    simp_all +decide [ ← Int.natCast_modEq_iff ];
    cases n <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
  rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.ModEq ];
  -- Since 2 is not composite, this leads to a contradiction.
  cases hc;
  contradiction

/-
Every strong Giuga number is odd.
-/
theorem strong_giuga_odd (n : ℕ) (h : IsStrongGiuga n) : Odd n := by
  -- By definition of strong Giuga, n is composite.
  have h_composite : n.Composite := by
    exact h.1;
  -- By definition of strong Giuga, n is a Carmichael number.
  have h_carmichael : IsCarmichael n := by
    exact?;
  exact?

/-
Every strong Giuga number has at least 3 prime factors.
-/
theorem strong_giuga_at_least_three_primes (n : ℕ) (h : IsStrongGiuga n) :
  3 ≤ n.primeFactors.card := by
    -- By `weak_giuga_sum_recip_gt_one`, we know that $\sum_{p|n} \frac{1}{p} > 1$.
    have h_sum_gt_one : ∑ p ∈ n.primeFactors, (1 / p : ℚ) > 1 := by
      convert weak_giuga_sum_recip_gt_one n _;
      exact?;
    -- Since all prime factors of n are odd primes (≥ 3), we can lower bound the sum by considering the smallest possible primes.
    have h_prime_factors_lower_bound : ∀ p ∈ n.primeFactors, 3 ≤ p := by
      -- Since n is odd, all its prime factors must be odd.
      have h_odd : Odd n := by
        exact?;
      exact fun p hp => Nat.succ_le_of_lt ( lt_of_le_of_ne ( Nat.Prime.two_le ( Nat.prime_of_mem_primeFactors hp ) ) ( Ne.symm ( by rintro rfl; exact absurd ( h_odd.of_dvd_nat ( Nat.dvd_of_mem_primeFactors hp ) ) ( by decide ) ) ) );
    -- If the number of prime factors is 1 or 2, then the sum of their reciprocals would be less than or equal to 1, contradicting `h_sum_gt_one`.
    by_cases h_card : n.primeFactors.card ≤ 2;
    · interval_cases _ : n.primeFactors.card <;> simp_all +decide;
      · cases ‹_› <;> simp_all +decide [ IsStrongGiuga ];
      · obtain ⟨ p, hp ⟩ := Finset.card_eq_one.mp ‹_›;
        simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
        exact h_sum_gt_one.not_le <| inv_le_one_of_one_le₀ <| mod_cast hp.1.1.one_lt.le;
      · -- Let $p$ and $q$ be the two prime factors of $n$.
        obtain ⟨p, q, hpq⟩ : ∃ p q : ℕ, p ∈ n.primeFactors ∧ q ∈ n.primeFactors ∧ p < q ∧ n.primeFactors = {p, q} := by
          rw [ Finset.card_eq_two ] at *;
          obtain ⟨ x, y, hxy, h ⟩ := ‹_›; exact hxy.lt_or_gt.elim ( fun h' => ⟨ x, y, h.symm ▸ Finset.mem_insert_self _ _, h.symm ▸ Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ), h', h ⟩ ) fun h' => ⟨ y, x, h.symm ▸ Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ), h.symm ▸ Finset.mem_insert_self _ _, h', by simpa [ Finset.pair_comm ] using h ⟩ ;
        simp_all +decide [ Finset.sum_pair ];
        rw [ Finset.sum_pair ] at h_sum_gt_one <;> norm_num at *;
        · rw [ inv_add_inv, lt_div_iff₀ ] at h_sum_gt_one <;> norm_cast at * <;> nlinarith [ h_prime_factors_lower_bound p hpq.1.1 hpq.1.2.1, h_prime_factors_lower_bound q hpq.2.1.1 hpq.2.1.2.1 ];
        · linarith;
    · linarith

#check bernoulli'

/-
AgohGiugaSum is the condition that the sum of i^(n-1) for i from 1 to n-1 is congruent to -1 modulo n.
-/
def AgohGiugaSum (n : ℕ) : Prop :=
  ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) ≡ -1 [ZMOD n]

/-
AgohGiugaCongr is the condition that n * B_{n-1} + 1 is an integer multiple of n.
-/
def AgohGiugaCongr (n : ℕ) : Prop :=
  ∃ k : ℤ, (n : ℚ) * bernoulli' (n - 1) + 1 = k * n

/-
AgohGiugaCongrCorrect is the condition that n * B_{n-1} + 1 is congruent to 0 modulo n in the ring of rationals with denominator coprime to n.
-/
def AgohGiugaCongrCorrect (n : ℕ) : Prop :=
  ∃ (a b : ℤ), (b : ℤ).gcd n = 1 ∧ (n : ℚ) * bernoulli (n - 1) + 1 = n * (a / b)