/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ae78b0df-8bec-4294-8f55-71708ed93227

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Erdős–Straus conjecture and several structural lemmas and reductions.

Key definitions and theorems:
- `ErdosStraus n`: The proposition that 4/n can be written as a sum of three unit fractions.
- `erdos_straus_iff_int`: Equivalence to the integer equation 4xyz = n(yz + xz + xy).
- `erdos_straus_mul`: If the conjecture holds for n, it holds for any multiple of n.
- `erdos_straus_of_prime`: The conjecture holds for all n ≥ 2 if it holds for all primes.
- `erdos_straus_even`: The conjecture holds for all even numbers.
- `erdos_straus_mod_4_eq_3`: The conjecture holds for all n ≡ 3 (mod 4).
- `erdos_straus_mod_3_eq_0`: The conjecture holds for all n ≡ 0 (mod 3).
- `erdos_straus_reduction`: The conjecture reduces to checking primes p ≡ 1 (mod 12) or p ≡ 5 (mod 12).
- `checkErdosStraus`: A computable function that verifies the conjecture for a given n.
- `erdos_straus_upto_100`: A proof that the conjecture holds for all 2 ≤ n ≤ 100, using the computable checker.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Erdős–Straus conjecture states that for every integer n ≥ 2, the equation 4/n = 1/x + 1/y + 1/z has a solution in positive integers x, y, z.
-/
def ErdosStraus (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x ≠ 0 ∧ y ≠ 0 ∧ z ≠ 0 ∧ 4 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
The Erdős–Straus conjecture is equivalent to the existence of positive integers x, y, z such that 4xyz = n(yz + xz + xy).
-/
theorem erdos_straus_iff_int (n : ℕ) (hn : n ≠ 0) :
  ErdosStraus n ↔ ∃ x y z : ℕ, x ≠ 0 ∧ y ≠ 0 ∧ z ≠ 0 ∧ 4 * x * y * z = n * (y * z + x * z + x * y) := by
    constructor <;> rintro ⟨ x, y, z, hx, hy, hz, h ⟩;
    · exact ⟨ x, y, z, hx, hy, hz, by rw [ div_add_div, div_add_div, div_eq_div_iff ] at h <;> norm_cast at * <;> first |linarith|aesop ⟩;
    · use x, y, z;
      field_simp;
      simp_all +decide [ ← @Nat.cast_inj ];
      norm_cast; linarith;

/-
If the Erdős–Straus conjecture holds for n, it holds for any multiple k * n.
-/
theorem erdos_straus_mul (n k : ℕ) (hk : k ≠ 0) (h : ErdosStraus n) : ErdosStraus (k * n) := by
  -- By definition of ErdosStraus, there exist positive integers x, y, z such � that� 4/n = 1/x + 1/y + 1/z.
  obtain ⟨x, y, z, hx, hy, hz, h_eq⟩ := h;
  -- By definition of ErdosStraus, there exist positive integers x', y', z' such that 4/(k*n) = 1/x' + 1/y' + 1/z'.
  use k * x, k * y, k * z;
  simp_all +decide [ ← mul_add, div_eq_mul_inv ];
  linear_combination' h_eq * ( k : ℚ ) ⁻¹

/-
If the Erdős–Straus conjecture holds for all prime numbers, then it holds for all integers n ≥ 2.
-/
theorem erdos_straus_of_prime (h : ∀ p, p.Prime → ErdosStraus p) : ∀ n ≥ 2, ErdosStraus n := by
  intro n hn;
  -- Let's choose any prime factor p of n.
  obtain ⟨p, hp_prime, hp_div⟩ : ∃ p, Nat.Prime p ∧ p ∣ n := by
    exact Nat.exists_prime_and_dvd ( by linarith );
  -- Since $p$ is a prime factor of $n$, we can write $n = k * p$ for some integer $k$.
  obtain ⟨k, rfl⟩ : ∃ k, n = k * p := by
    exact exists_eq_mul_left_of_dvd hp_div;
  exact erdos_straus_mul p k ( by aesop_cat ) ( h p hp_prime )

/-
The Erdős–Straus conjecture holds for all positive even numbers n.
-/
theorem erdos_straus_even (n : ℕ) (h_even : n % 2 = 0) (h_pos : n ≠ 0) : ErdosStraus n := by
  -- Since n is even and non �-zero�, let n = 2m where m > 0.
  obtain ⟨m, hm_pos, rfl⟩ : ∃ m, 0 < m ∧ n = 2 * m := by
    exact ⟨ n / 2, Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero h_pos ) ( Nat.dvd_of_mod_eq_zero h_even ) ) zero_lt_two, by rw [ Nat.mul_div_cancel' ( Nat.dvd_of_mod_eq_zero h_even ) ] ⟩;
  rcases Nat.even_or_odd' m with ⟨ k, rfl | rfl ⟩;
  · use k + 1, 2 * k * (k + 1), 2 * k * (k + 1);
    field_simp;
    grind;
  · use k + 1, 2 * ( k + 1 ) * ( 2 * k + 1 ), 2 * ( k + 1 ) * ( 2 * k + 1 );
    field_simp;
    grind

/-
The Erdős–Straus conjecture holds for all n ≡ 3 (mod 4).
-/
theorem erdos_straus_mod_4_eq_3 (n : ℕ) (h : n % 4 = 3) : ErdosStraus n := by
  -- Let $n = 4k + 3$ for some integer $k$.
  obtain ⟨k, hk⟩ : ∃ k, n = 4 * k + 3 := by
    exact ⟨ n / 4, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let's choose $x = k + 1$, $y = 2(k + 1)(4k + 3)$, and $z = 2(k + 1)(4k + 3)$.
  use k + 1, 2 * (k + 1) * (4 * k + 3), 2 * (k + 1) * (4 * k + 3);
  -- Combine the fractions on the right-hand side.
  field_simp [hk]
  ring;
  exact ⟨ by positivity, by positivity, by positivity, by rw [ hk ] ; push_cast; nlinarith [ mul_inv_cancel₀ ( by positivity : ( 4 * k + 3 : ℚ ) ≠ 0 ) ] ⟩

/-
The Erdős–Straus conjecture holds for all n ≡ 0 (mod 3).
-/
theorem erdos_straus_mod_3_eq_0 (n : ℕ) (h : n % 3 = 0) (hn : n ≠ 0) : ErdosStraus n := by
  obtain ⟨ k, rfl ⟩ := Nat.dvd_of_mod_eq_zero h;
  -- Then $4/(3k) = 1/k + 1/(3k)$.
  have h1 : 4 / (3 * k : ℚ) = 1 / k + 1 / (3 * k) := by
    ring;
  exact ⟨ k, 6 * k, 6 * k, by aesop_cat, by aesop_cat, by aesop_cat, by simpa [ ← @Nat.cast_inj ℚ ] using h1.trans ( by ring ) ⟩

/-
The function checkErdosStraus correctly verifies the Erdős–Straus conjecture for a given n.
-/
def checkErdosStraus (n : ℕ) : Bool :=
  (List.range (n - n / 4)).any fun k =>
    let x := n / 4 + 1 + k
    let A := 4 * x - n
    let B := n * x
    -- We want 1/y + 1/z = A/B.
    -- y > B/A, y <= 2B/A.
    -- Range for y: from B/A + 1 to 2B/A.
    let lower_y := B / A + 1
    let upper_y := (2 * B) / A
    (List.range (upper_y - lower_y + 1)).any fun j =>
      let y := lower_y + j
      let num_z := B * y
      let den_z := A * y - B
      den_z > 0 ∧ num_z % den_z == 0

theorem checkErdosStraus_correct (n : ℕ) (hn : n ≠ 0) : checkErdosStraus n = true → ErdosStraus n := by
  unfold checkErdosStraus;
  simp +zetaDelta at *;
  intro x hx y hy hxy h_mod
  use x + n / 4 + 1, n * (n / 4 + 1 + x) / (4 * (n / 4 + 1 + x) - n) + 1 + y, (n * (n / 4 + 1 + x) * (n * (n / 4 + 1 + x) / (4 * (n / 4 + 1 + x) - n) + 1 + y)) / ((4 * (n / 4 + 1 + x) - n) * (n * (n / 4 + 1 + x) / (4 * (n / 4 + 1 + x) - n) + 1 + y) - n * (n / 4 + 1 + x));
  refine' ⟨ by positivity, by positivity, _, _ ⟩;
  · exact ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero h_mod ) ) ( Nat.sub_pos_of_lt hxy ) );
  · rw [ Nat.cast_div ];
    · field_simp;
      rw [ Nat.cast_sub ] <;> push_cast;
      · rw [ Nat.cast_sub ] <;> push_cast;
        · ring;
        · omega;
      · linarith;
    · exact Nat.dvd_of_mod_eq_zero h_mod;
    · exact ne_of_gt <| Nat.cast_pos.mpr <| Nat.sub_pos_of_lt hxy

/-
The Erdős–Straus conjecture reduces to checking prime numbers p such that p ≡ 1 (mod 12) or p ≡ 5 (mod 12).
-/
theorem erdos_straus_reduction (h1 : ∀ p, p.Prime → p % 12 = 1 → ErdosStraus p)
    (h5 : ∀ p, p.Prime → p % 12 = 5 → ErdosStraus p) :
    ∀ n ≥ 2, ErdosStraus n := by
      -- By combining the results for the primes and the reductions, we can conclude that the conjecture holds for all $n \geq 2$.
      have h_combined : ∀ p : ℕ, Nat.Prime p → p ≥ 2 → ErdosStraus p := by
        intro p hp hp2;
        by_cases h_mod4 : p % 4 = 3;
        · exact?;
        · by_cases h_mod3 : p % 3 = 0;
          · have := Nat.dvd_of_mod_eq_zero h_mod3; rw [ hp.dvd_iff_eq ] at this <;> aesop;
          · by_cases h_mod2 : p % 2 = 0;
            · cases Nat.Prime.eq_two_or_odd hp <;> simp_all +decide;
              exact erdos_straus_even 2 rfl ( by decide );
            · grind;
      exact erdos_straus_of_prime fun p hp => h_combined p hp hp.two_le

/-
The Erdős–Straus conjecture holds for all integers n between 2 and 100.
-/
theorem erdos_straus_upto_100 : ∀ n, 2 ≤ n → n ≤ 100 → ErdosStraus n := by
  intro n h_ge_2 h_le_100
  apply checkErdosStraus_correct n (by linarith)
  -- We verify the condition for each n in the range.
  -- Since n is a variable, we can't just use native_decide directly on the goal.
  -- We need to iterate or unroll.
  -- However, for a fixed n, checkErdosStraus n = true can be proved by native_decide.
  -- A clean way is to use a helper lemma for the range.
  native_decide +revert