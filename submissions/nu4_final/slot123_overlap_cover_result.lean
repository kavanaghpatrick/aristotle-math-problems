/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b4f5ba0e-5774-495f-9d81-0204db36e126

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

def isTriangleCover (G : SimpleGraph V) [DecidableRel G.Adj] (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧ ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

def T_pair (G : SimpleGraph V) [DecidableRel G.Adj] (A B : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ A).card ≥ 2 ∨ (t ∩ B).card ≥ 2)

/-- Bridges: triangles in the overlap of two T_pair sets -/
def bridges (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B C D : Finset V) : Finset (Finset V) :=
  T_pair G A B ∩ T_pair G C D

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A

variable {V : Type*} [Fintype V] [DecidableEq V]
variable {G : SimpleGraph V} [DecidableRel G.Adj] {M : Finset (Finset V)}

/-- The 4 "cycle edges" connecting adjacent shared vertices -/
def cycleEdges (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, cfg.v_bc), s(cfg.v_bc, cfg.v_cd), s(cfg.v_cd, cfg.v_da), s(cfg.v_da, cfg.v_ab)}

lemma mem_edgeFinset_of_mem_clique3 {G : SimpleGraph V} [DecidableRel G.Adj]
    {S : Finset V} (hS : S ∈ G.cliqueFinset 3)
    {u v : V} (hu : u ∈ S) (hv : v ∈ S) (huv : u ≠ v) :
    s(u, v) ∈ G.edgeFinset := by
  rw [SimpleGraph.mem_cliqueFinset_iff, SimpleGraph.isNClique_iff] at hS
  have := hS.1
  rw [SimpleGraph.isClique_iff] at this
  specialize this hu hv huv
  simp [SimpleGraph.edgeFinset, this]

lemma cycleEdges_subset_edgeFinset (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (h_distinct : cfg.v_ab ≠ cfg.v_bc ∧ cfg.v_bc ≠ cfg.v_cd ∧
                  cfg.v_cd ≠ cfg.v_da ∧ cfg.v_da ≠ cfg.v_ab) :
    cycleEdges cfg ⊆ G.edgeFinset := by
  intro e he
  simp only [cycleEdges, Finset.mem_insert, Finset.mem_singleton] at he
  rcases he with rfl | rfl | rfl | rfl
  · exact mem_edgeFinset_of_mem_clique3 (hM.1.1 cfg.hB) cfg.h_vab_B cfg.h_vbc_B h_distinct.1
  · exact mem_edgeFinset_of_mem_clique3 (hM.1.1 cfg.hC) cfg.h_vbc_C cfg.h_vcd_C h_distinct.2.1
  · exact mem_edgeFinset_of_mem_clique3 (hM.1.1 cfg.hD) cfg.h_vcd_D cfg.h_vda_D h_distinct.2.2.1
  · exact mem_edgeFinset_of_mem_clique3 (hM.1.1 cfg.hA) cfg.h_vda_A cfg.h_vab_A h_distinct.2.2.2

lemma cycleEdges_card (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (cfg : Cycle4 G M)
    (h_distinct : cfg.v_ab ≠ cfg.v_bc ∧ cfg.v_bc ≠ cfg.v_cd ∧
                  cfg.v_cd ≠ cfg.v_da ∧ cfg.v_da ≠ cfg.v_ab ∧
                  cfg.v_ab ≠ cfg.v_cd ∧ cfg.v_bc ≠ cfg.v_da) :
    (cycleEdges cfg).card = 4 := by
  simp only [cycleEdges]
  -- The 4 edges are distinct because endpoints are distinct
  rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> simp +decide [ *, Sym2.eq_swap ];
  · -- Since $cfg.v_ab \ne cfg.v_cd$ by hypothesis, we can conclude that $cfg.v_cd \ne cfg.v_ab$.
    apply Ne.symm; exact h_distinct.right.right.right.right.left;
  · -- Since $cfg.v_ab \neq cfg.v_da$ by $h_distinct$, the implication $cfg.v_ab = cfg.v_da \rightarrow \neg cfg.v_bc = cfg.v_ab$ is trivially true.
    intros h_eq
    exfalso
    apply h_distinct.right.right.right.left
    exact h_eq.symm

lemma bridge_overlap_helper {V : Type*} [DecidableEq V] (X Y t : Finset V)
    (ht : t.card = 3)
    (hXt : 2 ≤ (t ∩ X).card) (hYt : 2 ≤ (t ∩ Y).card) :
    (X ∩ Y).Nonempty := by
      -- Since $t$ has exactly 3 elements and both $(t \cap X)$ and $(t \cap Y)$ have at least 2 elements, their intersection must contain at least one element.
      have h_inter : (t ∩ X ∩ Y).card ≥ 1 := by
        have h_inter : (t ∩ X ∩ Y).card = (t ∩ X).card + (t ∩ Y).card - (t ∩ X ∪ t ∩ Y).card := by
          rw [ ← Finset.card_union_add_card_inter ];
          simp +decide [ Finset.inter_left_comm, Finset.inter_assoc ];
        exact h_inter.symm ▸ Nat.sub_pos_of_lt ( by linarith [ show ( t ∩ X ∪ t ∩ Y ).card ≤ 3 by exact le_trans ( Finset.card_le_card ( Finset.union_subset ( Finset.inter_subset_left ) ( Finset.inter_subset_left ) ) ) ht.le ] );
      exact Exists.elim ( Finset.card_pos.mp h_inter ) fun x hx => ⟨ x, by aesop ⟩

lemma bridge_intersect_vertex {V : Type*} [DecidableEq V] (X Y t : Finset V)
    (ht : t.card = 3)
    (hXt : 2 ≤ (t ∩ X).card) (hYt : 2 ≤ (t ∩ Y).card)
    {v : V} (hXY : X ∩ Y = {v}) :
    v ∈ t := by
      -- Assume for contradiction that $v \notin t$.
      by_contra hv_not_in_t;
      -- If $v \notin t$, then $t \cap X$ and $t \cap Y$ must be subsets of $t \setminus \{v\}$.
      have h_subset : t ∩ X ⊆ t \ {v} ∧ t ∩ Y ⊆ t \ {v} := by
        grind;
      have h_card : (t ∩ X) ∩ (t ∩ Y) = ∅ := by
        simp_all +decide [ Finset.ext_iff ];
      have := Finset.card_union_add_card_inter ( t ∩ X ) ( t ∩ Y ) ; simp_all +decide ;
      exact absurd ( this ▸ Finset.card_le_card ( show t ∩ X ∪ t ∩ Y ⊆ t \ { v } from Finset.union_subset h_subset.1 h_subset.2 ) ) ( by simp +decide [ *, Finset.card_sdiff ] ; omega )

def trianglesContainingFirst (G : SimpleGraph V) [DecidableRel G.Adj]
    (v : V) (excluded : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => v ∈ t ∧ ∀ w ∈ excluded, w ∉ t)

def privateVertex (A : Finset V) (v1 v2 : V) : V :=
  if h : (A \ {v1, v2}).Nonempty then Classical.choose h else v1

def solutionCover (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  cycleEdges cfg ∪
  {s(cfg.v_ab, privateVertex cfg.A cfg.v_da cfg.v_ab),
   s(cfg.v_bc, privateVertex cfg.B cfg.v_ab cfg.v_bc),
   s(cfg.v_cd, privateVertex cfg.C cfg.v_bc cfg.v_cd),
   s(cfg.v_da, privateVertex cfg.D cfg.v_cd cfg.v_da)}

def edges_at (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) (K : Finset V) : Finset (Sym2 V) :=
  (K.erase v).image (s(v, ·))

lemma edges_at_subset (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) (K : Finset V) (hK : K ∈ G.cliqueFinset 3) (hv : v ∈ K) :
  edges_at G v K ⊆ G.edgeFinset := by
  intro e he
  simp only [edges_at, Finset.mem_image, Finset.mem_erase] at he
  rcases he with ⟨u, ⟨hu_ne, hu_in⟩, rfl⟩
  exact mem_edgeFinset_of_mem_clique3 hK hv hu_in (Ne.symm hu_ne)

def private_neighbors (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (K : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => t ∉ M ∧ t ∩ K ∈ K.powerset.filter (fun s => s.card = 2) ∧ ∀ L ∈ M, L ≠ K → (t ∩ L).card ≤ 1)

def edges_at_vertex (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) (K : Finset V) : Finset (Sym2 V) :=
  (K.erase v).image (s(v, ·))

def neighbors_on_edge (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Sym2 V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => t ∉ M ∧ e ∈ t.sym2)

lemma edges_at_vertex_card (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) (K : Finset V) (hK : K ∈ G.cliqueFinset 3) (hv : v ∈ K) :
  (edges_at_vertex G v K).card = 2 := by
    unfold edges_at_vertex;
    -- Since $K$ is a clique of size 3, $K.erase v$ has exactly 2 elements.
    have h_card_erase : (K.erase v).card = 2 := by
      -- Since $K$ is a clique of size 3, its cardinality is 3.
      have hK_card : K.card = 3 := by
        exact Finset.mem_filter.mp hK |>.2.2;
      rw [ Finset.card_erase_of_mem hv, hK_card ];
    -- Since the function $s(v, x)$ is injective, the cardinality of the image is the same as the cardinality of the domain.
    have h_inj : Function.Injective (fun x => s(v, x)) := by
      intro x y; aesop;
    rw [ Finset.card_image_of_injective _ h_inj, h_card_erase ]

def private_neighbors_set (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (K : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => t ∉ M ∧ t ∩ K ∈ K.powerset.filter (fun s => s.card = 2) ∧ ∀ L ∈ M, L ≠ K → (t ∩ L).card ≤ 1)

lemma disjoint_bridges_empty {V : Type*} [DecidableEq V] (X Y t : Finset V)
    (ht : t.card = 3)
    (hXt : 2 ≤ (t ∩ X).card) (hYt : 2 ≤ (t ∩ Y).card)
    (h_disjoint : X ∩ Y = ∅) : False := by
  have h_nonempty := bridge_overlap_helper X Y t ht hXt hYt
  rw [h_disjoint] at h_nonempty
  simp at h_nonempty

lemma bridges_classification {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B C D : Finset V) (t : Finset V)
    (ht : t ∈ bridges G A B C D)
    (ht_card : t.card = 3)
    (hAC : A ∩ C = ∅)
    (hBD : B ∩ D = ∅) :
    ((t ∩ A).card ≥ 2 ∧ (t ∩ D).card ≥ 2) ∨ ((t ∩ B).card ≥ 2 ∧ (t ∩ C).card ≥ 2) := by
  simp only [bridges, Finset.mem_inter, T_pair, Finset.mem_filter] at ht
  obtain ⟨⟨_, hAB⟩, ⟨_, hCD⟩⟩ := ht
  rcases hAB with hA | hB <;> rcases hCD with hC | hD
  · -- A and C
    exfalso
    exact disjoint_bridges_empty A C t ht_card hA hC hAC
  · -- A and D
    left
    exact ⟨hA, hD⟩
  · -- B and C
    right
    exact ⟨hB, hC⟩
  · -- B and D
    exfalso
    exact disjoint_bridges_empty B D t ht_card hB hD hBD

lemma triangle_structure (G : SimpleGraph V) [DecidableRel G.Adj]
    (K : Finset V) (hK : K ∈ G.cliqueFinset 3)
    (v1 v2 : V) (hv1 : v1 ∈ K) (hv2 : v2 ∈ K) (hne : v1 ≠ v2) :
    let u := privateVertex K v1 v2
    K = {v1, v2, u} := by
      -- Since $K$ has three elements and $v1$ and $v2$ are already in $K$, the remaining element must be $u$.
      have hK_card : K.card = 3 := by
        -- By definition of cliqueFinset, if K is in G.cliqueFinset 3, then K is a clique of size 3.
        have hK_card : K.card = 3 := by
          have := hK
          exact Finset.mem_filter.mp this |>.2.2;
        exact hK_card;
      have hK_subset : K ⊆ {v1, v2, privateVertex K v1 v2} := by
        intro x hx; by_cases hx1 : x = v1 <;> by_cases hx2 : x = v2 <;> simp_all +decide ;
        unfold privateVertex;
        split_ifs with h;
        · have := Classical.choose_spec h; simp_all +decide [ Finset.Nonempty ] ;
          have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset hx ( Finset.insert_subset hv1 ( Finset.singleton_subset_iff.mpr hv2 ) ) ) ; aesop;
        · exact False.elim ( h ⟨ x, by aesop ⟩ );
      refine' Finset.eq_of_subset_of_card_le hK_subset _;
      exact le_trans ( Finset.card_insert_le _ _ ) ( by exact le_trans ( add_le_add_right ( Finset.card_insert_le _ _ ) _ ) ( by simp +decide [ * ] ) )

def private_edges (cfg : Cycle4 G M) (K : Finset V) : Finset (Sym2 V) :=
  if h : K = cfg.A then {s(cfg.v_da, privateVertex cfg.A cfg.v_da cfg.v_ab), s(cfg.v_ab, privateVertex cfg.A cfg.v_da cfg.v_ab)}
  else if h : K = cfg.B then {s(cfg.v_ab, privateVertex cfg.B cfg.v_ab cfg.v_bc), s(cfg.v_bc, privateVertex cfg.B cfg.v_ab cfg.v_bc)}
  else if h : K = cfg.C then {s(cfg.v_bc, privateVertex cfg.C cfg.v_bc cfg.v_cd), s(cfg.v_cd, privateVertex cfg.C cfg.v_bc cfg.v_cd)}
  else {s(cfg.v_cd, privateVertex cfg.D cfg.v_cd cfg.v_da), s(cfg.v_da, privateVertex cfg.D cfg.v_cd cfg.v_da)}

lemma triangle_structure_explicit (G : SimpleGraph V) [DecidableRel G.Adj]
    (K : Finset V) (hK : K ∈ G.cliqueFinset 3)
    (v1 v2 : V) (hv1 : v1 ∈ K) (hv2 : v2 ∈ K) (hne : v1 ≠ v2) :
    let u := privateVertex K v1 v2
    K = {v1, v2, u} := by
      -- By definition of privateVertex, we know that K = {v1, v2, privateVertex K v1 v2} follows directly from the lemma triangle_structure.
      apply triangle_structure G K hK v1 v2 hv1 hv2 hne

lemma triangle_structure_helper {V : Type*} [DecidableEq V] (K : Finset V) (hK : K.card = 3) (v1 v2 : V) (hv1 : v1 ∈ K) (hv2 : v2 ∈ K) (hne : v1 ≠ v2) :
  K = {v1, v2, privateVertex K v1 v2} := by
    -- Since $K$ has exactly three elements and $v1$ and $v2$ are distinct, the remaining element must be $privateVertex K v1 v2$.
    have h_card : (K \ {v1, v2}).card = 1 := by
      grind;
    have h_private : privateVertex K v1 v2 ∈ K ∧ privateVertex K v1 v2 ≠ v1 ∧ privateVertex K v1 v2 ≠ v2 := by
      unfold privateVertex;
      split_ifs with h;
      · have := Classical.choose_spec h; aesop;
      · exact False.elim ( h ( Finset.card_pos.mp ( by rw [ h_card ] ; decide ) ) );
    -- Since K has exactly three elements and we already have v1 and v2 in K, the third element must be the private vertex.
    have h_card_eq : K.card = ({v1, v2, privateVertex K v1 v2} : Finset V).card := by
      grind;
    rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ hv1, Finset.insert_subset_iff.mpr ⟨ hv2, Finset.singleton_subset_iff.mpr h_private.1 ⟩ ⟩ ) ] ; aesop

lemma triangle_structure_v2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (K : Finset V) (hK : K ∈ G.cliqueFinset 3)
    (v1 v2 : V) (hv1 : v1 ∈ K) (hv2 : v2 ∈ K) (hne : v1 ≠ v2) :
    let u := privateVertex K v1 v2
    K = {v1, v2, u} := by
      -- Apply the lemma that states K is equal to {v1, v2, u} where u is the private vertex.
      apply triangle_structure_explicit G K hK v1 v2 hv1 hv2 hne

def is_busy (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (K : Finset V) : Prop :=
  (private_neighbors G M K).Nonempty

def target_triangles_A (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) : Finset (Finset V) :=
  private_neighbors G M cfg.A ∪
  (if is_busy G M cfg.A then ∅ else bridges G cfg.A cfg.B cfg.C cfg.D) ∪
  (if is_busy G M cfg.D then bridges G cfg.D cfg.A cfg.B cfg.C else ∅)

def target_triangles_B (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) : Finset (Finset V) :=
  private_neighbors G M cfg.B ∪
  (if is_busy G M cfg.B then ∅ else bridges G cfg.B cfg.C cfg.D cfg.A) ∪
  (if is_busy G M cfg.A then bridges G cfg.A cfg.B cfg.C cfg.D else ∅)

def target_triangles_C (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) : Finset (Finset V) :=
  private_neighbors G M cfg.C ∪
  (if is_busy G M cfg.C then ∅ else bridges G cfg.C cfg.D cfg.A cfg.B) ∪
  (if is_busy G M cfg.B then bridges G cfg.B cfg.C cfg.D cfg.A else ∅)

def target_triangles_D (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) : Finset (Finset V) :=
  private_neighbors G M cfg.D ∪
  (if is_busy G M cfg.D then ∅ else bridges G cfg.D cfg.A cfg.B cfg.C) ∪
  (if is_busy G M cfg.C then bridges G cfg.C cfg.D cfg.A cfg.B else ∅)

def is_private_bridge (cfg : Cycle4 G M) (t : Finset V) : Prop :=
  ((t ∩ cfg.A).card ≥ 2 ∧ (t ∩ cfg.D).card ≥ 2 ∧ cfg.v_ab ∉ t ∧ cfg.v_cd ∉ t) ∨
  ((t ∩ cfg.B).card ≥ 2 ∧ (t ∩ cfg.C).card ≥ 2 ∧ cfg.v_ab ∉ t ∧ cfg.v_cd ∉ t)