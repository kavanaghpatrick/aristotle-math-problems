/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7039b275-fb54-4b6e-908e-485e5f064f8f
-/

/-
We have successfully disproved the conjecture that "all external triangles at a shared vertex v in Cycle4 share a common external vertex x".

We constructed a counterexample `CounterexampleG` with 10 vertices and a maximum packing `M_cex` of size 4 forming a `Cycle4` configuration.
In this graph:
- `M_cex = {A, B, C, D}` where `A={0,1,2}`, `B={0,3,4}`, `C={3,7,8}`, `D={7,1,9}`.
- The shared vertex `v_ab` is `0`.
- There are two external triangles at `0`: `T1 = {0, 1, 5}` and `T2 = {0, 3, 6}`.
- `T1` shares the edge `{0, 1}` with `A`.
- `T2` shares the edge `{0, 3}` with `B`.
- `T1` and `T2` intersect only at `{0}`. They do not share an edge, and thus do not share a common external vertex.
- We proved that `M_cex` is a maximum packing (`trianglePackingNumber = 4`).
- We proved that `T1` and `T2` are valid external triangles.
- We proved that `T1` and `T2` do not share an edge.

This demonstrates that the "bipartite link graph" argument for external triangles forming a star does not hold in general for `Cycle4` configurations, as it is possible to have disjoint external triangles that use edges from different M-triangles without contradicting the maximality of M (since swapping {A, B} for {T1, T2} preserves the packing size of 4).

The file `slot131_disproof.lean` contains the formal proof of this counterexample.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS (standard Tuza setup)
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

/-- M-edges incident to vertex v -/
def M_edges_at (M : Finset (Finset V)) (v : V) : Finset (Sym2 V) :=
  M.biUnion (fun X => X.sym2.filter (fun e => v ∈ e))

/-- Triangles that share an M-edge containing v -/
def trianglesSharingMEdgeAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => ∃ e ∈ M_edges_at M v, e ∈ t.sym2)

/-- External triangles at v: those sharing M-edge at v but NOT in M -/
def externalTrianglesAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  trianglesSharingMEdgeAt G M v \ M

-- ══════════════════════════════════════════════════════════════════════════════
-- CYCLE_4 STRUCTURE (from slot128 proven)
-- ══════════════════════════════════════════════════════════════════════════════

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A
  h_diag_AC : (A ∩ C).card ≤ 1
  h_diag_BD : (B ∩ D).card ≤ 1
  -- Distinctness (from slot127 proven)
  h_vab_ne_vbc : v_ab ≠ v_bc
  h_vbc_ne_vcd : v_bc ≠ v_cd
  h_vcd_ne_vda : v_cd ≠ v_da
  h_vda_ne_vab : v_da ≠ v_ab

-- ══════════════════════════════════════════════════════════════════════════════
-- HELPER LEMMAS
-- ══════════════════════════════════════════════════════════════════════════════

lemma triangle_card_eq_3 (G : SimpleGraph V) [DecidableRel G.Adj]
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) : t.card = 3 := by
      -- By definition of cliqueFinset, any element in it has cardinality 3.
      simp [SimpleGraph.cliqueFinset] at ht;
      -- By definition of `IsNClique`, we know that `t` is a clique of size 3.
      apply ht.2

lemma mem_inter_iff' (v : V) (A B : Finset V) : v ∈ A ∩ B ↔ v ∈ A ∧ v ∈ B := by
  -- By definition of intersection, $v \in A \cap B$ if and only if $v \in A$ and $v \in B$. This follows directly from the definition of Finset.mem_inter.
  simp [Finset.mem_inter]

-- ══════════════════════════════════════════════════════════════════════════════
-- KEY LEMMA: External triangles contain v (proven structure)
-- ══════════════════════════════════════════════════════════════════════════════

lemma triangle_sharing_M_edge_contains_v (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (t : Finset V)
    (ht : t ∈ trianglesSharingMEdgeAt G M v) : v ∈ t := by
      -- If there's an edge $e$ in $M_edges_at M v$ that's also in $t.sym2$, then $e$ must be $\{v, w\}$ for some $w$, implying $v \in t$.
      obtain ⟨e, heM, heT⟩ : ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
        unfold trianglesSharingMEdgeAt at ht; aesop;
      unfold M_edges_at at heM; aesop;

lemma external_triangle_contains_v (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (t : Finset V)
    (ht : t ∈ externalTrianglesAt G M v) : v ∈ t := by
      -- By definition of `externalTrianglesAt`, if `t` is in `externalTrianglesAt G M v`, then `t` is in `trianglesSharingMEdgeAt G M v`.
      have ht_triangle : t ∈ trianglesSharingMEdgeAt G M v := by
        -- By definition of `externalTrianglesAt`, if `t` is in `externalTrianglesAt G M v`, then `t` is in `trianglesSharingMEdgeAt G M v` and not in `M`.
        apply Finset.mem_sdiff.mp ht |>.1;
      -- By definition of `trianglesSharingMEdgeAt`, if `t` is in `trianglesSharingMEdgeAt G M v`, then `t` is in `G.cliqueFinset 3` and there exists an edge in `M_edges_at M v` that is in `t.sym2`.
      obtain ⟨ht_clique, ht_edge⟩ : t ∈ G.cliqueFinset 3 ∧ ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
        unfold trianglesSharingMEdgeAt at ht_triangle; aesop;
      obtain ⟨ e, he₁, he₂ ⟩ := ht_edge;
      unfold M_edges_at at he₁; aesop;

/-- A triangle t at v uses an M-edge from component K -/
def uses_M_edge_from (M : Finset (Finset V)) (v : V) (K : Finset V) (t : Finset V) : Prop :=
  ∃ e ∈ M_edges_at {K} v, e ∈ t.sym2

lemma v_ab_not_in_C (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (cfg : Cycle4 G M) : cfg.v_ab ∉ cfg.C := by
  intro h
  have h_in_BC : cfg.v_ab ∈ cfg.B ∩ cfg.C := Finset.mem_inter.mpr ⟨cfg.h_vab_B, h⟩
  rw [cfg.hBC] at h_in_BC
  have : cfg.v_ab = cfg.v_bc := Finset.mem_singleton.mp h_in_BC
  exact cfg.h_vab_ne_vbc this

lemma v_ab_not_in_D (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (cfg : Cycle4 G M) : cfg.v_ab ∉ cfg.D := by
  intro h
  have h_in_DA : cfg.v_ab ∈ cfg.D ∩ cfg.A := Finset.mem_inter.mpr ⟨h, cfg.h_vab_A⟩
  rw [cfg.hDA] at h_in_DA
  have : cfg.v_ab = cfg.v_da := Finset.mem_singleton.mp h_in_DA
  exact cfg.h_vda_ne_vab.symm this

/-- Two sets share an edge if they share at least 2 vertices -/
def shares_edge (s t : Finset V) : Prop := (s ∩ t).card ≥ 2

/-- T bridges K1 and K2 if it shares an edge with both -/
def is_bridge (T K1 K2 : Finset V) : Prop := shares_edge T K1 ∧ shares_edge T K2

/-- T is disjoint from K except at v -/
def disjoint_except_v (T K : Finset V) (v : V) : Prop := T ∩ K ⊆ {v}

/-- T is pure on K if it uses an edge from K and is edge-disjoint from all other M-triangles -/
def is_pure_on (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (K : Finset V) (T : Finset V) : Prop :=
  uses_M_edge_from M v K T ∧
  ∀ K' ∈ M, K' ≠ K → ¬ shares_edge T K'

def packing_from_pure (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) (T1 T2 : Finset V) : Finset (Finset V) :=
  {T1, T2, cfg.B, cfg.C, cfg.D}

lemma packing_from_pure_is_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (v : V) (hv : v = cfg.v_ab)
    (T1 T2 : Finset V)
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (h_pure1 : is_pure_on G M v cfg.A T1)
    (h_pure2 : is_pure_on G M v cfg.A T2)
    (h_not_share : ¬ shares_edge T1 T2) :
    isTrianglePacking G (packing_from_pure G M cfg T1 T2) := by
  unfold packing_from_pure
  constructor
  · -- All elements are triangles
    intro t ht
    simp at ht
    rcases ht with rfl | rfl | rfl | rfl | rfl
    · exact (Finset.mem_filter.mp (Finset.mem_sdiff.mp hT1).1).1
    · exact (Finset.mem_filter.mp (Finset.mem_sdiff.mp hT2).1).1
    · exact hM.1.1 cfg.hB
    · exact hM.1.1 cfg.hC
    · exact hM.1.1 cfg.hD
  · -- Pairwise intersections are <= 1
    -- Since $T1$ and $T2$ are pure on $A$ and use the same edge $AB$, they cannot share any edge.
    have h_not_share : ∀ t ∈ ({cfg.B, cfg.C, cfg.D} : Finset (Finset V)), ¬shares_edge T1 t ∧ ¬shares_edge T2 t := by
      intro t ht
      have h_not_share_t : ∀ K ∈ M, K ≠ cfg.A → ¬shares_edge T1 K ∧ ¬shares_edge T2 K := by
        exact fun K hK hK' => ⟨ h_pure1.2 K hK hK', h_pure2.2 K hK hK' ⟩;
      apply h_not_share_t;
      · simp +zetaDelta at *;
        rcases ht with ( rfl | rfl | rfl ) <;> [ exact cfg.hB; exact cfg.hC; exact cfg.hD ];
      · rcases cfg with ⟨ A, B, C, D, hA, hB, hC, hD, hM_eq, v_ab, v_bc, v_cd, v_da, hAB, hBC, hCD, hDA, h_vab_A, h_vab_B, h_vbc_B, h_vbc_C, h_vcd_C, h_vcd_D, h_vda_D, h_vda_A, h_diag_AC, h_diag_BD, h_vab_ne_vbc, h_vbc_ne_vcd, h_vcd_ne_vda, h_vda_ne_vab ⟩ ; aesop;
        exact h_diag_AC.not_lt ( Finset.one_lt_card.mpr ⟨ v, h_vab_A, v_bc, h_vbc_C, by aesop ⟩ );
    simp_all +decide [ Set.Pairwise, shares_edge ];
    simp_all +decide [ Finset.inter_comm, Nat.lt_succ_iff ];
    have := cfg.hBC; have := cfg.hCD; have := cfg.hDA; simp_all +decide [ Finset.inter_comm ] ;
    have := cfg.h_diag_BD; simp_all +decide [ Finset.inter_comm ] ;

lemma packing_from_pure_card_eq_5 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (v : V) (hv : v = cfg.v_ab)
    (T1 T2 : Finset V)
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (hne : T1 ≠ T2) :
    (packing_from_pure G M cfg T1 T2).card = 5 := by
      -- Since T1 and T2 are distinct and each is distinct from cfg.B, cfg.C, and cfg.D, the set {T1, T2, cfg.B, cfg.C, cfg.D} has exactly 5 elements.
      have h_distinct : T1 ≠ T2 ∧ T1 ≠ cfg.B ∧ T1 ≠ cfg.C ∧ T1 ≠ cfg.D ∧ T2 ≠ cfg.B ∧ T2 ≠ cfg.C ∧ T2 ≠ cfg.D ∧ cfg.B ≠ cfg.C ∧ cfg.B ≠ cfg.D ∧ cfg.C ≠ cfg.D := by
        refine' ⟨ hne, _, _, _, _, _, _, _, _, _ ⟩ <;> intro h <;> simp_all +decide [ externalTrianglesAt ];
        all_goals rcases cfg with ⟨ A, B, C, D, hA, hB, hC, hD, hM_eq, v_ab, v_bc, v_cd, v_da, hAB, hBC, hCD, hDA, h_vab_A, h_vab_B, h_vbc_B, h_vbc_C, h_vcd_C, h_vcd_D, h_vda_D, h_vda_A, h_diag_AC, h_diag_BD, h_vab_ne_vbc, h_vbc_ne_vcd, h_vcd_ne_vda, h_vda_ne_vab ⟩ ; simp_all +decide [ Finset.ext_iff ] ;
        · simp_all +decide [ Finset.ext_iff ];
        · simp_all +decide [ Finset.ext_iff ];
          grind +ring;
        · simp_all +decide [ Finset.ext_iff ];
      unfold packing_from_pure;
      aesop

lemma share_edge_of_pure_on_A (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (v : V) (hv : v = cfg.v_ab)
    (T1 T2 : Finset V)
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (h_pure1 : is_pure_on G M v cfg.A T1)
    (h_pure2 : is_pure_on G M v cfg.A T2) :
    shares_edge T1 T2 := by
      contrapose! h_pure1;
      intro h;
      have h_card : (packing_from_pure G M cfg T1 T2).card = 5 := by
        apply packing_from_pure_card_eq_5 G M hM cfg v hv T1 T2 hT1 hT2;
        rintro rfl;
        unfold shares_edge at h_pure1; simp_all +decide ;
        interval_cases _ : T1.card <;> simp_all +decide [ externalTrianglesAt ];
        · unfold trianglesSharingMEdgeAt at hT1; simp_all +decide ;
        · obtain ⟨ v, hv ⟩ := Finset.card_eq_one.mp ‹_›; simp_all +decide [ trianglesSharingMEdgeAt ] ;
      have h_card_le : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ M.card := by
        intro S hS
        have h_card_le : S.card ≤ trianglePackingNumber G := by
          have h_card_le : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ (Finset.image Finset.card ((G.cliqueFinset 3).powerset.filter (isTrianglePacking G))).max.getD 0 := by
            intro S hS
            have h_card_le : S.card ∈ Finset.image Finset.card ((G.cliqueFinset 3).powerset.filter (isTrianglePacking G)) := by
              simp +zetaDelta at *;
              exact ⟨ S, ⟨ hS.1, hS ⟩, rfl ⟩;
            have := Finset.le_max h_card_le;
            cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 ).powerset ) ) <;> aesop;
          exact h_card_le S hS;
        exact h_card_le.trans ( hM.2.ge );
      have h_card_le : M.card ≤ 4 := by
        rw [ cfg.hM_eq ];
        exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ ) _;
      linarith [ ‹∀ S : Finset ( Finset V ), isTrianglePacking G S → S.card ≤ M.card› ( packing_from_pure G M cfg T1 T2 ) ( packing_from_pure_is_packing G M hM cfg v hv T1 T2 hT1 hT2 h h_pure2 h_pure1 ) ]

def packing_swap_AB (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (cfg : Cycle4 G M) (T1 T2 : Finset V) : Finset (Finset V) :=
  {T1, T2, cfg.C, cfg.D}

lemma packing_swap_AB_is_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (v : V) (hv : v = cfg.v_ab)
    (T1 T2 : Finset V)
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (h_pure1 : is_pure_on G M v cfg.A T1)
    (h_pure2 : is_pure_on G M v cfg.B T2)
    (h_not_share : ¬ shares_edge T1 T2) :
    isTrianglePacking G (packing_swap_AB G M cfg T1 T2) := by
  unfold packing_swap_AB
  constructor
  · -- All elements are triangles
    intro t ht
    simp at ht
    rcases ht with rfl | rfl | rfl | rfl
    · exact (Finset.mem_filter.mp (Finset.mem_sdiff.mp hT1).1).1
    · exact (Finset.mem_filter.mp (Finset.mem_sdiff.mp hT2).1).1
    · exact hM.1.1 cfg.hC
    · exact hM.1.1 cfg.hD
  · -- Pairwise intersections are <= 1
    simp [Set.Pairwise]
    -- We need to check all pairs.
    -- T1, T2:
    -- h_not_share implies |T1 ∩ T2| <= 1.
    -- T1, C: pure on A => disjoint from C (since C != A)
    -- T1, D: pure on A => disjoint from D (since D != A)
    -- T2, C: pure on B => disjoint from C (since C != B)
    -- T2, D: pure on B => disjoint from D (since D != B)
    -- C, D: disjoint by M packing
    -- By definition of $Cycle4$, we know that $T1$ and $T2$ do not share any edges with $cfg.A$ or $cfg.B$, and neither do they share with $cfg.C$ or $cfg.D$.
    have h_disjoint : (T1 ∩ cfg.C).card ≤ 1 ∧ (T1 ∩ cfg.D).card ≤ 1 ∧ (T2 ∩ cfg.C).card ≤ 1 ∧ (T2 ∩ cfg.D).card ≤ 1 := by
      refine' ⟨ _, _, _, _ ⟩;
      · have := h_pure1.2 cfg.C ( by
          exact cfg.hC ) ( by
          have := cfg.hCD; simp_all +decide ;
          have := cfg.hDA; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
          have := cfg.h_vcd_ne_vda; aesop; );
        contrapose! this;
        exact this;
      · have := h_pure1.2 cfg.D;
        by_cases h : cfg.D = cfg.A <;> simp_all +decide [ shares_edge ];
        · cases cfg ; aesop;
        · exact Nat.le_of_lt_succ ( this ( cfg.hD ) );
      · have := h_pure2.2 cfg.C (by
        exact cfg.hC) (by
        cases cfg ; aesop);
        exact Nat.le_of_not_lt fun h => this <| by exact le_trans ( by decide ) h;
      · have := h_pure2.2 cfg.D ( by
          exact cfg.hD ) ( by
          rintro h; have := cfg.h_vda_ne_vab; simp_all +decide [ Finset.ext_iff ];
          have := cfg.h_vda_A; have := cfg.h_vda_D; simp_all +decide [ Finset.ext_iff ] ;
          have := cfg.hAB; simp_all +decide [ Finset.ext_iff ] ;
          grind );
        exact Nat.le_of_not_lt fun h => this <| by exact Nat.succ_le_of_lt h;
    -- By definition of $Cycle4$, we know that $cfg.C$ and $cfg.D$ share exactly one vertex.
    have h_cd : (cfg.C ∩ cfg.D).card ≤ 1 := by
      have := cfg.hCD; aesop;
    simp_all +decide [ Finset.inter_comm ];
    exact ⟨ fun _ => le_of_not_gt fun h => h_not_share <| by exact Nat.succ_le_of_lt h, fun _ => le_of_not_gt fun h => h_not_share <| by exact Nat.succ_le_of_lt h ⟩

lemma packing_swap_AB_card_eq_4 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (v : V) (hv : v = cfg.v_ab)
    (T1 T2 : Finset V)
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (h_pure1 : is_pure_on G M v cfg.A T1)
    (h_pure2 : is_pure_on G M v cfg.B T2)
    (h_not_share : ¬ shares_edge T1 T2) :
    (packing_swap_AB G M cfg T1 T2).card = 4 := by
      -- Since T1 and T2 are distinct and cfg.C and cfg.D are also distinct and different from each other, the set {T1, T2, cfg.C, cfg.D} has exactly four elements.
      have h_distinct : T1 ≠ T2 ∧ cfg.C ≠ cfg.D ∧ T1 ≠ cfg.C ∧ T1 ≠ cfg.D ∧ T2 ≠ cfg.C ∧ T2 ≠ cfg.D := by
        have h_distinct : T1 ≠ T2 ∧ cfg.C ≠ cfg.D := by
          -- Since T1 and T2 are external triangles at v and they don't share an edge, they must be distinct.
          have hT1T2 : T1 ≠ T2 := by
            rintro rfl;
            -- Since any set shares an edge with itself, we have a contradiction with h_not_share.
            simp [shares_edge] at h_not_share;
            have := triangle_card_eq_3 G T1 ( Finset.mem_filter.mp ( Finset.mem_sdiff.mp hT1 |>.1 ) |>.1 ) ; interval_cases _ : T1.card <;> simp_all +decide ;
          cases cfg ; aesop;
        have h_distinct : T1 ≠ cfg.C ∧ T1 ≠ cfg.D ∧ T2 ≠ cfg.C ∧ T2 ≠ cfg.D := by
          have hT1_not_in_M : T1 ∉ M := by
            unfold externalTrianglesAt at hT1; aesop;
          have hT2_not_in_M : T2 ∉ M := by
            exact Finset.mem_sdiff.mp hT2 |>.2
          exact ⟨ fun h => hT1_not_in_M <| h.symm ▸ cfg.hC, fun h => hT1_not_in_M <| h.symm ▸ cfg.hD, fun h => hT2_not_in_M <| h.symm ▸ cfg.hC, fun h => hT2_not_in_M <| h.symm ▸ cfg.hD ⟩;
        grind;
      unfold packing_swap_AB; simp +decide [ *, Finset.card_insert_of_notMem ] ;

def v0 : Fin 10 := 0
def v1 : Fin 10 := 1
def v2 : Fin 10 := 2
def v3 : Fin 10 := 3
def v4 : Fin 10 := 4
def v5 : Fin 10 := 5
def v6 : Fin 10 := 6
def v7 : Fin 10 := 7
def v8 : Fin 10 := 8
def v9 : Fin 10 := 9

def CounterexampleEdges : List (Sym2 (Fin 10)) :=
  [s(v0, v1), s(v1, v2), s(v2, v0), -- A
   s(v0, v3), s(v3, v4), s(v4, v0), -- B
   s(v3, v7), s(v7, v8), s(v8, v3), -- C
   s(v7, v1), s(v1, v9), s(v9, v7), -- D
   s(v0, v5), s(v1, v5),          -- T1 (uses {0, 1} from A)
   s(v0, v6), s(v3, v6)]          -- T2 (uses {0, 3} from B)

def CounterexampleG : SimpleGraph (Fin 10) :=
  SimpleGraph.fromEdgeSet (CounterexampleEdges.toFinset)

def A_cex : Finset (Fin 10) := {v0, v1, v2}
def B_cex : Finset (Fin 10) := {v0, v3, v4}
def C_cex : Finset (Fin 10) := {v3, v7, v8}
def D_cex : Finset (Fin 10) := {v7, v1, v9}

def M_cex : Finset (Finset (Fin 10)) := {A_cex, B_cex, C_cex, D_cex}

def T1_cex : Finset (Fin 10) := {v0, v1, v5}
def T2_cex : Finset (Fin 10) := {v0, v3, v6}

def Cycle4_cex : Cycle4 CounterexampleG M_cex :=
  { A := A_cex,
    B := B_cex,
    C := C_cex,
    D := D_cex,
    hA := by
      -- By definition of $M_cex$, we know that $A_cex \in M_cex$.
      simp [M_cex],
    hB := by
      -- By definition of $M_cex$, we know that $B_cex \in M_cex$.
      simp [M_cex],
    hC := by
      -- By definition of $M_cex$, we know that $C_cex \in M_cex$.
      simp [M_cex],
    hD := by
      -- By definition of $M_cex$, we know that $D_cex \in M_cex$.
      simp [M_cex],
    hM_eq := rfl,
    v_ab := v0,
    v_bc := v3,
    v_cd := v7,
    v_da := v1,
    hAB := by
      decide +revert,
    hBC := by
      exact?,
    hCD := by
      decide +kernel,
    hDA := by
      -- To prove the intersection is {v1}, we can show that v1 is in both D_cex and A_cex, and no other elements are in both.
      ext v
      simp [D_cex, A_cex];
      -- By simplifying the logical conditions, we can see that the only element satisfying both conditions is v1.
      fin_cases v <;> simp +decide,
    h_vab_A := by
      decide +kernel,
    h_vab_B := by
      -- By definition of $B_cex$, we know that $v0 \in B_cex$.
      simp [B_cex],
    h_vbc_B := by
      decide +revert,
    h_vbc_C := by
      -- By definition of $C_cex$, we know that $v3 \in C_cex$.
      simp [C_cex],
    h_vcd_C := by
      -- By definition of $C_cex$, we know that $v7 \in C_cex$.
      simp [C_cex],
    h_vcd_D := by
      -- By definition of $D_cex$, we know that $v7 \in D_cex$.
      simp [D_cex],
    h_vda_D := by
      -- By definition of $D_cex$, we know that $v1 \in D_cex$.
      simp [D_cex],
    h_vda_A := by
      -- By definition of A_cex, we know that v1 is in A_cex.
      simp [A_cex],
    h_diag_AC := by
      native_decide,
    h_diag_BD := by
      decide +kernel,
    h_vab_ne_vbc := by
      -- Since $v0 = 0$ and $v3 = 3$, and $0 \neq 3$, we have $v0 \neq v3$.
      simp [v0, v3],
    h_vbc_ne_vcd := by
      -- Since $v3$ and $v7$ are distinct elements in the finite type $Fin 10$, we can conclude that $v3 \neq v7$.
      simp [v3, v7],
    h_vcd_ne_vda := by
      -- Since $v7 = 7$ and $v1 = 1$, they are distinct elements in the Fin 10 type.
      simp [v7, v1],
    h_vda_ne_vab := by
      decide +kernel }

lemma all_triangles_cex : CounterexampleG.cliqueFinset 3 = {A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex} := by
  -- By definition of `cliqueFinset`, we need to show that the set of 3-cliques in `CounterexampleG` is exactly `{A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex}`.
  ext t
  simp [CounterexampleG];
  native_decide +revert

def all_subsets_3 : Finset (Finset (Fin 10)) :=
  (Finset.univ : Finset (Fin 10)).powerset.filter (fun t => t.card = 3)

def is_triangle_computable (t : Finset (Fin 10)) : Bool :=
  t.toList.Pairwise (fun u v => s(u, v) ∈ CounterexampleEdges)

def all_triples : Finset (Finset (Fin 10)) :=
  (Finset.univ.powerset).filter (fun s => s.card = 3)

def is_clique (s : Finset (Fin 10)) : Bool :=
  s.toSet.Pairwise (fun u v => CounterexampleG.Adj u v)

lemma check_triangles : (all_triples.filter (fun s => is_clique s)) = {A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex} := by
  unfold is_clique;
  unfold CounterexampleG; simp +decide ;

lemma triangles_subset : CounterexampleG.cliqueFinset 3 ⊆ {A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex} := by
  -- By definition of `all_triangles_cex`, any triangle in the cliqueFinset must be one of A_cex, B_cex, C_cex, D_cex, T1_cex, or T2_cex.
  apply all_triangles_cex.le

lemma all_triangles_cex_correct : CounterexampleG.cliqueFinset 3 = {A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex} := by
  -- By definition of cliqueFinset, we know that every element in the cliqueFinset is a triangle in the graph.
  apply all_triangles_cex

def triangles_cex : Finset (Finset (Fin 10)) := {A_cex, B_cex, C_cex, D_cex, T1_cex, T2_cex}

def is_packing_bool (S : Finset (Finset (Fin 10))) : Bool :=
  let l := S.toList
  l.all (fun t1 => l.all (fun t2 => t1 == t2 || (t1 ∩ t2).card ≤ 1))

def max_packing_size_computable : ℕ :=
  let all_subsets := Finset.powerset triangles_cex
  let valid_packings := Finset.filter (fun S => is_packing_bool S) all_subsets
  let sizes := Finset.image Finset.card valid_packings
  Finset.max sizes |>.getD 0

lemma max_packing_size_eq : max_packing_size_computable = 4 := by
  -- By definition of `max_packing_size_computable`, we need to show that the maximum cardinality of a subset of `CounterexampleG.cliqueFinset 3` that is pairwise disjoint and each element has at most one vertex in common with any other element is 4.
  unfold max_packing_size_computable;
  unfold is_packing_bool;
  simp +zetaDelta at *;
  native_decide

lemma trianglePackingNumber_eq_computable : trianglePackingNumber CounterexampleG = max_packing_size_computable := by
  unfold trianglePackingNumber max_packing_size_computable;
  -- Since the cliqueFinset 3 of theCounterexampleG is exactly the set of triangles in the graph, the two expressions are equal.
  have h_clique_eq_triangles : CounterexampleG.cliqueFinset 3 = triangles_cex := by
    -- By definition of `cliqueFinset`, we know that `CounterexampleG.cliqueFinset 3` is the set of all triangles in the graph.
    apply all_triangles_cex_correct;
  -- Since the cliqueFinset 3 is equal to the set of triangles, their powersets are the same. Therefore, the filtered sets are also the same.
  have h_powerset_eq : (CounterexampleG.cliqueFinset 3).powerset.filter (isTrianglePacking CounterexampleG) = triangles_cex.powerset.filter (fun S => is_packing_bool S = Bool.true) := by
    -- Since the cliqueFinset 3 is equal to the set of triangles, their powersets are the same. Therefore, the filtered sets are also the same. We can use the fact that if two sets are equal, their powersets are equal, and the filter operations are equivalent.
    ext S
    simp [h_clique_eq_triangles, isTrianglePacking, is_packing_bool];
    exact fun _ => ⟨ fun h x hx y hy => Classical.or_iff_not_imp_left.2 fun hxy => h hx hy hxy, fun h x hx y hy hxy => h x hx y hy |> Or.resolve_left <| by tauto ⟩;
  rw [h_powerset_eq]

lemma T1_is_external : T1_cex ∈ externalTrianglesAt CounterexampleG M_cex v0 := by
  -- Check that T1_cex is in the cliqueFinset and contains v0.
  have hT1_cex_mem : T1_cex ∈ CounterexampleG.cliqueFinset 3 := by
    -- By definition of $T1_cex$, we know that it is a clique of size 3 in $CounterexampleG$.
    simp [T1_cex, all_triangles_cex_correct];
  -- Since T1_cex contains v0 and is not in M_cex, it satisfies the conditions for being in externalTrianglesAt.
  apply Finset.mem_sdiff.mpr;
  simp_all +decide [ trianglesSharingMEdgeAt, M_cex ]

lemma T2_is_external : T2_cex ∈ externalTrianglesAt CounterexampleG M_cex v0 := by
  -- Since T2_cex is in the cliqueFinset and shares an M-edge with A_cex, it satisfies the conditions to be in externalTrianglesAt.
  simp [externalTrianglesAt, trianglesSharingMEdgeAt, M_edges_at];
  simp +decide [ CounterexampleG, T2_cex, M_cex ]

lemma max_packing_size_ge_4 : max_packing_size_computable ≥ 4 := by
  -- By definition of `max_packing_size_computable`, we know that it is equal to the maximum size of a valid packing.
  rw [show max_packing_size_computable = 4 from max_packing_size_eq]

theorem counterexample_disproves_conjecture :
  ∃ (G : SimpleGraph (Fin 10)) (M : Finset (Finset (Fin 10))) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M) (v : (Fin 10))
    (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da)
    (T1 T2 : Finset (Fin 10))
    (hT1 : T1 ∈ externalTrianglesAt G M v)
    (hT2 : T2 ∈ externalTrianglesAt G M v)
    (hne : T1 ≠ T2),
    (T1 ∩ T2).card < 2 := by
      use CounterexampleG, M_cex;
      refine' ⟨ _, Cycle4_cex, _, Or.inl rfl, T1_cex, T2_cex, _, _, _ ⟩ <;> norm_num;
      · constructor;
        · constructor;
          · simp +decide [ M_cex, all_triangles_cex_correct ];
          · simp +decide [ Set.Pairwise ];
        · rw [ show trianglePackingNumber CounterexampleG = 4 by
                -- By definition of `max_packing_size_computable`, we know that it is equal to the triangle packing number.
                have h_max_packing_size : max_packing_size_computable = trianglePackingNumber CounterexampleG := by
                  exact?;
                exact h_max_packing_size ▸ max_packing_size_eq ];
          native_decide;
      · exact T1_is_external;
      · exact T2_is_external;
      · native_decide