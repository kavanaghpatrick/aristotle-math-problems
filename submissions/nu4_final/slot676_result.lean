/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 474bd383-5b5f-4927-b522-f6d6bef9b9a7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f70f28c9-0114-409b-9592-b92eeed54a36

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
S'(h, k) := ∑_{j=1}^{k-1} (-1)^{j + 1 + ⌊hj/k⌋}
-/
def S' (h k : ℕ) : ℤ := ∑ j ∈ Finset.Ico 1 k, (-1 : ℤ) ^ (j + 1 + ⌊(h * j : ℚ) / k⌋₊)

/-
S(k) := ∑_{h=1}^{k-1} S'(h, k)
-/
def S (k : ℕ) : ℤ := ∑ h ∈ Finset.Ico 1 k, S' h k

/-
verify_conj_1_1(N) checks if S(k) > 0 for all odd primes k < N.
-/
def verify_conj_1_1 (N : ℕ) : Bool :=
  (List.range N).all fun k => if k.Prime ∧ Odd k then decide (0 < S k) else true

/-
If verify_conj_1_1(N) is true, then S(k) > 0 for all odd primes k < N.
-/
lemma verify_conj_1_1_correct (N : ℕ) : verify_conj_1_1 N = true → ∀ k < N, k.Prime → Odd k → 0 < S k := by
  unfold verify_conj_1_1;
  grind

/-
Conjecture 1.1 verified for k < 100.
-/
theorem conj_1_1_verified_100 : ∀ k < 100, k.Prime → Odd k → 0 < S k := by
  apply verify_conj_1_1_correct 100
  native_decide

/-
verify_conj_4_1(N) checks if S(k) > k for all odd primes 5 < k < N.
-/
def verify_conj_4_1 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 5 < k ∧ k.Prime ∧ Odd k then decide (k < S k) else true

/-
If verify_conj_4_1(N) is true, then S(k) > k for all odd primes 5 < k < N.
-/
lemma verify_conj_4_1_correct (N : ℕ) : verify_conj_4_1 N = true → ∀ k < N, 5 < k → k.Prime → Odd k → k < S k := by
  unfold verify_conj_4_1;
  grind

/-
Conjecture 1.1 verified for k < 1000.
-/
theorem conj_1_1_verified_1000 : ∀ k < 1000, k.Prime → Odd k → 0 < S k := by
  apply verify_conj_1_1_correct 1000
  native_decide

/-
verify_conj_4_1_range(start, stop) checks if S(k) > k for all odd primes k in [start, stop).
-/
def verify_conj_4_1_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 5 < k ∧ k.Prime ∧ Odd k then decide (k < S k) else true

/-
If verify_conj_4_1_range(start, stop) is true, then S(k) > k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_1_range_correct (start stop : ℕ) :
  verify_conj_4_1_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 5 < k → k.Prime → Odd k → k < S k := by
    unfold verify_conj_4_1_range;
    grind

/-
Conjecture 4.1 verified for 5 < k < 500.
-/
theorem conj_4_1_verified_500 : ∀ k ∈ List.range' 0 500, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 0 500
  native_decide

/-
Conjecture 4.1 verified for 500 <= k < 600.
-/
theorem conj_4_1_verified_500_600 : ∀ k ∈ List.range' 500 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 500 600
  native_decide

/-
Conjecture 4.1 verified for 600 <= k < 700.
-/
theorem conj_4_1_verified_600_700 : ∀ k ∈ List.range' 600 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 600 700
  native_decide

/-
Conjecture 4.1 verified for 700 <= k < 800.
-/
theorem conj_4_1_verified_700_800 : ∀ k ∈ List.range' 700 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 700 800
  native_decide

/-
Conjecture 4.1 verified for 800 <= k < 900.
-/
theorem conj_4_1_verified_800_900 : ∀ k ∈ List.range' 800 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 800 900
  native_decide

/-
Conjecture 4.1 verified for 900 <= k < 1000.
-/
theorem conj_4_1_verified_900_1000 : ∀ k ∈ List.range' 900 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 900 1000
  native_decide

/-
Conjecture 4.1 verified for 500 <= k < 1000 by combining sub-ranges.
-/
theorem conj_4_1_verified_500_1000 : ∀ k ∈ List.range' 500 500, 5 < k → k.Prime → Odd k → k < S k := by
  intros k hk hk_gt hk_prime hk_odd;
  have h_split : k ∈ List.range' 500 100 ∨ k ∈ List.range' 600 100 ∨ k ∈ List.range' 700 100 ∨ k ∈ List.range' 800 100 ∨ k ∈ List.range' 900 100 := by
    simp +zetaDelta at *;
    omega;
  rcases h_split with ( h | h | h | h | h ) <;> [ exact conj_4_1_verified_500_600 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_600_700 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_700_800 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_800_900 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_900_1000 k h hk_gt hk_prime hk_odd ]

/-
Conjecture 4.1 verified for 5 < k < 1000 by combining 0-500 and 500-1000.
-/
theorem conj_4_1_verified_1000 : ∀ k < 1000, 5 < k → k.Prime → Odd k → k < S k := by
  -- By combining the results from the sub-ranges, we can conclude that the conjecture holds for all k from 6 to 999.
  intros k hk_lt hk_gt hk_prime hk_odd
  by_cases hk_range : k < 500;
  · convert conj_4_1_verified_500 k _ _ _ _ using 1;
    · grind;
    · linarith;
    · assumption;
    · assumption;
  · convert conj_4_1_verified_500_1000 k _ _ _ _ ; aesop;
    · linarith;
    · assumption;
    · assumption

/-
S(2) = 1.
-/
theorem S_2_eq_1 : S 2 = 1 := by
  native_decide

/-
verify_conj_4_2(N) checks if S(k) > 2k for all odd primes 233 < k < N.
-/
def verify_conj_4_2 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 233 < k ∧ k.Prime ∧ Odd k then decide (2 * k < S k) else true

/-
If verify_conj_4_2(N) is true, then S(k) > 2k for all odd primes 233 < k < N.
-/
lemma verify_conj_4_2_correct (N : ℕ) : verify_conj_4_2 N = true → ∀ k < N, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  intro h k hk₁ hk₂ hk₃ hk₄; revert k; contrapose! h; simp_all +decide [ List.all ] ;
  unfold verify_conj_4_2; aesop;

/-
verify_conj_4_2_range(start, stop) checks if S(k) > 2k for all odd primes k in [start, stop).
-/
def verify_conj_4_2_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 233 < k ∧ k.Prime ∧ Odd k then decide (2 * k < S k) else true

/-
Conjecture 4.2 verified for 234 <= k < 600.
-/
theorem conj_4_2_verified_234_600 : ∀ k ∈ List.range' 234 (600 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
  -- We'll use that $S(k)$ is computed for each $k$ in the range $234$ to $599$.
  have h_computed : ∀ k ∈ Finset.Ico 234 600, Nat.Prime k → Odd k → 2 * k < S k := by
    simp +zetaDelta at *;
    intros k hk1 hk2 hk3 hk4
    interval_cases k <;> norm_num [ S ];
    all_goals norm_num [ Finset.sum_Ico_eq_sum_range ] at *;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
  aesop

/-
If verify_conj_4_2_range(start, stop) is true, then S(k) > 2k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_2_range_correct (start stop : ℕ) :
  verify_conj_4_2_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 233 < k → k.Prime → Odd k → 2 * k < S k := by
    unfold verify_conj_4_2_range;
    grind

/-
Conjecture 4.2 verified for 600 <= k < 800.
-/
theorem conj_4_2_verified_600_800 : ∀ k ∈ List.range' 600 200, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  apply verify_conj_4_2_range_correct 600 800
  native_decide

/-
Conjecture 4.2 verified for 800 <= k < 1000.
-/
theorem conj_4_2_verified_800_1000 : ∀ k ∈ List.range' 800 200, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  intro k hk₁ hk₂ hk₃ hk₄;
  norm_num [ List.mem_range' ] at hk₁;
  obtain ⟨ i, hi, rfl ⟩ := hk₁; interval_cases i <;> norm_num at *;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert

/-
Conjecture 4.2 verified for 233 < k < 1000 by combining sub-ranges.
-/
theorem conj_4_2_verified_1000 : ∀ k < 1000, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  -- By combining the results from the subranges, we can conclude that the conjecture holds for all odd primes between 234 and 999. We'll use the fact that if the conjecture holds for each subrange, then it holds for the entire range.
  have h_combined : ∀ k ∈ List.range' 234 (1000 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
    intro k hk h233 h_prime h_odd
    have h600 : ∀ k ∈ List.range' 234 (600 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    have h800 : ∀ k ∈ List.range' 600 (800 - 600), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    have h1000 : ∀ k ∈ List.range' 800 (1000 - 800), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    grind;
  grind

/-
Check if S'(h, k) = -S'(k-h, k) for k < N.
-/
def check_symmetry (N : ℕ) : Bool :=
  (List.range N).all fun k =>
    if k > 2 then
      (List.range k).all fun h =>
        if h > 0 then S' h k == - S' (k - h) k else true
    else true

/-
Disproof of symmetry: there exist k, h such that S'(h, k) != -S'(k-h, k).
-/
theorem symmetry_disproof : ∃ k h, h < k ∧ S' h k ≠ - S' (k - h) k := by
  use 3, 1
  native_decide

/-
verify_conj_4_3(N) checks if S(k) > 3k for all odd primes 3119 < k < N.
-/
def verify_conj_4_3 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 3119 < k ∧ k.Prime ∧ Odd k then decide (3 * k < S k) else true

/-
If verify_conj_4_3(N) is true, then S(k) > 3k for all odd primes 3119 < k < N.
-/
lemma verify_conj_4_3_correct (N : ℕ) : verify_conj_4_3 N = true → ∀ k < N, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  intro h k hk₁ hk₂ hk₃ hk₄; revert h; unfold verify_conj_4_3; (
  grind);

/-
verify_conj_4_3_range(start, stop) checks if S(k) > 3k for all odd primes k in [start, stop).
-/
def verify_conj_4_3_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 3119 < k ∧ k.Prime ∧ Odd k then decide (3 * k < S k) else true

/-
If verify_conj_4_3_range(start, stop) is true, then S(k) > 3k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_3_range_correct (start stop : ℕ) :
  verify_conj_4_3_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 3119 < k → k.Prime → Odd k → 3 * k < S k := by
    -- By definition of `verify_conj_4_3_range`, if it returns true, then for all `k` in the range [start, stop), the condition `3 * k < S k` holds.
    intro h_true
    intro k hk_range hk_gt hk_prime hk_odd
    have h_cond : 3 * (k : ℤ) < S k := by
      contrapose! h_true; simp_all +decide [ verify_conj_4_3_range ] ;
      exact ⟨ k, hk_range.1, hk_range.2, ⟨ hk_gt, hk_prime, hk_odd ⟩, h_true ⟩
    exact h_cond

/-
Conjecture 4.3 verified for 3120 <= k < 3130.
-/
theorem conj_4_3_verified_3120_3130 : ∀ k ∈ List.range' 3120 10, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  apply verify_conj_4_3_range_correct 3120 3130
  native_decide

/-
Conjecture 4.3 verified for 3130 <= k < 3135.
-/
theorem conj_4_3_verified_3130_3135 : ∀ k ∈ List.range' 3130 5, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  apply verify_conj_4_3_range_correct 3130 3135
  native_decide

/-
Conjecture 4.3 holds for k = 3137.
-/
theorem conj_4_3_verified_3137 : 3 * 3137 < S 3137 := by
  -- Let's simplify the expression for $S(3137)$.
  unfold S S';
  norm_num +zetaDelta at *;
  -- By definition of exponentiation, we know that if $⌊↑x * ↑x_1 / 3137⌋₊$ is even, then $(-1)^{⌊↑x * ↑x_1 / 3137⌋₊} = 1$, and if it is odd, then $(-1)^{⌊↑x * ↑x_1 / 3137⌋₊} = -1$.
  suffices h_floor : ∀ x x_1 : ℕ, x ∈ Finset.Ico 1 3137 → x_1 ∈ Finset.Ico 1 3137 → (-1 : ℤ) ^ (x_1 + 1 + ⌊(x * x_1 : ℚ) / 3137⌋₊) = if Even (x_1 + 1 + ⌊(x * x_1 : ℚ) / 3137⌋₊) then 1 else -1 by
    rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_floor x y hx hy ];
    rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => by rw [ show ⌊ ( x : ℚ ) * y / 3137⌋₊ = x * y / 3137 from Nat.floor_eq_iff ( by positivity ) |>.2 ⟨ by rw [ le_div_iff₀' ] <;> norm_cast ; linarith [ Nat.div_mul_le_self ( x * y ) 3137 ], by rw [ div_lt_iff₀' ] <;> norm_cast ; linarith [ Nat.div_add_mod ( x * y ) 3137, Nat.mod_lt ( x * y ) ( by decide : 3137 > 0 ) ] ⟩ ] ] ; native_decide;
  intro x x_1 hx hx_1; split_ifs <;> simp_all +decide [ Nat.even_add ] ;
  by_cases h : Even x_1 <;> by_cases h' : Even ⌊ ( x : ℚ ) * x_1 / 3137⌋₊ <;> simp_all +decide [ parity_simps ]

/-
Disproof of symmetry: there exist k, h such that S'(h, k) != -S'(k-h, k).
-/
theorem symmetry_disproof_verified : ∃ k h, h < k ∧ S' h k ≠ - S' (k - h) k := by
  -- Let's choose $k = 3$ and $h = 1$.
  use 3;
  native_decide

/-
Conjecture 4.3 holds for k = 3163.
-/
theorem conj_4_3_verified_3163 : 3 * 3163 < S 3163 := by
  -- By definition of $S$, we know that
  unfold S S';
  norm_num [ Finset.sum_Ico_eq_sum_range ];
  simp_all +decide [ pow_add ];
  -- Let's simplify the expression inside the sum further.
  have h_simplify : ∀ x x_1 : ℕ, (-1 : ℤ) ^ ⌊(1 + x : ℚ) * (1 + x_1) / 3163⌋₊ = (-1 : ℤ) ^ ((1 + x) * (1 + x_1) / 3163) := by
    intro x x_1; norm_cast;
  simp_all +contextual [ ← pow_add ];
  -- Let's simplify the expression inside the sum further, considering that $(-1)^{x_1 + (1 + x) * (1 + x_1) / 3163}$ is equal to $-1$ when $x_1 + (1 + x) * (1 + x_1) / 3163$ is odd and $1$ when it is even.
  have h_parity : ∀ x x_1 : ℕ, (-1 : ℤ) ^ (x_1 + (1 + x) * (1 + x_1) / 3163) = if (x_1 + (1 + x) * (1 + x_1) / 3163) % 2 = 0 then 1 else -1 := by
    intro x x_1; rw [ ← Nat.mod_add_div ( x_1 + ( 1 + x ) * ( 1 + x_1 ) / 3163 ) 2 ] ; norm_num [ pow_add, pow_mul ] ; aesop;
  simpa only [ h_parity ] using by native_decide;

/-
Conjecture 4.3 holds for k = 3167.
-/
theorem conj_4_3_verified_3167 : 3 * 3167 < S 3167 := by
  -- We simplify the expression for S(3167).
  norm_num [S];
  unfold S';
  -- We'll use that ⌊(h * j : ℚ) / 3167⌋₊ is equal to h * j / 3167 since h and j are integers.
  have h_floor : ∀ h j : ℕ, ⌊(h * j : ℚ) / 3167⌋₊ = h * j / 3167 := by
    intro h j; norm_cast;
  -- The exponent (x_1 + 1 + x * x_1 / 3167) is even if and only if x_1 is odd and x * x_1 / 3167 is even, or x_1 is even and x * x_1 / 3167 is odd.
  have h_even_odd : ∀ x x_1 : ℕ, Even (x_1 + 1 + x * x_1 / 3167) ↔ (Odd x_1 ∧ Even (x * x_1 / 3167)) ∨ (Even x_1 ∧ Odd (x * x_1 / 3167)) := by
    grind;
  simp_all +contextual [ Nat.even_iff, Nat.odd_iff ];
  -- The sum of (-1)^(x_1 + 1 + x * x_1 / 3167) over x_1 from 1 to 3166 is equal to the number of odd x_1 minus the number of even x_1.
  have h_inner_sum : ∀ x ∈ Finset.Ico 1 3167, ∑ x_1 ∈ Finset.Ico 1 3167, (-1 : ℤ) ^ (x_1 + 1 + x * x_1 / 3167) = ∑ x_1 ∈ Finset.Ico 1 3167, if (x_1 % 2 = 1 ∧ x * x_1 / 3167 % 2 = 0) ∨ (x_1 % 2 = 0 ∧ x * x_1 / 3167 % 2 = 1) then 1 else -1 := by
    intro x hx; refine Finset.sum_congr rfl fun y hy => ?_; specialize h_even_odd x y; rcases Nat.mod_two_eq_zero_or_one y with ha | ha <;> rcases Nat.mod_two_eq_zero_or_one ( x * y / 3167 ) with hb | hb <;> simp +decide [ *, Nat.even_iff ] at h_even_odd ⊢;
    · rw [ ← Nat.mod_add_div ( y + 1 + x * y / 3167 ) 2, h_even_odd ] ; norm_num [ pow_add, pow_mul ];
    · rw [ ← Nat.mod_add_div ( y + 1 + x * y / 3167 ) 2, h_even_odd ] ; norm_num [ pow_add, pow_mul ];
  rw [ Finset.sum_congr rfl h_inner_sum ] ; native_decide;

/-
Conjecture 4.3 holds for k = 3169.
-/
theorem conj_4_3_verified_3169 : 3 * 3169 < S 3169 := by
  -- We can prove this using properties of the sums involved.
  have h_sum : ∑ h ∈ Finset.Ico 1 3169, ∑ j ∈ Finset.Ico 1 3169, (-1 : ℤ) ^ (j + 1 + (h * j) / 3169) > 3 * 3169 := by
    -- We'll use that $(-1)^{j + 1 + h * j / 3169}$ is $-1$ if $j + 1 + h * j / 3169$ is odd and $1$ if it's even.
    have h_parity : ∀ h j : ℕ, (-1 : ℤ) ^ (j + 1 + h * j / 3169) = if (j + 1 + h * j / 3169) % 2 = 1 then -1 else 1 := by
      intro h j; rw [ ← Nat.mod_add_div ( j + 1 + h * j / 3169 ) 2 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ; aesop;
    simpa only [ h_parity ] using by native_decide;
  exact h_sum.trans_le (by
  refine' Finset.sum_le_sum fun h hh => Finset.sum_le_sum fun j hj => _;
  erw [ Nat.floor_div_natCast ];
  norm_num [ show ⌊ ( h : ℚ ) * j⌋₊ = h * j by exact_mod_cast Nat.floor_natCast _ ])

/-
Conjecture 4.3 holds for k = 3181.
-/
theorem conj_4_3_verified_3181 : 3 * 3181 < S 3181 := by
  refine' lt_of_lt_of_le _ ( Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => _ );
  rotate_left;
  exact fun i j => if ( j + 1 + ⌊ ( i : ℚ ) * j / 3181⌋₊ ) % 2 = 0 then 1 else -1;
  · split_ifs;
    · norm_num [ Nat.even_iff, ‹_› ];
    · by_cases h : Even ( j + 1 + ⌊ ( i : ℚ ) * j / 3181⌋₊ ) <;> simp_all +decide;
  · exact mod_cast by native_decide;

/-
Conjecture 4.3 holds for k = 3187.
-/
theorem conj_4_3_verified_3187 : 3 * 3187 < S 3187 := by
  unfold S;
  unfold S';
  norm_num [ Finset.sum_Ico_eq_sum_range ];
  -- Let's simplify the expression inside the sum.
  have h_simplify : ∀ x x_1 : ℕ, (-1 : ℤ) ^ (1 + x_1 + 1 + ⌊(1 + x : ℚ) * (1 + x_1 : ℚ) / 3187⌋₊) = (-1 : ℤ) ^ (x_1 + ⌊(1 + x : ℚ) * (1 + x_1 : ℚ) / 3187⌋₊) := by
    intro x x_1; ring;
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => h_simplify i j ];
  -- Let's simplify the expression inside the sum further, considering that $(-1)^{j + \lfloor (1 + i)(1 + j) / 3187 \rfloor}$ is $1$ if $j + \lfloor (1 + i)(1 + j) / 3187 \rfloor$ is even and $-1$ if it is odd.
  suffices h_simplify : 9561 < ∑ i ∈ Finset.range 3186, ∑ j ∈ Finset.range 3186, if (j + ⌊(1 + i : ℚ) * (1 + j : ℚ) / 3187⌋₊) % 2 = 0 then 1 else -1 by
    exact h_simplify.trans_le ( Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => by rw [ ← Nat.mod_add_div ( j + ⌊ ( 1 + i : ℚ ) * ( 1 + j ) / 3187⌋₊ ) 2 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ; aesop );
  exact mod_cast by native_decide;

/-
Conjecture 4.3 holds for k = 3191.
-/
theorem conj_4_3_verified_3191 : 3 * 3191 < S 3191 := by
  -- Let's simplify the expression. Since we know $h$ and $k$ are integers, we can replace `⌊(h * j : ℚ) / k⌋₊` with `⌊(h * j) / k⌋`.
  suffices h_simp : 3 * 3191 < ∑ h ∈ Finset.Ico 1 3191, ∑ j ∈ Finset.Ico 1 3191, (-1 : ℤ) ^ (j + 1 + (h * j) / 3191) by
    unfold S S';
    convert h_simp using 4;
    norm_cast;
  -- Let's simplify the expression. Since we know $h$ and $k$ are integers, we can replace `⌊(h * j : ℚ) / k⌋₊` with `⌊(h * j) / k⌋` and `(-1 : ℚ)` with `(-1 : ℤ)`.
  have h_simp : 3 * 3191 < ∑ h ∈ Finset.Ico 1 3191, ∑ j ∈ Finset.Ico 1 3191, (-1 : ℤ) ^ ((j + 1 + (h * j) / 3191) % 2) := by
    native_decide +revert;
  convert h_simp using 3;
  rw [ ← Nat.mod_add_div ( _ + 1 + _ * _ / 3191 ) 2 ] ; norm_num [ pow_add, pow_mul ] ;

/-
Conjecture 4.3 holds for k = 3203.
-/
theorem conj_4_3_verified_3203 : 3 * 3203 < S 3203 := by
  push_cast [ S ];
  rw [ Finset.sum_Ico_eq_sum_range ];
  -- By simplifying, we can see that both sums are equal.
  simp [S'];
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ show ⌊ ( 1 + i : ℚ ) * j / 3203⌋₊ = ( ( 1 + i ) * j ) / 3203 from Nat.floor_eq_iff ( by positivity ) |>.2 ⟨ by rw [ le_div_iff₀ ] <;> norm_cast ; linarith [ Nat.div_mul_le_self ( ( 1 + i ) * j ) 3203 ], by rw [ div_lt_iff₀ ] <;> norm_cast ; linarith [ Nat.div_add_mod ( ( 1 + i ) * j ) 3203, Nat.mod_lt ( ( 1 + i ) * j ) ( by norm_num : 0 < 3203 ) ] ⟩ ] ];
  -- Calculate the number of odd terms in the inner sum.
  have h_odd_terms : ∀ i ∈ Finset.range 3202, ∑ j ∈ Finset.Ico 1 3203, (-1 : ℤ) ^ (j + 1 + (1 + i) * j / 3203) = 3202 - 2 * ((Finset.filter (fun j => (j + 1 + (1 + i) * j / 3203) % 2 = 1) (Finset.Ico 1 3203)).card) := by
    intro i hi
    have h_odd_terms : ∑ j ∈ Finset.Ico 1 3203, (-1 : ℤ) ^ (j + 1 + (1 + i) * j / 3203) = ∑ j ∈ Finset.Ico 1 3203, (if (j + 1 + (1 + i) * j / 3203) % 2 = 1 then -1 else 1) := by
      exact Finset.sum_congr rfl fun x hx => by rw [ ← Nat.mod_add_div ( x + 1 + ( 1 + i ) * x / 3203 ) 2 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ; aesop;
    rw [ h_odd_terms, Finset.sum_ite ] ; norm_num;
    rw [ show ( Finset.filter ( fun x => ( x + 1 + ( 1 + i ) * x / 3203 ) % 2 = 0 ) ( Finset.Ico 1 3203 ) ) = Finset.Ico 1 3203 \ ( Finset.filter ( fun x => ( x + 1 + ( 1 + i ) * x / 3203 ) % 2 = 1 ) ( Finset.Ico 1 3203 ) ) by ext x; aesop, Finset.card_sdiff ] ; norm_num;
    rw [ Finset.inter_eq_left.mpr ( Finset.filter_subset _ _ ) ] ; rw [ Nat.cast_sub ( by exact le_trans ( Finset.card_filter_le _ _ ) ( by norm_num ) ) ] ; ring;
  rw [ Finset.sum_congr rfl h_odd_terms ] ; native_decide

/-
Conjecture 4.3 holds for k = 3209.
-/
theorem conj_4_3_verified_3209 : 3 * 3209 < S 3209 := by
  -- By definition of $S$, we know that
  unfold S;
  -- By definition of $S'$, we know that
  simp [S'] at *;
  -- We'll use that ⌊(x * x_1 : ℚ) / 3209⌋₊ is equal to (x * x_1) / 3209 since 3209 is prime.
  have h_floor : ∀ x x_1 : ℕ, ⌊(x * x_1 : ℚ) / 3209⌋₊ = (x * x_1) / 3209 := by
    intro x x_1; norm_cast;
  simp [h_floor] at *;
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ neg_one_pow_eq_pow_mod_two ] ] ; native_decide;

/-
Conjecture 4.3 holds for k = 3217.
-/
theorem conj_4_3_verified_3217 : 3 * 3217 < S 3217 := by
  rw [ show S = _ from funext fun k => Finset.sum_congr rfl fun h hh => Finset.sum_congr rfl fun j hj => ?_ ];
  rotate_left;
  use fun k h j => if Even ( j + 1 + h * j / k ) then 1 else -1;
  · norm_cast;
    by_cases hj' : Even j <;> by_cases hk' : Even ( h * j / k ) <;> simp_all +decide [ Nat.even_add ];
    · simp_all +decide [ parity_simps ];
    · simp_all +decide [ parity_simps ];
  · native_decide +revert

/-
Definition of S using integer arithmetic and proof of equivalence.
-/
def S'_int (h k : ℕ) : ℤ := ∑ j ∈ Finset.Ico 1 k, (-1 : ℤ) ^ (j + 1 + (h * j) / k)

def S_int (k : ℕ) : ℤ := ∑ h ∈ Finset.Ico 1 k, S'_int h k

lemma S_eq_S_int (k : ℕ) : S k = S_int k := by
  unfold S S_int;
  unfold S' S'_int;
  convert rfl using 4;
  erw [ Nat.floor_div_natCast ] ; norm_cast

/-
Conjecture 4.3 holds for k = 3221.
-/
theorem conj_4_3_verified_3221 : 3 * 3221 < S 3221 := by
  rw [ S_eq_S_int ];
  unfold S_int;
  push_cast [ S'_int ];
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ neg_one_pow_eq_pow_mod_two ] ] ; native_decide;

/-
Conjecture 4.3 holds for k = 3229.
-/
theorem conj_4_3_verified_3229 : 3 * 3229 < S 3229 := by
  rw [ S_eq_S_int ];
  -- By definition of $S_int$, we know that $S_int 3229 = \sum_{h=1}^{3228} S'_int h 3229$.
  have h_S_int_def : S_int 3229 = ∑ h ∈ Finset.Ico 1 3229, ∑ j ∈ Finset.Ico 1 3229, (-1 : ℤ) ^ (j + 1 + (h * j) / 3229) := by
    rfl;
  rw [ h_S_int_def ];
  rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => by rw [ neg_one_pow_eq_pow_mod_two ] ] ; native_decide

/-
Conjecture 4.3 holds for k = 3251.
-/
theorem conj_4_3_verified_3251 : 3 * 3251 < S 3251 := by
  rw [ S_eq_S_int ];
  -- By definition of $S_int$, we know that $S_int(3251) = \sum_{h=1}^{3250} S'(h, 3251)$.
  have hS_int_def : S_int 3251 = ∑ h ∈ Finset.Ico 1 3251, ∑ j ∈ Finset.Ico 1 3251, (-1 : ℤ) ^ (j + 1 + (h * j) / 3251) := by
    rfl;
  rw [ hS_int_def, Finset.sum_comm ];
  refine' lt_of_lt_of_le _ ( Finset.sum_le_sum fun i hi => _ );
  rotate_left;
  use fun i => ∑ j ∈ Finset.Ico 1 3251, if ( i + 1 + j * i / 3251 ) % 2 = 0 then 1 else -1;
  · exact Finset.sum_le_sum fun x hx => by rw [ ← Nat.mod_add_div ( i + 1 + x * i / 3251 ) 2 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ; have := Nat.mod_lt ( i + 1 + x * i / 3251 ) two_pos; interval_cases ( i + 1 + x * i / 3251 ) % 2 <;> norm_num;
  · native_decide +revert

/-
Conjecture 4.3 holds for k = 3253.
-/
theorem conj_4_3_verified_3253 : 3 * 3253 < S 3253 := by
  -- By definition of $S$, we know that $S(3253) = \sum_{h=1}^{3252} S'(h, 3253)$.
  have hS_def : S 3253 = ∑ h ∈ Finset.Ico 1 3253, ∑ j ∈ Finset.Ico 1 3253, (-1 : ℤ) ^ (j + 1 + (h * j) / 3253) := by
    convert S_eq_S_int 3253 using 1;
  rw [ hS_def ];
  by_contra h_contra;
  revert h_contra;
  -- Let's simplify the expression inside the sum.
  have h_simplify : ∀ h ∈ Finset.Ico 1 3253, ∀ j ∈ Finset.Ico 1 3253, (-1 : ℤ) ^ (j + 1 + h * j / 3253) = if (j + 1 + h * j / 3253) % 2 = 0 then 1 else -1 := by
    intro h hh j hj; split_ifs <;> simp_all +decide [ Nat.even_iff ] ;
    rw [ ← Nat.mod_add_div ( j + 1 + h * j / 3253 ) 2, ‹ ( j + 1 + h * j / 3253 ) % 2 = 1› ] ; norm_num [ pow_add, pow_mul ];
  rw [ Finset.sum_congr rfl fun h hh => Finset.sum_congr rfl fun j hj => h_simplify h hh j hj ] ; native_decide

/-
Conjecture 4.3 holds for k = 3257.
-/
theorem conj_4_3_verified_3257 : 3 * 3257 < S 3257 := by
  rw [ S_eq_S_int ];
  -- By definition of $S'_int$, we can rewrite the goal in terms of the sum of $(-1)^{j + 1 + (h * j) / k}$.
  simp [S_int, S'_int];
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ neg_one_pow_eq_pow_mod_two ] ] ; native_decide;

/-
Conjecture 4.3 holds for k = 3259.
-/
theorem conj_4_3_verified_3259 : 3 * 3259 < S 3259 := by
  -- By definition of $S$, we know that $S(3259)$ is the sum of $S'(h, 3259)$ for $h$ from $1$ to $3258$.
  have hS_def : S 3259 = ∑ h ∈ Finset.Ico 1 3259, S'_int h 3259 := by
    exact S_eq_S_int _;
  -- By definition of $S'_int$, we know that $S'_int h 3259$ is an integer.
  simp [hS_def, S'_int] at *;
  rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ neg_one_pow_eq_pow_mod_two ] ] ; native_decide;

/-
Verification function for Conjecture 4.3 using integer arithmetic.
-/
def verify_conj_4_3_range_int (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 3119 < k ∧ k.Prime ∧ Odd k then decide (3 * k < S_int k) else true

lemma verify_conj_4_3_range_int_correct (start stop : ℕ) :
  verify_conj_4_3_range_int start stop = true →
  ∀ k ∈ List.range' start (stop - start), 3119 < k → k.Prime → Odd k → 3 * k < S k := by
    intros h k hk hk' hk'' hk''' ; have := h ; simp_all +decide [ verify_conj_4_3_range_int ] ;
    convert h k hk.1 hk.2 using 1 ; rw [ S_eq_S_int ];
    grind +ring