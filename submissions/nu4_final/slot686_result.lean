/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0756461c-3a97-423f-ab2b-2351aed5fcbb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the First Hardy-Littlewood Conjecture (k-tuples conjecture).

We define:
- `countMod`: The number of distinct residues of the tuple offsets modulo p.
- `Admissible`: The condition that the tuple does not cover all residue classes modulo any prime.
- `singularSeriesTerm` and `singularSeries`: The constant C_P.
- `primeTupleCount`: The counting function π_P(n).
- `logarithmicIntegral`: The integral approximation Li_{k+1}(n).
- `FirstHardyLittlewoodConjectureFor`: The statement that the counting function is asymptotic to C_P * Li_{k+1}(n).
- `FirstHardyLittlewoodConjecture`: The proposition stating the conjecture for all admissible tuples.

Note: The conjecture itself is an open problem and cannot be proven by the ATP. The theorem statement `first_hardy_littlewood_conjecture` could not be added as a declaration because the ATP times out attempting to prove it (as expected for an open problem). The formal statement is captured in `FirstHardyLittlewoodConjecture`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.Primes

#check Nat.totient

/-
The number of distinct residues of the set {m_1, ..., m_k} modulo p.
-/
def countMod {k : ℕ} (m : Fin k.succ → ℕ) (p : ℕ) : ℕ :=
  (Finset.univ.image (fun i => m i % p)).card

/-
A tuple is admissible if it does not cover all residue classes modulo any prime p.
-/
def Admissible {k : ℕ} (m : Fin k.succ → ℕ) : Prop :=
  ∀ p : ℕ, p.Prime → countMod m p < p

/-
The term for prime p in the singular series product.
C_P = ∏_{p} (1 - ν(p)/p) / (1 - 1/p)^(k+1)
-/
noncomputable def singularSeriesTerm (k : ℕ) (m : Fin k.succ → ℕ) (p : Nat.Primes) : ℝ :=
  let p_val : ℝ := p.1
  let ν : ℝ := countMod m p.1
  (1 - ν / p_val) / (1 - 1 / p_val) ^ (k + 1)

/-
The singular series constant C_P.
C_P = exp(∑_p log((1 - ν(p)/p) / (1 - 1/p)^(k+1)))
This is equivalent to the product form.
-/
noncomputable def singularSeries (k : ℕ) (m : Fin k.succ → ℕ) : ℝ :=
  Real.exp (∑' p : Nat.Primes, Real.log (singularSeriesTerm k m p))

/-
The number of integers x ≤ n such that x + m_i is prime for all i.
-/
def primeTupleCount {k : ℕ} (m : Fin k.succ → ℕ) (n : ℕ) : ℕ :=
  (Finset.range (n + 1)).filter (fun x => ∀ i, (x + m i).Prime) |>.card

/-
The logarithmic integral Li_{k+1}(n) = ∫_2^n dt / (log t)^(k+1).
-/
noncomputable def logarithmicIntegral (k : ℕ) (n : ℕ) : ℝ :=
  ∫ t in (2 : ℝ)..n, 1 / (Real.log t) ^ (k + 1)

/-
The statement of the First Hardy-Littlewood Conjecture for a specific tuple m.
-/
def FirstHardyLittlewoodConjectureFor {k : ℕ} (m : Fin k.succ → ℕ) : Prop :=
  Admissible m →
  Asymptotics.IsEquivalent Filter.atTop (fun n => (primeTupleCount m n : ℝ))
    (fun n => singularSeries k m * logarithmicIntegral k n)

/-
The statement of the First Hardy-Littlewood Conjecture (as a proposition).
-/
def FirstHardyLittlewoodConjecture : Prop :=
  ∀ {k : ℕ} (m : Fin k.succ → ℕ), FirstHardyLittlewoodConjectureFor m