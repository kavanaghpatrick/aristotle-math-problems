/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0bf1319a-c7f2-43a7-ae42-4c9cb1076bc0

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Eisenstein integers as the ring of integers of the 3rd cyclotomic field.
-/
abbrev EisensteinInteger := CyclotomicRing 3 ℤ ℚ

/-
Define ω as the primitive 3rd root of unity in the Eisenstein integers.
-/
noncomputable def ω : EisensteinInteger := IsCyclotomicExtension.zeta 3 ℤ EisensteinInteger

/-
Define A(q) = q^2 + q + 1.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

/-
Prove that ω^2 + ω + 1 = 0.
-/
theorem omega_sq_add_omega_add_one : ω^2 + ω + 1 = 0 := by
  have hω : ω^3 = 1 := by
    exact IsCyclotomicExtension.zeta_pow 3 ℤ _;
  refine mul_left_cancel₀ ( sub_ne_zero_of_ne ( show ω ≠ 1 from ?_ ) ) ?_;
  · intro h; have := h ▸ hω; norm_num at this;
    -- Since $\omega$ is a primitive third root of unity, we have $\omega \neq 1$.
    have h_primitive : IsPrimitiveRoot ω 3 := by
      convert IsCyclotomicExtension.zeta_spec 3 ℤ (CyclotomicRing 3 ℤ ℚ);
    exact absurd ( h_primitive.eq_orderOf ) ( by norm_num [ h ] );
  · linear_combination' hω

/-
Prove that ω^3 = 1.
-/
theorem omega_pow_three : ω^3 = 1 := by
  exact IsCyclotomicExtension.zeta_pow 3 ℤ EisensteinInteger

/-
Prove that (q - ω)(q - ω²) = q² + q + 1 in Eisenstein integers.
-/
theorem mul_conj_eq_val (q : ℕ) : ((q : EisensteinInteger) - ω) * ((q : EisensteinInteger) - ω^2) = (q : EisensteinInteger)^2 + q + 1 := by
  ring_nf at *;
  rw [ show ω ^ 3 = 1 by exact omega_pow_three ] ; rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; ring;

/-
Prove that (a + bω)(a + bω²) = a² - ab + b² in Eisenstein integers.
-/
theorem mul_conj_eq_val_general (a b : ℤ) : ((a : EisensteinInteger) + b * ω) * ((a : EisensteinInteger) + b * ω^2) = a^2 - a * b + b^2 := by
  -- We'll use that ω^2 = -ω - 1 to simplify the expression.
  have h_omega_sq : ω^2 = -ω - 1 := by
    linear_combination' omega_sq_add_omega_add_one;
  rw [ h_omega_sq ] ; ring;
  rw [ h_omega_sq ] ; ring

/-
Prove the action of a + bω on the basis {1, ω}.
-/
theorem mul_action_basis (a b : ℤ) :
  ((a : EisensteinInteger) + b * ω) * 1 = (a : EisensteinInteger) * 1 + b * ω ∧
  ((a : EisensteinInteger) + b * ω) * ω = -(b : EisensteinInteger) * 1 + (a - b) * ω := by
    constructor <;> ring_nf at *;
    rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; ring

/-
Prove that a + bω is a root of X^2 - (2a - b)X + (a^2 - ab + b^2).
-/
theorem is_root_of_poly (a b : ℤ) :
  let z : EisensteinInteger := a + b * ω
  z^2 - (2*a - b) * z + (a^2 - a*b + b^2) = 0 := by
    -- Substitute $ω^2 = -ω - 1$ into the expression and simplify.
    have h_sub : ω^2 = -ω - 1 := by
      linear_combination' omega_sq_add_omega_add_one;
    grind +ring

/-
Prove that the minimal polynomial of a + bω is X^2 - (2a - b)X + (a^2 - ab + b^2) if b ≠ 0.
-/
theorem minpoly_eq_of_b_ne_zero (a b : ℤ) (hb : b ≠ 0) :
  minpoly ℤ ((a : EisensteinInteger) + b * ω) = Polynomial.X^2 - Polynomial.C (2*a - b) * Polynomial.X + Polynomial.C (a^2 - a*b + b^2) := by
    -- Since $a + b\omega$ is a root of $p$ and $p$ is irreducible with integer coefficients, $p$ must be the minimal polynomial of $a + b\omega$.
    have irreducible_poly : Irreducible (Polynomial.X ^ 2 - (Polynomial.C (2 * a - b)) * Polynomial.X + (Polynomial.C (a ^ 2 - a * b + b ^ 2))) := by
      -- Since the discriminant is negative, the polynomial has no real roots and is therefore irreducible over ℤ.
      have h_no_real_roots : ¬∃ x : ℝ, x^2 - (2 * a - b) * x + (a^2 - a * b + b^2) = 0 := by
        exact fun ⟨ x, hx ⟩ => hb <| by exact_mod_cast ( by nlinarith [ sq_nonneg ( x - ( 2 * a - b ) / 2 : ℝ ) ] : ( b : ℝ ) = 0 ) ;
      -- Since the polynomial has no real roots, it is irreducible over ℤ.
      have h_irreducible : ∀ p q : Polynomial ℤ, p.degree > 0 → q.degree > 0 → Polynomial.X ^ 2 - Polynomial.C (2 * a - b) * Polynomial.X + Polynomial.C (a ^ 2 - a * b + b ^ 2) = p * q → False := by
        intros p q hp hq h_factor
        have h_deg : p.degree = 1 ∧ q.degree = 1 := by
          have h_deg : p.degree + q.degree = 2 := by
            rw [ ← Polynomial.degree_mul, ← h_factor, Polynomial.degree_add_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
            · exact lt_of_le_of_lt ( add_le_add_right ( Polynomial.degree_le_zero_iff.mpr <| by norm_num ) _ ) ( by norm_num );
            · exact lt_of_le_of_lt ( add_le_add_right ( Polynomial.degree_le_zero_iff.mpr <| by norm_num ) _ ) ( by norm_num );
          rw [ Polynomial.degree_eq_natDegree ( Polynomial.ne_zero_of_degree_gt hp ), Polynomial.degree_eq_natDegree ( Polynomial.ne_zero_of_degree_gt hq ) ] at * ; norm_cast at * ; exact ⟨ by linarith, by linarith ⟩;
        obtain ⟨x, hx⟩ : ∃ x : ℝ, Polynomial.eval x (Polynomial.map (algebraMap ℤ ℝ) p) = 0 := by
          exact Polynomial.exists_root_of_degree_eq_one ( by erw [ Polynomial.degree_map_eq_of_leadingCoeff_ne_zero ] <;> aesop );
        replace h_factor := congr_arg ( Polynomial.map ( algebraMap ℤ ℝ ) ) h_factor; replace h_factor := congr_arg ( Polynomial.eval x ) h_factor; simp_all +decide ;
      constructor;
      · rw [ Polynomial.isUnit_iff ];
        rintro ⟨ r, hr, hr' ⟩ ; have := congr_arg ( Polynomial.eval 0 ) hr'; norm_num at this; have := congr_arg ( Polynomial.eval 1 ) hr'; norm_num at this; have := congr_arg ( Polynomial.eval ( -1 ) ) hr'; norm_num at this; nlinarith [ mul_self_pos.mpr hb ] ;
      · contrapose! h_irreducible;
        obtain ⟨ p, q, hpq, hp, hq ⟩ := h_irreducible;
        refine' ⟨ p, q, _, _, hpq, trivial ⟩;
        · refine' not_le.mp fun h => hp _;
          rw [ Polynomial.eq_C_of_degree_le_zero h ] at hpq ⊢;
          replace hpq := congr_arg ( fun p => Polynomial.coeff p 2 ) hpq ; simp_all +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
          exact Polynomial.isUnit_C.mpr ( isUnit_of_mul_eq_one _ _ hpq.symm );
        · refine' not_le.mp fun h => hq _;
          rw [ Polynomial.eq_C_of_degree_le_zero h ] at hpq ⊢;
          replace hpq := congr_arg ( fun q => Polynomial.coeff q 2 ) hpq ; simp_all +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
          exact Polynomial.isUnit_C.mpr ( isUnit_of_dvd_one <| hpq.symm ▸ dvd_mul_left _ _ );
    have h_minpoly : minpoly ℤ (a + b * ω) ∣ (Polynomial.X ^ 2 - Polynomial.C (2 * a - b) * Polynomial.X + Polynomial.C (a ^ 2 - a * b + b ^ 2)) := by
      refine minpoly.isIntegrallyClosed_dvd ?_ ?_;
      · refine' ⟨ _, _ ⟩;
        exact Polynomial.X ^ 2 - Polynomial.C ( 2 * a - b ) * Polynomial.X + Polynomial.C ( a ^ 2 - a * b + b ^ 2 );
        rw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
        · norm_num [ sq, Polynomial.coeff_eq_zero_of_natDegree_lt ];
          erw [ Polynomial.eval₂_C, Polynomial.eval₂_C ] ; ring;
          rw [ show ω ^ 2 = -ω - 1 by linear_combination' omega_sq_add_omega_add_one ] ; ring;
          norm_num ; ring;
        · refine' lt_of_le_of_lt ( Polynomial.natDegree_mul_le .. ) _ ; norm_num;
          erw [ Polynomial.natDegree_sub_C ] ; erw [ Polynomial.natDegree_C_mul ] <;> norm_num [ hb ];
      · convert is_root_of_poly a b using 1 ; norm_num ; ring;
        erw [ Polynomial.aeval_C ] ; norm_num;
    rw [ irreducible_poly.dvd_iff ] at h_minpoly;
    refine' h_minpoly.resolve_left _ |> fun h => _;
    · refine' Polynomial.eq_of_monic_of_associated _ _ h.symm;
      · apply minpoly.monic;
        refine' ⟨ Polynomial.X ^ 2 - Polynomial.C ( 2 * a - b ) * Polynomial.X + Polynomial.C ( a ^ 2 - a * b + b ^ 2 ), _, _ ⟩;
        · rw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
          · norm_num [ sq, Polynomial.coeff_eq_zero_of_natDegree_lt ];
          · refine' lt_of_le_of_lt ( Polynomial.natDegree_mul_le .. ) _ ; norm_num;
            erw [ Polynomial.natDegree_sub_C ] ; erw [ Polynomial.natDegree_C_mul ] <;> norm_num;
        · convert is_root_of_poly a b using 1 ; norm_num ; ring;
          erw [ Polynomial.eval₂_C, Polynomial.eval₂_C, Polynomial.eval₂_pow, Polynomial.eval₂_C, Polynomial.eval₂_pow, Polynomial.eval₂_C ] ; norm_num ; ring;
      · rw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
        · norm_num [ sq, Polynomial.coeff_eq_zero_of_natDegree_lt ];
        · refine' lt_of_le_of_lt ( Polynomial.natDegree_mul_le .. ) _ ; norm_num;
          erw [ Polynomial.natDegree_sub_C ] ; erw [ Polynomial.natDegree_C_mul ] <;> norm_num [ hb ];
    · exact?

/-
Prove that the rank of Eisenstein integers over Z is 2.
-/
theorem rank_eisenstein_integer : Module.finrank ℤ EisensteinInteger = 2 := by
  -- The cyclotomic field $\mathbb{Q}(\zeta_3)$ has degree 2 over $\mathbb{Q}$.
  have h_deg : Module.finrank ℚ (CyclotomicField 3 ℚ) = 2 := by
    convert ( CyclotomicField.isCyclotomicExtension 3 ℚ ).finrank;
    exact ⟨ fun h => fun _ => h, fun h => h <| Polynomial.cyclotomic.irreducible_rat <| by decide ⟩;
  -- Since the finrank of the ring of integers over ℤ is equal to the finrank of the field extension over ℚ, we can conclude that the finrank of the ring of integers over ℤ is 2.
  have h_finrank_eq : Module.finrank ℤ (CyclotomicRing 3 ℤ ℚ) = Module.finrank ℚ (CyclotomicField 3 ℚ) := by
    have h_iso : IsIntegralClosure (CyclotomicRing 3 ℤ ℚ) ℤ (CyclotomicField 3 ℚ) := by
      exact?;
    exact?;
  aesop

/-
Prove that the norm of an integer cast to Eisenstein integers is its square.
-/
theorem norm_int_cast (a : ℤ) : Algebra.norm ℤ (a : EisensteinInteger) = a^2 := by
  unfold Algebra.norm; norm_num [ map_neg, map_add, map_mul ] ; ring;
  -- The determinant of a scalar multiplication is the scalar raised to the power of the dimension of the vector space.
  have h_det_scalar : ∀ (a : ℤ), LinearMap.det (LinearMap.mul ℤ EisensteinInteger (a : EisensteinInteger)) = a ^ Module.finrank ℤ EisensteinInteger := by
    intro a
    have h_det_scalar : LinearMap.det (LinearMap.mul ℤ EisensteinInteger (a : EisensteinInteger)) = LinearMap.det (a • LinearMap.id : EisensteinInteger →ₗ[ℤ] EisensteinInteger) := by
      congr ; aesop;
    convert LinearMap.det_smul ( a : ℤ ) ( LinearMap.id : EisensteinInteger →ₗ[ℤ] EisensteinInteger ) using 1;
    · norm_num;
    · have h_free : Module.Finite ℤ EisensteinInteger := by
        have h_free : Module.Finite ℤ (CyclotomicRing 3 ℤ ℚ) := by
          have h_cyclotomic : IsCyclotomicExtension {3} ℤ (CyclotomicRing 3 ℤ ℚ) := by
            infer_instance
          convert h_cyclotomic.finite;
        exact h_free;
      exact?;
  rw [ h_det_scalar, rank_eisenstein_integer ]