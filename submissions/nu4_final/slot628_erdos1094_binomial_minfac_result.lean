/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0673b4d7-4840-4cf2-940e-c37c10c7354c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The set of pairs (n, k) such that 0 < k, 2k ≤ n, and the minimum prime factor of n choose k is greater than max(n/k, k).
-/
def exceptional_pairs : Set (ℕ × ℕ) :=
  {p | 0 < p.2 ∧ 2 * p.2 ≤ p.1 ∧ (p.1.choose p.2).minFac > max (p.1 / p.2) p.2}

/-
There are no exceptional pairs (n, k) with k = 1.
-/
lemma exceptional_pairs_k_eq_one : ∀ n, (n, 1) ∉ exceptional_pairs := by
  intro n hn; have := hn.2.2; simp_all +decide [ Nat.choose ] ;
  exact this.1.not_le ( Nat.minFac_le ( Nat.pos_of_ne_zero ( by rintro rfl; simp_all +decide [ exceptional_pairs ] ) ) )

/-
The set of n such that (n, 2) is an exceptional pair is finite.
-/
lemma exceptional_pairs_k_eq_two : {n | (n, 2) ∈ exceptional_pairs}.Finite := by
  -- For $n \geq \max(6, k)$, we have $\binom{n}{2} = \frac{n(n-1)}{2}$. The minimum prime factor of $\binom{n}{2}$ is therefore less than or equal to $\frac{n}{2}$.
  have h_min_fac_le_half_n : ∀ n ≥ max 6 2, (Nat.minFac ((Nat.choose n 2))) ≤ (n / 2) := by
    intro n hn; rw [ Nat.choose_two_right ] ; rcases Nat.even_or_odd' n with ⟨ c, rfl | rfl ⟩ <;> norm_num at *; (
    norm_num [ mul_assoc ] at * ; linarith [ Nat.minFac_le_of_dvd ( by linarith ) ( dvd_mul_right c ( 2 * c - 1 ) ) ] ;);
    norm_num [ Nat.mul_div_assoc ] at *;
    norm_num [ Nat.add_div ] at * ; nlinarith [ Nat.minFac_le_of_dvd ( by linarith ) ( dvd_mul_left c ( 2 * c + 1 ) ) ] ;
  exact Set.finite_iff_bddAbove.2 ⟨ 22, fun n hn => not_lt.1 fun contra => not_lt_of_ge ( h_min_fac_le_half_n n <| le_trans ( by decide ) contra ) <| lt_of_le_of_lt ( by aesop ) ( hn.2.2 ) ⟩

/-
For any fixed k ≥ 3, there exists a bound N such that for all n ≥ N, (n, k) is not an exceptional pair.
-/
lemma exceptional_pairs_large_n_implies_not_exceptional (k : ℕ) (hk : 3 ≤ k) :
    ∃ N, ∀ n ≥ N, (n, k) ∉ exceptional_pairs := by
      -- We choose N = k! + k^2 + k + 2.
      set N := Nat.factorial k + k^2 + k + 2 with hN_def;
      use N + 1; intro n hn; intro H; have := H.2.2; simp_all +decide [ Nat.minFac_eq, Nat.primeFactors_mul, Nat.primeFactors_pow ] ;
      -- From the identity prod_{i<k} (n-i) = k! * choose(n, k), we have v_p(prod (n-i)) = v_p(k!) for all p <= n/k.
      have h_div : ∀ p, Nat.Prime p → p ≤ n / k → (Nat.factorization (∏ i ∈ Finset.range k, (n - i))) p = (Nat.factorization (Nat.factorial k)) p := by
        -- From the identity prod_{i<k} (n-i) = k! * choose(n, k), we have v_p(prod (n-i)) = v_p(k!) + v_p(choose(n, k)) for all p.
        have h_div : ∀ p, Nat.Prime p → p ≤ n / k → (Nat.factorization (∏ i ∈ Finset.range k, (n - i))) p = (Nat.factorization (Nat.factorial k)) p + (Nat.factorization (Nat.choose n k)) p := by
          have h_div : ∏ i ∈ Finset.range k, (n - i) = Nat.factorial k * Nat.choose n k := by
            rw [ ← Nat.descFactorial_eq_factorial_mul_choose ];
            rw [ Nat.descFactorial_eq_prod_range ];
          intro p pp _; rw [ h_div, Nat.factorization_mul ( by positivity ) ( by exact Nat.ne_of_gt ( Nat.choose_pos ( by nlinarith [ Nat.div_mul_le_self n k ] ) ) ) ] ; aesop;
        -- Since $p$ is a prime factor of $\binom{n}{k}$ and $p \leq n/k$, it must be that $p$ does not divide $\binom{n}{k}$.
        intros p hp hle
        have h_not_div : ¬(p ∣ Nat.choose n k) := by
          have h_not_div : Nat.minFac (Nat.choose n k) > n / k := by
            have := H.2.2; aesop;
          exact fun h => not_lt_of_ge hle <| h_not_div.trans_le <| Nat.minFac_le_of_dvd hp.two_le h;
        rw [ h_div p hp hle, Nat.factorization_eq_zero_of_not_dvd h_not_div, add_zero ];
      -- For each i in 0..k-1, let A_i be the product of p^v_p(n-i) for p <= n/k, and B_i be the product for p > n/k.
      set A : ℕ → ℕ := fun i => ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (n / k)), p ^ (Nat.factorization (n - i) p)
      set B : ℕ → ℕ := fun i => ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (n / k + 1) (n - i)), p ^ (Nat.factorization (n - i) p) with hB_def
      have h_prod : ∀ i ∈ Finset.range k, n - i = A i * B i := by
        intro i hi; rw [ ← Nat.factorization_prod_pow_eq_self ( show n - i ≠ 0 from Nat.sub_ne_zero_of_lt <| by nlinarith [ Finset.mem_range.mp hi, Nat.div_mul_le_self n k, Nat.self_le_factorial k ] ) ] ;
        rw [ Finsupp.prod_of_support_subset ];
        any_goals exact fun _ _ => rfl;
        rw [ ← Finset.prod_union ];
        · exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hx₁ |>.1 ), Finset.mem_Icc.mp ( Finset.mem_filter.mp hx₂ |>.1 ) ] ;
        · intro p hp; by_cases h : p ≤ n / k <;> [ exact Finset.mem_union_left _ <| Finset.mem_filter.mpr ⟨ Finset.mem_Icc.mpr ⟨ Nat.pos_of_mem_primeFactors hp, by linarith ⟩, Nat.prime_of_mem_primeFactors hp ⟩ ; exact Finset.mem_union_right _ <| Finset.mem_filter.mpr ⟨ Finset.mem_Icc.mpr ⟨ by linarith, Nat.le_of_mem_primeFactors hp ⟩, Nat.prime_of_mem_primeFactors hp ⟩ ] ;
      have h_prod_A : ∏ i ∈ Finset.range k, A i = Nat.factorial k := by
        -- Since $v_p(\prod_{i<k} (n-i)) = v_p(k!)$ for all $p \leq n/k$, the product $\prod_{i<k} A_i$ must equal $k!$.
        have h_prod_A_eq : (∏ i ∈ Finset.range k, A i) = ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (n / k)), p ^ (Nat.factorization (∏ i ∈ Finset.range k, (n - i)) p) := by
          have h_prod_A_eq : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (n / k)), (∏ i ∈ Finset.range k, p ^ (Nat.factorization (n - i) p)) = p ^ (Nat.factorization (∏ i ∈ Finset.range k, (n - i)) p) := by
            intro p hp; rw [ Nat.factorization_prod ] ; simp +decide [ Finset.prod_pow_eq_pow_sum ] ;
            exact fun i hi => Nat.sub_ne_zero_of_lt <| by nlinarith [ Finset.mem_range.mp hi, Nat.div_mul_le_self n k, Nat.self_le_factorial k ] ;
          rw [ ← Finset.prod_congr rfl h_prod_A_eq, Finset.prod_comm ];
        rw [ h_prod_A_eq, Finset.prod_congr rfl fun p hp => by rw [ h_div p ( Finset.mem_filter.mp hp |>.2 ) ( Finset.mem_Icc.mp ( Finset.mem_filter.mp hp |>.1 ) |>.2 ) ] ];
        conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self ( Nat.factorial_ne_zero k ) ] ;
        rw [ Finsupp.prod_of_support_subset ] <;> norm_num [ Finset.subset_iff ];
        exact fun p pp dp _ => ⟨ ⟨ pp.pos, Nat.le_div_iff_mul_le ( by linarith ) |>.2 <| by nlinarith [ pp.dvd_factorial.mp dp, Nat.self_le_factorial k ] ⟩, pp ⟩
      have h_A_le : ∀ i ∈ Finset.range k, A i ≤ Nat.factorial k := by
        exact fun i hi => h_prod_A ▸ Finset.single_le_prod' ( fun i _ => Nat.one_le_iff_ne_zero.mpr <| Finset.prod_ne_zero_iff.mpr fun p hp => pow_ne_zero _ <| Nat.Prime.ne_zero <| by simpa using Finset.mem_filter.mp hp |>.2 ) hi |> le_trans ( by simp +decide [ A ] ) ;
      have h_B_gt : ∀ i ∈ Finset.range k, 1 < B i := by
        intro i hi; specialize h_prod i hi; contrapose! h_prod; simp_all +decide [ Nat.factorial_ne_zero ] ;
        exact ne_of_gt <| by nlinarith [ Nat.sub_add_cancel <| show i ≤ n from by nlinarith [ Nat.self_le_factorial k ], h_A_le i hi, Nat.factorial_pos k ] ;
      have h_A_lt : ∀ i ∈ Finset.range k, A i < k := by
        intros i hi
        have h_B_gt_i : B i > n / k := by
          -- Since $B_i$ contains only prime factors $> n/k$, we have $B_i > n/k$.
          have h_B_gt_i : ∃ p ∈ Finset.filter Nat.Prime (Finset.Icc (n / k + 1) (n - i)), p ∣ (n - i) := by
            contrapose! h_B_gt;
            use i, hi; rw [ show B i = 1 from Finset.prod_eq_one fun p hp => ?_ ] ; norm_num;
            exact Or.inr ( Nat.factorization_eq_zero_of_not_dvd <| h_B_gt p hp )
          obtain ⟨p, hp₁, hp₂⟩ := h_B_gt_i
          have hp₃ : p > n / k := by
            linarith [ Finset.mem_Icc.mp ( Finset.mem_filter.mp hp₁ |>.1 ) ]
          have hp₄ : p ∣ B i := by
            exact Finset.dvd_prod_of_mem _ hp₁ |> dvd_trans ( dvd_pow_self _ <| Nat.ne_of_gt <| Nat.pos_of_ne_zero <| Finsupp.mem_support_iff.mp <| by { exact Nat.mem_primeFactors.mpr ⟨ Finset.mem_filter.mp hp₁ |>.2, hp₂, by { exact Nat.sub_ne_zero_of_lt <| by { nlinarith [ Finset.mem_range.mp hi, Nat.div_add_mod n k, Nat.mod_lt n ( by linarith : 0 < k ) ] } } ⟩ } ) ;
          have hp₅ : B i ≥ p := by
            exact Nat.le_of_dvd ( pos_of_gt ( h_B_gt i hi ) ) hp₄
          linarith [hp₅, hp₃]
        have h_A_lt_i : A i < k := by
          nlinarith [ h_prod i hi, Nat.div_add_mod n k, Nat.mod_lt n ( by linarith : 0 < k ), Nat.sub_add_cancel ( show i ≤ n from by nlinarith [ Finset.mem_range.mp hi, Nat.factorial_pos k ] ) ]
        exact h_A_lt_i
      have h_div_k : ∃ j ∈ Finset.range k, k ∣ (n - j) := by
        use n % k; simp [Nat.dvd_iff_mod_eq_zero];
        exact ⟨ Nat.mod_lt _ ( by linarith ), Nat.mod_eq_zero_of_dvd ( Nat.dvd_sub_mod _ ) ⟩
      have h_div_A : ∃ j ∈ Finset.range k, k ∣ A j := by
        obtain ⟨ j, hj₁, hj₂ ⟩ := h_div_k;
        use j, hj₁;
        rw [ h_prod j hj₁ ] at hj₂;
        refine' Nat.Coprime.dvd_of_dvd_mul_right _ hj₂;
        refine' Nat.Coprime.prod_right fun p hp => _;
        refine' Nat.Coprime.pow_right _ _;
        refine' Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( Finset.mem_filter.mp hp |>.2 ) |>.2 _ );
        intro h; have := Nat.le_of_dvd ( by linarith ) h; norm_num at *; nlinarith [ Nat.div_add_mod n k, Nat.mod_lt n ( by linarith : 0 < k ), Nat.self_le_factorial k ] ;
      have h_contra : ∃ j ∈ Finset.range k, k ≤ A j := by
        exact ⟨ h_div_A.choose, h_div_A.choose_spec.1, Nat.le_of_dvd ( Finset.prod_pos fun p hp => pow_pos ( Nat.Prime.pos ( by simpa using Finset.mem_filter.mp hp |>.2 ) ) _ ) h_div_A.choose_spec.2 ⟩
      exact h_contra.elim fun j hj => by linarith [h_A_lt j hj.left, hj.right];

/-
For any fixed k ≥ 3, the set of n such that (n, k) is an exceptional pair is finite.
-/
lemma exceptional_pairs_fixed_k (k : ℕ) (hk : 3 ≤ k) : {n | (n, k) ∈ exceptional_pairs}.Finite := by
  obtain ⟨ N, hN ⟩ := exceptional_pairs_large_n_implies_not_exceptional k hk; exact Set.finite_iff_bddAbove.mpr ⟨ N, fun n hn => not_lt.1 fun contra => hN n contra.le hn ⟩ ;

/-
If (n, k) is an exceptional pair, then for all primes p ≤ k, k % p + (n - k) % p < p.
-/
lemma exceptional_implies_no_carry (n k : ℕ) (h : (n, k) ∈ exceptional_pairs) :
    ∀ p, p.Prime → p ≤ k → k % p + (n - k) % p < p := by
      obtain ⟨hk₁, hk₂, hk₃⟩ : 0 < k ∧ 2 * k ≤ n ∧ (Nat.choose n k).minFac > max (n / k) k := h;
      intro p hp hp_le
      by_contra h_contra
      have h_div : p ∣ Nat.choose (n) k := by
        -- By Lucas' Theorem, $\binom{n}{k} \equiv \binom{n \% p}{k \% p} \pmod p$.
        have h_lucas : Nat.choose n k ≡ Nat.choose (n % p) (k % p) * Nat.choose (n / p) (k / p) [MOD p] := by
          haveI := Fact.mk hp;
          exact?;
        -- Since $k \% p + (n - k) \% p \ge p$, we have $n \% p < k \% p$.
        have h_mod : n % p < k % p := by
          have h_mod : n % p = (k % p + (n - k) % p) % p := by
            simp +decide [ ← Nat.add_mod, Nat.add_sub_of_le ( by linarith : k ≤ n ) ];
          rw [ h_mod, Nat.mod_eq_sub_mod ];
          · rw [ Nat.mod_eq_of_lt ];
            · rw [ tsub_lt_iff_left ] <;> linarith [ Nat.mod_lt k hp.pos, Nat.mod_lt ( n - k ) hp.pos ];
            · rw [ tsub_lt_iff_left ] <;> linarith [ Nat.mod_lt k hp.pos, Nat.mod_lt ( n - k ) hp.pos ];
          · linarith;
        simp_all +decide [ Nat.choose_eq_zero_of_lt h_mod, Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
      exact not_lt_of_ge ( Nat.minFac_le_of_dvd hp.two_le h_div ) ( lt_of_le_of_lt hp_le ( lt_of_le_of_lt ( le_max_right _ _ ) hk₃ ) )