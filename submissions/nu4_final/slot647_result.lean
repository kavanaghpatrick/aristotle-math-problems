/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 06776e0a-4ddc-49f1-8827-19cc5751e563

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def radical (n : ℕ) : ℕ := ∏ p ∈ n.primeFactors, p

def IsPowerful (n : ℕ) : Prop := ∀ p, p.Prime → p ∣ n → p ^ 2 ∣ n

def ABC_conjecture : Prop :=
  ∀ ε > 0, ∃ K_ε > 0, ∀ a b c : ℕ,
    0 < a → 0 < b → 0 < c →
    Nat.Coprime a b → a + b = c →
    (c : ℝ) < K_ε * (radical (a * b * c) : ℝ) ^ (1 + ε)

lemma powerful_implies_factorization_ge_2 {n : ℕ} (h : IsPowerful n) {p : ℕ} (hp : p ∈ n.primeFactors) : 2 ≤ n.factorization p := by
  have := h p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp );
  rw [ ← Nat.factorization_le_iff_dvd ] at this <;> aesop

lemma radical_sq_le_self_of_powerful {n : ℕ} (h0 : n ≠ 0) (h : IsPowerful n) : (radical n) ^ 2 ≤ n := by
  -- By definition of radical, we have that radical n = ∏ p ∈ n.primeFactors, p.
  have h_radical_def : radical n = ∏ p ∈ n.primeFactors, p := by
    rfl;
  -- Since n is powerful, for every prime p|n, p^2 | n. This means the exponent of p in the prime factorization of n is at least 2.
  have h_exponent_ge_2 : ∀ p ∈ n.primeFactors, 2 ≤ n.factorization p := by
    exact?;
  conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self h0 ];
  rw [ h_radical_def, ← Finset.prod_pow ];
  exact Finset.prod_le_prod' fun p hp => Nat.pow_le_pow_right ( Nat.pos_of_mem_primeFactors hp ) ( h_exponent_ge_2 p hp )

lemma odd_of_powerful_n_n_plus_2 {n : ℕ} (hn : IsPowerful n) (hn2 : IsPowerful (n + 2)) : Odd n := by
  -- If n is even, then 2 divides n.
  by_cases h_even : Even n
  obtain ⟨k, hk⟩ : ∃ k, n = 2 * k := by
    exact even_iff_two_dvd.mp h_even
  have h₂_even : Even (n + 2) := by
    simp +arith +decide [ *, parity_simps ]
  have h₂_div : 4 ∣ (n + 2) := by
    exact hn2 2 Nat.prime_two ( even_iff_two_dvd.mp h₂_even ) |> fun x => dvd_trans ( by decide ) x;
  have h₂_mod : (n + 2) % 4 = 2 := by
    rcases h₂_div with ⟨ m, hm ⟩ ; replace hn := hn 2 Nat.prime_two ; simp_all +decide [ Nat.pow_succ', ← even_iff_two_dvd, parity_simps ] ;
    omega
  contrapose! h₂_div
  skip;
  · norm_num [ Nat.dvd_iff_mod_eq_zero, h₂_mod ];
  · simpa using h_even

lemma radical_le_sqrt {n : ℕ} (h0 : n ≠ 0) (h : IsPowerful n) : radical n ≤ Real.sqrt n := by
  exact Real.le_sqrt_of_sq_le ( mod_cast radical_sq_le_self_of_powerful h0 h )

lemma radical_bound_triple {n : ℕ} (hn : IsPowerful n) (hn1 : IsPowerful (n + 1)) (hn2 : IsPowerful (n + 2)) :
  (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) ≤ Real.sqrt (n * (n + 2)) * Real.sqrt (n + 1) := by
    -- Since n and n+2 are powerful, n is odd (by odd_of_powerful_n_n_plus_2).
    have h_odd : Odd n := by
      exact?;
    -- Thus gcd(n, n+2) = gcd(n, 2) = 1.
    have h_coprime : Nat.gcd n (n + 2) = 1 := by
      cases h_odd ; aesop
    have h_coprime_sq : Nat.gcd (n * (n + 2)) ((n + 1) ^ 2) = 1 := by
      simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      norm_num [ ( by ring : n + 2 = n + 1 + 1 ) ];
    -- So the radical of the product is the product of the radicals.
    have h_radical : radical (n * (n + 2) * (n + 1) ^ 2) = radical n * radical (n + 2) * radical (n + 1) := by
      have h_radical : radical (n * (n + 2) * (n + 1) ^ 2) = (∏ p ∈ (n * (n + 2) * (n + 1) ^ 2).primeFactors, p) := by
        rfl;
      have h_radical : radical (n * (n + 2) * (n + 1) ^ 2) = ∏ p ∈ (n.primeFactors ∪ (n + 2).primeFactors ∪ (n + 1).primeFactors), p := by
        rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.primeFactors_mul, Nat.primeFactors_pow ];
        native_decide;
      rw [ h_radical, Finset.prod_union, Finset.prod_union ];
      · rfl;
      · exact Nat.Coprime.disjoint_primeFactors h_coprime;
      · simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, Nat.Coprime, Nat.gcd_comm ];
        exact Nat.Coprime.disjoint_primeFactors ( by simp [ ( by ring : n + 1 = n + 1 ) ] )
    have h_radical_le_sqrt : radical n ≤ Real.sqrt n ∧ radical (n + 2) ≤ Real.sqrt (n + 2) ∧ radical (n + 1) ≤ Real.sqrt (n + 1) := by
      apply And.intro;
      · apply radical_le_sqrt; aesop;
        assumption;
      · exact ⟨ Real.le_sqrt_of_sq_le <| mod_cast radical_sq_le_self_of_powerful ( by positivity ) hn2, Real.le_sqrt_of_sq_le <| mod_cast radical_sq_le_self_of_powerful ( by positivity ) hn1 ⟩;
    convert mul_le_mul ( mul_le_mul h_radical_le_sqrt.1 h_radical_le_sqrt.2.1 ( by positivity ) ( by positivity ) ) h_radical_le_sqrt.2.2 ( by positivity ) ( by positivity ) using 1 ; norm_num [ h_radical ];
    rw [ Real.sqrt_mul <| by positivity ]

/-
The radical of the product n(n+2)(n+1)^2 is strictly less than (n+1)^(3/2) for positive powerful n, n+1, n+2.
-/
lemma radical_bound_triple_strict {n : ℕ} (hn : IsPowerful n) (hn1 : IsPowerful (n + 1)) (hn2 : IsPowerful (n + 2)) (hpos : n > 0) :
  (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) < (n + 1 : ℝ) ^ (3 / 2 : ℝ) := by
  -- We have `radical_bound_triple` giving rad <= sqrt(n(n+2)) * sqrt(n+1).
  have h_radical_bound_triple : (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) ≤ Real.sqrt (n * (n + 2)) * Real.sqrt (n + 1) := by
    convert radical_bound_triple hn hn1 hn2 using 1;
  -- Since $\sqrt{n(n+2)} < \sqrt{(n+1)^2} = n+1$, we have $\sqrt{n(n+2)} \cdot \sqrt{n+1} < (n+1) \cdot \sqrt{n+1} = (n+1)^{3/2}$.
  have h_sqrt_bound : Real.sqrt (n * (n + 2)) * Real.sqrt (n + 1) < (n + 1) * Real.sqrt (n + 1) := by
    exact mul_lt_mul_of_pos_right ( Real.sqrt_lt' ( by positivity ) |>.2 ( by nlinarith ) ) ( Real.sqrt_pos.mpr ( by positivity ) );
  exact h_radical_bound_triple.trans_lt <| h_sqrt_bound.trans_eq <| by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ; linarith;

/-
For any p < 2 and K > 0, the set of natural numbers n such that n^2 < K * n^p is finite.
-/
lemma finite_of_pow_lt_pow_mul_const {p : ℝ} {K : ℝ} (hp : p < 2) (hK : 0 < K) :
  {n : ℕ | (n : ℝ) ^ 2 < K * (n : ℝ) ^ p}.Finite := by
  -- For $n > 0$, $n^2 < K * n^p$ is equivalent to $n^{2-p} < K$.
  suffices h_pos : {n : ℕ | 0 < n ∧ (n : ℝ) ^ (2 - p) < K}.Finite by
    refine Set.Finite.subset ( h_pos.union ( Set.finite_singleton 0 ) ) ?_;
    intro n hn; by_cases h : n = 0 <;> simp_all +decide [ Real.rpow_sub ] ;
    exact ⟨ Nat.pos_of_ne_zero h, by rw [ Real.rpow_sub ( by positivity ) ] ; rw [ Real.rpow_two ] ; rw [ div_lt_iff₀ ( by positivity ) ] ; linarith ⟩;
  exact Set.finite_iff_bddAbove.2 ⟨ ⌊K ^ ( 1 / ( 2 - p ) ) ⌋₊, fun n hn => Nat.le_floor <| by exact le_trans ( by rw [ ← Real.rpow_mul ( Nat.cast_nonneg _ ), mul_one_div_cancel ( by linarith ), Real.rpow_one ] ) ( Real.rpow_le_rpow ( by positivity ) ( le_of_lt hn.2 ) <| by exact div_nonneg zero_le_one <| by linarith ) ⟩

/-
If x^2 < K * x^p with p < 2 and x, K > 0, then x is bounded by K^(1/(2-p)).
-/
lemma bound_of_pow_lt_pow_mul_const {x K p : ℝ} (hx : 0 < x) (hK : 0 < K) (hp : p < 2) (h : x ^ 2 < K * x ^ p) :
  x < K ^ (1 / (2 - p)) := by
  -- Dividing both sides by $x^p$ gives $x^{2-p} < K$.
  have h_div : x ^ (2 - p) < K := by
    rw [ Real.rpow_sub hx, Real.rpow_two ];
    rwa [ div_lt_iff₀ ( Real.rpow_pos_of_pos hx _ ) ];
  exact lt_of_le_of_lt ( by rw [ ← Real.rpow_mul hx.le, mul_one_div_cancel ( by linarith ), Real.rpow_one ] ) ( Real.rpow_lt_rpow ( by positivity ) h_div ( by exact one_div_pos.mpr ( by linarith ) ) )

/-
For any natural number n, 1 and n(n+2) are coprime, and 1 + n(n+2) = (n+1)^2.
-/
lemma powerful_triple_setup (n : ℕ) : Nat.Coprime 1 (n * (n + 2)) ∧ 1 + n * (n + 2) = (n + 1) ^ 2 := by
  exact ⟨ Nat.coprime_one_left _, by ring ⟩

def rad_real (n : ℕ) : ℝ := radical n

#check radical

variable (K : ℝ) (n : ℕ)
#check ((n : ℝ) + 1) ^ 2 < K * (radical (n * (n + 2) * (n + 1) ^ 2) : ℝ) ^ (7 / 6 : ℝ)

/-
1 + 1/6 equals 7/6 in the real numbers.
-/
lemma one_plus_inv_six_eq_seven_div_six : (1 : ℝ) + 1 / 6 = 7 / 6 := by
  norm_num

/-
For n > 0, the triple (1, n(n+2), (n+1)^2) satisfies the conditions of the ABC conjecture (positive, coprime, sum).
-/
def abc_triple_a (n : ℕ) : ℕ := 1
def abc_triple_b (n : ℕ) : ℕ := n * (n + 2)
def abc_triple_c (n : ℕ) : ℕ := (n + 1) ^ 2

lemma abc_triple_properties (n : ℕ) (hn : n > 0) :
  let a := abc_triple_a n
  let b := abc_triple_b n
  let c := abc_triple_c n
  0 < a ∧ 0 < b ∧ 0 < c ∧ Nat.Coprime a b ∧ a + b = c := by
  exact ⟨ zero_lt_one, by exact mul_pos hn ( Nat.succ_pos _ ), by exact pow_pos ( Nat.succ_pos _ ) _, by exact powerful_triple_setup n |>.1, by exact powerful_triple_setup n |>.2 ⟩