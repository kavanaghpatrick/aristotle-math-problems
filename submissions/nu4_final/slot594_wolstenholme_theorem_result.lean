/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b70f66c4-2b78-44a4-b88a-f1367870a6a4

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes Wolstenholme's Theorem, which states that for any prime p > 3, the binomial coefficient C(2p-1, p-1) is congruent to 1 modulo p^3. The proof proceeds by expanding the binomial coefficient as a product of terms (1 + p/k), and then analyzing the sums of products of these terms using properties of harmonic numbers and elementary symmetric polynomials. Key lemmas include the vanishing of the sum of inverse squares modulo p, the divisibility of the numerator of the harmonic number H_{p-1} by p^2, and the divisibility of higher-order symmetric sums by p^3.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For prime p > 3, the sum of inverse squares modulo p is 0.
-/
theorem sum_inv_sq_eq_zero (p : ℕ) (hp : p.Prime) (h : p > 3) :
  ∑ k ∈ Finset.Icc 1 (p-1), (k : ZMod p)⁻¹ ^ 2 = 0 := by
    -- The sum of squares modulo p is 0, which implies the result we want since the inverses are equivalent to their squares modulo p.
    have h_sum_square : ∑ j ∈ Finset.Icc 1 (p - 1), j ^ 2 ≡ 0 [MOD p] := by
      -- We can use the formula for the sum of squares: $\sum_{j=1}^{n} j^2 = \frac{n(n+1)(2n+1)}{6}$.
      have h_sum_of_squares : ∑ j ∈ Finset.Icc 1 (p - 1), j ^ 2 = (p - 1) * p * (2 * (p - 1) + 1) / 6 := by
        exact Eq.symm ( Nat.div_eq_of_eq_mul_left ( by decide ) ( Nat.recOn p ( by norm_num ) fun p hp => by cases p <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] at * ; linarith ) );
      rw [ Nat.modEq_zero_iff_dvd, h_sum_of_squares ];
      use ( p - 1 ) * ( 2 * ( p - 1 ) + 1 ) / 6;
      rw [ ← Nat.mul_div_assoc ];
      · grind;
      · rw [ Nat.dvd_iff_mod_eq_zero ] ; rw [ ← Nat.mod_add_div p 6 ] ; have := Nat.mod_lt p ( by decide : 6 > 0 ) ; interval_cases _ : p % 6 <;> norm_num [ Nat.add_mod, two_mul, add_assoc, Nat.mul_mod ] ;
        · simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hp.dvd_iff_eq ];
        · exact absurd ( Nat.Prime.eq_two_or_odd hp ) ( by omega );
        · exact absurd ( Nat.dvd_of_mod_eq_zero ( show p % 3 = 0 by norm_num [ ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 6 ), * ] ) ) ( by rw [ hp.dvd_iff_eq ] <;> linarith );
        · exact absurd ( Nat.Prime.eq_two_or_odd hp ) ( by omega );
    have h_inv_square : ∑ j ∈ Finset.Icc 1 (p - 1), (j : (ZMod p))⁻¹ ^ 2 = ∑ j ∈ Finset.Icc 1 (p - 1), (j : (ZMod p)) ^ 2 := by
      haveI := Fact.mk hp; norm_num [ ← ZMod.natCast_eq_zero_iff ] at *;
      -- Since these are all elements in the finite field $\mathbb{Z}/p\mathbb{Z}$, we can rearrange the terms in the sum.
      have h_rearrange : ∑ x ∈ Finset.univ.erase 0, (x : ZMod p)⁻¹ ^ 2 = ∑ x ∈ Finset.univ.erase 0, (x : ZMod p) ^ 2 := by
        apply Finset.sum_bij (fun x _ => x⁻¹);
        · grind;
        · aesop;
        · exact fun b hb => ⟨ b⁻¹, by aesop ⟩;
        · grind;
      erw [ Finset.sum_Ico_eq_sub _ _, Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ h_rearrange ];
      simp_all +decide [ Finset.sum_range, Nat.sub_add_cancel hp.pos ];
      rcases p with ( _ | _ | p ) <;> simp_all +decide [ Fin.sum_univ_succ, ZMod ];
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

#check harmonic

/-
For an odd prime p, the (p-1)-th harmonic number equals p times the sum of 1/(k(p-k)) for k from 1 to (p-1)/2.
-/
theorem harmonic_eq_sum_pair (p : ℕ) (hp : p.Prime) (h : p > 2) :
  harmonic (p - 1) = p * ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ)) := by
    -- Let's rewrite the sum $\sum_{k=1}^{p-1} \frac{1}{k}$ as $\sum_{k=1}^{(p-1)/2} \left(\frac{1}{k} + \frac{1}{p-k}\right)$
    have h_split : ∑ k ∈ Finset.Icc 1 (p-1), (1 / (k : ℚ)) = ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), ((1 / (k : ℚ)) + (1 / (p - k : ℚ))) := by
      rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num at *;
      · simp_all +decide [ Nat.prime_mul_iff ];
      · erw [ Finset.sum_Ico_eq_sum_range, Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, Finset.sum_add_distrib ];
        norm_num [ two_mul, add_assoc, add_comm, add_left_comm, Finset.sum_range_add ];
        rw [ ← Finset.sum_range_reflect ];
        exact Finset.sum_congr rfl fun x hx => by rw [ Nat.cast_sub <| Nat.le_sub_one_of_lt <| Finset.mem_range.mp hx ] ; rw [ Nat.cast_sub <| by linarith [ Finset.mem_range.mp hx ] ] ; push_cast ; ring;
    convert h_split using 1;
    · erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ harmonic ];
      cases p <;> norm_num [ Finset.sum_range_succ' ] at *;
    · rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ div_add_div ] <;> ring <;> nlinarith [ show ( x : ℚ ) ≥ 1 by exact_mod_cast Finset.mem_Icc.mp hx |>.1, show ( x : ℚ ) < p by exact_mod_cast lt_of_le_of_lt ( Finset.mem_Icc.mp hx |>.2 ) ( Nat.div_lt_of_lt_mul <| by linarith [ Nat.sub_add_cancel hp.pos ] ) ] ;

/-
For prime p > 3, the sum of inverse squares from 1 to (p-1)/2 modulo p is 0.
-/
theorem sum_inv_sq_half_eq_zero (p : ℕ) (hp : p.Prime) (h : p > 3) :
  ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (k : ZMod p)⁻¹ ^ 2 = 0 := by
    -- We know that sum of inverse squares from 1 to (p-1) is 0 modulo p from the provided solution.
    have h_sum_inv_sq : ∑ k ∈ Finset.Icc 1 (p - 1), (k : ZMod p)⁻¹ ^ 2 = 0 := by
      exact?;
    -- But we also know that $\sum_{k=1}^{p-1} k^{-2} = \sum_{k=1}^{(p-1)/2} (k^{-2} + (p-k)^{-2})$.
    have h_pair : ∑ k ∈ Finset.Icc 1 (p - 1), (k : ZMod p)⁻¹ ^ 2 = ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), ((k : ZMod p)⁻¹ ^ 2 + ((p - k) : ZMod p)⁻¹ ^ 2) := by
      rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num;
      · simp_all +decide [ Nat.prime_mul_iff ];
      · erw [ Finset.sum_Ico_eq_sum_range, Finset.sum_Ico_eq_sum_range ] ; norm_num [ two_mul, Finset.sum_add_distrib ];
        norm_num [ add_comm, add_left_comm, Finset.sum_range_add ];
        rw [ ← Finset.sum_range_reflect ];
        refine' Finset.sum_congr rfl fun x hx => _ ; rw [ Nat.cast_sub <| Nat.le_sub_one_of_lt <| Finset.mem_range.mp hx ] ; rw [ Nat.cast_sub <| by linarith [ Finset.mem_range.mp hx ] ] ; norm_num ; ring;
        norm_num [ show ( c : ZMod ( 2 * c + 1 ) ) * 2 = -1 by { exact eq_neg_of_add_eq_zero_left <| by norm_cast; simp +arith +decide } ];
    simp_all +decide [ Finset.sum_add_distrib ];
    haveI := Fact.mk hp; simp_all +decide [ ← two_mul ] ;
    exact h_sum_inv_sq.resolve_left ( by erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by positivity ) ( by linarith ) )

/-
For prime p > 3, the sum of 1/(k(p-k)) modulo p for k from 1 to (p-1)/2 is 0.
-/
theorem sum_inv_mul_p_sub_k_eq_zero (p : ℕ) (hp : p.Prime) (h : p > 3) :
  ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), ((k : ZMod p) * ((p : ZMod p) - k))⁻¹ = 0 := by
    haveI := Fact.mk hp; norm_num [ ← ZMod.natCast_eq_zero_iff ] ;
    convert sum_inv_sq_half_eq_zero p hp h using 1 ; ring

/-
If a rational number q has denominator coprime to p and its value mod p is 0, then its numerator is divisible by p.
-/
lemma rat_num_dvd_of_mod_eq_zero (p : ℕ) (hp : p.Prime) (q : ℚ)
  (h_denom : ¬ (p : ℤ) ∣ q.den)
  (h_mod : (q.num : ZMod p) * (q.den : ZMod p)⁻¹ = 0) :
  (p : ℤ) ∣ q.num := by
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;

/-
For prime p > 3, the denominator of the sum of 1/(k(p-k)) is not divisible by p.
-/
theorem sum_inv_mul_p_sub_k_denom_not_dvd_p (p : ℕ) (hp : p.Prime) (h : p > 3) :
  ¬ (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ))).den := by
    -- The denominator of a sum of rationals divides the product of their denominators.
    have h_denom_divides_prod : (∑ k ∈ Finset.Icc 1 ((p - 1) / 2), 1 / (k * (p - k) : ℚ)).den ∣ (∏ k ∈ Finset.Icc 1 ((p - 1) / 2), (k * (p - k) : ℕ)) := by
      have h_denom_divides_prod : ∀ (s : Finset ℕ) (f : ℕ → ℚ), (∀ k ∈ s, (f k).den ∣ k * (p - k)) → (∑ k ∈ s, f k).den ∣ (∏ k ∈ s, k * (p - k)) := by
        intros s f hf
        induction' s using Finset.induction with k s ih;
        · norm_num;
        · rw [ Finset.prod_insert ih, Finset.sum_insert ih ];
          have h_denom_divides_prod : ∀ (a b : ℚ), (a + b).den ∣ a.den * b.den := by
            exact?;
          exact dvd_trans ( h_denom_divides_prod _ _ ) ( mul_dvd_mul ( hf k ( Finset.mem_insert_self _ _ ) ) ( by apply_assumption; intros x hx; exact hf x ( Finset.mem_insert_of_mem hx ) ) );
      convert h_denom_divides_prod _ _ _;
      intro k hk; rw [ Rat.div_def' ] ; norm_num;
      norm_cast;
      rw [ Int.subNatNat_of_le ( by linarith [ Finset.mem_Icc.mp hk, Nat.div_mul_le_self ( p - 1 ) 2, Nat.sub_add_cancel hp.pos ] ) ] ; norm_num [ Rat.divInt_eq_div ];
      erw [ Rat.mul_den ] ; norm_num;
      split_ifs <;> simp_all +decide [ mul_comm, Int.sign_eq_one_of_pos ];
      exact Nat.div_dvd_of_dvd <| Nat.gcd_dvd_right _ _;
    -- Since $p$ is prime and greater than 3, none of the factors $k(p-k)$ in the product are divisible by $p$.
    have h_prod_not_div_p : ¬(p : ℤ) ∣ (∏ k ∈ Finset.Icc 1 ((p - 1) / 2), (k * (p - k) : ℤ)) := by
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Finset.prod_eq_zero_iff ] ;
      exact fun x hx₁ hx₂ => by rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt hx₁ ( by omega ) ;
    contrapose! h_prod_not_div_p; norm_cast at *;
    rw [ Finset.prod_congr rfl fun x hx => by rw [ Int.subNatNat_of_le ( by linarith [ Finset.mem_Icc.mp hx, Nat.div_mul_le_self ( p - 1 ) 2, Nat.sub_add_cancel hp.pos ] ) ] ] ; exact_mod_cast dvd_trans h_prod_not_div_p h_denom_divides_prod;

/-
The modular value of a sum of rationals is the sum of their modular values, provided denominators are coprime to p.
-/
lemma rat_add_mod_eq_add_mod (p : ℕ) (hp : p.Prime) (q1 q2 : ℚ)
  (h1 : ¬ (p : ℤ) ∣ q1.den) (h2 : ¬ (p : ℤ) ∣ q2.den) :
  ((q1 + q2).num : ZMod p) * ((q1 + q2).den : ZMod p)⁻¹ =
  ((q1.num : ZMod p) * (q1.den : ZMod p)⁻¹) + ((q2.num : ZMod p) * (q2.den : ZMod p)⁻¹) := by
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Rat.add_def ] ;
    rw [ Int.cast_div ] <;> norm_num [ h1, h2 ];
    · have h_gcd : Nat.gcd (Int.natAbs (q1.num * q2.den + q2.num * q1.den)) (q1.den * q2.den) ∣ q1.den * q2.den := by
        exact Nat.gcd_dvd_right _ _;
      have h_gcd : ¬(p : ℤ) ∣ (Nat.gcd (Int.natAbs (q1.num * q2.den + q2.num * q1.den)) (q1.den * q2.den)) := by
        intro h; have := Nat.dvd_trans ( Int.natCast_dvd_natCast.mp h ) h_gcd; simp_all +decide [ Nat.Prime.dvd_mul ] ;
        cases this <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
      simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Nat.cast_div ];
      grind;
    · exact Int.natCast_dvd.mpr ( Nat.gcd_dvd_left _ _ );
    · rw [ ZMod.natCast_eq_zero_iff ] at *;
      rw [ Nat.dvd_gcd_iff ] ; simp_all +decide [ Nat.Prime.dvd_mul ]

/-
The modular value of a sum of rationals is the sum of their modular values, provided all denominators are coprime to p.
-/
lemma rat_sum_mod_eq_sum_mod (p : ℕ) (hp : p.Prime) (s : Finset ℕ) (f : ℕ → ℚ)
  (hf : ∀ i ∈ s, ¬ (p : ℤ) ∣ (f i).den) :
  ((∑ i ∈ s, f i).num : ZMod p) * ((∑ i ∈ s, f i).den : ZMod p)⁻¹ =
  ∑ i ∈ s, ((f i).num : ZMod p) * ((f i).den : ZMod p)⁻¹ := by
    -- By induction on the size of the finite set $s$.
    induction' s using Finset.induction with x s ih;
    · norm_num;
    · simp_all +decide [ Finset.sum_insert ih ];
      have h_denom : ¬(p : ℤ) ∣ (∑ i ∈ s, f i).den := by
        have h_denom : ∀ (s : Finset ℕ), (∀ i ∈ s, ¬(p : ℤ) ∣ (f i).den) → ¬(p : ℤ) ∣ (∑ i ∈ s, f i).den := by
          intro s hs; induction s using Finset.induction <;> simp_all +decide [ Rat.add_def ] ;
          · exact mod_cast hp.not_dvd_one;
          · refine' fun h => hs.1 ( Int.dvd_of_dvd_mul_left_of_gcd_one ( dvd_trans h ( Int.ediv_dvd_of_dvd <| mod_cast Nat.gcd_dvd_right _ _ ) ) _ );
            exact hp.coprime_iff_not_dvd.mpr fun h => ‹¬ ( p : ℤ ) ∣ ( ∑ i ∈ _, f i |> Rat.den ) › <| Int.natCast_dvd.mpr h;
        exact h_denom s hf.2;
      convert rat_add_mod_eq_add_mod p hp ( f x ) ( ∑ i ∈ s, f i ) _ _ using 1 <;> aesop

/-
For prime p > 3, the numerator of the sum of 1/(k(p-k)) is divisible by p.
-/
theorem sum_inv_mul_p_sub_k_num_dvd_p (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ))).num := by
    -- By the previous lemma, the sum's modular value is 0, and since the denominator is coprime to p, the numerator must be divisible by p.
    have h_mod_zero : ((∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ))).num : ZMod p) * ((∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ))).den : ZMod p)⁻¹ = 0 := by
      convert sum_inv_mul_p_sub_k_eq_zero p hp h using 1;
      convert rat_sum_mod_eq_sum_mod p hp _ _ _ using 1;
      · refine' Finset.sum_congr rfl fun x hx => _;
        haveI := Fact.mk hp; simp +decide [ Rat.num_div_den ] ;
        rw [ Rat.mul_num, Rat.mul_den ] ; norm_num;
        norm_cast ; simp_all +decide [ Int.sign_eq_one_of_pos, Nat.cast_sub ( show x ≤ p from le_trans ( Finset.mem_Icc.mp hx |>.2 ) ( Nat.div_le_of_le_mul <| by linarith [ Nat.sub_add_cancel hp.pos ] ) ) ];
        split_ifs <;> simp_all +decide [ Int.subNatNat_eq_coe, Nat.cast_sub ( show x ≤ p from by omega ) ];
        · omega;
        · rw [ Int.sign_eq_one_of_pos, Int.sign_eq_one_of_pos ] <;> norm_num;
          · rw [ abs_of_nonneg ( sub_nonneg_of_le ( mod_cast by omega ) ) ] ; norm_num [ hp.ne_zero, ‹¬x = 0› ];
          · grind;
          · omega;
      · convert sum_inv_mul_p_sub_k_denom_not_dvd_p p hp h using 1;
        constructor <;> intros <;> simp_all +decide [ Rat.mul_den ];
        · convert sum_inv_mul_p_sub_k_denom_not_dvd_p p hp h using 1;
          simp +decide [ mul_comm, div_eq_mul_inv ];
        · split_ifs <;> simp_all +decide [ sub_eq_iff_eq_add ];
          · exact_mod_cast hp.not_dvd_one;
          · norm_cast at *;
            rw [ Int.subNatNat_of_le ( by omega ) ] ; norm_cast ; simp_all +decide [ Nat.dvd_gcd_iff ];
            rw [ Int.sign_eq_one_of_pos, Int.sign_eq_one_of_pos ] <;> norm_num <;> try omega;
            exact Nat.Prime.not_dvd_mul hp ( Nat.not_dvd_of_pos_of_lt ( Nat.sub_pos_of_lt ( by omega ) ) ( Nat.sub_lt hp.pos ( Nat.pos_of_ne_zero ‹_› ) ) ) ( Nat.not_dvd_of_pos_of_lt ( Nat.pos_of_ne_zero ‹_› ) ( by omega ) );
    have h_denom_not_dvd_p : ¬ (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ))).den := by
      convert sum_inv_mul_p_sub_k_denom_not_dvd_p p hp h using 1;
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;

/-
For prime p > 3, the numerator of the (p-1)-th harmonic number is divisible by p^2.
-/
theorem harmonic_num_dvd (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ^ 2 ∣ (harmonic (p - 1)).num := by
    -- Let $S = \sum_{k=1}^{(p-1)/2} \frac{1}{k(p-k)}$.
    set S := ∑ k ∈ Finset.Icc 1 ((p - 1) / 2), (1 / (k * (p - k) : ℚ)) with hS_def;
    -- By harmonic_eq_sum_pair, we have H_{p-1} = p * S.
    have h_harmonic : (harmonic (p - 1)) = p * S := by
      convert harmonic_eq_sum_pair p hp ( by linarith ) using 1
    generalize_proofs at *; (
    -- Let $S = \frac{A}{B}$ where $A = S.num$ and $B = S.den$.
    obtain ⟨A, B, hA, hB⟩ : ∃ A B : ℤ, S = A / B ∧ Int.gcd A B = 1 ∧ 0 < B ∧ (p : ℤ) ∣ A ∧ ¬(p : ℤ) ∣ B := by
      refine' ⟨ S.num, S.den, S.num_div_den.symm, S.reduced, Nat.cast_pos.mpr S.pos, _, _ ⟩
      generalize_proofs at *; (
      convert sum_inv_mul_p_sub_k_num_dvd_p p hp h using 1);
      convert sum_inv_mul_p_sub_k_denom_not_dvd_p p hp h using 1
    generalize_proofs at *; (
    -- So $H_{p-1} = p * (A/B) = (p * A) / B = (p^2 * k) / B$.
    obtain ⟨k, hk⟩ : ∃ k : ℤ, A = p * k := hB.right.right.left
    have h_harmonic_eq : harmonic (p - 1) = (p^2 * k) / B := by
      exact h_harmonic.trans ( by rw [ hA, hk ] ; push_cast; ring ) ;
    generalize_proofs at *; (
    -- The numerator of $H_{p-1}$ is $(p^2 * k) / \gcd(p^2 * k, B)$.
    have h_num : (harmonic (p - 1)).num = (p^2 * k) / Int.gcd (p^2 * k) B := by
      rw [ h_harmonic_eq ] ; norm_cast; simp +decide [ Int.gcd, Int.natAbs_mul ] ; ring;
      rw [ Rat.divInt_eq_div, div_eq_mul_inv ] ; norm_cast ; simp +decide [ Rat.mul_den, Rat.mul_num, Rat.mkRat_def ] ; ring;
      simp +decide [ Int.sign_eq_one_of_pos hB.2.1, Int.natAbs_mul, Int.natAbs_pow, Nat.gcd_mul_left ] ; ring;
      grind
    generalize_proofs at *; (
    -- Since $p \nmid B$, we have $\gcd(p^2 * k, B) = \gcd(k, B)$.
    have h_gcd : Int.gcd (p^2 * k) B = Int.gcd k B := by
      have h_gcd : Int.gcd (p^2) B = 1 := by
        exact_mod_cast Nat.Coprime.pow_left 2 ( hp.coprime_iff_not_dvd.mpr fun h => hB.2.2.2 <| Int.natCast_dvd.mpr h )
      generalize_proofs at *; (
      exact?)
    generalize_proofs at *; (
    simp_all +decide [ Int.gcd, Int.natAbs_mul ];
    refine' Int.dvd_div_of_mul_dvd _;
    rw [ mul_comm ] ; exact mul_dvd_mul_left _ ( Int.natCast_dvd.mpr ( Nat.gcd_dvd_left _ _ ) ) ;)))))

/-
The binomial coefficient C(2p-1, p-1) equals the product of (1 + p/k) for k from 1 to p-1.
-/
theorem choose_eq_prod_one_add_div (p : ℕ) (h : p > 0) :
  ((2 * p - 1).choose (p - 1) : ℚ) = ∏ k ∈ Finset.Icc 1 (p - 1), (1 + (p : ℚ) / k) := by
    -- Now use the identity $\prod_{k=1}^{p-1} (1 + \frac{p}{k}) = \prod_{k=1}^{p-1} \frac{p+k}{k} = \frac{\prod_{k=1}^{p-1} (p+k)}{\prod_{k=1}^{p-1} k}$.
    suffices h_prod : (∏ k ∈ Finset.Icc 1 (p - 1), ((p + k) : ℚ) / ((k) : ℚ)) =
                        Nat.choose (2 * p - 1) (p - 1) by
                          exact h_prod.symm.trans ( Finset.prod_congr rfl fun x hx => by rw [ add_div' ] ; ring ; norm_cast ; linarith [ Finset.mem_Icc.mp hx ] );
    -- The product of (p + k) for k from 1 to p-1 is equal to (2p-1)! / p!.
    have h_prod_num : (∏ k ∈ Finset.Icc 1 (p - 1), (p + k : ℚ)) = (Nat.factorial (2 * p - 1)) / (Nat.factorial p) := by
      -- The product $\prod_{k=1}^{p-1} (p + k)$ can be rewritten as $\prod_{k=p+1}^{2p-1} k$.
      have h_prod_rewrite : (∏ k ∈ Finset.Icc 1 (p - 1), (p + k : ℚ)) = (∏ k ∈ Finset.Icc (p + 1) (2 * p - 1), (k : ℚ)) := by
        erw [ Finset.prod_Ico_eq_prod_range, Finset.prod_Ico_eq_prod_range ] ; norm_num [ two_mul, add_assoc ] ; ring;
        grind;
      -- The product $\prod_{k=p+1}^{2p-1} k$ can be rewritten as $\frac{(2p-1)!}{p!}$.
      have h_prod_factorial : (∏ k ∈ Finset.Icc (p + 1) (2 * p - 1), (k : ℚ)) = (∏ k ∈ Finset.Icc 1 (2 * p - 1), (k : ℚ)) / (∏ k ∈ Finset.Icc 1 p, (k : ℚ)) := by
        erw [ eq_div_iff <| Finset.prod_ne_zero_iff.mpr fun x hx => Nat.cast_ne_zero.mpr <| by linarith [ Finset.mem_Icc.mp hx ] ];
        erw [ mul_comm, Finset.prod_Ico_consecutive ] <;> norm_cast <;> omega;
      erw [ h_prod_rewrite, h_prod_factorial, ← Nat.cast_prod, Finset.prod_Ico_id_eq_factorial, ← Nat.cast_prod, Finset.prod_Ico_id_eq_factorial ];
    rcases p <;> simp_all +decide [ Nat.cast_choose, two_mul, Finset.prod_Ioc_succ_top, Finset.Icc_succ_left_eq_Ioc ];
    erw [ ← Nat.cast_prod, Finset.prod_Ico_id_eq_factorial ] ; ring

/-
Twice the sum of pairwise products of inverses equals the square of the sum of inverses minus the sum of squared inverses.
-/
theorem sum_inv_pair_eq (p : ℕ) (h : p > 0) :
  2 * ∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, (1 / (y : ℚ)) =
  (harmonic (p - 1)) ^ 2 - ∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2 := by
    -- Apply the identity $(\sum_{i=1}^{n} a_i)^2 = \sum_{i=1}^{n} a_i^2 + 2 \sum_{1 \leq i < j \leq n} a_i a_j$ to the sum of $1/k$.
    have h_identity : ∀ (n : ℕ) (hn : 0 < n), (∑ k ∈ Finset.Icc 1 n, (1 / (k : ℚ)))^2 = ∑ k ∈ Finset.Icc 1 n, (1 / (k : ℚ))^2 + 2 * ∑ x ∈ Finset.powersetCard 2 (Finset.Icc 1 n), (∏ y ∈ x, (1 / (y : ℚ))) := by
      intro n;
      induction' n with n ih <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
      -- Split the sum over the powersetCard 2 of the Ioc 0 (n+1) into the sum over the powersetCard 2 of the Ioc 0 n and the sum over the pairs that include (n+1).
      have h_split : Finset.powersetCard 2 (Finset.Ioc 0 (n + 1)) = Finset.powersetCard 2 (Finset.Ioc 0 n) ∪ Finset.image (fun x => {x, n + 1}) (Finset.Ioc 0 n) := by
        ext; simp [Finset.mem_union, Finset.mem_powersetCard, Finset.mem_image];
        constructor;
        · intro h; rcases Finset.card_eq_two.mp h.2 with ⟨ a, b, hab, rfl ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
          grind;
        · rintro ( ⟨ h₁, h₂ ⟩ | ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ) <;> [ exact ⟨ Finset.Subset.trans h₁ ( Finset.Ioc_subset_Ioc_right ( Nat.le_succ _ ) ), h₂ ⟩ ; exact ⟨ Finset.insert_subset_iff.mpr ⟨ Finset.mem_Ioc.mpr ⟨ by linarith, by linarith ⟩, Finset.singleton_subset_iff.mpr ( Finset.mem_Ioc.mpr ⟨ by linarith, by linarith ⟩ ) ⟩, by simp +decide [ Finset.card_insert_of_notMem, show a ≠ n + 1 by linarith ] ⟩ ];
      rw [ h_split, Finset.sum_union ];
      · rcases n <;> simp_all +decide [ Finset.sum_add_distrib, add_sq, Finset.mul_sum _ _ _, Finset.sum_mul ] ; ring;
        rw [ Finset.sum_image ] <;> norm_num [ add_comm, add_left_comm, add_assoc ] ; ring;
        · rw [ Finset.sum_mul _ _ _ ] ; rw [ Finset.sum_mul _ _ _ ] ; refine' congrArg₂ _ _ _ ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ Finset.prod_pair ] <;> norm_num ; ring ; linarith [ Finset.mem_Ioc.mp hx ] ;
          convert rfl;
        · exact fun x hx y hy hxy => by rw [ Finset.ext_iff ] at hxy; have := hxy x; have := hxy y; aesop;
      · norm_num [ Finset.disjoint_right ];
        intros; subst_vars; simp_all +decide [ Finset.subset_iff ] ;
    rcases p with ( _ | _ | p ) <;> simp_all +decide [ harmonic ];
    convert congr_arg ( fun x : ℚ => x - ∑ x ∈ Finset.Icc 1 ( p + 1 ), ( x : ℚ ) ⁻¹ ^ 2 ) ( h_identity ( p + 1 ) ( Nat.succ_pos _ ) ) using 1 <;> norm_num [ Finset.sum_Ico_eq_sum_range ] ; ring;
    · rw [ h_identity ] <;> norm_num ; ring;
    · convert congr_arg ( fun x : ℚ => x - ∑ x ∈ Finset.Icc 1 ( p + 1 ), ( x : ℚ ) ⁻¹ ^ 2 ) ( h_identity ( p + 1 ) ( Nat.succ_pos _ ) ) using 1 <;> norm_num [ Finset.sum_Ico_eq_sum_range ] ; ring;
      erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ add_comm, Finset.sum_range_succ' ];
      norm_num [ add_comm 1, add_assoc, Finset.sum_range_succ' ];
      grind

/-
For prime p > 3, the numerator of the sum of inverse squares is divisible by p.
-/
theorem sum_inv_sq_num_dvd_p (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).num := by
    have h_sum_sq_mod : ( ∑ k ∈ Finset.Icc 1 ( p - 1 ), ( k : ZMod p ) ⁻¹ ^ 2 : ZMod p ) = 0 := by
      convert sum_inv_sq_eq_zero p hp h using 1;
    have h_num_dvd : (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).num := by
      have h_denom_coprime : ¬ (p : ℤ) ∣ (∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).den := by
        -- The denominator of the sum of rational numbers is the product of the denominators of the individual terms.
        have h_denom_prod : (∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).den ∣ (∏ k ∈ Finset.Icc 1 (p - 1), k ^ 2) := by
          have h_denom_prod : ∀ (s : Finset ℕ) (f : ℕ → ℚ), (∀ k ∈ s, (f k).den ∣ k ^ 2) → (∑ k ∈ s, f k).den ∣ (∏ k ∈ s, k ^ 2) := by
            intros s f hf_denom_div
            induction' s using Finset.induction with k s ih;
            · norm_num;
            · rw [ Finset.prod_insert ih, Finset.sum_insert ih ];
              refine' dvd_trans ( Rat.add_den_dvd _ _ ) _;
              exact mul_dvd_mul ( hf_denom_div k ( Finset.mem_insert_self _ _ ) ) ( by apply_assumption; intros x hx; exact hf_denom_div x ( Finset.mem_insert_of_mem hx ) );
          convert h_denom_prod _ _ _ ; aesop;
        have h_denom_coprime : Nat.gcd (∏ k ∈ Finset.Icc 1 (p - 1), k ^ 2) p = 1 := by
          exact Nat.Coprime.prod_left fun x hx => Nat.Coprime.pow_left _ <| Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Finset.mem_Icc.mp hx |>.1 ) <| lt_of_le_of_lt ( Finset.mem_Icc.mp hx |>.2 ) <| Nat.pred_lt hp.ne_zero;
        exact_mod_cast fun h => hp.not_dvd_one <| h_denom_coprime ▸ Nat.dvd_gcd ( Nat.dvd_trans ( Int.natCast_dvd_natCast.mp h ) h_denom_prod ) ( dvd_refl p )
      have h_num_dvd : ((∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).num : ZMod p) * ((∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).den : ZMod p)⁻¹ = 0 := by
        have h_num_dvd : ((∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).num : ZMod p) * ((∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2).den : ZMod p)⁻¹ = ∑ x ∈ Finset.Icc 1 ( p - 1 ), ( x : ZMod p ) ⁻¹ ^ 2 := by
          convert rat_sum_mod_eq_sum_mod p hp _ _ _ using 2;
          · haveI := Fact.mk hp; simp +decide [ ← div_eq_mul_inv ] ;
            rw [ Int.sign_eq_one_of_pos ( sq_pos_of_pos ( Nat.cast_pos.mpr ( Finset.mem_Icc.mp ‹_› |>.1 ) ) ) ] ; aesop;
          · norm_num [ Rat.mul_self_den ];
            exact fun i hi₁ hi₂ => by rw [ if_neg ( by linarith ) ] ; exact mod_cast mt ( hp.dvd_of_dvd_pow ) ( Nat.not_dvd_of_pos_of_lt hi₁ ( lt_of_le_of_lt hi₂ ( Nat.pred_lt hp.ne_zero ) ) ) ;
        convert h_num_dvd using 1 ; aesop;
      exact?;
    convert h_num_dvd using 1

/-
For prime p > 3, the numerator of the sum of pairwise products of inverses is divisible by p.
-/
theorem sum_inv_pair_num_dvd_p (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ∣ (∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, (1 / (y : ℚ))).num := by
    -- By sum_inv_pair_eq, we have $2 * S2 = H_{p-1}^2 - S_sq$, where $S_sq = \sum_{k=1}^{p-1} \frac{1}{k^2}$.
    set S2 := ∑ x ∈ Finset.powersetCard 2 (Finset.Icc 1 (p - 1)), ∏ y ∈ x, (1 / (y : ℚ))
    set H := harmonic (p - 1)
    set S_sq := ∑ k ∈ Finset.Icc 1 (p - 1), (1 / (k : ℚ)) ^ 2
    have h_eq : 2 * S2 = H^2 - S_sq := by
      convert sum_inv_pair_eq p ( by linarith ) using 1;
    -- Since $p^2 \mid H.num$ and $p \mid S_sq.num$, it follows that $p \mid (H^2 - S_sq).num$.
    have h_div : (p : ℤ) ∣ (H^2 - S_sq).num := by
      have h_div : (p : ℤ) ∣ (H^2).num ∧ (p : ℤ) ∣ S_sq.num := by
        have h_div : (p : ℤ) ^ 2 ∣ H.num ∧ (p : ℤ) ∣ S_sq.num := by
          exact ⟨ harmonic_num_dvd p hp h, sum_inv_sq_num_dvd_p p hp h ⟩;
        simp_all +decide [ sq, Rat.mul_self_num ];
        exact dvd_mul_of_dvd_left ( dvd_of_mul_left_dvd h_div.1 ) _;
      have h_div : ∀ (a b : ℚ), (p : ℤ) ∣ a.num → (p : ℤ) ∣ b.num → (p : ℤ) ∣ (a - b).num := by
        intros a b ha hb;
        rw [ Rat.sub_def ];
        rw [ Rat.normalize_eq ];
        refine' Int.dvd_div_of_mul_dvd _;
        refine' Int.natCast_dvd.mpr ( Nat.Coprime.mul_dvd_of_dvd_of_dvd _ _ _ );
        · refine' Nat.Coprime.coprime_dvd_left ( Nat.gcd_dvd_right _ _ ) _;
          refine' Nat.Coprime.mul_left _ _;
          · exact Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr fun h => by have := Rat.reduced a; exact absurd ( Nat.dvd_gcd ( Int.natAbs_dvd_natAbs.mpr ha ) h ) ( by aesop ) );
          · exact Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr fun h => by have := Rat.reduced b; exact absurd ( Nat.dvd_gcd ( Int.natAbs_dvd_natAbs.mpr hb ) h ) ( by aesop ) );
        · exact Nat.gcd_dvd_left _ _;
        · exact Int.natAbs_dvd_natAbs.mpr ( dvd_sub ( dvd_mul_of_dvd_left ha _ ) ( dvd_mul_of_dvd_left hb _ ) );
      exact h_div _ _ ( by tauto ) ( by tauto );
    -- Since $p$ is coprime to $2$, it follows that $p \mid S2.num$.
    have h_coprime : Int.gcd (p : ℤ) 2 = 1 := by
      exact hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p;
    have h_div_S2 : (p : ℤ) ∣ (2 * S2).num := by
      grind;
    rw [ Rat.mul_num ] at h_div_S2;
    refine' Int.dvd_of_dvd_mul_right_of_gcd_one _ _;
    exact 2;
    · refine' dvd_trans h_div_S2 _;
      refine' Int.ediv_dvd_of_dvd _;
      exact Int.natCast_dvd.mpr ( Nat.gcd_dvd_left _ _ );
    · exact h_coprime

/-
For prime p > 3, the sum of products of 3 or more terms of the form p/k is divisible by p^3.
-/
theorem sum_esymm_ge_3_num_dvd_p3 (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ^ 3 ∣ (∑ t ∈ (Finset.Icc 1 (p - 1)).powerset.filter (fun t => 3 ≤ t.card), ∏ k ∈ t, ((p : ℚ) / k)).num := by
    have h_sum_div : ∀ t ∈ Finset.filter (fun t => 3 ≤ t.card) (Finset.powerset (Finset.Icc 1 (p - 1))), (p : ℤ) ^ 3 ∣ (∏ k ∈ t, (p : ℚ) / k).num := by
      intro t ht
      have h_term : (∏ x ∈ t, (p : ℚ) / x) = (p ^ t.card : ℚ) / (∏ x ∈ t, x) := by
        simp +decide [ Finset.prod_div_distrib ];
      -- Since $t.card \geq 3$, we have $p^t.card$ is divisible by $p^3$.
      have h_div : (p : ℤ) ^ 3 ∣ (p ^ t.card : ℤ) := by
        exact pow_dvd_pow _ ( Finset.mem_filter.mp ht |>.2 );
      convert h_div using 1;
      convert Rat.num_div_eq_of_coprime _ _ <;> norm_cast;
      rotate_left;
      exact ↑ ( ∏ x ∈ t, x );
      · exact_mod_cast Finset.prod_pos fun x hx => Finset.mem_Icc.mp ( Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hx ) |>.1;
      · refine' Nat.Coprime.pow_left _ _;
        exact Nat.Coprime.prod_right fun x hx => hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( Finset.mem_Icc.mp ( Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hx ) |>.1 ) h; linarith [ Finset.mem_Icc.mp ( Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hx ) |>.2, Nat.sub_add_cancel hp.pos ] ;
      · simp_all +decide [ Rat.divInt_eq_div ];
    have h_sum_div : ∀ {S : Finset (Finset ℕ)}, (∀ t ∈ S, (p : ℤ) ^ 3 ∣ (∏ k ∈ t, (p : ℚ) / k).num) → (p : ℤ) ^ 3 ∣ (∑ t ∈ S, (∏ k ∈ t, (p : ℚ) / k)).num := by
      intros S hS_div; induction' S using Finset.induction with t S htS ih; aesop;
      rw [ Finset.sum_insert htS ];
      have h_num_div : ∀ (q1 q2 : ℚ), (p : ℤ) ^ 3 ∣ q1.num → (p : ℤ) ^ 3 ∣ q2.num → (p : ℤ) ^ 3 ∣ (q1 + q2).num := by
        intros q1 q2 hq1 hq2
        have h_num_div : (p : ℤ) ^ 3 ∣ (q1.num * q2.den + q2.num * q1.den) := by
          exact dvd_add ( dvd_mul_of_dvd_left hq1 _ ) ( dvd_mul_of_dvd_left hq2 _ );
        rw [ Rat.add_def ];
        rw [ Rat.normalize_eq ];
        refine' Int.dvd_div_of_mul_dvd _;
        refine' Int.natCast_dvd.mpr _;
        refine' Nat.Coprime.mul_dvd_of_dvd_of_dvd _ _ _;
        · refine' Nat.Coprime.coprime_dvd_left ( Nat.gcd_dvd_right _ _ ) _;
          simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
          exact ⟨ Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr fun h => by have := Rat.reduced q1; exact absurd ( Int.natCast_dvd.mp <| Int.dvd_trans ( dvd_pow_self _ three_pos.ne' ) hq1 ) <| by exact fun h' => by have := Nat.dvd_gcd h' h; aesop, Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr fun h => by have := Rat.reduced q2; exact absurd ( Int.natCast_dvd.mp <| Int.dvd_trans ( dvd_pow_self _ three_pos.ne' ) hq2 ) <| by exact fun h' => by have := Nat.dvd_gcd h' h; aesop ⟩;
        · exact Nat.gcd_dvd_left _ _;
        · exact?;
      exact h_num_div _ _ ( hS_div t ( Finset.mem_insert_self _ _ ) ) ( ih fun x hx => hS_div x ( Finset.mem_insert_of_mem hx ) );
    exact h_sum_div ‹_›

/-
For prime p > 3, the numerator of the sum of pairwise products of p/k is divisible by p^3.
-/
theorem sum_pair_p_div_num_dvd_p3 (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ^ 3 ∣ (∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, ((p : ℚ) / y)).num := by
    -- Let S2 = ∑_{i<j} 1/(ij).
    set S2 := ∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, (1 / (y : ℚ)) with hS2
    have h_sum_pairwise : ∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, ((p : ℚ) / y) = p^2 * S2 := by
      rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; aesop;
    -- By Lemma 2, we know that $p | S2.num$.
    have h_S2_num_dvd_p : (p : ℤ) ∣ S2.num := by
      convert sum_inv_pair_num_dvd_p p hp h using 1;
    rw [ h_sum_pairwise, Rat.mul_num ];
    -- Since $p$ is prime and greater than 3, $p^2$ and $S2.den$ are coprime.
    have h_coprime : Nat.gcd (p^2) S2.den = 1 := by
      have h_coprime : S2.den ∣ (∏ x ∈ Finset.powersetCard 2 (Finset.Icc 1 (p - 1)), (∏ y ∈ x, y)) := by
        have h_S2_denom : ∀ {s : Finset (Finset ℕ)}, (∀ x ∈ s, (∏ y ∈ x, y) ≠ 0) → (∑ x ∈ s, (∏ y ∈ x, (1 / (y : ℚ)))).den ∣ (∏ x ∈ s, (∏ y ∈ x, y)) := by
          intros s hs_nonzero
          induction' s using Finset.induction with x s hx ih;
          · norm_num;
          · rw [ Finset.prod_insert hx, Finset.sum_insert hx ];
            refine' dvd_trans ( Rat.add_den_dvd _ _ ) _;
            refine' mul_dvd_mul _ ( ih fun y hy => hs_nonzero y ( Finset.mem_insert_of_mem hy ) );
            norm_num [ Rat.mul_den, Rat.divInt_eq_div ];
            split_ifs <;> simp_all +decide [ Finset.prod_eq_zero_iff ];
            rw [ ← Nat.cast_prod ] ; norm_cast;
        exact h_S2_denom fun x hx => Finset.prod_ne_zero_iff.mpr fun y hy => by linarith [ Finset.mem_Icc.mp ( Finset.mem_powersetCard.mp hx |>.1 hy ) ] ;
      refine' Nat.Coprime.pow_left _ ( hp.coprime_iff_not_dvd.mpr _ );
      refine' fun h => absurd ( Nat.dvd_trans h h_coprime ) _;
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Finset.prod_eq_zero_iff ] ;
      intro x hx hx' y hy; rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( Finset.mem_Icc.mp ( hx hy ) |>.1 ) ( lt_of_le_of_lt ( Finset.mem_Icc.mp ( hx hy ) |>.2 ) ( Nat.pred_lt hp.ne_zero ) ) ;
    norm_num [ Int.natAbs_mul, Int.natAbs_pow, Nat.gcd_mul_left, h_coprime ];
    rw [ Nat.Coprime.gcd_eq_one ] <;> norm_num [ Nat.Coprime, Nat.Coprime.gcd_mul_left_cancel, Nat.Coprime.gcd_mul_right_cancel, h_coprime ];
    · exact mul_dvd_mul_left _ h_S2_num_dvd_p |> fun h => dvd_trans ( by ring_nf; norm_num ) h;
    · exact Rat.reduced _

/-
For prime p > 3, the numerator of the sum of p/k is divisible by p^3.
-/
theorem sum_single_p_div_num_dvd_p3 (p : ℕ) (hp : p.Prime) (h : p > 3) :
  (p : ℤ) ^ 3 ∣ (∑ k ∈ Finset.Icc 1 (p - 1), ((p : ℚ) / k)).num := by
    -- Let H = harmonic (p-1). We know p^2 | H.num (by harmonic_num_dvd).
    set H : ℚ := harmonic (p - 1);
    -- Let H = harmonic (p-1). We know p^2 | H.num (by harmonic_num_dvd). Thus p^3 | p * H.num.
    have h_div : (p : ℤ) ^ 3 ∣ (p * H).num := by
      have h_div : (p : ℤ) ^ 2 ∣ H.num := by
        convert harmonic_num_dvd p hp h using 1;
      convert mul_dvd_mul_left ( p : ℤ ) h_div using 1;
      · ring;
      · norm_num [ Rat.mul_num ];
        -- Since $p$ is prime and does not divide $H.den$, the gcd of $p * H.num$ and $H.den$ is 1.
        have h_gcd : Nat.gcd (p * H.num.natAbs) H.den = 1 := by
          refine' Nat.Coprime.mul_left _ _;
          · refine' hp.coprime_iff_not_dvd.mpr _;
            -- The denominator of $H$ is the product of the denominators of the terms in the sum, which are all less than $p$.
            have h_denom : H.den ∣ (∏ k ∈ Finset.Icc 1 (p - 1), k) := by
              have h_denom : ∀ {s : Finset ℕ}, (∀ k ∈ s, k ≠ 0) → (∑ k ∈ s, (1 / (k : ℚ))).den ∣ (∏ k ∈ s, k) := by
                intros s hs_nonzero
                induction' s using Finset.induction with k s ih;
                · norm_num;
                · rw [ Finset.sum_insert ih, Finset.prod_insert ih ];
                  rw [ Rat.add_def ];
                  rw [ Rat.normalize_eq ];
                  refine' Nat.dvd_trans ( Nat.div_dvd_of_dvd <| Nat.gcd_dvd_right _ _ ) _;
                  exact mul_dvd_mul ( by aesop ) ( by aesop );
              convert h_denom fun k hk => ne_of_gt <| Finset.mem_Icc.mp hk |>.1 using 1;
              simp +zetaDelta at *;
              rw [ harmonic ];
              erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ];
            exact fun h => absurd ( Nat.dvd_trans h h_denom ) ( by erw [ Finset.prod_Ico_id_eq_factorial ] ; exact mt hp.dvd_factorial.mp ( by omega ) );
          · exact H.reduced;
        simp_all +decide [ Int.natAbs_mul, Nat.gcd_mul_left ];
    -- Since the sum of p/k is exactly p * H, we can conclude that the numerator of the sum is divisible by p^3.
    convert h_div using 1;
    norm_num +zetaDelta at *;
    norm_num [ div_eq_mul_inv, Finset.mul_sum _ _ _, harmonic ];
    erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ]

/-
Wolstenholme's Theorem: For any prime p > 3, the binomial coefficient C(2p-1, p-1) is congruent to 1 modulo p^3.
-/
theorem wolstenholme_theorem (p : ℕ) (h : p > 3) (hp : Nat.Prime p) :
    (2 * p - 1).choose (p - 1) ≡ 1 [MOD p ^ 3] := by
      -- By expanding the product using the binomial theorem, we can express $C(2p-1, p-1)$ as:
      have h_expand : ((2 * p - 1).choose (p - 1) : ℚ) = 1 + ∑ k ∈ Finset.Icc 1 (p - 1), ((p : ℚ) / k) + ∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, ((p : ℚ) / y) + ∑ t ∈ (Finset.Icc 1 (p - 1)).powerset.filter (fun t => 3 ≤ t.card), ∏ k ∈ t, ((p : ℚ) / k) := by
        have h_expand : ((2 * p - 1).choose (p - 1) : ℚ) = ∑ t ∈ Finset.powerset (Finset.Icc 1 (p - 1)), ∏ k ∈ t, ((p : ℚ) / k) := by
          convert choose_eq_prod_one_add_div p ( by linarith ) using 1;
          simp +decide [ add_comm ( 1 : ℚ ), Finset.prod_add ];
        rw [ h_expand, ← Finset.sum_filter_add_sum_filter_not ( Finset.powerset ( Finset.Icc 1 ( p - 1 ) ) ) fun t => t.card ≤ 2 ];
        rw [ show ( Finset.powerset ( Finset.Icc 1 ( p - 1 ) ) |> Finset.filter fun t => t.card ≤ 2 ) = { ∅ } ∪ Finset.powersetCard 1 ( Finset.Icc 1 ( p - 1 ) ) ∪ Finset.powersetCard 2 ( Finset.Icc 1 ( p - 1 ) ) from ?_, Finset.sum_union, Finset.sum_union ] <;> norm_num;
        · norm_num [ Finset.powersetCard_one ];
          rfl;
        · exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => by rw [ Finset.mem_powersetCard ] at hx₁ hx₂; aesop;
        · grind;
      -- We have proved that p^3 divides the numerator of S1 (sum_single_p_div_num_dvd_p3).
      -- We have proved that p^3 divides the numerator of S2 (sum_pair_p_div_num_dvd_p3).
      -- We have proved that p^3 divides the numerator of S3+ (sum_esymm_ge_3_num_dvd_p3).
      have h_div : (p : ℤ) ^ 3 ∣ (∑ k ∈ Finset.Icc 1 (p - 1), ((p : ℚ) / k) + ∑ x ∈ (Finset.Icc 1 (p - 1)).powersetCard 2, ∏ y ∈ x, ((p : ℚ) / y) + ∑ t ∈ (Finset.Icc 1 (p - 1)).powerset.filter (fun t => 3 ≤ t.card), ∏ k ∈ t, ((p : ℚ) / k)).num := by
        have h_div : ∀ (q1 q2 q3 : ℚ), ¬ (p : ℤ) ∣ q1.den → ¬ (p : ℤ) ∣ q2.den → ¬ (p : ℤ) ∣ q3.den → (p : ℤ) ^ 3 ∣ q1.num → (p : ℤ) ^ 3 ∣ q2.num → (p : ℤ) ^ 3 ∣ q3.num → (p : ℤ) ^ 3 ∣ (q1 + q2 + q3).num := by
          intros q1 q2 q3 hq1 hq2 hq3 hq1_div hq2_div hq3_div
          have h_sum : (q1 + q2 + q3).num * (q1.den * q2.den * q3.den) = (q1.num * q2.den * q3.den + q2.num * q1.den * q3.den + q3.num * q1.den * q2.den) * (q1 + q2 + q3).den := by
            have h_sum : (q1 + q2 + q3) = (q1.num * q2.den * q3.den + q2.num * q1.den * q3.den + q3.num * q1.den * q2.den) / (q1.den * q2.den * q3.den) := by
              field_simp;
              rw [ ← Rat.mul_den_eq_num, ← Rat.mul_den_eq_num, ← Rat.mul_den_eq_num ] ; ring;
            rw [ eq_div_iff ] at h_sum <;> norm_cast at * <;> simp_all +decide [ Rat.den_nz ];
            rw [ ← @Int.cast_inj ℚ ] ; push_cast ; rw [ ← Rat.mul_den_eq_num ] ; linear_combination' h_sum * ( q1 + q2 + q3 |> Rat.den ) ;
          refine' Int.dvd_of_dvd_mul_left_of_gcd_one _ _;
          use ( q1.den * q2.den * q3.den );
          · exact h_sum.symm ▸ dvd_mul_of_dvd_left ( dvd_add ( dvd_add ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left hq1_div _ ) _ ) ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left hq2_div _ ) _ ) ) ( dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left hq3_div _ ) _ ) ) _;
          · exact_mod_cast Nat.Coprime.pow_left 3 <| Nat.Coprime.mul_right ( Nat.Coprime.mul_right ( hp.coprime_iff_not_dvd.mpr fun h => hq1 <| Int.natCast_dvd_natCast.mpr h ) ( hp.coprime_iff_not_dvd.mpr fun h => hq2 <| Int.natCast_dvd_natCast.mpr h ) ) ( hp.coprime_iff_not_dvd.mpr fun h => hq3 <| Int.natCast_dvd_natCast.mpr h );
        apply h_div;
        any_goals exact sum_single_p_div_num_dvd_p3 p hp h;
        · have h_denom_coprime : ∀ k ∈ Finset.Icc 1 (p - 1), ¬(p : ℤ) ∣ (p / k : ℚ).den := by
            intro k hk; erw [ Rat.den_div_eq_of_coprime ] <;> norm_cast <;> norm_num [ hp.coprime_iff_not_dvd, Nat.dvd_iff_mod_eq_zero, Nat.mod_eq_of_lt ( show k < p from lt_of_le_of_lt ( Finset.mem_Icc.mp hk |>.2 ) ( Nat.pred_lt hp.ne_zero ) ) ] ;
            · linarith [ Finset.mem_Icc.mp hk ];
            · linarith [ Finset.mem_Icc.mp hk ];
            · linarith [ Finset.mem_Icc.mp hk ];
          have h_denom_coprime : ∀ (s : Finset ℕ) (f : ℕ → ℚ), (∀ k ∈ s, ¬(p : ℤ) ∣ (f k).den) → ¬(p : ℤ) ∣ (∑ k ∈ s, f k).den := by
            intros s f hf; induction s using Finset.induction <;> simp_all +decide [ Rat.add_def ] ;
            · exact_mod_cast hp.not_dvd_one;
            · refine' fun h => _;
              have := Int.Prime.dvd_mul' hp ( dvd_trans h ( Int.ediv_dvd_of_dvd <| Int.natCast_dvd_natCast.mpr <| Nat.gcd_dvd_right _ _ ) ) ; simp_all +decide [ Nat.Prime.dvd_mul ] ;
          exact h_denom_coprime _ _ ‹_›;
        · have h_denom_coprime : ∀ x ∈ Finset.powersetCard 2 (Finset.Icc 1 (p - 1)), ¬ (p : ℤ) ∣ (∏ y ∈ x, ((p : ℚ) / y)).den := by
            intros x hx
            have h_denom_coprime : (∏ y ∈ x, ((p : ℚ) / y)).den = (∏ y ∈ x, y) := by
              have h_denom_coprime : ∀ y ∈ x, (∏ y ∈ x, ((p : ℚ) / y)).den = (∏ y ∈ x, y) := by
                intro y hy
                have h_denom_coprime : ∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → (a / b : ℚ).den = b / Nat.gcd a b := by
                  intros a b ha hb; rw [ div_eq_mul_inv ] ; simp +decide [ ha, hb, Rat.mul_den ] ;
                  simp +decide [ Int.sign_eq_one_of_pos ( Nat.cast_pos.mpr ( Nat.pos_of_ne_zero hb ) ), Int.natAbs_mul ]
                have h_denom_coprime : ∀ {s : Finset ℕ}, (∀ y ∈ s, y ≠ 0) → (∏ y ∈ s, ((p : ℚ) / y)).den = (∏ y ∈ s, y) / Nat.gcd (p ^ s.card) (∏ y ∈ s, y) := by
                  intros s hs; induction s using Finset.induction <;> simp_all +decide [ Finset.prod_insert, Nat.gcd_mul_left ] ;
                  convert h_denom_coprime _ _ using 1 <;> norm_cast <;> simp_all +decide [ Nat.gcd_mul_left, Nat.gcd_mul_right ];
                  · linarith;
                  · exact Finset.prod_ne_zero_iff.mpr fun x hx => by aesop;
                rw [ h_denom_coprime fun y hy => by linarith [ Finset.mem_Icc.mp ( Finset.mem_powersetCard.mp hx |>.1 hy ) ], Nat.gcd_comm ];
                rw [ Nat.Coprime.gcd_eq_one ] <;> norm_num;
                exact Nat.Coprime.prod_left fun y hy => Nat.Coprime.pow_right _ <| Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Finset.mem_Icc.mp ( Finset.mem_powersetCard.mp hx |>.1 hy ) |>.1 ) <| lt_of_le_of_lt ( Finset.mem_Icc.mp ( Finset.mem_powersetCard.mp hx |>.1 hy ) |>.2 ) <| Nat.pred_lt hp.ne_zero;
              exact h_denom_coprime _ ( Classical.choose_spec ( Finset.card_pos.mp ( by rw [ Finset.mem_powersetCard.mp hx |>.2 ] ; norm_num ) ) );
            norm_cast ; simp_all +decide [ Nat.Prime.dvd_iff_not_coprime hp ];
            exact Nat.Coprime.prod_right fun y hy => hp.coprime_iff_not_dvd.mpr fun h => by have := Finset.mem_Icc.mp ( hx.1 hy ) ; linarith [ Nat.le_of_dvd ( by linarith [ Finset.mem_Icc.mp ( hx.1 hy ) ] ) h, Nat.sub_add_cancel hp.pos ] ;
          have h_denom_coprime : ∀ (s : Finset (Finset ℕ)), (∀ x ∈ s, ¬ (p : ℤ) ∣ (∏ y ∈ x, ((p : ℚ) / y)).den) → ¬ (p : ℤ) ∣ (∑ x ∈ s, ∏ y ∈ x, ((p : ℚ) / y)).den := by
            intros s hs_coprime
            have h_denom_coprime : ∀ (q : ℚ), ¬ (p : ℤ) ∣ q.den → ∀ (r : ℚ), ¬ (p : ℤ) ∣ r.den → ¬ (p : ℤ) ∣ (q + r).den := by
              intros q hq r hr
              have h_denom_coprime : (q + r).den ∣ q.den * r.den := by
                exact?;
              exact fun h => hq <| Int.Prime.dvd_mul' hp ( dvd_trans h <| mod_cast h_denom_coprime ) |> fun h => h.resolve_right hr;
            induction' s using Finset.induction with x s hx ih;
            · exact_mod_cast hp.not_dvd_one;
            · rw [ Finset.sum_insert hx ];
              exact h_denom_coprime _ ( hs_coprime x ( Finset.mem_insert_self _ _ ) ) _ ( ih fun y hy => hs_coprime y ( Finset.mem_insert_of_mem hy ) );
          exact h_denom_coprime _ ‹_›;
        · have h_denom_coprime : ∀ t ∈ (Finset.Icc 1 (p - 1)).powerset.filter (fun t => 3 ≤ t.card), ¬ (p : ℤ) ∣ (∏ k ∈ t, ((p : ℚ) / k)).den := by
            intros t ht
            have h_denom_coprime : ∀ k ∈ t, ¬ (p : ℤ) ∣ (p / k : ℚ).den := by
              intros k hk
              have h_denom_coprime : ¬ (p : ℤ) ∣ (p / k : ℚ).den := by
                have h_denom : (p / k : ℚ).den = k / Nat.gcd p k := by
                  rw [ div_eq_mul_inv ];
                  erw [ Rat.mul_den ] ; norm_num;
                  cases k <;> simp +decide [ Int.sign_eq_one_of_pos ];
                  exact absurd ( Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hk ) ( by norm_num )
                norm_cast;
                rw [ h_denom, Nat.dvd_div_iff_mul_dvd ];
                · exact Nat.not_dvd_of_pos_of_lt ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( by nlinarith [ Nat.gcd_pos_of_pos_left k hp.pos, Nat.sub_add_cancel hp.pos, Finset.mem_Icc.mp ( Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hk ) ] );
                · exact Nat.gcd_dvd_right _ _;
              convert h_denom_coprime using 1;
            have h_denom_coprime : ∀ {s : Finset ℕ}, (∀ k ∈ s, ¬ (p : ℤ) ∣ (p / k : ℚ).den) → ¬ (p : ℤ) ∣ (∏ k ∈ s, (p / k : ℚ)).den := by
              intros s hs; induction s using Finset.induction <;> simp_all +decide [ Finset.prod_insert, Rat.mul_den ] ;
              · exact_mod_cast hp.not_dvd_one;
              · rw [ pow_succ', mul_div_mul_comm ];
                rw [ Rat.mul_den ] ; norm_cast at * ; simp_all +decide [ Nat.Prime.dvd_mul ];
                exact fun h => absurd ( Nat.dvd_trans h ( Nat.div_dvd_of_dvd <| Nat.gcd_dvd_right _ _ ) ) ( by exact fun h' => hs.1 <| hp.dvd_mul.mp h' |> Or.resolve_right <| by assumption );
            exact h_denom_coprime ‹_›;
          have h_denom_coprime : ∀ (s : Finset (Finset ℕ)), (∀ t ∈ s, ¬ (p : ℤ) ∣ (∏ k ∈ t, ((p : ℚ) / k)).den) → ¬ (p : ℤ) ∣ (∑ t ∈ s, ∏ k ∈ t, ((p : ℚ) / k)).den := by
            intros s hs; induction s using Finset.induction <;> simp_all +decide [ Finset.sum_insert, Finset.prod_insert ] ;
            · exact_mod_cast hp.not_dvd_one;
            · have h_denom_coprime : ∀ (q1 q2 : ℚ), ¬ (p : ℤ) ∣ q1.den → ¬ (p : ℤ) ∣ q2.den → ¬ (p : ℤ) ∣ (q1 + q2).den := by
                intros q1 q2 hq1 hq2; exact (by
                have h_denom_coprime : (q1 + q2).den ∣ q1.den * q2.den := by
                  exact?;
                exact fun h => hq1 <| Int.Prime.dvd_mul' hp ( dvd_trans h <| mod_cast h_denom_coprime ) |> fun h => h.resolve_right hq2);
              have h_denom_coprime : ∀ (s : Finset (Finset ℕ)), (∀ t ∈ s, ¬ (p : ℤ) ∣ (∏ k ∈ t, ((p : ℚ) / k)).den) → ¬ (p : ℤ) ∣ (∑ t ∈ s, ∏ k ∈ t, ((p : ℚ) / k)).den := by
                intro s hs; induction s using Finset.induction <;> simp_all +decide [ Finset.sum_insert, Finset.prod_insert ] ;
                exact_mod_cast hp.not_dvd_one;
              convert ‹∀ ( q1 q2 : ℚ ), ¬ ( p : ℤ ) ∣ q1.den → ¬ ( p : ℤ ) ∣ q2.den → ¬ ( p : ℤ ) ∣ ( q1 + q2 ).den› _ _ _ _ using 1 <;> simp_all +decide [ Finset.prod_div_distrib ];
          exact h_denom_coprime _ ‹_›;
        · convert sum_pair_p_div_num_dvd_p3 p hp h using 1;
        · convert sum_esymm_ge_3_num_dvd_p3 p hp h using 1;
      -- Since $C(2p-1, p-1)$ is an integer, $p^3$ divides $C(2p-1, p-1) - 1$.
      have h_div_int : (p : ℤ) ^ 3 ∣ ((2 * p - 1).choose (p - 1) : ℤ) - 1 := by
        convert h_div using 1;
        rw [ show ( ∑ k ∈ Finset.Icc 1 ( p - 1 ), ( p : ℚ ) / k + ∑ x ∈ Finset.powersetCard 2 ( Finset.Icc 1 ( p - 1 ) ), ∏ y ∈ x, ( p : ℚ ) / y + ∑ t ∈ Finset.powerset ( Finset.Icc 1 ( p - 1 ) ) |>.filter fun t => 3 ≤ t.card, ∏ k ∈ t, ( p : ℚ ) / k ) = ( Nat.choose ( 2 * p - 1 ) ( p - 1 ) : ℚ ) - 1 by linarith ] ; norm_cast;
      exact Nat.ModEq.symm <| Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_div_int;

/-
Wolstenholme's Theorem: For any prime p > 3, the binomial coefficient C(2p-1, p-1) is congruent to 1 modulo p^3.
-/
theorem wolstenholme_theorem_final (p : ℕ) (h : p > 3) (hp : Nat.Prime p) :
    (2 * p - 1).choose (p - 1) ≡ 1 [MOD p ^ 3] := by
      convert wolstenholme_theorem p h hp using 1

#print wolstenholme_theorem
#print wolstenholme_theorem_final