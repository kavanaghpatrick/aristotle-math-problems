/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0a9d60c3-82d2-4366-b44e-6a9883d5a2db

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This file defines the sum S(k) as described in the prompt and proves that S(k) = 0 for all primes k.
Consequently, the conjecture that S(k) > 0 for all odd primes k is disproved.
The definitions use rational arithmetic as implied by the presence of the floor function and division.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define S(k) and evaluate for small primes.
-/
def term (h j k : ℕ) : ℚ :=
  ⌊(h * j : ℚ) / k⌋ - (h * j : ℚ) / k + 1/2

def S' (h k : ℕ) : ℚ :=
  ∑ j ∈ Finset.Ico 1 k, term h j k

def S (k : ℕ) : ℚ :=
  ∑ h ∈ Finset.Ico 1 k, S' h k

#eval S 3
#eval S 5
#eval S 7

/-
Prove that S(k) is 0 for all primes k.
-/
theorem S_eq_zero (k : ℕ) (hk : k.Prime) : S k = 0 := by
  -- For any $h$ coprime to $k$, the term $\{hj/k\}$ permutes $\{1/k, ..., (k-1)/k\}$.
  have h_perm : ∀ h ∈ Finset.Ico 1 k, Nat.gcd h k = 1 → ∑ j ∈ Finset.Ico 1 k, (⌊(h * j : ℚ) / k⌋ - (h * j : ℚ) / k + 1/2) = 0 := by
    -- For any $h$ coprime to $k$, the term $\{hj/k\}$ permutes $\{1/k, ..., (k-1)/k\}$ as $j$ runs through the residues modulo $k$.
    intros h h_mem h_coprime
    have h_perm : (∑ j ∈ Finset.Ico 1 k, (h * j : ℚ) / k - ∑ j ∈ Finset.Ico 1 k, ⌊(h * j : ℚ) / k⌋) = (∑ j ∈ Finset.Ico 1 k, (j : ℚ) / k) := by
      have h_perm : Finset.image (fun j => (h * j) % k) (Finset.Ico 1 k) = Finset.Ico 1 k := by
        refine Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => Finset.mem_Ico.mpr ⟨ Nat.pos_of_ne_zero ?_, Nat.mod_lt _ hk.pos ⟩ ) ?_;
        · exact fun con => by have := Nat.dvd_of_mod_eq_zero con; exact absurd ( hk.dvd_mul.mp this ) ( by rintro ( H | H ) <;> have := Nat.le_of_dvd ( by linarith [ Finset.mem_Ico.mp h_mem, Finset.mem_Ico.mp hx ] ) H <;> linarith [ Finset.mem_Ico.mp h_mem, Finset.mem_Ico.mp hx ] ) ;
        · rw [ Finset.card_image_of_injOn fun x hx y hy hxy => ?_ ];
          haveI := Fact.mk hk; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ] ;
          exact Nat.mod_eq_of_lt hx.2 ▸ Nat.mod_eq_of_lt hy.2 ▸ by simpa [ ← ZMod.natCast_eq_natCast_iff' ] using hxy.resolve_right ( by rw [ ZMod.natCast_eq_zero_iff ] ; exact fun h => by have := Nat.gcd_eq_right h; aesop ) ;
      -- Since $\{hj/k\}$ permutes $\{1/k, ..., (k-1)/k\}$, we can rewrite the sum as:
      have h_sum_eq : ∑ j ∈ Finset.Ico 1 k, (h * j : ℚ) / k = ∑ j ∈ Finset.Ico 1 k, (⌊(h * j : ℚ) / k⌋ + (↑((h * j) % k) : ℚ) / k) := by
        apply Finset.sum_congr rfl;
        intro x hx; rw [ show ( h * x : ℚ ) = k * ( ⌊ ( h * x : ℚ ) / k⌋ : ℚ ) + ( h * x % k : ℕ ) by
                          norm_cast; rw [ ← Nat.div_add_mod ( h * x ) k ] ; norm_num [ hk.ne_zero, mul_div_cancel_left₀ ] ;
                          rw [ Nat.div_add_mod ] ] ;
        norm_num [ add_div, mul_div_cancel_left₀, hk.ne_zero ];
        exact ⟨ by positivity, by rw [ div_lt_one ( Nat.cast_pos.mpr hk.pos ) ] ; exact_mod_cast Nat.mod_lt _ hk.pos ⟩;
      simp_all +decide [ Finset.sum_add_distrib ];
      conv_rhs => rw [ ← h_perm, Finset.sum_image ( Finset.card_image_iff.mp <| by aesop ) ] ;
    -- The sum of the fractional parts $\{hj/k\}$ is $\sum_{r=1}^{k-1} r/k = \frac{1}{k} \frac{(k-1)k}{2} = \frac{k-1}{2}$.
    have h_frac_sum : ∑ j ∈ Finset.Ico 1 k, (j : ℚ) / k = (k - 1) / 2 := by
      rw [ ← Finset.sum_div _ _ _, Finset.sum_Ico_eq_sub _ hk.pos ];
      exact div_eq_div_iff ( Nat.cast_ne_zero.mpr hk.ne_zero ) ( by norm_num ) |>.2 ( Nat.recOn k ( by norm_num ) fun n ih => by norm_num [ Finset.sum_range_succ ] at * ; linarith );
    simp_all +decide [ Finset.sum_add_distrib ];
    rw [ Nat.cast_pred hk.pos ] ; linear_combination -h_perm;
  convert Finset.sum_eq_zero fun x hx => h_perm x hx <| Nat.coprime_comm.mp ( hk.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Finset.mem_Ico.mp hx |>.1 ) ( Finset.mem_Ico.mp hx |>.2 ) ) using 1

/-
Disprove the conjecture that S(k) > 0 for all odd primes k.
-/
theorem conj_1_1_false : ¬ (∀ k : ℕ, k.Prime → Odd k → 0 < S k) := by
  -- Assume the conjecture is true.
  by_contra h_contra;
  exact absurd ( h_contra 3 Nat.prime_three ( by decide ) ) ( by native_decide )