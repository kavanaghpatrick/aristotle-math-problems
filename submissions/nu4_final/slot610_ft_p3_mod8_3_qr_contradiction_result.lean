/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 82a90a6d-a70c-4aa4-8081-a560d591d880

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formally proven the Feit-Thompson p=3 case for q ≡ 3 (mod 8).

The main result is `ft_p3_q_mod8_eq3`, which states that for a prime q > 9 with q ≡ 3 (mod 8) and A = q² + q + 1 prime, 3^q ≢ 1 (mod A).

The proof proceeds by contradiction:
1. Assuming 3^q ≡ 1 (mod A), we derive that (1-q)^((A-1)/2) ≡ -1 (mod A) using the helper lemma `one_sub_q_pow_A_minus_one_div_two`.
2. We compute the Legendre symbol (1-q / A) unconditionally using quadratic reciprocity.
   - We show A ≡ 1 (mod 4) (`A_mod_4_eq_1`) and A ≡ 5 (mod 8) (`A_mod_8_eq_5`).
   - We show q ≡ 11 (mod 24) (`q_mod_24_eq_11`).
   - We use these congruences to evaluate the Jacobi symbols involved, ultimately showing `legendreSym A (1-q) = 1` (`legendreSym_one_sub_q_eq_one`).
3. By Euler's criterion, (1-q)^((A-1)/2) ≡ (1-q / A) (mod A).
4. This leads to -1 ≡ 1 (mod A), which implies A | 2, contradicting A > 3 (`A_gt_three`).

All steps have been formally verified in Lean 4.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For A = q^2 + q + 1, (1-q)^2 = -3q in ZMod A.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

theorem one_sub_q_sq_eq_neg_three_q (q : ℕ) [Fact (Nat.Prime (A q))] :
    ((1 - q : ZMod (A q)) ^ 2) = -3 * q := by
      have h_sub : (q ^ 2 + q + 1 : (ZMod (A q))) = 0 := by
        norm_cast;
        erw [ ZMod.natCast_eq_zero_iff ] ; exact ⟨ 1, by unfold A; ring ⟩;
      linear_combination' h_sub

/-
If 3^q = 1 mod A, then (1-q)^(2q) = q+1 mod A.
-/
theorem one_sub_q_pow_2q (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3)
    [Fact (Nat.Prime (A q))] (h_3q : (3 : ZMod (A q))^q = 1) :
    (1 - q : ZMod (A q)) ^ (2 * q) = q + 1 := by
      -- From Fact 2, (1-q)^{2q} = ((1-q)^2)^q = (-3q)^q = (-1)^q * 3^q * q^q.
      have h1 : ((1 - q : ZMod (A q)) ^ (2 * q)) = (-1 : ZMod (A q)) ^ q * 3 ^ q * q ^ q := by
        rw [ pow_mul ];
        rw [ ← mul_pow, ← mul_pow ] ; rw [ one_sub_q_sq_eq_neg_three_q ] ; ring;
      -- Since $q$ is odd, $(-1)^q = -1$.
      have h2 : (-1 : ZMod (A q)) ^ q = -1 := by
        by_cases h : Even q <;> simp_all +decide [ Nat.even_iff ];
        · omega;
        · rw [ neg_one_pow_eq_pow_mod_two ] ; aesop;
      -- By assumption, $3^q = 1$. So we need to show that $q^q = -(q+1)$.
      have h3 : (q : ZMod (A q)) ^ q = -(q + 1) := by
        -- From Fact 2, $q^q = q^{q \mod 3} = q^2$ in $ZMod A$ (since $q \equiv 2 \mod 3$).
        have h3 : (q : ZMod (A q)) ^ q = (q : ZMod (A q)) ^ 2 := by
          -- Since $q \equiv 2 \mod 3$, we have $q^q \equiv q^2 \mod A$.
          have h_q_mod3 : q % 3 = 2 := by
            by_contra h_contra;
            -- If $q \equiv 1 \mod 3$, then $A \equiv 3 \mod 3$, which contradicts the assumption that $A$ is prime.
            have hA_mod3 : (A q) % 3 = 0 := by
              unfold A; norm_num [ Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt q zero_lt_three; interval_cases _ : q % 3 <;> simp_all +decide ;
              simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_iff_eq Fact.out ];
            have := Nat.dvd_of_mod_eq_zero hA_mod3; simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ] ;
            exact absurd this ( by rw [ show A q = q^2 + q + 1 from rfl ] ; nlinarith )
          have h_q_pow : (q : ZMod (A q)) ^ q = (q : ZMod (A q)) ^ (q % 3) := by
            -- Since $q$ is a prime number greater than 9, we have $q^3 \equiv 1 \mod A$.
            have h_q3 : (q : ZMod (A q)) ^ 3 = 1 := by
              have h_q3 : (q : ZMod (A q)) ^ 3 - 1 = 0 := by
                norm_cast at *;
                rw [ ZMod.intCast_zmod_eq_zero_iff_dvd ];
                norm_num [ Int.subNatNat_eq_coe ] ; exact ⟨ q - 1, by rw [ show A q = q ^ 2 + q + 1 from rfl ] ; push_cast; ring ⟩ ;
              exact eq_of_sub_eq_zero h_q3;
            exact?
          rw [h_q_pow, h_q_mod3];
        -- Since $q^2 + q + 1 \equiv 0 \pmod{A}$, we have $q^2 \equiv -q - 1 \pmod{A}$.
        have h4 : (q : ZMod (A q)) ^ 2 = - (q + 1) := by
          erw [ eq_neg_iff_add_eq_zero ] ; norm_cast ; aesop
        rw [h3, h4]
      simp_all +decide [ pow_mul', ← mul_pow ]

/-
If 3^q = 1 mod A, then (1-q)^(6q) = -1 mod A.
-/
theorem one_sub_q_pow_6q (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3)
    [Fact (Nat.Prime (A q))] (h_3q : (3 : ZMod (A q))^q = 1) :
    (1 - q : ZMod (A q)) ^ (6 * q) = -1 := by
      -- From (1) we have (1-q)^{2q} q+1 mod A.
      have h_one_sub_q_pow_2q_mod_A : (1 - q : ZMod (A q)) ^ (2 * q) = q + 1 := by
        convert one_sub_q_pow_2q q hq_gt_9 hq_mod8 h_3q using 1;
      -- So (q+1)^3 = (q+1)^2 * (q+1) = q * (q+1) = q^2 + q = -1.
      have h_q1_cubed : (q + 1 : ZMod (A q)) ^ 3 = -1 := by
        -- Since $A = q^2 + q + 1$, we have $q^2 + q + 1 = 0$ in $ZMod (A q)$.
        have h_A_zero : (q^2 + q + 1 : ZMod (A q)) = 0 := by
          norm_cast;
          erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
        linear_combination' h_A_zero * ( q + 2 );
      rw [ ( by ring : 6 * q = 2 * q * 3 ), pow_mul, h_one_sub_q_pow_2q_mod_A, h_q1_cubed ]

/-
If q ≡ 1 (mod 3), then 3 divides A(q).
-/
theorem q_mod_3_eq_1_implies_3_dvd_A (q : ℕ) (h : q % 3 = 1) : 3 ∣ A q := by
  exact Nat.dvd_of_mod_eq_zero ( by unfold A; norm_num [ Nat.add_mod, Nat.pow_mod, h ] )

/-
If q > 1, then A(q) > 3.
-/
theorem A_gt_three (q : ℕ) (hq : q > 1) : A q > 3 := by
  exact Nat.lt_of_lt_of_le ( by decide ) ( Nat.add_le_add ( Nat.add_le_add ( Nat.pow_le_pow_left hq 2 ) hq ) le_rfl )

/-
If q > 1 and A(q) is prime, then q % 3 ≠ 1.
-/
theorem q_mod_3_ne_1 (q : ℕ) (hq_gt_1 : q > 1) [Fact (Nat.Prime (A q))] : q % 3 ≠ 1 := by
  -- Assume q % 3 = 1.
  by_contra h_contra
  have h_div : 3 ∣ A q := by
    exact?;
  simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ];
  exact absurd h_div ( by { exact ne_of_gt ( by { exact lt_of_lt_of_le ( by decide ) ( Nat.add_le_add ( Nat.add_le_add ( Nat.pow_le_pow_left hq_gt_1 2 ) hq_gt_1 ) le_rfl ) } ) } )

/-
If q is prime > 3 and A(q) is prime, then q ≡ 2 (mod 3).
-/
theorem prime_A_implies_q_mod_3_eq_2 (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_3 : q > 3) [Fact (Nat.Prime (A q))] :
    q % 3 = 2 := by
      -- Since q is prime and q > 3, q is not divisible by 3. So q % 3 ≠ 0.
      have hq_mod_3_ne_0 : q % 3 ≠ 0 := by
        exact fun h => by have := Nat.dvd_of_mod_eq_zero h; rw [ Nat.dvd_prime ( Fact.out : Nat.Prime q ) ] at this; omega;
      have := Nat.mod_lt q three_pos; interval_cases _ : q % 3 <;> simp_all +decide ;
      exact absurd ( q_mod_3_ne_1 q ( by linarith ) ) ( by simp +decide [ * ] )

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then (A(q)-1)/2 ≡ 6q (mod 12q).
-/
theorem exponent_congruence (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    (A q - 1) / 2 % (12 * q) = 6 * q := by
      -- By prime_A_implies_q_mod_3_eq_2, q % 3 = 2. We have q ≡ 3 (mod 8) and q ≡ 2 (mod 3).
      have hq_mod_3 : q % 3 = 2 := by
        exact prime_A_implies_q_mod_3_eq_2 q ( by linarith )
      have hq_mod_24 : q % 24 = 11 := by
        grind +ring;
      -- We need to show that $(A-1)/2 \equiv 6q \pmod{12q}$.
      have h_cong : (q * (q + 1)) / 2 ≡ 6 * q [MOD 12 * q] := by
        rw [ Nat.modEq_iff_dvd ];
        exact ⟨ - ( q / 24 ), by push_cast; nlinarith [ Nat.mod_add_div q 24, Nat.div_mul_cancel ( show 2 ∣ q * ( q + 1 ) from even_iff_two_dvd.mp ( by simp +arith +decide [ mul_add, parity_simps ] ) ) ] ⟩;
      rw [ show A q = q ^ 2 + q + 1 by rfl, Nat.add_sub_cancel ];
      rw [ show q ^ 2 + q = q * ( q + 1 ) by ring, h_cong ];
      rw [ Nat.mod_eq_of_lt ( by linarith ) ]

/-
If 3^q = 1 mod A, then (1-q)^((A-1)/2) = -1 mod A.
-/
theorem one_sub_q_pow_A_minus_one_div_two (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] (h_3q : (3 : ZMod (A q))^q = 1) :
    (1 - q : ZMod (A q)) ^ ((A q - 1) / 2) = -1 := by
      -- By exponent_congruence, (A-1)/2 = k * (12q) + 6q for some k.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, (A q - 1) / 2 = k * (12 * q) + 6 * q := by
        have := exponent_congruence q hq_gt_9 hq_mod8 ; simp_all +decide [ Nat.div_eq_of_lt ];
        exact ⟨ ( A q - 1 ) / 2 / ( 12 * q ), by linarith [ Nat.mod_add_div ( ( A q - 1 ) / 2 ) ( 12 * q ) ] ⟩;
      -- By one_sub_q_pow_6q, (1 - q)^{6q} = -1.
      have h_exp : (1 - q : ZMod (A q)) ^ (6 * q) = -1 := by
        convert one_sub_q_pow_6q q hq_gt_9 hq_mod8 h_3q using 1;
      simp_all +decide [ pow_add, pow_mul' ];
      rw [ show ( ( 1 - q : ZMod ( A q ) ) ^ q ) ^ 12 = ( ( ( 1 - q : ZMod ( A q ) ) ^ q ) ^ 6 ) ^ 2 by ring, h_exp ] ; norm_num

/-
If q ≡ 3 (mod 8), then A(q) ≡ 1 (mod 4).
-/
theorem A_mod_4_eq_1 (q : ℕ) (hq_mod8 : q % 8 = 3) : A q % 4 = 1 := by
  unfold A; rw [ ← Nat.mod_add_div q 8, hq_mod8 ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ;

/-
If q ≡ 3 (mod 8) and A(q) is prime, then legendreSym A(q) (-1) = 1.
-/
theorem legendreSym_neg_one_eq_one (q : ℕ) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    legendreSym (A q) (-1) = 1 := by
      -- By A_mod_4_eq_1, A q % 4 = 1.
      have hA_mod_4 : (A q) % 4 = 1 := by
        exact A_mod_4_eq_1 q hq_mod8;
      rw [ legendreSym.at_neg_one ];
      · erw [ ZMod.χ₄_nat_mod_four ] ; aesop;
      · grind

/-
If q ≡ 3 (mod 8), then A(q) ≡ 5 (mod 8).
-/
theorem A_mod_8_eq_5 (q : ℕ) (hq_mod8 : q % 8 = 3) : A q % 8 = 5 := by
  unfold A; norm_num [ Nat.add_mod, Nat.pow_mod, hq_mod8 ] ;

/-
If q ≡ 3 (mod 8) and A(q) is prime, then legendreSym A(q) 2 = -1.
-/
theorem legendreSym_two_eq_neg_one (q : ℕ) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    legendreSym (A q) 2 = -1 := by
      -- By A_mod_8_eq_5, A q % 8 = 5.
      have hA_mod_8 : (A q) % 8 = 5 := by
        exact?;
      rw [ legendreSym.at_two ];
      · erw [ ZMod.χ₈_nat_mod_eight ] ; aesop;
      · grind

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then q ≡ 11 (mod 24).
-/
theorem q_mod_24_eq_11 (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    q % 24 = 11 := by
      have := prime_A_implies_q_mod_3_eq_2 q ( by linarith ) ; ( rw [ ← Nat.mod_mod_of_dvd q ( by decide : 3 ∣ 24 ) ] at this; ( rw [ ← Nat.mod_mod_of_dvd q ( by decide : 8 ∣ 24 ) ] at *; ( have := Nat.mod_lt q ( by decide : 0 < 24 ) ; interval_cases _ : q % 24 <;> simp_all +decide only ; ) ) )

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then (q-1)/2 ≡ 5 (mod 12).
-/
theorem m_mod_12_eq_5 (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    ((q - 1) / 2) % 12 = 5 := by
      -- By q_mod_24_eq_11, q % 24 = 11.
      have h_mod : (q % 24) = 11 := by
        convert q_mod_24_eq_11 q hq_gt_9 hq_mod8 using 1;
      omega

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then (q-1)/2 ≡ 1 (mod 4).
-/
theorem m_mod_4_eq_1 (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    ((q - 1) / 2) % 4 = 1 := by
      grind

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then jacobiSym ((q-1)/2) A(q) = -1.
-/
theorem jacobiSym_m_eq_neg_one (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    jacobiSym ((q - 1) / 2) (A q) = -1 := by
      -- Let m = (q-1)/2.
      set m : ℕ := (q - 1) / 2;
      -- By quadratic reciprocity, (m/A)(A/m) = (-1)^((m-1)/2 * (A-1)/2).
      have h_reciprocity : jacobiSym m (A q) * jacobiSym (A q) m = (-1) ^ ((m - 1) / 2 * ((A q - 1) / 2)) := by
        rw [ jacobiSym.quadratic_reciprocity ];
        · -- Since $A q$ is prime and $m$ is odd, we have $\left(\frac{A q}{m}\right) = \pm 1$.
          have h_jacobi_Aq_m : jacobiSym (A q) m = 1 ∨ jacobiSym (A q) m = -1 := by
            refine' jacobiSym.eq_one_or_neg_one _;
            refine' Nat.Coprime.symm _;
            refine' Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( Fact.out : Nat.Prime ( A q ) ) |>.2 _ );
            exact Nat.not_dvd_of_pos_of_lt ( Nat.div_pos ( Nat.le_sub_one_of_lt ( by linarith ) ) zero_lt_two ) ( Nat.div_lt_of_lt_mul <| by rw [ show A q = q ^ 2 + q + 1 from rfl ] ; nlinarith [ Nat.sub_add_cancel ( by linarith : 1 ≤ q ) ] );
          rcases Nat.even_or_odd' m with ⟨ k, hk | hk ⟩ <;> rcases Nat.even_or_odd' ( A q ) with ⟨ l, hl | hl ⟩ <;> simp_all +decide [ Nat.add_div ];
          · exact absurd ( Fact.out ( p := Nat.Prime ( 2 * l ) ) ) ( Nat.not_prime_mul ( by decide ) ( by linarith [ show l > 1 from by linarith [ show A q > 2 from by exact lt_add_of_le_of_pos ( Nat.succ_le_of_lt ( by nlinarith only [ hq_gt_9 ] ) ) ( Nat.succ_pos _ ) ] ] ) );
          · grind;
          · simp_all +decide [ Nat.prime_mul_iff ];
            norm_num [ show l = 1 by exact Fact.out ] at *;
            exact absurd hl ( by rw [ show A q = q ^ 2 + q + 1 by rfl ] ; nlinarith only [ hq_gt_9 ] );
          · rcases h_jacobi_Aq_m with h | h <;> rw [ h ] <;> ring;
        · exact Nat.odd_iff.mpr ( by omega );
        · exact Nat.odd_iff.mpr ( by unfold A; norm_num [ Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt q ( by decide : 0 < 2 ) ; interval_cases q % 2 <;> trivial );
      -- Since m ≡ 1 (mod 4), (m-1)/2 is even, so (-1)^... = 1.
      have h_even : ((m - 1) / 2 * ((A q - 1) / 2)) % 2 = 0 := by
        -- Since m ≡ 1 (mod 4), (m-1)/2 is even.
        have h_even_m : ((m - 1) / 2) % 2 = 0 := by
          exact Nat.mod_eq_zero_of_dvd ( Nat.dvd_div_of_mul_dvd ( by omega ) );
        norm_num [ Nat.mul_mod, h_even_m ];
      -- So (m/A) = (A/m).
      have h_eq : jacobiSym m (A q) = jacobiSym (A q) m := by
        rw [ ← Nat.mod_add_div ( ( m - 1 ) / 2 * ( ( A q - 1 ) / 2 ) ) 2, h_even ] at h_reciprocity ; norm_num [ pow_add, pow_mul ] at h_reciprocity;
        rw [ Int.mul_eq_one_iff_eq_one_or_neg_one ] at h_reciprocity ; aesop;
      -- A = q^2 + q + 1 = (2m+1)^2 + (2m+1) + 1 = 4m^2 + 4m + 1 + 2m + 2 = 4m^2 + 6m + 3.
      have hA : A q = 4 * m ^ 2 + 6 * m + 3 := by
        unfold A m; nlinarith [ Nat.div_mul_cancel ( show 2 ∣ q - 1 from even_iff_two_dvd.mp ( by rw [ Nat.even_sub ( by linarith ) ] ; simpa [ parity_simps ] using Nat.Prime.odd_of_ne_two ( Fact.out : Nat.Prime q ) ( by linarith ) ) ), Nat.sub_add_cancel ( by linarith : 1 ≤ q ) ] ;
      -- A ≡ 3 (mod m).
      have hA_mod_m : A q ≡ 3 [MOD m] := by
        norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, hA ];
        norm_num [ Nat.pow_mod ];
      -- So (A/m) = (3/m).
      have hA_m : jacobiSym (A q) m = jacobiSym 3 m := by
        rw [ jacobiSym.mod_left ];
        rw_mod_cast [ hA_mod_m ];
        rcases m with ( _ | _ | _ | _ | m ) <;> norm_num at *;
        rw [ Int.emod_eq_of_lt ] <;> linarith;
      -- By quadratic reciprocity, (3/m)(m/3) = (-1)^((3-1)/2 * (m-1)/2) = 1.
      have h_reciprocity_3_m : jacobiSym 3 m * jacobiSym m 3 = 1 := by
        rw [ jacobiSym.quadratic_reciprocity ] <;> norm_num;
        · -- Since $m \equiv 5 \pmod{12}$, we have $m / 2 \equiv 2 \pmod{6}$.
          have h_m_div_2_mod_6 : m / 2 % 6 = 2 := by
            have h_m_div_2_mod_6 : m % 12 = 5 := by
              exact?;
            omega;
          rw [ ← Nat.mod_add_div ( m / 2 ) 6, h_m_div_2_mod_6 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
          rw [ ← sq, jacobiSym.sq_one ];
          refine' Nat.prime_three.coprime_iff_not_dvd.mpr _;
          omega;
        · exact Nat.odd_iff.mpr ( by omega );
      -- By m_mod_12_eq_5, m ≡ 5 (mod 12), so m ≡ 2 (mod 3).
      have hm_mod_3 : m % 3 = 2 := by
        have hm_mod_3 : m % 12 = 5 := by
          exact?;
        norm_num [ ← Nat.mod_mod_of_dvd m ( by decide : 3 ∣ 12 ), hm_mod_3 ];
      -- So (m/3) = (2/3) = -1.
      have hm_3 : jacobiSym m 3 = -1 := by
        rw [ jacobiSym.mod_left ] ; norm_num [ hm_mod_3 ];
        norm_cast; rw [ hm_mod_3 ] ; norm_num;
        rfl;
      grind

/-
If q > 9, q ≡ 3 (mod 8), and A(q) is prime, then legendreSym A(q) (1-q) = 1.
-/
theorem legendreSym_one_sub_q_eq_one (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3) [Fact (Nat.Prime (A q))] :
    legendreSym (A q) (1 - q) = 1 := by
      -- By definition of legendreSym, we know that legendreSym (A q) (1 - q) = legendreSym (A q) (-1) * legendreSym (A q) 2 * legendreSym (A q) ((q - 1) / 2).
      have h_legendre_mul : legendreSym (A q) (1 - q) = legendreSym (A q) (-1) * legendreSym (A q) 2 * legendreSym (A q) ((q - 1) / 2) := by
        rw [ ← legendreSym.mul, ← legendreSym.mul ];
        exact congr_arg _ ( by linarith [ Int.ediv_mul_cancel ( show 2 ∣ ( q : ℤ ) - 1 from even_iff_two_dvd.mp ( by simpa [ parity_simps ] using Nat.Prime.odd_of_ne_two Fact.out ( by linarith ) ) ) ] );
      -- By definition of jacobiSym, we know that jacobiSym m (A q) = legendreSym (A q) m.
      have h_jacobi_eq_legendre : jacobiSym ((q - 1) / 2) (A q) = legendreSym (A q) ((q - 1) / 2) := by
        rw [ jacobiSym ];
        norm_num [ Nat.primeFactorsList_prime Fact.out ];
      -- By definition of jacobiSym, we know that jacobiSym m (A q) = -1.
      have h_jacobi_neg_one : jacobiSym ((q - 1) / 2) (A q) = -1 := by
        convert jacobiSym_m_eq_neg_one q hq_gt_9 hq_mod8 using 1;
      -- By definition of legendreSym, we know that legendreSym (A q) (-1) = 1 and legendreSym (A q) 2 = -1.
      have h_legendre_neg_one : legendreSym (A q) (-1) = 1 := by
        convert legendreSym_neg_one_eq_one q hq_mod8 using 1
      have h_legendre_two : legendreSym (A q) 2 = -1 := by
        convert legendreSym_two_eq_neg_one q hq_mod8 using 1;
      grind

/-
For q prime, q > 9, q ≡ 3 (mod 8), A = q²+q+1 prime, prove 3^q ≢ 1 (mod A).
-/
theorem ft_p3_q_mod8_eq3 (q : ℕ) [Fact (Nat.Prime q)] (hq_gt_9 : q > 9) (hq_mod8 : q % 8 = 3)
    [Fact (Nat.Prime (A q))] : (3 : ZMod (A q))^q ≠ 1 := by
      by_contra h_contra;
      -- By Euler's criterion, $(1-q)^{(A-1)/2} \equiv \left(\frac{1-q}{A}\right) \pmod{A}$.
      have h_euler : (1 - q : ZMod (A q)) ^ ((A q - 1) / 2) = (legendreSym (A q) (1 - q)) := by
        simp +decide [ legendreSym.eq_pow ];
        norm_num [ show A q = q ^ 2 + q + 1 from rfl ];
        norm_num [ Nat.add_div, show q ^ 2 + q = 2 * ( q * ( q + 1 ) / 2 ) by linarith [ Nat.div_mul_cancel ( show 2 ∣ q * ( q + 1 ) from even_iff_two_dvd.mp ( by simp +arith +decide [ mul_add, parity_simps ] ) ) ] ];
      -- By legendreSym_one_sub_q_eq_one, we have $\left(\frac{1-q}{A}\right) = 1$.
      have h_legendre : legendreSym (A q) (1 - q) = 1 := by
        convert legendreSym_one_sub_q_eq_one q hq_gt_9 hq_mod8 using 1;
      -- By one_sub_q_pow_A_minus_one_div_two, we have $(1-q)^{(A-1)/2} \equiv -1 \pmod{A}$.
      have h_contradiction : (1 - q : ZMod (A q)) ^ ((A q - 1) / 2) = -1 := by
        convert one_sub_q_pow_A_minus_one_div_two q hq_gt_9 hq_mod8 h_contra using 1;
      simp_all +decide [ ZMod.intCast_eq_intCast_iff ];
      rw [ neg_eq_iff_add_eq_zero ] at h_euler;
      rcases q with ( _ | _ | _ | q ) <;> cases h_euler ; contradiction