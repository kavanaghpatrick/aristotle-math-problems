/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ca7aa1dc-e202-4a31-bc8a-5f6d669b9b71

Full scaffolding with 30+ proven lemmas for PATH_4 case.

PROOF STRATEGY FOR MAIN THEOREM (τ ≤ 8):

The PATH_4 structure: A — B — C — D (consecutive pairs share 1 vertex, non-consecutive disjoint)

Key decomposition:
All triangles = S_A ⊔ X_AB ⊔ S_B ⊔ X_BC ⊔ S_C ⊔ X_CD ⊔ S_D

Where:
- S_e = triangles sharing edge with e only (private to e)
- X_ef = triangles sharing edge with both e and f (bridges)

Proven bounds:
- τ(S_e) ≤ 2 for all e (tau_S_le_2)
- τ(X_ef) ≤ 2 for adjacent e,f (tau_X_le_2)
- τ(T_A) ≤ 4 for endpoint A (tau_Te_le_4_for_endpoint)
- X_ef = ∅ for disjoint e,f (X_ef_empty_of_disjoint)

KEY INSIGHT: X_AB ⊆ T_A and X_CD ⊆ T_D, so we can use:
τ(all) ≤ τ(T_A ∪ T_D ∪ S_B ∪ X_BC ∪ S_C)
      ≤ τ(T_A) + τ(T_D) + τ(S_B ∪ X_BC ∪ S_C)  [by subadditivity]

For the middle part S_B ∪ X_BC ∪ S_C, observe:
- All these triangles contain the spine vertex v2 = B ∩ C
- We need only 2 edges incident to v2 to cover them (star structure!)

Actually simpler: Use the cover
  E_A (2 edges for S_A) + E_AB (2 edges for X_AB) +
  E_D (2 edges for S_D) + E_CD (2 edges for X_CD)
= 8 edges total

This covers T_A and T_D. What remains is T_B ∪ T_C minus what's already covered.
T_B = S_B ∪ X_BA ∪ X_BC, and X_BA ⊆ T_A already covered!
T_C = S_C ∪ X_CB ∪ X_CD, and X_CD ⊆ T_D already covered!

Remaining: S_B ∪ X_BC ∪ S_C

But wait - the 8 edges might already cover some of this!
Specifically, any triangle in S_B that shares a vertex with X_AB might be hit.
And any triangle in S_C that shares a vertex with X_CD might be hit.

Alternative approach: Prove τ(S_B ∪ X_BC ∪ S_C) = 0 after T_A ∪ T_D cover?
No, that's too strong.

CORRECT APPROACH:
Show that the 4 edges covering T_A ALSO cover S_B (or part of it)
because the shared vertex v1 = A ∩ B appears in both.

Actually, use: All ⊆ T_A ∪ T_D, then τ ≤ τ(T_A) + τ(T_D) ≤ 4 + 4 = 8!

This requires proving: G.cliqueFinset 3 ⊆ T_A ∪ T_D

Hmm, that's NOT true. A triangle in S_B might not be in T_A or T_D.

OK let me try yet another approach. Use the explicit 8-edge cover:
- 2 edges from A (covering A itself and S_A)
- 2 edges incident to v1 = A ∩ B (covering X_AB)
- 2 edges incident to v3 = C ∩ D (covering X_CD)
- 2 edges from D (covering D itself and S_D)

Wait, that's 8 edges but some overlap...

Actually the cleanest is:
τ(All) ≤ τ(T_A) + τ(T_D) + τ(middle)

where middle = triangles not in T_A or T_D = S_B ∪ X_BC ∪ S_C

And τ(middle) ≤ 0 if we can show middle = ∅... but it's not.

OR show τ(T_A) + τ(T_D) ≤ 8 - τ(middle)...

Let me just include the scaffolding and add helper lemmas.
-/

import Mathlib


set_option linter.mathlibStandardSet false

open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical

variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def S_e (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G e).filter (fun t => ∀ f ∈ M, f ≠ e → (t ∩ f).card ≤ 1)

def bridges (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G e).filter (fun t => ∃ f ∈ M, f ≠ e ∧ (t ∩ f).card ≥ 2)

def X_ef (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2)

def isTriangleCover (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧ ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2

-- Path structure: A—B—C—D where adjacent pairs share exactly one vertex
def isPath4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ A ≠ C ∧ A ≠ D ∧ B ≠ C ∧ B ≠ D ∧ C ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧
  (A ∩ C).card = 0 ∧ (A ∩ D).card = 0 ∧ (B ∩ D).card = 0

lemma le_triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (A : Finset (Finset V)) (E' : Finset (Sym2 V))
    (h : isTriangleCover G A E') :
    triangleCoveringNumberOn G A ≤ E'.card := by
  unfold triangleCoveringNumberOn
  have h_mem : E' ∈ G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2) := by
    exact Finset.mem_filter.mpr ⟨Finset.mem_powerset.mpr h.1, h.2⟩
  have := Finset.min_le (Finset.mem_image_of_mem Finset.card h_mem)
  rw [WithTop.le_coe_iff] at this; aesop

lemma isTriangleCover_union (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) (EA EB : Finset (Sym2 V))
    (hA : isTriangleCover G A EA) (hB : isTriangleCover G B EB) :
    isTriangleCover G (A ∪ B) (EA ∪ EB) := by
  unfold isTriangleCover at *
  constructor
  · exact Finset.union_subset hA.1 hB.1
  · intro t ht
    simp only [Finset.mem_union] at ht
    cases ht with
    | inl htA =>
      obtain ⟨e, heEA, het⟩ := hA.2 t htA
      exact ⟨e, Finset.mem_union_left EB heEA, het⟩
    | inr htB =>
      obtain ⟨e, heEB, het⟩ := hB.2 t htB
      exact ⟨e, Finset.mem_union_right EA heEB, het⟩

-- PROVEN: Te = Se ∪ bridges
lemma Te_eq_Se_union_bridges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (e : Finset V) :
    trianglesSharingEdge G e = S_e G M e ∪ bridges G M e := by
  ext t
  simp only [Finset.mem_union, S_e, bridges, trianglesSharingEdge, Finset.mem_filter]
  constructor
  · intro ht
    by_cases h : ∀ f ∈ M, f ≠ e → (t ∩ f).card ≤ 1
    · left; exact ⟨ht, h⟩
    · right; push_neg at h; obtain ⟨f, hfM, hfne, hcard⟩ := h; exact ⟨ht, f, hfM, hfne, hcard⟩
  · intro h; rcases h with ⟨ht, _⟩ | ⟨ht, _⟩ <;> exact ht

lemma exists_minimal_cover (G : SimpleGraph V) [DecidableRel G.Adj] (A : Finset (Finset V))
    (h : ∃ E, isTriangleCover G A E) :
    ∃ E, isTriangleCover G A E ∧ E.card = triangleCoveringNumberOn G A := by
      unfold triangleCoveringNumberOn;
      obtain ⟨E, hE⟩ := h
      have h_subset : E ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2)) := by
        exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hE.1, hE.2 ⟩;
      have h_min_card : ∃ m ∈ (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2})), ∀ n ∈ (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2})), m ≤ n := by
        exact ⟨ Finset.min' ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2 ) ( Finset.powerset G.edgeFinset ) ) ) ⟨ _, Finset.mem_image_of_mem _ h_subset ⟩, Finset.min'_mem _ _, fun n hn => Finset.min'_le _ _ hn ⟩;
      obtain ⟨ m, hm₁, hm₂ ⟩ := h_min_card;
      have h_min_card : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2})).min = some m := by
        exact le_antisymm ( Finset.min_le hm₁ ) ( Finset.le_min fun n hn => WithTop.coe_le_coe.mpr ( hm₂ n hn ) );
      obtain ⟨ E, hE₁, hE₂ ⟩ := Finset.mem_image.mp hm₁;
      exact ⟨ E, ⟨ Finset.mem_powerset.mp ( Finset.mem_filter.mp hE₁ |>.1 ), Finset.mem_filter.mp hE₁ |>.2 ⟩, by rw [ h_min_card, Option.getD_some, hE₂ ] ⟩

theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) :
    triangleCoveringNumberOn G (A ∪ B) ≤
    triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by
  -- We proceed by cases on whether covers exist for A and B.
  by_cases hA : ∃ E, isTriangleCover G A E
  by_cases hB : ∃ E, isTriangleCover G B E;
  · obtain ⟨EA, hEA⟩ := exists_minimal_cover G A hA
    obtain ⟨EB, hEB⟩ := exists_minimal_cover G B hB
    have h_union : isTriangleCover G (A ∪ B) (EA ∪ EB) := by
      exact isTriangleCover_union G A B EA EB hEA.1 hEB.1;
    exact le_trans ( le_triangleCoveringNumberOn G ( A ∪ B ) ( EA ∪ EB ) h_union ) ( by linarith [ Finset.card_union_le EA EB ] );
  · unfold triangleCoveringNumberOn;
    rw [ show { E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2 } = ∅ from Finset.eq_empty_of_forall_notMem fun E' hE' => hB ⟨ E', ⟨ Finset.mem_powerset.mp ( Finset.mem_filter.mp hE' |>.1 ), Finset.mem_filter.mp hE' |>.2 ⟩ ⟩ ] ; simp +decide [ Finset.min ];
    rw [ show ( { E' ∈ G.edgeFinset.powerset | ∀ t, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } : Finset ( Finset ( Sym2 V ) ) ) = ∅ from Finset.eq_empty_of_forall_notMem fun E' hE' => hB ⟨ E', ⟨ Finset.mem_powerset.mp ( Finset.mem_filter.mp hE' |>.1 ), fun t ht => by aesop ⟩ ⟩ ] ; simp +decide [ Finset.inf ] ;
  · simp +decide [ triangleCoveringNumberOn, hA ];
    rw [ show ( { E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) = ∅ from _ ] <;> norm_num;
    · exact Nat.zero_le _;
    · contrapose! hA;
      exact ⟨ hA.choose, fun e he => by have := hA.choose_spec.1 he; aesop, fun t ht => by have := hA.choose_spec.2 t ( Or.inl ht ) ; aesop ⟩

lemma larger_packing_of_disjoint_pair (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 : Finset V) (h1 : t1 ∈ S_e G M e) (h2 : t2 ∈ S_e G M e)
    (h_disj : (t1 ∩ t2).card ≤ 1) (h_diff : t1 ≠ t2) :
    False := by
      -- Let $M' = (M \setminus \{e\}) \cup \{t_1, t_2\}$.
      set M' : Finset (Finset V) := (M \ {e}) ∪ {t1, t2};
      -- First, show that $M'$ is a packing.
      have hM'_packing : isTrianglePacking G M' := by
        -- Show that $M'$ is a packing by verifying that all elements are triangles and pairwise intersections are at most one vertex.
        have hM'_packing : ∀ t ∈ M', t ∈ G.cliqueFinset 3 ∧ ∀ t' ∈ M', t ≠ t' → (t ∩ t').card ≤ 1 := by
          simp +zetaDelta at *;
          unfold S_e at *; simp_all +decide [ Finset.subset_iff, Finset.mem_filter ] ;
          unfold trianglesSharingEdge at *; simp_all +decide [ Finset.inter_comm ] ;
          have := hM.1; simp_all +decide [ Finset.subset_iff, isTrianglePacking ] ;
          exact fun a ha ha' b hb hb' hab => this.2 ha hb hab;
        exact ⟨ fun t ht => hM'_packing t ht |>.1, fun t ht t' ht' h => hM'_packing t ht |>.2 t' ht' h ⟩;
      -- Since $M$ is a maximum packing, we have $|M'| \leq |M|$.
      have hM'_card : M'.card ≤ M.card := by
        have hM'_card : ∀ M'' : Finset (Finset V), isTrianglePacking G M'' → M''.card ≤ M.card := by
          intro M'' hM''_packing
          have hM''_card : M''.card ≤ trianglePackingNumber G := by
            unfold trianglePackingNumber;
            have hM''_card : M''.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
              simp +zetaDelta at *;
              exact ⟨ M'', ⟨ hM''_packing.1, hM''_packing ⟩, rfl ⟩;
            have := Finset.le_max hM''_card;
            cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
          exact hM''_card.trans ( hM.2.ge );
        exact hM'_card M' hM'_packing;
      -- Since $t1$ and $t2$ are in $S_e$, they are not in $M \setminus \{e\}$.
      have h_not_in_M_minus_e : t1 ∉ M \ {e} ∧ t2 ∉ M \ {e} := by
        constructor <;> intro h <;> simp_all +decide [ S_e ];
        · have := h1.2 t1 h.1 h.2; simp_all +decide [ trianglesSharingEdge ] ;
          exact this.not_lt ( by rw [ G.isNClique_iff ] at h1; aesop );
        · have := h2.2 t2 h.1 h.2; simp_all +decide [ trianglesSharingEdge ] ;
          exact this.not_lt ( by rw [ h2.1.1.2 ] ; decide );
      grind +ring

lemma common_vertex_of_different_edges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 : Finset V) (h1 : t1 ∈ S_e G M e) (h2 : t2 ∈ S_e G M e)
    (hne1 : t1 ≠ e) (hne2 : t2 ≠ e)
    (h_diff_edge : t1 ∩ e ≠ t2 ∩ e) :
    t1 \ e = t2 \ e := by
      -- Since $t1 \neq e$ and $t2 \neq e$, their intersections with $e$ are both exactly one edge. However, since they are different, their intersections with $e$ must share exactly one vertex.
      have h_inter_diff : (t1 ∩ e).card = 2 ∧ (t2 ∩ e).card = 2 ∧ (t1 ∩ e) ≠ (t2 ∩ e) := by
        have h_inter_diff : ∀ t ∈ S_e G M e, t ≠ e → (t ∩ e).card = 2 := by
          intro t ht hne
          have h_card_t : t.card = 3 := by
            have h_card_t : t ∈ G.cliqueFinset 3 := by
              exact Finset.mem_filter.mp ht |>.1 |> Finset.mem_filter.mp |>.1;
            exact Finset.mem_filter.mp h_card_t |>.2.2
          have h_card_e : e.card = 3 := by
            have := hM.1;
            have := this.1;
            have := this he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
            exact this.card_eq
          have h_card_inter : (t ∩ e).card ≥ 2 := by
            have h_card_inter : (t ∩ e).card ≥ 2 := by
              have := ht
              exact Finset.mem_filter.mp this |>.2 |> fun h => by have := Finset.mem_filter.mp ( Finset.mem_filter.mp this |>.1 ) |>.2; aesop;
            exact h_card_inter;
          have h_card_inter_le : (t ∩ e).card ≤ 3 := by
            exact le_trans ( Finset.card_le_card fun x hx => by aesop ) h_card_t.le;
          interval_cases _ : Finset.card ( t ∩ e ) <;> simp_all +decide;
          have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ e ⊆ t ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t ∩ e ⊆ e ) ; aesop;
        exact ⟨ h_inter_diff t1 h1 hne1, h_inter_diff t2 h2 hne2, h_diff_edge ⟩;
      -- Since $t1 \cap t2 \neq \emptyset$, there exists a vertex $v$ such that $v \in t1 \cap t2$.
      obtain ⟨v, hv⟩ : ∃ v, v ∈ t1 ∧ v ∈ t2 ∧ v ∉ e := by
        have h_inter_diff : (t1 ∩ t2).card ≥ 2 := by
          by_contra h_contra;
          exact larger_packing_of_disjoint_pair G M hM e he t1 t2 h1 h2 ( by linarith ) ( by aesop );
        contrapose! h_inter_diff;
        have h_inter_diff : (t1 ∩ t2) ⊆ (t1 ∩ e) ∩ (t2 ∩ e) := by
          grind;
        have h_inter_diff : (t1 ∩ e) ∩ (t2 ∩ e) ⊂ t1 ∩ e := by
          simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
          exact Exists.elim ( Finset.not_subset.mp ( show ¬t1 ∩ e ⊆ t2 ∩ e from fun h => ‹ ( t1 ∩ e ).card = 2 ∧ ( t2 ∩ e ).card = 2 ∧ ¬t1 ∩ e = t2 ∩ e ›.2.2 <| Finset.eq_of_subset_of_card_le h <| by linarith ) ) fun x hx => ⟨ x, by aesop ⟩;
        exact lt_of_le_of_lt ( Finset.card_le_card ‹_› ) ( lt_of_lt_of_le ( Finset.card_lt_card h_inter_diff ) ( by simp +decide [ * ] ) );
      have h_inter_eq : t1.card = 3 ∧ t2.card = 3 ∧ e.card = 3 := by
        have h_card : ∀ t ∈ M, t.card = 3 := by
          have := hM.1.1;
          intro t ht; specialize this ht; simp_all +decide [ SimpleGraph.mem_cliqueFinset_iff ] ;
          exact this.2;
        have h_card_t1 : t1.card = 3 := by
          have h_card_t1 : t1 ∈ G.cliqueFinset 3 := by
            exact Finset.mem_filter.mp h1 |>.1 |> Finset.mem_filter.mp |>.1;
          exact Finset.mem_filter.mp h_card_t1 |>.2.2
        have h_card_t2 : t2.card = 3 := by
          have h_card_t2 : t2 ∈ G.cliqueFinset 3 := by
            exact Finset.mem_filter.mp h2 |>.1 |> Finset.mem_filter.mp |>.1;
          exact Finset.mem_filter.mp h_card_t2 |>.2.2
        have h_card_e : e.card = 3 := by
          exact h_card e he
        exact ⟨h_card_t1, h_card_t2, h_card_e⟩;
      have h_inter_eq : (t1 \ e).card = 1 ∧ (t2 \ e).card = 1 := by
        grind;
      simp_all +decide [ Finset.card_eq_one ];
      obtain ⟨ ⟨ a, ha ⟩, ⟨ b, hb ⟩ ⟩ := h_inter_eq; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
      grind

lemma S_e_structure (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M) :
    (∃ u v : V, u ≠ v ∧ {u, v} ⊆ e ∧ ∀ t ∈ S_e G M e, {u, v} ⊆ t) ∨
    (∃ x : V, S_e G M e ⊆ {e} ∪ (e.powerset.filter (fun f => f.card = 2)).image (fun f => f ∪ {x})) := by
      by_cases h : ∃ t1 t2 : Finset V, t1 ∈ S_e G M e ∧ t2 ∈ S_e G M e ∧ t1 ≠ e ∧ t2 ≠ e ∧ t1 ∩ e ≠ t2 ∩ e;
      · obtain ⟨t1, t2, ht1, ht2, ht1e, ht2e, h_diff⟩ := h
        obtain ⟨x, hx⟩ : ∃ x : V, ∀ t ∈ S_e G M e, t ≠ e → t \ e = {x} := by
          have h_common_vertex : ∀ t ∈ S_e G M e, t ≠ e → t \ e = t1 \ e := by
            intros t ht hte
            by_cases h_diff_edge : t ∩ e ≠ t1 ∩ e;
            · exact common_vertex_of_different_edges G M hM e he t t1 ht ht1 hte ht1e h_diff_edge
            · have h_common_vertex : t \ e = t2 \ e := by
                apply common_vertex_of_different_edges G M hM e he t t2 ht ht2 hte ht2e;
                grind +ring;
              have := common_vertex_of_different_edges G M hM e he t1 t2 ht1 ht2 ht1e ht2e; aesop;
          have h_card : (t1 \ e).card = 1 := by
            have h_card : t1.card = 3 ∧ e.card = 3 := by
              have h_card : ∀ t ∈ G.cliqueFinset 3, t.card = 3 := by
                simp +decide [ SimpleGraph.cliqueFinset ];
                exact fun t ht => ht.2;
              have h_card : e ∈ G.cliqueFinset 3 := by
                have := hM.1.1 he; aesop;
              have h_card : t1 ∈ G.cliqueFinset 3 := by
                exact Finset.mem_filter.mp ht1 |>.1 |> Finset.mem_filter.mp |>.1;
              grind;
            have h_card : (t1 ∩ e).card = 2 := by
              have h_card : (t1 ∩ e).card ≥ 2 := by
                have h_card : (t1 ∩ e).card ≥ 2 := by
                  have h_card : t1 ∈ trianglesSharingEdge G e := by
                    exact Finset.mem_filter.mp ht1 |>.1
                  unfold trianglesSharingEdge at h_card; aesop;
                exact h_card;
              have h_card : (t1 ∩ e).card ≤ 3 := by
                exact le_trans ( Finset.card_le_card ( Finset.inter_subset_left ) ) ( by linarith );
              interval_cases _ : ( t1 ∩ e ).card <;> simp_all +decide;
              have h_eq : t1 ∩ e = t1 := by
                exact Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left ) ( by aesop );
              have h_eq : t1 ⊆ e := by
                exact h_eq ▸ Finset.inter_subset_right;
              exact ht1e ( Finset.eq_of_subset_of_card_le h_eq ( by simp +decide [ h_card ] ) );
            grind;
          obtain ⟨ x, hx ⟩ := Finset.card_eq_one.mp h_card; use x; aesop;
        right
        use x
        intro t ht
        by_cases hte : t = e;
        · aesop;
        · -- Since $t \neq e$, we have $t \setminus e = \{x\}$, thus $t = (t \cap e) \cup \{x\}$.
          have ht_union : t = (t ∩ e) ∪ {x} := by
            rw [ ← hx t ht hte, Finset.union_comm ];
            rw [ Finset.sdiff_union_inter ];
          have ht_card : t.card = 3 := by
            have ht_card : t ∈ G.cliqueFinset 3 := by
              exact Finset.mem_filter.mp ht |>.1 |> Finset.mem_filter.mp |>.1;
            exact Finset.mem_filter.mp ht_card |>.2.2;
          grind;
      · by_cases h1 : ∃ t : Finset V, t ∈ S_e G M e ∧ t ≠ e <;> simp_all +decide [ Finset.subset_iff ];
        · obtain ⟨ t, ht1, ht2 ⟩ := h1;
          -- Since $t \neq e$, we have $t \cap e$ is an edge of $e$.
          obtain ⟨u, v, huv⟩ : ∃ u v : V, u ≠ v ∧ {u, v} ⊆ e ∧ {u, v} ⊆ t := by
            have := Finset.mem_filter.mp ( Finset.mem_coe.mp ( Finset.mem_filter.mp ht1 |>.1 ) ) |>.2; simp_all +decide [ Finset.subset_iff ] ;
            obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.mp this; use u, v; aesop;
          refine' Or.inl ⟨ u, v, huv.1, ⟨ huv.2.1 ( Finset.mem_insert_self _ _ ), huv.2.1 ( Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ) ⟩, fun t' ht' => _ ⟩;
          by_cases ht'_eq_e : t' = e <;> simp_all +decide [ Finset.subset_iff ];
          specialize h t ht1 t' ht' ht2 ht'_eq_e; simp_all +decide [ Finset.ext_iff ] ;
          exact ⟨ h u huv.2.1.1 |>.1 huv.2.2.1, h v huv.2.1.2 |>.1 huv.2.2.2 ⟩;
        · right;
          rcases e.eq_empty_or_nonempty with ( rfl | ⟨ x, hx ⟩ ) <;> simp_all +decide [ Finset.ext_iff ];
          · have := hM.1.1 he; aesop;
          · exact ⟨ x ⟩

lemma tau_le_2_of_star_structure (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (e : Finset V) (he : e ∈ G.cliqueFinset 3)
    (x : V) (hx : x ∉ e)
    (hS_sub : S ⊆ {e} ∪ (e.powerset.filter (fun f => f.card = 2)).image (fun f => f ∪ {x}))
    (hS_clique : S ⊆ G.cliqueFinset 3) :
    triangleCoveringNumberOn G S ≤ 2 := by
      by_contra h_contra;
      -- Since $e$ is a clique, it must be a triangle.
      obtain ⟨u, v, w, huv, hvw, huw, huvx⟩ : ∃ u v w : V, u ≠ v ∧ v ≠ w ∧ u ≠ w ∧ e = {u, v, w} := by
        simp_all +decide [ SimpleGraph.cliqueFinset ];
        rcases he with ⟨ he₁, he₂ ⟩;
        rw [ Finset.card_eq_three ] at he₂; obtain ⟨ u, v, w, hu, hv, hw ⟩ := he₂; use u, v, by aesop, w; aesop;
      -- Consider the vertex $u$.
      by_cases hux : G.Adj u x;
      · -- Let $E' = \{ s(u, x), s(v, w) \}$.
        set E' : Finset (Sym2 V) := {Sym2.mk (u, x), Sym2.mk (v, w)};
        refine' h_contra ( le_trans ( le_triangleCoveringNumberOn G S E' _ ) _ );
        · refine' ⟨ _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
          · simp +zetaDelta at *;
            exact ⟨ hux, by have := he.1; aesop ⟩;
          · intro t ht; specialize hS_sub ht; rcases hS_sub with ( rfl | ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            · aesop;
            · rw [ Finset.card_eq_two ] at ha₂ ; aesop;
        · exact Finset.card_insert_le _ _;
      · -- Since $\{u, x\}$ is not an edge, $T_{uv} \notin S$ and $T_{uw} \notin S$, because if they were in $S$, they would be cliques, implying $\{u, x\}$ is an edge.
        have hS_subset : S ⊆ {e, {v, w, x}} := by
          intro t ht; specialize hS_sub ht; simp_all +decide [ Finset.subset_iff ] ;
          rcases hS_sub with ( rfl | ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ) <;> simp_all +decide [ Finset.card_eq_two ];
          have := hS_clique ht; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          rcases ha₂ with ⟨ x, y, hxy, rfl ⟩ ; simp_all +decide [ SimpleGraph.isClique_iff ] ;
          rcases ha₁ with ⟨ rfl | rfl | rfl, rfl | rfl | rfl ⟩ <;> simp_all +decide [ SimpleGraph.adj_comm ];
          · grind;
          · aesop;
        refine' h_contra ( le_trans ( le_triangleCoveringNumberOn G S _ _ ) _ );
        exact { Sym2.mk ( v, w ) };
        · refine' ⟨ _, _ ⟩;
          · simp_all +decide [ SimpleGraph.mem_edgeSet ];
            exact he.1 ( by aesop ) ( by aesop ) ( by aesop );
          · intro t ht; specialize hS_subset ht; aesop;
        · simp +decide

lemma tau_S_le_2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumberOn G (S_e G M e) ≤ 2 := by
  obtain h|h := S_e_structure G M hM e he;
  · obtain ⟨ u, v, hne, huv, h ⟩ := h;
    refine' le_trans ( le_triangleCoveringNumberOn G _ { s(u, v) } _ ) _ <;> simp_all +decide [ SimpleGraph.edgeSet, Sym2.fromRel ];
    refine' ⟨ _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff, SimpleGraph.cliqueFinset ];
    have := hM.1.1 he; simp_all +decide [ SimpleGraph.isClique_iff, Finset.subset_iff ] ;
    exact this.1 ( by aesop ) ( by aesop ) ( by aesop );
  · -- Apply `tau_le_2_of_star_structure` with the given hypotheses.
    obtain ⟨x, hx⟩ := h;
    by_cases hx_in_e : x ∈ e;
    · have h_S_e_subset_e : S_e G M e ⊆ {e} := by
        intro t ht
        have ht_card : t.card = 3 := by
          have ht_card : t ∈ G.cliqueFinset 3 := by
            exact Finset.mem_filter.mp ht |>.1 |> Finset.mem_filter.mp |>.1;
          exact Finset.mem_filter.mp ht_card |>.2.2
        have ht_subset : t ⊆ e := by
          grind
        have ht_eq_e : t = e := by
          have := hM.1;
          have := this.1;
          have := this he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
          exact Finset.eq_of_subset_of_card_le ht_subset ( by linarith [ this.2 ] )
        exact ht_eq_e ▸ Finset.mem_singleton_self e;
      have h_S_e_subset_e : S_e G M e ⊆ G.cliqueFinset 3 := by
        exact fun t ht => Finset.mem_filter.mp ( Finset.mem_filter.mp ht |>.1 ) |>.1;
      have h_tau_le_1 : ∀ (S : Finset (Finset V)), S ⊆ {e} → S ⊆ G.cliqueFinset 3 → triangleCoveringNumberOn G S ≤ 1 := by
        intros S hS_subset_e hS_subset_clique
        have h_tau_le_1 : triangleCoveringNumberOn G S ≤ 1 := by
          have h_edge : ∃ f ∈ G.edgeFinset, f ∈ e.sym2 := by
            have := hM.1;
            have := this.1 he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
            rcases this with ⟨ h₁, h₂ ⟩ ; rcases Finset.card_eq_three.mp h₂ with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; use Sym2.mk ( a, b ) ; aesop;
          obtain ⟨ f, hf₁, hf₂ ⟩ := h_edge;
          exact le_trans ( le_triangleCoveringNumberOn G S { f } ⟨ by aesop_cat, by aesop_cat ⟩ ) ( by simp +decide );
        exact h_tau_le_1;
      exact le_trans ( h_tau_le_1 _ ‹_› ‹_› ) ( by norm_num );
    · apply_rules [ tau_le_2_of_star_structure ];
      · have := hM.1;
        exact this.1 he;
      · intro t ht; exact (by
        exact Finset.mem_filter.mp ( Finset.mem_filter.mp ht |>.1 ) |>.1)

lemma X_ef_inter_card (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M) (hef : e ≠ f)
    (t : Finset V) (ht : t ∈ X_ef G e f) :
    (e ∩ f).card = 1 := by
      have h_inter_le_one : (e ∩ f).card ≤ 1 := by
        cases hM ; aesop;
      interval_cases _ : Finset.card ( e ∩ f ) <;> simp_all +decide [ X_ef ];
      have h_sum : (t ∩ e).card + (t ∩ f).card ≤ t.card := by
        have h_card_le : (t ∩ e ∪ t ∩ f).card ≤ t.card := by
          exact Finset.card_le_card fun x hx => by aesop;
        rwa [ Finset.card_union_of_disjoint ( Finset.disjoint_left.mpr fun x hx₁ hx₂ => by simp_all +decide [ Finset.ext_iff ] ) ] at h_card_le;
      linarith [ show t.card = 3 by exact ht.1.card_eq ]

/-- In a path A—B—C—D, bridges from A only go to B (the unique neighbor). -/
lemma path4_A_bridges_only_to_B (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hpath : isPath4 M A B C D) :
    bridges G M A ⊆ X_ef G A B := by
  intro t ht
  simp only [bridges, Finset.mem_filter] at ht
  obtain ⟨h_share_A, f, hfM, hfne, h_share_f⟩ := ht
  simp only [X_ef, Finset.mem_filter]
  constructor
  · simp only [trianglesSharingEdge, Finset.mem_filter] at h_share_A
    exact h_share_A.1
  constructor
  · simp only [trianglesSharingEdge, Finset.mem_filter] at h_share_A
    exact h_share_A.2
  · obtain ⟨hM_eq, hAB, hAC_ne, hAD_ne, hBC_ne, hBD_ne, hCD_ne,
            hAB_share, hBC_share, hCD_share, hAC_disj, hAD_disj, hBD_disj⟩ := hpath
    have hfM' : f ∈ ({A, B, C, D} : Finset (Finset V)) := by rw [← hM_eq]; exact hfM
    simp only [Finset.mem_insert, Finset.mem_singleton] at hfM'
    rcases hfM' with rfl | rfl | rfl | rfl
    · exact absurd rfl hfne
    · exact h_share_f
    · exfalso
      have h_contradiction : (t ∩ A).card + (t ∩ f).card ≤ (t : Finset V).card := by
        rw [ ← Finset.card_union_of_disjoint ];
        · exact Finset.card_le_card fun x hx => by aesop;
        · simp_all +decide [ Finset.disjoint_left ];
          exact fun x hx hx' hx'' => Finset.notMem_empty x ( hAC_disj ▸ Finset.mem_inter_of_mem hx' hx'' );
      have h_contradiction : (t : Finset V).card ≤ 3 := by
        have h_contradiction : t ∈ G.cliqueFinset 3 := by
          unfold trianglesSharingEdge at h_share_A; aesop;
        exact Finset.mem_filter.mp h_contradiction |>.2.2.le;
      linarith [ show ( t ∩ A ).card ≥ 2 by exact Finset.mem_filter.mp h_share_A |>.2 ]
    · exfalso
      have h_contradiction : (t ∩ A).card + (t ∩ f).card > 3 := by
        linarith [ show Finset.card ( t ∩ A ) ≥ 2 from by { unfold trianglesSharingEdge at h_share_A; aesop } ];
      have h_contradiction : (t ∩ A).card + (t ∩ f).card ≤ t.card := by
        have h_contradiction : (t ∩ A) ∪ (t ∩ f) ⊆ t := by
          exact Finset.union_subset ( Finset.inter_subset_left ) ( Finset.inter_subset_left );
        have := Finset.card_mono h_contradiction;
        rwa [ Finset.card_union_of_disjoint ( Finset.disjoint_left.mpr fun x hx₁ hx₂ => by simp_all +decide [ Finset.ext_iff ] ) ] at this;
      have h_card_t : t ∈ G.cliqueFinset 3 := by
        unfold trianglesSharingEdge at h_share_A; aesop;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      exact absurd h_contradiction ( by linarith [ h_card_t.card_eq ] )

lemma X_ef_mem_inter (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M) (hef : e ≠ f)
    (v : V) (hv : e ∩ f = {v})
    (t : Finset V) (ht : t ∈ X_ef G e f) :
    v ∈ t := by
      by_contra hv_not_in_t
      have h_disjoint : Disjoint (t ∩ e) (e ∩ f) ∧ Disjoint (t ∩ f) (e ∩ f) := by
        simp_all +decide [ Finset.disjoint_left ];
        grind;
      have h_card : (t ∩ e).card + (t ∩ f).card ≤ 3 := by
        have h_card : (t ∩ (e ∪ f)).card ≤ 3 := by
          have h_card : t ∈ G.cliqueFinset 3 := by
            unfold X_ef at ht; aesop;
          norm_num +zetaDelta at *;
          exact le_trans ( Finset.card_le_card fun x hx => by aesop ) ( h_card.2.le );
        rw [ ← Finset.card_union_of_disjoint ];
        · simpa only [ ← Finset.inter_union_distrib_left ] using h_card;
        · simp_all +decide [ Finset.disjoint_left, Finset.ext_iff ];
      have h_card_ge_2 : (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2 := by
        unfold X_ef at ht; aesop;
      linarith

/-- All triangles in G are covered by T_A ∪ T_B ∪ T_C ∪ T_D. -/
lemma path4_triangle_partition (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hpath : isPath4 M A B C D) :
    G.cliqueFinset 3 ⊆
      trianglesSharingEdge G A ∪ trianglesSharingEdge G B ∪
      trianglesSharingEdge G C ∪ trianglesSharingEdge G D := by
  intro t ht
  by_contra h_none
  simp only [Finset.mem_union, not_or] at h_none
  have h_not_A := h_none.1.1.1
  have h_not_B := h_none.1.1.2
  have h_not_C := h_none.1.2
  have h_not_D := h_none.2
  have h_disj_A : (t ∩ A).card ≤ 1 := by
    simp only [trianglesSharingEdge, Finset.mem_filter, not_and] at h_not_A
    by_contra h; push_neg at h; exact (h_not_A ht) (Nat.lt_of_succ_le h)
  have h_disj_B : (t ∩ B).card ≤ 1 := by
    simp only [trianglesSharingEdge, Finset.mem_filter, not_and] at h_not_B
    by_contra h; push_neg at h; exact (h_not_B ht) (Nat.lt_of_succ_le h)
  have h_disj_C : (t ∩ C).card ≤ 1 := by
    simp only [trianglesSharingEdge, Finset.mem_filter, not_and] at h_not_C
    by_contra h; push_neg at h; exact (h_not_C ht) (Nat.lt_of_succ_le h)
  have h_disj_D : (t ∩ D).card ≤ 1 := by
    simp only [trianglesSharingEdge, Finset.mem_filter, not_and] at h_not_D
    by_contra h; push_neg at h; exact (h_not_D ht) (Nat.lt_of_succ_le h)
  unfold isPath4 at hpath;
  unfold isMaxPacking at hM;
  unfold isTrianglePacking at hM; simp_all +decide [ Finset.subset_iff ] ;
  have h_contradiction : ∃ M' : Finset (Finset V), isTrianglePacking G M' ∧ M'.card = 5 := by
    use {A, B, C, D, t};
    unfold isTrianglePacking; simp_all +decide [ Finset.subset_iff ] ;
    rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> simp +decide [ * ];
    · simp_all +decide [ Finset.insert_subset_iff, Set.Pairwise ];
      simp_all +decide [ Finset.inter_comm ];
    · rintro rfl; simp_all +decide [ Finset.ext_iff ] ;
      exact absurd h_disj_D ( by rw [ ht.2 ] ; decide );
    · rintro rfl;
      simp_all +decide [ SimpleGraph.isNClique_iff ];
    · rintro rfl; simp_all +decide [ Finset.ext_iff ];
      exact absurd h_disj_B ( by have := ht.2; aesop );
    · rintro rfl; simp_all +decide [ SimpleGraph.isNClique_iff ];
  obtain ⟨ M', hM', hM'' ⟩ := h_contradiction; have := hM.2.symm; simp_all +decide [ trianglePackingNumber ] ;
  have h_contradiction : Finset.card M' ≤ Option.getD (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max 0 := by
    have h_contradiction : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
      simp_all +decide [ isTrianglePacking ];
      exact ⟨ M', hM', hM'' ⟩;
    have h_contradiction : ∀ x ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset), x ≤ Option.getD (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max 0 := by
      simp +decide [ Option.getD ];
      intro x S hS hS' hx; rw [ hx.symm ] ; exact (by
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> simp_all +decide [ Finset.le_max ];
      exact hx ▸ Finset.le_max_of_eq ( Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hS, hS' ⟩ ) ) h);
    exact h_contradiction _ ‹_›;
  linarith

lemma X_ef_edge_cover (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M) (hef : e ≠ f)
    (v : V) (hv : e ∩ f = {v}) :
    ∃ E' : Finset (Sym2 V), E'.card = 2 ∧ E' ⊆ G.edgeFinset ∧
    ∀ t ∈ X_ef G e f, ∃ ε ∈ E', ε ∈ t.sym2 := by
      obtain ⟨x, y, hx, hy, heq⟩ : ∃ x y : V, x ∈ e ∧ y ∈ e ∧ x ≠ y ∧ x ≠ v ∧ y ≠ v ∧ e = {v, x, y} := by
        have h_card : e.card = 3 := by
          have := hM.1 he;
          simp_all +decide [ SimpleGraph.cliqueFinset ];
          exact this.card_eq;
        have hv_in_e : v ∈ e := by
          exact Finset.mem_of_mem_inter_left ( hv.symm ▸ Finset.mem_singleton_self _ );
        rw [ Finset.card_eq_three ] at h_card;
        rcases h_card with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; use if v = x then y else if v = y then z else x, if v = x then z else if v = y then x else y; aesop;
      refine' ⟨ { Sym2.mk ( v, x ), Sym2.mk ( v, y ) }, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
      · have := hM.1 he; simp_all +decide [ Finset.subset_iff, SimpleGraph.adj_comm ] ;
        simp_all +decide [ SimpleGraph.isNClique_iff, SimpleGraph.adj_comm ];
        grind;
      · intro t ht
        have hv_in_t : v ∈ t := by
          apply X_ef_mem_inter G M hM {v, x, y} f he hf hef v hv t ht
        have hx_or_y_in_t : x ∈ t ∨ y ∈ t := by
          have := Finset.mem_filter.mp ht; simp_all +decide [ Finset.subset_iff ] ;
          contrapose! this; aesop;
        aesop

lemma tau_X_le_2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M) (hef : e ≠ f) :
    triangleCoveringNumberOn G (X_ef G e f) ≤ 2 := by
  by_cases h_empty : X_ef G e f = ∅;
  · simp +decide [ h_empty, triangleCoveringNumberOn ];
    rw [ Finset.min ];
    rw [ Finset.inf_eq_iInf ];
    rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ];
    rotate_left;
    exact 0;
    · exact fun _ => zero_le _;
    · exact fun w hw => ⟨ 0, by aesop ⟩;
    · decide +revert;
  · obtain ⟨ t, ht ⟩ := Finset.nonempty_of_ne_empty h_empty;
    obtain ⟨v, hv⟩ : ∃ v, e ∩ f = {v} := by
      have h_inter_card : (e ∩ f).card = 1 := by
        apply X_ef_inter_card G M hM.1 e f he hf hef t ht;
      exact Finset.card_eq_one.mp h_inter_card;
    obtain ⟨ E', hE₁, hE₂, hE₃ ⟩ := X_ef_edge_cover G M hM.1 e f he hf hef v hv;
    exact le_trans ( le_triangleCoveringNumberOn G _ _ ⟨ hE₂, hE₃ ⟩ ) hE₁.le

/-- τ(T_A) ≤ 2 + τ(bridges from A). -/
lemma tau_Te_le_4_for_endpoint (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hpath : isPath4 M A B C D) :
    triangleCoveringNumberOn G (trianglesSharingEdge G A) ≤ 4 := by
  rw [Te_eq_Se_union_bridges G M A]
  have h_bridges : bridges G M A ⊆ X_ef G A B := path4_A_bridges_only_to_B G M A B C D hpath
  calc triangleCoveringNumberOn G (S_e G M A ∪ bridges G M A)
      ≤ triangleCoveringNumberOn G (S_e G M A) + triangleCoveringNumberOn G (bridges G M A) := by
        apply tau_union_le_sum
    _ ≤ 2 + triangleCoveringNumberOn G (bridges G M A) := by
        have hA : A ∈ M := by rw [hpath.1]; simp
        linarith [tau_S_le_2 G M hM A hA]
    _ ≤ 2 + triangleCoveringNumberOn G (X_ef G A B) := by
        apply le_of_forall_le;
        intro c hc
        have h_cover : ∃ E' : Finset (Sym2 V), isTriangleCover G (X_ef G A B) E' ∧ E'.card ≤ triangleCoveringNumberOn G (X_ef G A B) := by
          have h_cover : ∃ E' ∈ Finset.filter (fun E' => ∀ t ∈ X_ef G A B, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset), E'.card = triangleCoveringNumberOn G (X_ef G A B) := by
            unfold triangleCoveringNumberOn;
            have h_nonempty : Finset.Nonempty (Finset.filter (fun E' => ∀ t ∈ X_ef G A B, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset)) := by
              refine' ⟨ G.edgeFinset, _ ⟩;
              simp +decide [ X_ef ];
              intro t ht htA htB; obtain ⟨ u, v, w, h ⟩ := Finset.card_eq_three.mp ht.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
              exact ⟨ s(u, v), by aesop ⟩;
            have := Finset.min_of_mem ( Finset.mem_image_of_mem Finset.card h_nonempty.choose_spec );
            obtain ⟨ b, hb ⟩ := this;
            have := Finset.mem_of_min hb;
            rw [ Finset.mem_image ] at this; obtain ⟨ E', hE', rfl ⟩ := this; use E'; aesop;
          obtain ⟨ E', hE₁, hE₂ ⟩ := h_cover;
          exact ⟨ E', ⟨ Finset.mem_powerset.mp ( Finset.mem_filter.mp hE₁ |>.1 ), Finset.mem_filter.mp hE₁ |>.2 ⟩, hE₂.le ⟩;
        obtain ⟨ E', hE', hE'' ⟩ := h_cover;
        have h_cover_bridges : isTriangleCover G (bridges G M A) E' := by
          exact ⟨ hE'.1, fun t ht => hE'.2 t ( h_bridges ht ) ⟩;
        exact hc.trans ( add_le_add_left ( le_triangleCoveringNumberOn G _ _ h_cover_bridges ) _ |> le_trans <| by linarith )
    _ ≤ 2 + 2 := by
        have hA : A ∈ M := by rw [hpath.1]; simp
        have hB : B ∈ M := by rw [hpath.1]; simp
        linarith [tau_X_le_2 G M hM A B hA hB hpath.2.1]
    _ = 4 := by ring

/-
If two cliques e and f are disjoint, then the set of bridges X_ef is empty.
-/
lemma X_ef_empty_of_disjoint (G : SimpleGraph V) [DecidableRel G.Adj]
    (e f : Finset V) (h_disj : Disjoint e f) :
    X_ef G e f = ∅ := by
  rw [Finset.eq_empty_iff_forall_not_mem]
  intro t ht
  simp only [X_ef, Finset.mem_filter] at ht
  obtain ⟨ht_clique, ht_e, ht_f⟩ := ht
  have h_card : (t ∩ e).card + (t ∩ f).card ≤ t.card := by
    rw [← Finset.card_union_of_disjoint]
    · apply Finset.card_le_card
      apply Finset.union_subset_iff.mpr
      constructor
      · exact Finset.inter_subset_left
      · exact Finset.inter_subset_left
    · exact Finset.disjoint_of_subset_right (Finset.inter_subset_right) (Finset.disjoint_of_subset_left (Finset.inter_subset_right) h_disj)
  have h_t_card : t.card = 3 := by
    rw [SimpleGraph.mem_cliqueFinset_iff] at ht_clique
    exact ht_clique.2
  linarith

lemma path4_B_bridges_subset (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hpath : isPath4 M A B C D) :
    bridges G M B ⊆ X_ef G B A ∪ X_ef G B C := by
      -- Let's unfold the definition of `bridges` and `X_ef`.
      unfold bridges X_ef;
      -- Let's unfold the definition of `trianglesSharingEdge`.
      unfold trianglesSharingEdge at *;
      simp +decide [ Finset.subset_iff ];
      rcases hpath with ⟨ hM, hA, hB, hC, hD ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
      intro t ht htB htD htD';
      have h_contradiction : (t ∩ B).card + (t ∩ D).card ≤ t.card := by
        rw [ ← Finset.card_union_of_disjoint ];
        · exact Finset.card_le_card ( Finset.union_subset ( Finset.inter_subset_left ) ( Finset.inter_subset_left ) );
        · exact Finset.disjoint_left.mpr fun x hx hx' => Finset.notMem_empty x <| hD.2.2.2.2.2.2.2.2 ▸ Finset.mem_inter.mpr ⟨ Finset.mem_inter.mp hx |>.2, Finset.mem_inter.mp hx' |>.2 ⟩;
      have := ht.card_eq; simp_all +decide ;
      linarith

lemma X_ef_structure (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M) (hef : e ≠ f)
    (v : V) (hv : e ∩ f = {v})
    (u w : V) (hue : e = {u, v, w}) (huv : u ≠ v) (hvw : v ≠ w) (huw : u ≠ w) :
    ∀ t ∈ X_ef G e f, (∃ y ∈ f, y ≠ v ∧ t = {u, v, y}) ∨ (∃ y ∈ f, y ≠ v ∧ t = {w, v, y}) := by
      -- Since $t$ shares at least two vertices with $e$ and $f$, and $e$ and $f$ intersect only at $v$, $t$ must contain $v$ and either $u$ or $w$.
      intros t ht
      have h_vertices : v ∈ t ∧ (u ∈ t ∨ w ∈ t) := by
        have h_vertices : v ∈ t := by
          exact X_ef_mem_inter G M hM e f he hf hef v hv t ht;
        simp_all +decide [ X_ef ];
        contrapose! ht; simp_all +decide [ Finset.ext_iff ] ;
      -- Since $t$ shares at least two vertices with $f$, and $f$ contains $v$ and two other vertices (say $y$ and $z$), $t$ must contain $v$ and either $y$ or $z$.
      obtain ⟨y, hy⟩ : ∃ y ∈ f, y ≠ v ∧ y ∈ t := by
        have h_vertices_f : (t ∩ f).card ≥ 2 := by
          unfold X_ef at ht; aesop;
        obtain ⟨ y, hy ⟩ := Finset.exists_mem_ne h_vertices_f v; use y; aesop;
      have h_card : t.card = 3 := by
        have h_card : t ∈ G.cliqueFinset 3 := by
          exact Finset.mem_filter.mp ht |>.1;
        simp_all +decide [ SimpleGraph.cliqueFinset ];
        exact h_card.2;
      rw [ Finset.card_eq_three ] at h_card;
      rcases h_card with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ] ;
      grind

/-
If two triangles share at least 2 vertices, there exists an edge covering both.
-/
lemma overlap_implies_cover_lemma (G : SimpleGraph V) [DecidableRel G.Adj]
    (t1 t2 : Finset V) (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3)
    (h_overlap : (t1 ∩ t2).card ≥ 2) :
    ∃ ε ∈ G.edgeFinset, ε ∈ t1.sym2 ∧ ε ∈ t2.sym2 := by
      -- Since $|t1 \cap t2| \ge 2$, there exist $u, v \in t1 \cap t2$ such that $u \ne v$.
      obtain ⟨u, v, huv⟩ : ∃ u v : V, u ∈ t1 ∩ t2 ∧ v ∈ t1 ∩ t2 ∧ u ≠ v := by
        exact Finset.one_lt_card.1 h_overlap |> Exists.imp fun u => by aesop;
      use s(u, v);
      simp_all +decide [ SimpleGraph.isClique_iff, Finset.subset_iff ];
      exact ht1.1 ( by aesop ) ( by aesop ) huv.2.2

/-
Given triangles t1, t2, t3 covering edges of e, either they can be covered by 2 edges or they form a packing.
-/
lemma tau_le_2_or_packing_of_triangles_on_edges (G : SimpleGraph V) [DecidableRel G.Adj]
    (e : Finset V) (he : e ∈ G.cliqueFinset 3)
    (u v w : V) (hue : e = {u, v, w}) (huv : u ≠ v) (hvw : v ≠ w) (huw : u ≠ w)
    (t1 t2 t3 : Finset V)
    (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (ht3 : t3 ∈ G.cliqueFinset 3)
    (h_cov1 : {u, v} ⊆ t1) (h_cov2 : {v, w} ⊆ t2) (h_cov3 : {u, w} ⊆ t3) :
    triangleCoveringNumberOn G {t1, t2, t3} ≤ 2 ∨ isTrianglePacking G {t1, t2, t3} := by
      by_cases h_case : (t1 ∩ t2).card ≥ 2 ∨ (t1 ∩ t3).card ≥ 2 ∨ (t2 ∩ t3).card ≥ 2;
      · rcases h_case with ( h | h | h );
        · have h_edge_cover : ∃ ε ∈ G.edgeFinset, ε ∈ t1.sym2 ∧ ε ∈ t2.sym2 := by
            exact?;
          -- Since ε covers both t1 and t2, we need one more edge to cover t3. Let's find an edge in t3 that covers the remaining vertices.
          obtain ⟨ε', hε'⟩ : ∃ ε' ∈ G.edgeFinset, ε' ∈ t3.sym2 := by
            simp_all +decide [ SimpleGraph.isClique_iff, Finset.subset_iff ];
            obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.card_eq_three.mp ht3.2;
            exact ⟨ s(x, hx), by have := ht3.1; aesop ⟩;
          refine' Or.inl ( le_trans ( le_triangleCoveringNumberOn G { t1, t2, t3 } { h_edge_cover.choose, ε' } _ ) _ );
          · refine' ⟨ _, _ ⟩;
            · exact Finset.insert_subset_iff.mpr ⟨ h_edge_cover.choose_spec.1, Finset.singleton_subset_iff.mpr hε'.1 ⟩;
            · simp +zetaDelta at *;
              exact ⟨ Or.inl fun x hx => by have := h_edge_cover.choose_spec.2.1; rw [ Finset.mem_sym2_iff ] at this; aesop, Or.inl fun x hx => by have := h_edge_cover.choose_spec.2.2; rw [ Finset.mem_sym2_iff ] at this; aesop, Or.inr fun x hx => hε'.2 x hx ⟩;
          · exact Finset.card_insert_le _ _;
        · -- If $t1$ and $t3$ share at least 2 vertices, then there exists an edge covering both.
          obtain ⟨ε, hε⟩ : ∃ ε ∈ G.edgeFinset, ε ∈ t1.sym2 ∧ ε ∈ t3.sym2 := by
            exact?;
          refine' Or.inl ( le_trans ( le_triangleCoveringNumberOn G _ _ _ ) _ );
          exact { ε, if v ∈ t2 then Sym2.mk ( v, w ) else Sym2.mk ( v, u ) };
          · constructor <;> simp_all +decide [ Finset.subset_iff ];
            exact ht2.1 ( by aesop ) ( by aesop ) ( by aesop );
          · exact Finset.card_insert_le _ _;
        · left;
          obtain ⟨ ε, hε ⟩ := overlap_implies_cover_lemma G t2 t3 ht2 ht3 h;
          -- Since $t1$ covers an edge of $e$, we can pick that edge to cover $t1$.
          obtain ⟨ε', hε'⟩ : ∃ ε' ∈ G.edgeFinset, ε' ∈ t1.sym2 := by
            simp_all +decide [ SimpleGraph.isNClique_iff ];
            rcases Finset.card_eq_three.mp ht1.2 with ⟨ x, y, z, hx, hy, hz, hxyz ⟩ ; use Sym2.mk ( x, y ) ; aesop;
          refine' le_trans ( le_triangleCoveringNumberOn _ _ _ _ ) _;
          exact { ε, ε' };
          · constructor <;> simp_all +decide [ Finset.subset_iff ];
          · exact Finset.card_insert_le _ _;
      · refine' Or.inr ⟨ _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
        simp_all +decide [ Set.Pairwise ];
        exact ⟨ ⟨ fun _ => Nat.le_of_lt_succ h_case.1, fun _ => Nat.le_of_lt_succ h_case.2.1 ⟩, ⟨ fun _ => Nat.le_of_lt_succ ( by rw [ Finset.inter_comm ] ; exact h_case.1 ), fun _ => Nat.le_of_lt_succ h_case.2.2 ⟩, fun _ => Nat.le_of_lt_succ ( by rw [ Finset.inter_comm ] ; exact h_case.2.1 ), fun _ => Nat.le_of_lt_succ ( by rw [ Finset.inter_comm ] ; exact h_case.2.2 ) ⟩

-- Symmetric version for endpoint D
lemma path4_D_bridges_only_to_C (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A B C D : Finset V)
    (hpath : isPath4 M A B C D) :
    bridges G M D ⊆ X_ef G D C := by
  intro t ht
  simp only [bridges, Finset.mem_filter] at ht
  obtain ⟨h_share_D, f, hfM, hfne, h_share_f⟩ := ht
  simp only [X_ef, Finset.mem_filter]
  constructor
  · simp only [trianglesSharingEdge, Finset.mem_filter] at h_share_D
    exact h_share_D.1
  constructor
  · simp only [trianglesSharingEdge, Finset.mem_filter] at h_share_D
    exact h_share_D.2
  · obtain ⟨hM_eq, hAB, hAC_ne, hAD_ne, hBC_ne, hBD_ne, hCD_ne,
            hAB_share, hBC_share, hCD_share, hAC_disj, hAD_disj, hBD_disj⟩ := hpath
    have hfM' : f ∈ ({A, B, C, D} : Finset (Finset V)) := by rw [← hM_eq]; exact hfM
    simp only [Finset.mem_insert, Finset.mem_singleton] at hfM'
    rcases hfM' with rfl | rfl | rfl | rfl
    · exfalso
      have h_contradiction : (t ∩ D).card + (t ∩ f).card ≤ (t : Finset V).card := by
        rw [ ← Finset.card_union_of_disjoint ];
        · exact Finset.card_le_card fun x hx => by aesop;
        · simp_all +decide [ Finset.disjoint_left ];
          exact fun x hx hx' hx'' => Finset.notMem_empty x ( hAD_disj ▸ Finset.mem_inter_of_mem hx'' hx' );
      have h_contradiction : (t : Finset V).card ≤ 3 := by
        have h_contradiction : t ∈ G.cliqueFinset 3 := by
          unfold trianglesSharingEdge at h_share_D; aesop;
        exact Finset.mem_filter.mp h_contradiction |>.2.2.le;
      linarith [ show ( t ∩ D ).card ≥ 2 by exact Finset.mem_filter.mp h_share_D |>.2 ]
    · exfalso
      have h_contradiction : (t ∩ D).card + (t ∩ f).card > 3 := by
        linarith [ show Finset.card ( t ∩ D ) ≥ 2 from by { unfold trianglesSharingEdge at h_share_D; aesop } ];
      have h_contradiction : (t ∩ D).card + (t ∩ f).card ≤ t.card := by
        have h_contradiction : (t ∩ D) ∪ (t ∩ f) ⊆ t := by
          exact Finset.union_subset ( Finset.inter_subset_left ) ( Finset.inter_subset_left );
        have := Finset.card_mono h_contradiction;
        rwa [ Finset.card_union_of_disjoint ( Finset.disjoint_left.mpr fun x hx₁ hx₂ => by simp_all +decide [ Finset.ext_iff ] ) ] at this;
      have h_card_t : t ∈ G.cliqueFinset 3 := by
        unfold trianglesSharingEdge at h_share_D; aesop;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      exact absurd h_contradiction ( by linarith [ h_card_t.card_eq ] )
    · exact h_share_f
    · exact absurd rfl hfne

-- Symmetric version for endpoint D
lemma tau_Te_le_4_for_endpoint_D (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hpath : isPath4 M A B C D) :
    triangleCoveringNumberOn G (trianglesSharingEdge G D) ≤ 4 := by
  rw [Te_eq_Se_union_bridges G M D]
  have h_bridges : bridges G M D ⊆ X_ef G D C := path4_D_bridges_only_to_C G M A B C D hpath
  calc triangleCoveringNumberOn G (S_e G M D ∪ bridges G M D)
      ≤ triangleCoveringNumberOn G (S_e G M D) + triangleCoveringNumberOn G (bridges G M D) := by
        apply tau_union_le_sum
    _ ≤ 2 + triangleCoveringNumberOn G (bridges G M D) := by
        have hD : D ∈ M := by rw [hpath.1]; simp
        linarith [tau_S_le_2 G M hM D hD]
    _ ≤ 2 + triangleCoveringNumberOn G (X_ef G D C) := by
        apply le_of_forall_le;
        intro c hc
        have h_cover : ∃ E' : Finset (Sym2 V), isTriangleCover G (X_ef G D C) E' ∧ E'.card ≤ triangleCoveringNumberOn G (X_ef G D C) := by
          have h_cover : ∃ E' ∈ Finset.filter (fun E' => ∀ t ∈ X_ef G D C, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset), E'.card = triangleCoveringNumberOn G (X_ef G D C) := by
            unfold triangleCoveringNumberOn;
            have h_nonempty : Finset.Nonempty (Finset.filter (fun E' => ∀ t ∈ X_ef G D C, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset)) := by
              refine' ⟨ G.edgeFinset, _ ⟩;
              simp +decide [ X_ef ];
              intro t ht htD htC; obtain ⟨ u, v, w, h ⟩ := Finset.card_eq_three.mp ht.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
              exact ⟨ s(u, v), by aesop ⟩;
            have := Finset.min_of_mem ( Finset.mem_image_of_mem Finset.card h_nonempty.choose_spec );
            obtain ⟨ b, hb ⟩ := this;
            have := Finset.mem_of_min hb;
            rw [ Finset.mem_image ] at this; obtain ⟨ E', hE', rfl ⟩ := this; use E'; aesop;
          obtain ⟨ E', hE₁, hE₂ ⟩ := h_cover;
          exact ⟨ E', ⟨ Finset.mem_powerset.mp ( Finset.mem_filter.mp hE₁ |>.1 ), Finset.mem_filter.mp hE₁ |>.2 ⟩, hE₂.le ⟩;
        obtain ⟨ E', hE', hE'' ⟩ := h_cover;
        have h_cover_bridges : isTriangleCover G (bridges G M D) E' := by
          exact ⟨ hE'.1, fun t ht => hE'.2 t ( h_bridges ht ) ⟩;
        exact hc.trans ( add_le_add_left ( le_triangleCoveringNumberOn G _ _ h_cover_bridges ) _ |> le_trans <| by linarith )
    _ ≤ 2 + 2 := by
        have hC : C ∈ M := by rw [hpath.1]; simp
        have hD : D ∈ M := by rw [hpath.1]; simp
        linarith [tau_X_le_2 G M hM D C hD hC hpath.2.2.2.2.2.1]
    _ = 4 := by ring

-- Key lemma: X_BA = X_AB (symmetry)
lemma X_ef_symm (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) :
    X_ef G e f = X_ef G f e := by
  ext t
  simp only [X_ef, Finset.mem_filter]
  constructor <;> intro ⟨h1, h2, h3⟩ <;> exact ⟨h1, h3, h2⟩

-- Main covering number relates to triangleCoveringNumberOn
lemma triangleCoveringNumber_le_on_all (G : SimpleGraph V) [DecidableRel G.Adj] :
    triangleCoveringNumber G ≤ triangleCoveringNumberOn G (G.cliqueFinset 3) := by
  unfold triangleCoveringNumber triangleCoveringNumberOn
  apply le_of_eq
  congr 1
  ext E'
  simp only [Finset.mem_filter, Finset.mem_powerset]
  constructor
  · intro ⟨h1, h2, h3⟩
    exact ⟨h1, h3⟩
  · intro ⟨h1, h2⟩
    exact ⟨h1, h1, h2⟩

/-
MAIN THEOREM: For PATH_4 configuration, τ ≤ 8

PROOF APPROACH:
Using the path structure A—B—C—D:

1. All triangles partition into: S_A ⊔ X_AB ⊔ S_B ⊔ X_BC ⊔ S_C ⊔ X_CD ⊔ S_D
   (disjoint because X_AC = X_AD = X_BD = ∅ by X_ef_empty_of_disjoint)

2. Group these into:
   - T_A = S_A ∪ X_AB (endpoint, ≤4 edges by tau_Te_le_4_for_endpoint)
   - T_D = S_D ∪ X_CD (endpoint, ≤4 edges by tau_Te_le_4_for_endpoint_D)
   - Middle = S_B ∪ X_BC ∪ S_C

3. Key insight: X_BA ⊆ T_A and X_CD ⊆ T_D, so the 8 edges for T_A ∪ T_D
   also cover X_BA and X_DC.

4. For middle elements: T_B = S_B ∪ X_BA ∪ X_BC where X_BA already covered
   T_C = S_C ∪ X_CB ∪ X_CD where X_CD already covered

5. Remaining after T_A ∪ T_D: need to cover S_B ∪ X_BC ∪ S_C

6. But τ(T_A) + τ(T_D) ≤ 4 + 4 = 8, and if we can show the remaining
   triangles are already covered, we're done!

   Actually the remaining S_B ∪ X_BC ∪ S_C needs 0 additional edges IF
   every triangle there is already hit by the T_A or T_D covers.

   This is where the proof gets tricky - we need to show the covers overlap.

ALTERNATIVE: Show directly that 8 edges suffice by explicit construction:
- 2 edges incident to v1 = A ∩ B (covers X_AB)
- 1 edge from A not incident to v1 (covers remaining S_A with first edge)
- 2 edges incident to v3 = C ∩ D (covers X_CD)
- 1 edge from D not incident to v3 (covers remaining S_D)
- 2 edges incident to v2 = B ∩ C (covers X_BC, S_B, S_C)

Wait, that's 8 edges! But we need to verify they cover everything.
-/
theorem tau_le_8_path4 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (hcard : M.card = 4)
    (A B C D : Finset V) (hpath : isPath4 M A B C D) :
    triangleCoveringNumber G ≤ 8 := by
  -- Strategy: Use partition and proven bounds
  -- All triangles ⊆ T_A ∪ T_B ∪ T_C ∪ T_D by path4_triangle_partition
  -- Decompose and bound each part
  sorry

end
