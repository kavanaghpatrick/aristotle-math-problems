/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d548b3db-fa68-45a4-80d1-031439a43f07

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalized Pell numbers and properties related to the open conjecture on infinite Pell primes. Defined Pell numbers and Pell-Lucas numbers. Proved recurrence relations, divisibility properties (strong divisibility sequence), GCD properties, rank of appearance theorem, connection to Legendre symbol, and properties of prime divisors. The main conjecture remains open.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def pellNumber : ℕ → ℕ
  | 0 => 0
  | 1 => 1
  | (n + 2) => 2 * pellNumber (n + 1) + pellNumber n

/-
If n divides m, then the n-th Pell number divides the m-th Pell number.
-/
theorem pellNumber_dvd_pellNumber {n m : ℕ} (h : n ∣ m) : pellNumber n ∣ pellNumber m := by
  obtain ⟨ k, rfl ⟩ := h; induction k <;> simp_all +decide [ Nat.mul_succ, pellNumber ] ;
  -- Let's use the identity for Pell numbers: $P_{n+m} = P_n P_{m+1} + P_{n-1} P_m$.
  have h_identity : ∀ n m : ℕ, n > 0 → pellNumber (n + m) = pellNumber n * pellNumber (m + 1) + pellNumber (n - 1) * pellNumber m := by
    -- We proceed by induction on $m$.
    intro n m hn_pos
    induction' m with m ih generalizing n;
    · rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ pellNumber ];
    · convert ih ( n + 1 ) ( Nat.succ_pos _ ) using 1 ; ring!;
      rcases n <;> simp_all +decide [ pellNumber ] ; ring!;
  by_cases hn : n > 0 <;> simp_all +decide [ Nat.mul_succ, Nat.dvd_add_right ];
  rw [ add_comm, h_identity _ _ hn ] ; simp +decide [ *, Nat.dvd_add_right, dvd_mul_of_dvd_left ];
  exact dvd_mul_of_dvd_right ‹_› _

/-
If the n-th Pell number is prime, then n is prime.
-/
theorem prime_of_prime_pellNumber {n : ℕ} (h : Prime (pellNumber n)) : Prime n := by
  -- By definition of Pell numbers, we know that if n is composite, then P_n is also composite.
  by_cases h_comp : ¬n.Prime;
  · -- If n is composite, then n = k * m where 1 < k < n. Then P_k divides P_n.
    obtain ⟨k, m, hk, hm, hkm⟩ : ∃ k m, 1 < k ∧ k < n ∧ n = k * m := by
      contrapose! h_comp; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ ← Nat.prime_iff ] ;
      exact Nat.prime_def_lt'.mpr ⟨ Nat.le_add_left _ _, fun x hx₁ hx₂ hx₃ => h_comp x ( ( n + 2 ) / x ) hx₁ ( Nat.le_of_lt_succ <| by nlinarith [ Nat.div_mul_cancel hx₃ ] ) <| by rw [ Nat.mul_div_cancel' hx₃ ] ⟩;
    -- Since Pell numbers are strictly increasing for n >= 1, we have P_k > 1 and P_k < P_n.
    have h_pell_strict_mono : ∀ {n m : ℕ}, 1 ≤ n → n < m → pellNumber n < pellNumber m := by
      intros n m hn hm; induction hm <;> simp_all +decide [ Nat.mul_succ ] ;
      · induction hn <;> simp_all +decide [ Nat.mul_succ, pellNumber ];
        grind;
      · rename_i m hm ih;
        rcases m with ( _ | _ | m ) <;> simp_all +arith +decide [ pellNumber ];
        linarith;
    have h_pell_gt_one : 1 < pellNumber k := by
      exact lt_of_le_of_lt ( by decide ) ( h_pell_strict_mono ( by linarith ) hk )
    have h_pell_lt_pell_n : pellNumber k < pellNumber n := by
      exact h_pell_strict_mono hk.le hm
    have h_pell_div : pellNumber k ∣ pellNumber n := by
      exact pellNumber_dvd_pellNumber ( hkm.symm ▸ dvd_mul_right _ _ )
    have h_pell_prime : pellNumber k = 1 ∨ pellNumber k = pellNumber n := by
      rw [ h.nat_prime.dvd_iff_eq ] at h_pell_div <;> aesop;
    grind;
  · simpa only [ ← Nat.prime_iff ] using Classical.not_not.mp h_comp

/-
The GCD of the n-th and m-th Pell numbers is the Pell number of the GCD of n and m.
-/
theorem pellNumber_gcd (n m : ℕ) : Nat.gcd (pellNumber n) (pellNumber m) = pellNumber (Nat.gcd n m) := by
  -- By definition of Pell numbers, we know that $U_n$ is the $n$-th term of the sequence defined by $U_0 = 0$, $U_1 = 1$, and $U_{n+2} = 2U_{n+1} + U_n$.
  set U : ℕ → ℤ := fun n => Nat.iterate (fun p => (p.2, 2 * p.2 + p.1)) n (0, 1) |>.1;
  -- By definition of $U$, we know that $U_n$ is the $n$-th term of the sequence defined by $U_0 = 0$, $U_1 = 1$, and $U_{n+2} = 2U_{n+1} + U_n$.
  have hU_def : ∀ n, U n = pellNumber n := by
    intro n
    simp [U];
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Function.iterate_succ_apply' ];
    have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ Function.iterate_succ_apply' ] at * ; aesop;
  -- By definition of $U$, we know that $U_{n+m} = U_n U_{m+1} + U_{n-1} U_m$ for all $n, m \geq 1$.
  have hU_recurrence : ∀ n m : ℕ, 1 ≤ n → 1 ≤ m → U (n + m) = U n * U (m + 1) + U (n - 1) * U m := by
    intros n m hn hm; induction' hn with n hn ih generalizing m <;> simp_all +decide [ Function.iterate_succ_apply' ] ; ring;
    · norm_num [ add_comm, pellNumber ];
    · convert ih ( m + 1 ) ( by linarith ) using 1 ; ring!;
      norm_num [ show pellNumber 2 = 2 by rfl, show pellNumber 1 = 1 by rfl, show pellNumber ( m + 1 + 1 ) = 2 * pellNumber ( m + 1 ) + pellNumber m by rfl ] ; ring;
  -- By definition of $U$, we know that $\gcd(U_n, U_m) = \gcd(U_{n-m}, U_m)$ for all $n > m$.
  have hU_gcd_step : ∀ n m : ℕ, 1 ≤ n → 1 ≤ m → n > m → Int.gcd (U n) (U m) = Int.gcd (U (n - m)) (U m) := by
    intros n m hn hm hnm
    have h_recurrence : U n = U (n - m) * U (m + 1) + U (n - m - 1) * U m := by
      convert hU_recurrence ( n - m ) m ( Nat.sub_pos_of_lt hnm ) hm using 1 ; rw [ Nat.sub_add_cancel hnm.le ];
    rw [ h_recurrence ];
    -- By definition of $U$, we know that $U_{m+1}$ and $U_m$ are coprime.
    have h_coprime : Int.gcd (U (m + 1)) (U m) = 1 := by
      refine' Nat.recOn m _ _ <;> simp_all +decide [ Function.iterate_succ_apply' ];
      simp +decide [ Int.gcd, Int.natAbs_mul ];
      exact fun n hn => Nat.gcd_comm _ _ ▸ hn;
    refine' Nat.dvd_antisymm _ _;
    · refine' Nat.dvd_gcd _ ( Nat.gcd_dvd_right _ _ );
      have h_div : Int.gcd (U (n - m) * U (m + 1) + U (n - m - 1) * U m) (U m) ∣ Int.natAbs (U (n - m) * U (m + 1)) := by
        convert Int.natAbs_dvd_natAbs.mpr ( Int.dvd_sub ( Int.gcd_dvd_left _ _ ) ( dvd_mul_of_dvd_right ( Int.gcd_dvd_right _ _ ) ( U ( n - m - 1 ) ) ) ) using 1 ; ring;
      rw [ Int.natAbs_mul ] at h_div;
      exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( Int.gcd ( U ( n - m ) * U ( m + 1 ) + U ( n - m - 1 ) * U m ) ( U m ) ) ( Int.natAbs ( U ( m + 1 ) ) ) from Nat.Coprime.coprime_dvd_left ( Nat.gcd_dvd_right _ _ ) <| by simpa [ Int.gcd_comm ] using h_coprime ) h_div );
    · exact Int.natCast_dvd_natCast.mp ( Int.dvd_coe_gcd ( dvd_add ( dvd_mul_of_dvd_left ( Int.gcd_dvd_left _ _ ) _ ) ( dvd_mul_of_dvd_right ( Int.gcd_dvd_right _ _ ) _ ) ) ( Int.gcd_dvd_right _ _ ) );
  -- By induction on $n + m$, we can show that $\gcd(U_n, U_m) = U_{\gcd(n, m)}$ for all $n, m \geq 1$.
  have hU_gcd_induction : ∀ n m : ℕ, 1 ≤ n → 1 ≤ m → Int.gcd (U n) (U m) = U (Nat.gcd n m) := by
    intros n m hn hm; induction' n using Nat.strong_induction_on with n ih generalizing m; induction' m using Nat.strong_induction_on with m ih'; rcases lt_trichotomy n m with ( h | rfl | h ) <;> norm_num at *;
    · rw [ Int.gcd_comm, hU_gcd_step m n hm hn h ];
      convert ih' ( m - n ) ( Nat.sub_lt hm hn ) ( Nat.sub_pos_of_lt h ) using 1 ; simp +decide [ Nat.gcd_comm, h.le ];
      · exact Int.gcd_comm _ _;
      · rw [ Nat.gcd_sub_self_right h.le ];
    · grind;
    · rw [ hU_gcd_step n m hn hm h, ih ( n - m ) ( Nat.sub_lt hn hm ) m ( Nat.sub_pos_of_lt h ) hm ];
      rw [ Nat.gcd_sub_self_left h.le ];
  by_cases hn : 1 ≤ n <;> by_cases hm : 1 ≤ m <;> simp_all +decide [ Int.gcd_eq_natAbs ];
  · -- Since $pellNumber 0 = 0$, we have $\gcd(pellNumber n, pellNumber 0) = \gcd(pellNumber n, 0) = pellNumber n$.
    simp [pellNumber];
  · exact Nat.gcd_zero_left _

/-
For any prime p, there exists a positive index k such that p divides the k-th Pell number.
-/
theorem exists_pell_dvd (p : ℕ) (hp : p.Prime) : ∃ k > 0, p ∣ pellNumber k := by
  -- By the pigeonhole principle, since there are infinitely many pairs $(P_n, P_{n+1})$ modulo $p$, there must be some repetition.
  obtain ⟨n, m, hnm, h_mod⟩ : ∃ n m, n < m ∧ (pellNumber n % p = pellNumber m % p) ∧ (pellNumber (n + 1) % p = pellNumber (m + 1) % p) := by
    -- There are only $p^2$ possible pairs $(P_n, P_{n+1})$ modulo $p$.
    have h_finite : Set.Finite ((Set.range (fun n => (pellNumber n % p, pellNumber (n + 1) % p)))) := by
      exact Set.finite_iff_bddAbove.mpr ⟨ ⟨ p - 1, p - 1 ⟩, by rintro a ⟨ n, rfl ⟩ ; exact ⟨ Nat.le_sub_one_of_lt ( Nat.mod_lt _ hp.pos ), Nat.le_sub_one_of_lt ( Nat.mod_lt _ hp.pos ) ⟩ ⟩;
    contrapose! h_finite;
    exact Set.infinite_range_of_injective fun m n hmn => le_antisymm ( le_of_not_gt fun hmn' => h_finite _ _ hmn' ( by aesop ) ( by aesop ) ) ( le_of_not_gt fun hmn' => h_finite _ _ hmn' ( by aesop ) ( by aesop ) );
  induction' n with n ih generalizing m;
  · exact ⟨ m, hnm, Nat.dvd_of_mod_eq_zero <| h_mod.1.symm ▸ Nat.zero_mod _ ⟩;
  · contrapose! ih;
    use m - 1;
    rcases m <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero ];
    have h_mod_eq : pellNumber (n + 2) = 2 * pellNumber (n + 1) + pellNumber n ∧ pellNumber (Nat.succ ‹_› + 1) = 2 * pellNumber (Nat.succ ‹_›) + pellNumber ‹_› := by
      exact ⟨ rfl, rfl ⟩;
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ];
    linear_combination' h_mod.2 - h_mod.1 * 2

/-
The rank of appearance z(p) divides n if and only if p divides the n-th Pell number.
-/
def rankOfAppearance (p : ℕ) (hp : p.Prime) : ℕ := Nat.find (exists_pell_dvd p hp)

theorem rankOfAppearance_pos (p : ℕ) (hp : p.Prime) : rankOfAppearance p hp > 0 := by
  exact (Nat.find_spec (exists_pell_dvd p hp)).1

theorem rank_dvd_iff_dvd_pell (p : ℕ) (hp : p.Prime) (n : ℕ) : rankOfAppearance p hp ∣ n ↔ p ∣ pellNumber n := by
  unfold rankOfAppearance;
  constructor <;> intro hn;
  · obtain ⟨ k, rfl ⟩ := hn;
    exact dvd_trans ( Nat.find_spec ( exists_pell_dvd p hp ) |>.2 ) ( pellNumber_dvd_pellNumber ( dvd_mul_right _ _ ) );
  · by_contra h_not_div;
    -- By definition of $z(p)$, we know that $p \mid P_{z(p)}$.
    have h_div_z : p ∣ pellNumber (Nat.find (exists_pell_dvd p hp)) := by
      exact Nat.find_spec ( exists_pell_dvd p hp ) |>.2;
    -- Since $z(p)$ is the smallest index such that $p \mid P_{z(p)}$, we have $P_{\gcd(z(p), n)} \equiv 0 \pmod{p}$.
    have h_gcd : pellNumber (Nat.gcd (Nat.find (exists_pell_dvd p hp)) n) ≡ 0 [MOD p] := by
      have h_gcd : Nat.gcd (pellNumber (Nat.find (exists_pell_dvd p hp))) (pellNumber n) = pellNumber (Nat.gcd (Nat.find (exists_pell_dvd p hp)) n) := by
        exact?;
      exact h_gcd ▸ Nat.modEq_zero_iff_dvd.mpr ( Nat.dvd_gcd h_div_z hn );
    -- Since $z(p)$ is the smallest index such that $p \mid P_{z(p)}$, we have $\gcd(z(p), n) < z(p)$.
    have h_gcd_lt : Nat.gcd (Nat.find (exists_pell_dvd p hp)) n < Nat.find (exists_pell_dvd p hp) := by
      exact lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.gcd_dvd_left _ _ ) ) fun con => h_not_div <| con ▸ Nat.gcd_dvd_right _ _;
    exact h_gcd_lt.not_le ( Nat.find_min' ( exists_pell_dvd p hp ) ⟨ Nat.gcd_pos_of_pos_left _ ( Nat.pos_of_ne_zero ( by aesop ) ), by simpa [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ] using h_gcd ⟩ )

/-
The Pell numbers are strictly increasing.
-/
theorem pellNumber_strictMono : StrictMono pellNumber := by
  refine' strictMono_nat_of_lt_succ _;
  intro n;
  induction n <;> norm_num [ pellNumber ] at *;
  grind

/-
The set of indices n such that the n-th Pell number is composite is infinite.
-/
theorem pell_composites_infinite : Set.Infinite {n : ℕ | ¬ (pellNumber n).Prime} := by
  rw [ Set.infinite_iff_exists_gt ];
  intro a
  obtain ⟨k, hk⟩ : ∃ k > a, ¬Nat.Prime (pellNumber (3 * k)) := by
    use 2 * a + 2;
    -- By definition of $pellNumber$, we know that $pellNumber (3 * (2 * a + 2))$ is divisible by $pellNumber (3)$.
    have h_div : pellNumber 3 ∣ pellNumber (3 * (2 * a + 2)) := by
      exact pellNumber_dvd_pellNumber ( dvd_mul_right _ _ ) |> fun h => dvd_trans ( by decide ) h;
    rw [ Nat.prime_def_lt' ];
    exact ⟨ by linarith, fun h => h.2 _ ( show 2 ≤ pellNumber 3 by decide ) ( show pellNumber 3 < pellNumber ( 3 * ( 2 * a + 2 ) ) from by { exact strictMono_nat_of_lt_succ ( fun n => by { exact Nat.recOn n ( by decide ) fun n ihn => by { exact Nat.recOn n ( by decide ) fun n ihn => by { exact by { rw [ show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) from rfl ] ; linarith! } } } } ) ( by linarith ) } ) h_div ⟩
  use 3 * k
  simp [hk];
  linarith

/-
There exists a prime number n such that the n-th Pell number is composite.
-/
theorem exists_prime_index_composite_pell : ∃ n, Nat.Prime n ∧ ¬ Nat.Prime (pellNumber n) := by
  -- We use the fact that $P_19$ is composite.
  use 19;
  native_decide

/-
The set of prime divisors of the Pell sequence is exactly the set of all prime numbers.
-/
theorem pell_prime_divisors_eq_all_primes : {p : ℕ | p.Prime ∧ ∃ n, p ∣ pellNumber n} = {p : ℕ | p.Prime} := by
  ext p;
  simp;
  exact fun hp => by obtain ⟨ n, hn ⟩ := exists_pell_dvd p hp; exact ⟨ n, hn.2 ⟩ ;

/-
Cassini's identity for Pell numbers: P_{n+1} * P_{n-1} - P_n^2 = (-1)^n for n >= 1.
-/
theorem pell_cassini (n : ℕ) (h : n ≥ 1) : (pellNumber (n + 1) : ℤ) * (pellNumber (n - 1) : ℤ) - ((pellNumber n : ℤ) ^ 2) = (-1) ^ n := by
  -- We'll use induction on $n$ to prove Cassini's identity.
  induction' n with n ih;
  · contradiction;
  · rcases n with ( _ | _ | n ) <;> norm_num [ pow_succ, pellNumber ] at *;
    linarith

/-
The n-th Pell number is odd if and only if n is odd.
-/
theorem pell_odd_iff_odd (n : ℕ) : Odd (pellNumber n) ↔ Odd n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> simp +arith +decide [ *, parity_simps ];
  rw [ show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) by rfl ] ; simp +arith +decide [ *, parity_simps ]

/-
Double angle formula for Pell numbers: P_{2n} = 2 * P_n * (P_{n+1} - P_n).
-/
theorem pell_double_angle (n : ℕ) : pellNumber (2 * n) = 2 * pellNumber n * (pellNumber (n + 1) - pellNumber n) := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.mul_succ ];
  have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; simp_all +decide [ Nat.mul_succ, pellNumber ] ;
  zify at *;
  rw [ Nat.cast_sub ] at * <;> push_cast at * <;> repeat linarith;
  · rw [ Nat.cast_sub ] at * <;> push_cast at * <;> linarith;
  · exact monotone_nat_of_le_succ ( fun n => by induction n <;> simp +decide [ *, pellNumber ] ; linarith ) ( Nat.le_succ _ );
  · exact Nat.recOn n ( by decide ) fun n ihn => by { rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; linarith }

/-
Addition formula for Pell numbers: P_{m+n+1} = P_{m+1} * P_{n+1} + P_m * P_n.
-/
theorem pell_add_one (m n : ℕ) : pellNumber (m + n + 1) = pellNumber (m + 1) * pellNumber (n + 1) + pellNumber m * pellNumber n := by
  -- By definition of Pell numbers, we can write them using the closed form.
  have h_closed_form : ∀ n, pellNumber n = ((1 + Real.sqrt 2) ^ n - (1 - Real.sqrt 2) ^ n) / (2 * Real.sqrt 2) := by
    intro n; induction' n using Nat.strongRecOn with n ih; rcases n with ( _ | _ | n ) <;> norm_num [ Nat.succ_eq_add_one ] ; ring_nf ; aesop;
    rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; push_cast [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; ring ; norm_num ; ring;
  rw [ ← @Nat.cast_inj ℝ ] ; push_cast [ h_closed_form ] ; ring ; norm_num ; ring;
  rw [ show ( Real.sqrt 2 ) ⁻¹ = Real.sqrt 2 / 2 by rw [ inv_eq_one_div, Real.sqrt_div_self' ] ] ; ring;

/-
The pair (P_{n+1} - P_n, P_n) satisfies the Pell equation x^2 - 2y^2 = (-1)^n.
-/
theorem pell_equation_sol (n : ℕ) : ((pellNumber (n + 1) : ℤ) - pellNumber n) ^ 2 - 2 * (pellNumber n : ℤ) ^ 2 = (-1) ^ n := by
  induction n <;> norm_num [ pow_succ, pellNumber ] at * ; linarith! [ pell_cassini ( Nat.succ ‹_› ) ( Nat.succ_pos _ ) ] ;

/-
If (2/p) = 1, then p divides P_{p-1}.
-/
theorem pell_dvd_of_legendre_one (p : ℕ) [Fact (Nat.Prime p)] (h : legendreSym p 2 = 1) : p ∣ pellNumber (p - 1) := by
  -- From the definition of the Legendre symbol, we know that $(2/p) = 1$ implies there exists an integer $a$ such that $a^2 \equiv 2 \pmod{p}$.
  obtain ⟨a, ha⟩ : ∃ a : ZMod p, a ^ 2 = 2 := by
    rw [ legendreSym.eq_one_iff ] at h;
    · exact Exists.elim h fun x hx => ⟨ x, by rw [ sq, ← hx ] ; norm_num ⟩;
    · norm_num +zetaDelta at *;
      erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases p <;> simp_all +decide [ legendreSym ] ;
      · exact Nat.not_prime_one Fact.out;
      · simp_all +decide [ quadraticCharFun ];
        simp_all +decide [ ZMod ];
  -- Using the identity $P_{p-1} = \frac{(1+a)^{p-1} - (1-a)^{p-1}}{2a}$, we can show that $p \mid P_{p-1}$.
  have h_identity : pellNumber (p - 1) * (2 * a) = (1 + a) ^ (p - 1) - (1 - a) ^ (p - 1) := by
    have h_identity : ∀ n : ℕ, pellNumber n * (2 * a) = (1 + a) ^ n - (1 - a) ^ n := by
      intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pow_succ, pellNumber ] ; ring;
      grind;
    apply h_identity;
  by_cases ha : a = 0 <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
  · rcases p with ( _ | _ | _ | p ) <;> cases ‹ ( 0 : ZMod _ ) = 2 › ; trivial;
    decide +revert;
  · by_cases h : ( 1 + a ) = 0 <;> by_cases h' : ( 1 - a ) = 0 <;> simp_all +decide [ ZMod.pow_card_sub_one_eq_one ];
    · simp_all +decide [ show a = -1 by linear_combination' h ];
    · grind;
    · grind;
    · grind

/-
If (2/p) = -1, then p divides P_{p+1}.
-/
theorem pell_dvd_of_legendre_neg_one (p : ℕ) [Fact (Nat.Prime p)] (h : legendreSym p 2 = -1) : p ∣ pellNumber (p + 1) := by
  -- By definition of $Pell$, we know that $Pell(p+1) = \frac{(1+\sqrt{2})^{p+1} - (1-\sqrt{2})^{p+1}}{2\sqrt{2}}$.
  have h_pell_def : (pellNumber (p + 1) : ℤ) = ((1 + Real.sqrt 2) ^ (p + 1) - (1 - Real.sqrt 2) ^ (p + 1)) / (2 * Real.sqrt 2) := by
    -- We'll use induction to prove that the formula holds for all $n$.
    have h_ind : ∀ n, pellNumber n = ((1 + Real.sqrt 2) ^ n - (1 - Real.sqrt 2) ^ n) / (2 * Real.sqrt 2) := by
      intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> norm_num [ pow_succ' ] at *;
      · ring_nf; norm_num;
        rfl;
      · rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; push_cast [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; ring ; norm_num ; ring;
    exact?;
  -- Let's simplify the expression for $Pell(p+1)$ using the binomial theorem.
  have h_pell_simplified : (pellNumber (p + 1) : ℤ) = ∑ k ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * k + 1) * 2 ^ k := by
    have h_binom : ((1 + Real.sqrt 2) ^ (p + 1) - (1 - Real.sqrt 2) ^ (p + 1)) = ∑ k ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * k + 1) * (Real.sqrt 2) ^ (2 * k + 1) * 2 := by
      have h_binom : ((1 + Real.sqrt 2) ^ (p + 1) - (1 - Real.sqrt 2) ^ (p + 1)) = ∑ k ∈ Finset.range (p + 2), Nat.choose (p + 1) k * Real.sqrt 2 ^ k * (if k % 2 = 1 then 2 else 0) := by
        have h_pell_mod : ((1 + Real.sqrt 2) ^ (p + 1) - (1 - Real.sqrt 2) ^ (p + 1)) = ∑ k ∈ Finset.range (p + 2), Nat.choose (p + 1) k * Real.sqrt 2 ^ k - ∑ k ∈ Finset.range (p + 2), Nat.choose (p + 1) k * (-Real.sqrt 2) ^ k := by
          exact congrArg₂ _ ( by rw [ add_comm, add_pow ] ; simp +decide [ mul_comm ] ) ( by rw [ sub_eq_neg_add, add_pow ] ; simp +decide [ mul_comm ] );
        rw [ h_pell_mod, ← Finset.sum_sub_distrib ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rcases Nat.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
      simp_all +decide [ Finset.sum_ite ];
      refine' Finset.sum_bij ( fun x hx => x / 2 ) _ _ _ _ <;> simp_all +decide [ Nat.add_mod, Nat.mul_mod ];
      · omega;
      · intros; omega;
      · exact fun b hb => ⟨ 2 * b + 1, ⟨ by linarith [ Nat.div_mul_le_self p 2 ], by norm_num [ Nat.add_mod ] ⟩, by norm_num [ Nat.add_div ] ⟩;
      · intro a ha₁ ha₂; rw [ ← Nat.mod_add_div a 2, ha₂ ] ;
        norm_num [ Nat.add_div ] ; ring;
    norm_num [ ← @Int.cast_inj ℝ, h_pell_def, h_binom ];
    convert congr_arg ( fun x : ℝ => x / ( 2 * Real.sqrt 2 ) ) h_binom using 1 ; ring ; norm_num [ pow_add, pow_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _ ] ; ring;
    norm_num [ pow_mul', mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ; ring;
  -- Let's simplify the expression for $Pell(p+1)$ modulo $p$.
  have h_pell_mod : (∑ k ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * k + 1) * 2 ^ k) % p = (Nat.choose (p + 1) 1 * 2 ^ 0 + Nat.choose (p + 1) (p) * 2 ^ (p / 2)) % p := by
    have h_pell_mod : ∀ k ∈ Finset.Ico 1 (p / 2), Nat.choose (p + 1) (2 * k + 1) * 2 ^ k ≡ 0 [MOD p] := by
      intro k hk; rw [ Nat.modEq_zero_iff_dvd ] ;
      have h_choose : p ∣ Nat.choose (p + 1) (2 * k + 1) := by
        have h_choose : p ∣ Nat.choose p (2 * k) := by
          exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime p ) ( by linarith [ Finset.mem_Ico.mp hk ] ) ( by linarith [ Finset.mem_Ico.mp hk, Nat.div_mul_le_self p 2 ] );
        simp_all +decide [ Nat.choose_succ_succ, add_mul ];
        exact dvd_add h_choose ( Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime p ) ( by linarith ) ( by linarith [ Nat.div_mul_le_self p 2 ] ) ) );
      exact dvd_mul_of_dvd_left h_choose _;
    rw [ Finset.sum_range_succ ];
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( Nat.div_pos ( show p ≥ 2 by exact Nat.Prime.two_le Fact.out ) zero_lt_two ) ) ];
    rw [ Nat.add_assoc, Nat.add_mod, Nat.mod_eq_zero_of_dvd <| Finset.dvd_sum fun x hx => Nat.dvd_of_mod_eq_zero <| h_pell_mod x <| Finset.mem_Ico.mpr ⟨ Nat.pos_of_ne_zero <| by aesop, Finset.mem_range.mp <| Finset.mem_sdiff.mp hx |>.1 ⟩ ] ; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
    rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num [ Nat.add_div ] at *;
  -- Since $p \equiv 3 \pmod{8}$ or $p \equiv 5 \pmod{8}$, we have $2^{p/2} \equiv -1 \pmod{p}$.
  have h_exp : 2 ^ (p / 2) ≡ -1 [ZMOD p] := by
    have h_exp : 2 ^ (p / 2) ≡ legendreSym p 2 [ZMOD p] := by
      simp +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym.eq_pow ];
    aesop;
  simp_all +decide [ ← Int.natCast_dvd_natCast, ← ZMod.intCast_zmod_eq_zero_iff_dvd, ← ZMod.intCast_eq_intCast_iff ];
  norm_cast at *; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ] ;

/-
For an odd prime p, the rank of appearance z(p) divides p - (2/p).
-/
theorem rank_dvd_p_sub_legendre (p : ℕ) [Fact (Nat.Prime p)] (hp_odd : p ≠ 2) :
    (rankOfAppearance p Fact.out : ℤ) ∣ (p : ℤ) - legendreSym p 2 := by
      -- We need to show that the rank of appearance $z(p)$ divides $p - (2/p)$.
      -- This follows from the fact that $P_{p - (2/p)}$ is divisible by $p$ if $(2/p)=1$, and $P_{p + (2/p)}$ is divisible by $p$ if $(2/p)=-1$.
      by_cases h : legendreSym p 2 = 1
      all_goals generalize_proofs at *;
      · -- By definition of rankOfAppearance, if $p \mid P_{p-1}$, then $rankOfAppearance p \mid p-1$.
        have h_rank_div : (rankOfAppearance p ‹Nat.Prime p›) ∣ (p - 1) := by
          apply (rank_dvd_iff_dvd_pell p ‹Nat.Prime p› (p - 1)).mpr;
          exact?;
        rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.succ_eq_add_one ];
        · contradiction;
        · exact?;
      · by_cases h' : legendreSym p 2 = -1;
        · have := pell_dvd_of_legendre_neg_one p h';
          -- Since $p \mid P_{p+1}$, we can apply the rank_div_iff_dvd_pell theorem to conclude that $z(p) \mid p+1$.
          have h_rank_div_p1 : rankOfAppearance p ‹_› ∣ p + 1 := by
            exact?;
          convert Int.natCast_dvd_natCast.mpr h_rank_div_p1 using 1 ; norm_num [ h' ];
        · simp_all +decide [ legendreSym ];
          simp_all +decide [ quadraticCharFun ];
          split_ifs at * <;> simp_all +decide;
          rcases p with ( _ | _ | _ | p ) <;> cases ‹_› <;> trivial

/-
The exponent of 2 in the prime factorization of P_n is equal to the exponent of 2 in the prime factorization of n.
-/
theorem pell_valuation_two (n : ℕ) : Nat.factorization (pellNumber n) 2 = Nat.factorization n 2 := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩;
  · rcases k with ( _ | k ) <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd ];
    rw [ pell_double_angle ];
    rw [ Nat.factorization_mul, Nat.factorization_mul ] <;> simp_all +decide;
    · rw [ Nat.factorization_eq_zero_of_not_dvd ];
      induction k <;> simp_all +arith +decide [ pellNumber, parity_simps ];
      grind;
    · exact ne_of_gt ( Nat.recOn k ( by decide ) fun n ih => by { rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; positivity } );
    · exact ne_of_gt ( Nat.recOn k ( by decide ) fun n ih => by { rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; positivity } );
    · exact Nat.sub_ne_zero_of_lt ( by linarith [ show pellNumber ( k + 2 ) > pellNumber ( k + 1 ) from by exact strictMono_nat_of_lt_succ ( fun n => by { exact Nat.recOn n ( by trivial ) fun n ihn => by { simp +decide [ *, pellNumber ] ; linarith } } ) ( Nat.lt_succ_self _ ) ] );
  · -- If $n$ is odd, then $P_n$ is odd.
    have h_odd : Odd (pellNumber (2 * k + 1)) := by
      exact pell_odd_iff_odd _ |>.2 ( by norm_num );
    simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ]

/-
For n > 1, P_n divides P_m if and only if n divides m.
-/
theorem pellNumber_dvd_iff (n m : ℕ) (h : n > 1) : pellNumber n ∣ pellNumber m ↔ n ∣ m := by
  by_contra hn_not_div_m;
  have h_contra : pellNumber (Nat.gcd n m) = pellNumber n := by
    have h_gcd : Nat.gcd (pellNumber n) (pellNumber m) = pellNumber (Nat.gcd n m) := by
      exact?;
    by_cases h_div : n ∣ m <;> simp_all +decide [ Nat.gcd_eq_left_iff_dvd ];
    · rw [ Nat.gcd_eq_left h_div ];
    · rw [ ← h_gcd, Nat.gcd_eq_left hn_not_div_m ];
  -- Since Pell numbers are strictly increasing, we have Nat.gcd n m = n.
  have h_gcd_eq_n : Nat.gcd n m = n := by
    apply StrictMono.injective pellNumber_strictMono h_contra;
  exact hn_not_div_m <| iff_of_true ( pellNumber_dvd_pellNumber <| h_gcd_eq_n ▸ Nat.gcd_dvd_right _ _ ) ( h_gcd_eq_n ▸ Nat.gcd_dvd_right _ _ )

/-
If p is odd, q is an odd prime, and p is congruent to 1 or -1 modulo q, then p is congruent to 1 or -1 modulo 2q.
-/
lemma odd_prime_mod_congruence (p q : ℕ) (hp_odd : Odd p) (hq : q.Prime) (hq_odd : q ≠ 2)
  (h : (p : ℤ) ≡ 1 [ZMOD q] ∨ (p : ℤ) ≡ -1 [ZMOD q]) :
  (p : ℤ) ≡ 1 [ZMOD (2 * q : ℤ)] ∨ (p : ℤ) ≡ -1 [ZMOD (2 * q : ℤ)] := by
    obtain h | h := h;
    · -- Since $q$ is an odd prime, $2q$ is also odd.
      -- Therefore, $p \equiv 1 \pmod{2q}$ implies $p \equiv 1 \pmod{q}$.
      have h_mod_q : (p : ℤ) ≡ 1 [ZMOD 2] := by
        exact Int.natCast_modEq_iff.mpr ( Nat.odd_iff.mp hp_odd );
      rw [ ← Int.modEq_and_modEq_iff_modEq_mul ] ; tauto;
      exact Nat.prime_two.coprime_iff_not_dvd.mpr fun h => hq_odd <| by have := Nat.prime_dvd_prime_iff_eq Nat.prime_two hq; tauto;
    · obtain ⟨ k, hk ⟩ := h.symm.dvd;
      rcases Int.even_or_odd' k with ⟨ k, rfl | rfl ⟩;
      · exact Or.inr <| Int.modEq_iff_dvd.mpr ⟨ -k, by linarith ⟩;
      · obtain ⟨ m, hm ⟩ := hp_odd; replace hk := congr_arg Even hk; simp_all +decide [ parity_simps ] ;
        exact absurd ( hq.even_iff.mp hk ) hq_odd

/-
If q is an odd prime and p is a prime divisor of P_q, then p is congruent to 1 or -1 modulo 2q.
-/
theorem prime_divisor_of_pell_prime_index (q : ℕ) (hq : q.Prime) (hq_odd : q ≠ 2) (p : ℕ) (hp : p.Prime) (h_dvd : p ∣ pellNumber q) :
    (p : ℤ) ≡ 1 [ZMOD (2 * q : ℤ)] ∨ (p : ℤ) ≡ -1 [ZMOD (2 * q : ℤ)] := by
      by_cases hp_eq_two : p = 2 <;> simp_all +decide [ Nat.prime_dvd_prime_iff_eq ];
      · rcases Nat.even_or_odd' q with ⟨ k, rfl | rfl ⟩ <;> simp_all +decide [ Nat.prime_mul_iff ];
        exact absurd h_dvd ( by rw [ ← even_iff_two_dvd ] ; exact Nat.recOn k ( by decide ) fun n ih => by erw [ show pellNumber ( 2 * ( n + 1 ) + 1 ) = 2 * pellNumber ( 2 * n + 2 ) + pellNumber ( 2 * n + 1 ) from rfl ] ; simp_all +decide [ parity_simps ] );
      · -- By definition of $z(p)$, we know that $z(p) \mid q$.
        have hz_div_q : rankOfAppearance p hp ∣ q := by
          exact?;
        -- Since $p$ is an odd prime, we know that $z(p) = 1$ or $z(p) = q$.
        have hz_cases : rankOfAppearance p hp = 1 ∨ rankOfAppearance p hp = q := by
          rwa [ Nat.dvd_prime hq ] at hz_div_q;
        -- If $z(p) = q$, then by the theorem about the rank of appearance, $p$ must divide $P_q$. But since $p$ is a prime divisor of $P_q$, and $q$ is an odd prime, we can use the properties of the Pell sequence to show that $p$ must be congruent to $\pm 1$ modulo $2q$.
        by_cases hz_q : rankOfAppearance p hp = q;
        · -- By the theorem about the rank of appearance, $p$ must divide $P_q$. But since $p$ is a prime divisor of $P_q$, and $q$ is an odd prime, we can use the properties of the Pell sequence to show that $p$ must be congruent to $\pm 1$ modulo $2q$.
          have h_cong : (p : ℤ) ≡ 1 [ZMOD q] ∨ (p : ℤ) ≡ -1 [ZMOD q] := by
            have h_cong : (p : ℤ) ∣ (pellNumber (p - 1) : ℤ) ∨ (p : ℤ) ∣ (pellNumber (p + 1) : ℤ) := by
              haveI := Fact.mk hp; norm_num [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
              by_cases h_legendre : legendreSym p 2 = 1 ∨ legendreSym p 2 = -1;
              · cases h_legendre <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
                · exact Or.inl <| by simpa [ ← ZMod.natCast_eq_zero_iff ] using pell_dvd_of_legendre_one p ‹_›;
                · exact Or.inr ( by simpa [ ← ZMod.natCast_eq_zero_iff ] using pell_dvd_of_legendre_neg_one p ‹_› );
              · simp_all +decide [ legendreSym ];
                simp_all +decide [ quadraticCharFun ];
                split_ifs at h_legendre <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
                rcases p with ( _ | _ | _ | p ) <;> cases ‹_› <;> trivial;
            have h_cong : q ∣ p - 1 ∨ q ∣ p + 1 := by
              have h_cong : ∀ m, p ∣ pellNumber m → q ∣ m := by
                intros m hm; exact hz_q ▸ rank_dvd_iff_dvd_pell p hp m |>.2 hm;
              norm_cast at * ; aesop;
            rcases h_cong with ( h | h ) <;> obtain ⟨ k, hk ⟩ := h <;> rw [ Int.modEq_iff_dvd ];
            · exact Or.inl ⟨ -k, by linarith [ Nat.sub_add_cancel hp.pos ] ⟩;
            · exact Or.inr <| Int.modEq_iff_dvd.mpr ⟨ -k, by linarith ⟩;
          convert odd_prime_mod_congruence p q ( Nat.Prime.odd_of_ne_two hp hp_eq_two ) hq ( by simpa using hq_odd ) h_cong using 1;
        · -- If $z(p) = 1$, then $p$ divides $P_1$, which is $1$. But $p$ is a prime greater than $1$, so this is impossible.
          have h_contra : p ∣ pellNumber 1 := by
            have := rank_dvd_iff_dvd_pell p hp 1; aesop;
          exact absurd h_contra ( Nat.Prime.not_dvd_one hp )

/-
If q is an odd prime and p is a prime divisor of P_q, then p is congruent to 1 or -1 modulo q.
-/
lemma prime_divisor_mod_q (q : ℕ) (hq : q.Prime) (hq_odd : q ≠ 2) (p : ℕ) (hp : p.Prime) (h_dvd : p ∣ pellNumber q) :
    (p : ℤ) ≡ 1 [ZMOD q] ∨ (p : ℤ) ≡ -1 [ZMOD q] := by
      -- By the previous result, p ≡ 1 or -1 (mod 2q).
      have h_mod_2q : (p : ℤ) ≡ 1 [ZMOD (2 * q : ℤ)] ∨ (p : ℤ) ≡ -1 [ZMOD (2 * q : ℤ)] := by
        apply prime_divisor_of_pell_prime_index q hq hq_odd p hp h_dvd;
      exact Or.imp ( fun h => h.of_dvd <| dvd_mul_left _ _ ) ( fun h => h.of_dvd <| dvd_mul_left _ _ ) h_mod_2q

/-
If q is an odd prime and p is a prime divisor of P_q, then p is congruent to 1 or -1 modulo 2q.
-/
theorem prime_divisor_of_pell_prime_index' (q : ℕ) (hq : q.Prime) (hq_odd : q ≠ 2) (p : ℕ) (hp : p.Prime) (h_dvd : p ∣ pellNumber q) :
    (p : ℤ) ≡ 1 [ZMOD (2 * q : ℤ)] ∨ (p : ℤ) ≡ -1 [ZMOD (2 * q : ℤ)] := by
      convert prime_divisor_of_pell_prime_index q hq hq_odd p hp h_dvd using 1

/-
Definition of Pell-Lucas numbers and their relation to Pell numbers: Q_n = P_{n-1} + P_{n+1} for n >= 1.
-/
def pellLucasNumber : ℕ → ℕ
  | 0 => 2
  | 1 => 2
  | (n + 2) => 2 * pellLucasNumber (n + 1) + pellLucasNumber n

theorem pellLucas_eq_pell_add (n : ℕ) (h : n ≥ 1) : pellLucasNumber n = pellNumber (n - 1) + pellNumber (n + 1) := by
  rcases n with ( _ | _ | n ) <;> norm_num [ pellNumber, pellLucasNumber ] at *;
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber, pellLucasNumber ];
  have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ pellNumber, pellLucasNumber ] at * ; linarith

/-
Identity relating Pell and Pell-Lucas numbers: Q_n^2 - 8P_n^2 = 4(-1)^n.
-/
theorem pell_lucas_sq_sub_eight_pell_sq (n : ℕ) : (pellLucasNumber n : ℤ) ^ 2 - 8 * (pellNumber n : ℤ) ^ 2 = 4 * (-1) ^ n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> norm_num [ ih, pellLucasNumber, pellNumber ] at *;
  have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ; norm_num [ pow_succ, pellLucasNumber, pellNumber ] at * ; linarith;

/-
Relation between the fundamental unit of Z[sqrt(2)] and Pell/Pell-Lucas numbers: (1+sqrt(2))^n = Q_n/2 + P_n*sqrt(2).
-/
theorem pell_fundamental_unit_pow (n : ℕ) : (1 + Real.sqrt 2) ^ n = (pellLucasNumber n : ℝ) / 2 + (pellNumber n : ℝ) * Real.sqrt 2 := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | n ) <;> norm_num at *;
  · norm_num [ pellLucasNumber ];
  · norm_num [ pellLucasNumber, pellNumber ];
  · convert congr_arg ( · * ( 1 + Real.sqrt 2 ) ) ( ih _ <| Nat.lt_succ_self _ ) using 1 ; ring;
    rw [ show 2 + n = 1 + n + 1 by ring, show 1 + n = n + 1 by ring ] ; norm_num [ pow_succ, pellLucasNumber, pellNumber ] ; ring;
    grind

/-
Pell numbers grow at least as fast as their indices: P_n >= n for all n.
-/
theorem pell_ge_n (n : ℕ) : pellNumber n ≥ n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> simp +arith +decide [ *, pellNumber ];
  linarith [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ]

/-
Pell numbers grow strictly faster than their indices for n > 2: P_n > n.
-/
theorem pell_gt_n (n : ℕ) (h : n > 2) : pellNumber n > n := by
  induction' h with n hn;
  · decide;
  · rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ];
    omega

/-
For any odd prime p, p does not divide P_p.
-/
theorem pell_not_dvd_self_prime (p : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) : ¬ p ∣ pellNumber p := by
  -- Assume $p$ is a prime factor of $P_p$, then $p$ must be congruent to $1$ or $-1$ modulo $q$.
  by_contra h_contra
  have h_congr : (p : ℤ) ≡ 1 [ZMOD (2 * p : ℤ)] ∨ (p : ℤ) ≡ -1 [ZMOD (2 * p : ℤ)] := by
    apply prime_divisor_of_pell_prime_index' p hp hp_odd p hp h_contra;
  rcases h_congr with h | h <;> rw [ Int.ModEq ] at h;
  · rw [ Int.emod_eq_of_lt, Int.emod_eq_of_lt ] at h <;> linarith [ hp.two_le ];
  · norm_num [ Int.emod_eq_emod_iff_emod_sub_eq_zero ] at h;
    linarith [ Int.le_of_dvd ( by linarith [ hp.pos ] ) h, hp.two_le ]

/-
Expansion of P_{np} in terms of P_n and H_n = P_{n-1} + P_n.
-/
def pellHalfLucas (n : ℕ) : ℕ := pellNumber (n - 1) + pellNumber n

theorem pell_expansion (n p : ℕ) (hp : Odd p) :
    pellNumber (n * p) = ∑ k ∈ Finset.range ((p + 1) / 2), Nat.choose p (2 * k + 1) * (pellHalfLucas n) ^ (p - (2 * k + 1)) * (pellNumber n) ^ (2 * k + 1) * 2 ^ k := by
      -- Using the identity $P_{np} = \frac{\alpha^{np} - \beta^{np}}{2\sqrt{2}}$, we can expand $\alpha^{np}$ and $\beta^{np}$.
      have h_expand : (pellNumber (n * p) : ℝ) = ((1 + Real.sqrt 2) ^ (n * p) - (1 - Real.sqrt 2) ^ (n * p)) / (2 * Real.sqrt 2) := by
        induction' n * p using Nat.strong_induction_on with n ih;
        rcases n with ( _ | _ | n ) <;> norm_num [ pellNumber ];
        · ring_nf; norm_num;
        · rw [ ih _ <| Nat.lt_succ_self _, ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _ ] ; repeat ring <;> norm_num [ pow_succ' ];
      -- Using the identity $P_{np} = \frac{\alpha^{np} - \beta^{np}}{2\sqrt{2}}$, we can expand $\alpha^{np}$ and $\beta^{np}$ using the binomial theorem.
      have h_binom : ((1 + Real.sqrt 2) ^ (n * p) - (1 - Real.sqrt 2) ^ (n * p)) / (2 * Real.sqrt 2) = ∑ k ∈ Finset.range ((p + 1) / 2), Nat.choose p (2 * k + 1) * ((pellLucasNumber n : ℝ) / 2) ^ (p - (2 * k + 1)) * (pellNumber n : ℝ) ^ (2 * k + 1) * 2 ^ k := by
        -- Using the identity $P_{np} = \frac{\alpha^{np} - \beta^{np}}{2\sqrt{2}}$, we can expand $\alpha^{np}$ and $\beta^{np}$ using the binomial theorem and the definitions of $H_n$ and $P_n$.
        have h_binom : ((1 + Real.sqrt 2) ^ (n * p) - (1 - Real.sqrt 2) ^ (n * p)) / (2 * Real.sqrt 2) = (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (pellNumber n * Real.sqrt 2) ^ k) / (2 * Real.sqrt 2) - (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (-pellNumber n * Real.sqrt 2) ^ k) / (2 * Real.sqrt 2) := by
          have h_binom : ((1 + Real.sqrt 2) ^ (n * p) - (1 - Real.sqrt 2) ^ (n * p)) = (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (pellNumber n * Real.sqrt 2) ^ k) - (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (-pellNumber n * Real.sqrt 2) ^ k) := by
            have h_binom : ((1 + Real.sqrt 2) ^ (n * p) - (1 - Real.sqrt 2) ^ (n * p)) = (((pellLucasNumber n : ℝ) / 2) + (pellNumber n : ℝ) * Real.sqrt 2) ^ p - (((pellLucasNumber n : ℝ) / 2) - (pellNumber n : ℝ) * Real.sqrt 2) ^ p := by
              have h_binom : ((1 + Real.sqrt 2) ^ n - (1 - Real.sqrt 2) ^ n) = 2 * Real.sqrt 2 * pellNumber n := by
                have h_binom : ∀ n, (1 + Real.sqrt 2) ^ n - (1 - Real.sqrt 2) ^ n = 2 * Real.sqrt 2 * pellNumber n := by
                  intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> norm_num [ pow_succ' ] at *;
                  · rw [ show pellNumber 1 = 1 by rfl ] ; ring;
                  · have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ pow_succ', pellNumber ] at * ; ring_nf at * ; norm_num at * ; linarith;
                apply h_binom;
              have h_binom : ((1 + Real.sqrt 2) ^ n + (1 - Real.sqrt 2) ^ n) = pellLucasNumber n := by
                clear h_expand h_binom hp;
                induction' n using Nat.strong_induction_on with n ih;
                rcases n with ( _ | _ | n ) <;> norm_num [ pellLucasNumber ];
                grind;
              rw [ ← h_binom ] ; ring;
              rw [ show ( - ( Real.sqrt 2 * pellNumber n ) + ( 1 - Real.sqrt 2 ) ^ n * ( 1 / 2 ) + ( 1 + Real.sqrt 2 ) ^ n * ( 1 / 2 ) ) = ( 1 - Real.sqrt 2 ) ^ n by linarith, show ( Real.sqrt 2 * pellNumber n + ( 1 - Real.sqrt 2 ) ^ n * ( 1 / 2 ) + ( 1 + Real.sqrt 2 ) ^ n * ( 1 / 2 ) ) = ( 1 + Real.sqrt 2 ) ^ n by linarith ] ; ring;
            exact h_binom.trans ( congrArg₂ _ ( by rw [ add_comm, add_pow ] ; congr; ext; ring ) ( by rw [ sub_eq_add_neg, add_comm, add_pow ] ; congr; ext; ring ) );
          rw [ h_binom, sub_div ];
        -- Combine like terms in the binomial expansion.
        have h_combine : (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (pellNumber n * Real.sqrt 2) ^ k) / (2 * Real.sqrt 2) - (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (-pellNumber n * Real.sqrt 2) ^ k) / (2 * Real.sqrt 2) = ∑ k ∈ Finset.filter (fun k => k % 2 = 1) (Finset.range (p + 1)), Nat.choose p k * ((pellLucasNumber n : ℝ) / 2) ^ (p - k) * (pellNumber n * Real.sqrt 2) ^ k / Real.sqrt 2 := by
          rw [ ← sub_div, Finset.sum_filter ];
          rw [ ← Finset.sum_sub_distrib, Finset.sum_div ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rcases Nat.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
        -- Notice that Finset.range (p + 1) with k % 2 = 1 is equivalent to Finset.image (fun k => 2 * k + 1) (Finset.range ((p + 1) / 2)).
        have h_filter : Finset.filter (fun k => k % 2 = 1) (Finset.range (p + 1)) = Finset.image (fun k => 2 * k + 1) (Finset.range ((p + 1) / 2)) := by
          ext ( _ | k ) <;> simp +arith +decide [ Nat.add_mod, Nat.mul_mod ];
          exact ⟨ fun h => ⟨ k / 2, by omega, by omega ⟩, fun ⟨ a, ha, ha' ⟩ => ⟨ by omega, by omega ⟩ ⟩;
        simp_all +decide [ Finset.sum_image ];
        norm_num [ pow_add, pow_mul, mul_pow ] ; ring_nf ; norm_num;
        ac_rfl;
      -- Recognize that $pellLucasNumber n = 2 * pellHalfLucas n$ for $n \geq 1$.
      have h_pellLucas_eq : ∀ n ≥ 1, pellLucasNumber n = 2 * pellHalfLucas n := by
        intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.mul_succ, pellLucasNumber ] ;
        rcases n with ( _ | _ | n ) <;> simp +arith +decide [ *, pellHalfLucas ];
        rw [ show pellNumber ( n + 4 ) = 2 * pellNumber ( n + 3 ) + pellNumber ( n + 2 ) by rfl, show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) by rfl ] ; ring;
      rcases n with ( _ | n ) <;> simp_all +decide [ mul_pow ];
      · norm_num [ pellNumber ];
      · exact_mod_cast h_expand

/-
If an odd prime p divides P_n, then p does not divide Q_n.
-/
theorem pellLucas_not_dvd_prime (n p : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) (h_dvd : p ∣ pellNumber n) : ¬ p ∣ pellLucasNumber n := by
  -- Assume for contradiction that $p \mid P_n$ and $p \mid Q_n$.
  by_contra h_contra
  obtain ⟨k, hk⟩ := h_dvd
  obtain ⟨m, hm⟩ : ∃ m, pellLucasNumber n = p * m := by
    exact h_contra;
  -- Substitute $P_n = p \cdot k$ and $Q_n = p \cdot m$ into the identity $Q_n^2 - 8P_n^2 = 4(-1)^n$.
  have h_sub : (p * m : ℤ)^2 - 8 * (p * k : ℤ)^2 = 4 * (-1 : ℤ)^n := by
    convert pell_lucas_sq_sub_eight_pell_sq n using 1 ; push_cast [ ← @Nat.cast_inj ℤ, hm, hk ] ; ring;
  replace h_sub := congr_arg ( ( ↑ ) : ℤ → ZMod p ) h_sub ; haveI := Fact.mk hp ; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
  rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h_sub <;> contradiction

/-
The k-th term in the expansion of P_{np}.
-/
def pell_term (n p k : ℕ) : ℕ := Nat.choose p (2 * k + 1) * (pellHalfLucas n) ^ (p - (2 * k + 1)) * (pellNumber n) ^ (2 * k + 1) * 2 ^ k

/-
The 0-th term in the expansion of P_{np} is p * P_n * H_n^{p-1}.
-/
theorem pell_term_zero (n p : ℕ) : pell_term n p 0 = p * pellNumber n * (pellHalfLucas n) ^ (p - 1) := by
  unfold pell_term pellHalfLucas;
  norm_num [ mul_assoc, mul_comm, mul_left_comm ]

/-
For n >= 1, k >= 1, the p-adic valuation of the k-th term in the expansion is strictly greater than the valuation of the 0-th term.
-/
theorem pell_term_valuation_gt (n p k : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) (h_dvd : p ∣ pellNumber n) (hn : n ≥ 1) (hk : k ≥ 1) (hk_bound : 2 * k + 1 ≤ p) :
    Nat.factorization (pell_term n p k) p > Nat.factorization (pell_term n p 0) p := by
      -- The p-adic valuation of the k-th term is $v_p(\binom{p}{2k+1}) + (2k+1)v_p(P_n) + (p-(2k+1))v_p(H_n) + kv_p(2)$.
      have h_val_k : Nat.factorization (pell_term n p k) p = Nat.factorization (Nat.choose p (2 * k + 1)) p + (2 * k + 1) * Nat.factorization (pellNumber n) p + (p - (2 * k + 1)) * Nat.factorization (pellHalfLucas n) p + k * Nat.factorization 2 p := by
        unfold pell_term;
        rw [ Nat.factorization_mul, Nat.factorization_mul, Nat.factorization_mul ] <;> simp_all +decide [ Nat.Prime.ne_zero ];
        any_goals linarith [ Nat.choose_pos hk_bound ];
        · exact fun h => absurd h <| ne_of_gt <| add_pos_of_nonneg_of_pos ( Nat.zero_le _ ) <| Nat.pos_of_ne_zero <| by { exact ne_of_gt <| Nat.le_induction ( by decide ) ( fun m hm ih => by { rw [ show pellNumber ( m + 1 ) = 2 * pellNumber m + pellNumber ( m - 1 ) from by { cases m <;> trivial } ] ; positivity } ) _ hn } ;
        · exact ⟨ Nat.ne_of_gt <| Nat.choose_pos <| by linarith, fun h => absurd h <| by exact ne_of_gt <| add_pos_of_nonneg_of_pos ( Nat.zero_le _ ) <| Nat.pos_of_ne_zero <| by { exact fun h' => by have := pell_gt_n n ( show n > 2 from not_le.mp fun contra => by interval_cases n <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ) ; aesop } ⟩;
        · exact ne_of_gt <| Nat.le_induction ( by decide ) ( fun n hn ih => by { rw [ show pellNumber ( n + 1 ) = 2 * pellNumber n + pellNumber ( n - 1 ) from by cases n <;> trivial ] ; linarith } ) n hn;
        · exact ⟨ ⟨ Nat.ne_of_gt <| Nat.choose_pos <| by linarith, fun h => absurd h <| ne_of_gt <| add_pos_of_nonneg_of_pos ( Nat.zero_le _ ) <| Nat.pos_of_ne_zero <| by rintro h'; have := pellNumber_strictMono <| show n > 0 from hn; aesop ⟩, Nat.ne_of_gt <| Nat.pos_of_ne_zero <| by rintro h'; have := pellNumber_strictMono <| show n > 0 from hn; aesop ⟩;
      -- The p-adic valuation of the 0-th term is $v_p(p) + v_p(P_n) + (p-1)v_p(H_n)$.
      have h_val_0 : Nat.factorization (pell_term n p 0) p = 1 + Nat.factorization (pellNumber n) p + (p - 1) * Nat.factorization (pellHalfLucas n) p := by
        rw [ pell_term_zero, Nat.factorization_mul ] <;> norm_num [ hp.ne_zero ];
        · rw [ Nat.factorization_mul ] <;> norm_num [ hp.ne_zero ];
          · norm_num [ hp ];
          · exact ne_of_gt <| Nat.le_induction ( by decide ) ( fun n hn ih => by { rw [ show pellNumber ( n + 1 ) = 2 * pellNumber n + pellNumber ( n - 1 ) from by cases n <;> trivial ] ; linarith } ) n hn;
        · exact ne_of_gt <| Nat.le_induction ( by decide ) ( fun n hn ih => by { rw [ show pellNumber ( n + 1 ) = 2 * pellNumber n + pellNumber ( n - 1 ) from by cases n <;> trivial ] ; linarith } ) n hn;
        · intro h; simp_all +decide [ pellHalfLucas ] ;
          exact absurd h.2 ( ne_of_gt ( Nat.le_induction ( by decide ) ( fun m hm ih => by { rw [ show pellNumber ( m + 1 ) = 2 * pellNumber m + pellNumber ( m - 1 ) from by rcases m with ( _ | _ | m ) <;> trivial ] ; linarith } ) n hn ) );
      -- Since $p$ is odd and $p \mid P_n$, we have $v_p(H_n) = 0$.
      have h_val_H : Nat.factorization (pellHalfLucas n) p = 0 := by
        have h_val_H : ¬(p ∣ pellLucasNumber n) := by
          exact?;
        rw [ Nat.factorization_eq_zero_of_not_dvd ] ; simp_all +decide [ pellLucas_eq_pell_add ] ;
        unfold pellHalfLucas; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.dvd_add_right ] ;
        · exact absurd h_dvd ( by erw [ show pellNumber 1 = 1 from rfl ] ; exact Nat.Prime.not_dvd_one hp );
        · intro h; haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, pellNumber ] ;
      rcases p with ( _ | _ | _ | p ) <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ];
      nlinarith [ show 0 < Nat.factorization ( pellNumber n ) ( p + 1 + 1 + 1 ) from Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp <| by { exact Nat.mem_primeFactors.mpr ⟨ hp, h_dvd, by { exact Nat.ne_of_gt <| Nat.le_induction ( by decide ) ( fun n hn ih ↦ by { rw [ show pellNumber ( n + 1 ) = 2 * pellNumber n + pellNumber ( n - 1 ) from by cases n <;> trivial ] ; linarith } ) _ hn } ⟩ } ) ]

/-
Q_n = 2 * H_n for n >= 1.
-/
theorem pellLucas_eq_two_mul_pellHalfLucas (n : ℕ) (h : n ≥ 1) : pellLucasNumber n = 2 * pellHalfLucas n := by
  rw [ show pellLucasNumber n = pellNumber ( n - 1 ) + pellNumber ( n + 1 ) from ?_, show pellHalfLucas n = pellNumber ( n - 1 ) + pellNumber n from ?_ ];
  · cases n <;> simp_all +arith +decide [ pellNumber ];
  · rfl;
  · exact?

/-
Law of Repetition for Pell numbers: if p is an odd prime dividing P_n (n != 0), then v_p(P_{np}) = v_p(P_n) + 1.
-/
theorem pell_valuation_mul_prime (p n : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) (hn : n ≠ 0) (h_dvd : p ∣ pellNumber n) :
    Nat.factorization (pellNumber (n * p)) p = Nat.factorization (pellNumber n) p + 1 := by
      -- By definition of $pell_term$, we know that $pellNumber (n * p) = \sum_{k=0}^{(p+1)/2} pell_term n p k$.
      have h_sum : pellNumber (n * p) = ∑ k ∈ Finset.range ((p + 1) / 2), pell_term n p k := by
        convert pell_expansion n p ( Nat.Prime.odd_of_ne_two hp hp_odd ) using 1;
      -- Since p divides P_n, the first term in the sum, p * P_n * H_n^{p-1}, is divisible by p but not by p^2.
      have h_first_term : Nat.factorization (pell_term n p 0) p = Nat.factorization (pellNumber n) p + 1 := by
        rw [ pell_term_zero ];
        rw [ Nat.factorization_mul, Nat.factorization_mul ] <;> simp +decide [ hp.ne_zero, hp_odd, hn, h_dvd ];
        · simp +decide [ hp.factorization, add_comm, add_left_comm, add_assoc ];
          refine Or.inr <| Nat.factorization_eq_zero_of_not_dvd ?_;
          have h_not_div : ¬ p ∣ pellLucasNumber n := by
            exact?;
          exact fun h => h_not_div <| dvd_trans h <| by rw [ pellLucas_eq_two_mul_pellHalfLucas n ( Nat.pos_of_ne_zero hn ) ] ; exact dvd_mul_left _ _;
        · exact ne_of_gt <| Nat.le_induction ( by decide ) ( fun k hk ih => by { rw [ show pellNumber ( k + 1 ) = 2 * pellNumber k + pellNumber ( k - 1 ) from by cases k <;> trivial ] ; linarith } ) n <| Nat.pos_of_ne_zero hn;
        · intro h; have := pell_ge_n n; aesop;
        · -- Since $pellNumber$ is strictly increasing and $pellNumber 0 = 0$, $pellNumber n$ is positive for all $n \geq 1$.
          have h_pell_pos : ∀ n ≥ 1, 0 < pellNumber n := by
            exact fun n hn => Nat.le_induction ( by decide ) ( fun k hk ih => by { rw [ show pellNumber ( k + 1 ) = 2 * pellNumber k + pellNumber ( k - 1 ) from by cases k <;> trivial ] ; positivity } ) n hn;
          exact fun h => absurd h ( ne_of_gt ( add_pos_of_nonneg_of_pos ( Nat.zero_le _ ) ( h_pell_pos _ ( Nat.pos_of_ne_zero hn ) ) ) );
      -- For any $k \geq 1$, the p-adic valuation of the k-th term is strictly greater than the p-adic valuation of the first term.
      have h_term_valuation_gt : ∀ k ∈ Finset.range ((p + 1) / 2) \ {0}, Nat.factorization (pell_term n p k) p > Nat.factorization (pell_term n p 0) p := by
        intros k hk
        apply pell_term_valuation_gt n p k hp hp_odd h_dvd (Nat.pos_of_ne_zero hn) (Nat.pos_of_ne_zero (by
        aesop)) (by
        linarith [ Finset.mem_range.mp ( Finset.mem_sdiff.mp hk |>.1 ), Nat.div_mul_le_self ( p + 1 ) 2 ]);
      -- Therefore, the sum $\sum_{k=0}^{(p+1)/2} pell_term n p k$ is divisible by $p^{v_p(pell_term n p 0)}$ but not by $p^{v_p(pell_term n p 0) + 1}$.
      have h_sum_div : p ^ (Nat.factorization (pell_term n p 0) p) ∣ ∑ k ∈ Finset.range ((p + 1) / 2), pell_term n p k ∧ ¬(p ^ (Nat.factorization (pell_term n p 0) p + 1) ∣ ∑ k ∈ Finset.range ((p + 1) / 2), pell_term n p k) := by
        have h_sum_div : p ^ (Nat.factorization (pell_term n p 0) p) ∣ ∑ k ∈ Finset.range ((p + 1) / 2), pell_term n p k ∧ ¬(p ^ (Nat.factorization (pell_term n p 0) p + 1) ∣ pell_term n p 0) := by
          refine' ⟨ _, _ ⟩;
          · exact Finset.dvd_sum fun k hk => Nat.dvd_trans ( pow_dvd_pow _ <| if hk0 : k = 0 then by aesop else le_of_lt <| h_term_valuation_gt k <| by aesop ) <| Nat.ordProj_dvd _ _;
          · rw [ Nat.Prime.pow_dvd_iff_le_factorization ] <;> aesop;
        refine ⟨ h_sum_div.1, fun h => h_sum_div.2 <| ?_ ⟩;
        convert Nat.dvd_sub' h ( show p ^ ( Nat.factorization ( pell_term n p 0 ) p + 1 ) ∣ ∑ k ∈ Finset.range ( ( p + 1 ) / 2 ) \ { 0 }, pell_term n p k from Finset.dvd_sum fun k hk => Nat.dvd_trans ( pow_dvd_pow _ <| Nat.succ_le_of_lt <| h_term_valuation_gt k hk ) <| Nat.ordProj_dvd _ _ ) using 1;
        rw [ Finset.sum_eq_add_sum_diff_singleton <| Finset.mem_range.mpr <| Nat.div_pos ( by linarith [ hp.two_le ] ) zero_lt_two ] ; aesop;
      simp_all +decide [ ← h_sum ];
      exact le_antisymm ( Nat.le_of_not_lt fun h => h_sum_div.2 <| dvd_trans ( pow_dvd_pow _ h ) <| Nat.ordProj_dvd _ _ ) ( Nat.le_of_not_lt fun h => by exact absurd ( Nat.dvd_trans ( pow_dvd_pow _ h ) h_sum_div.1 ) <| Nat.pow_succ_factorization_not_dvd ( by aesop ) <| by aesop )

/-
Law of Repetition for Pell numbers: if p is an odd prime dividing P_n (n != 0), then v_p(P_{np}) = v_p(P_n) + 1.
-/
theorem pell_valuation_mul_prime' (p n : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) (hn : n ≠ 0) (h_dvd : p ∣ pellNumber n) :
    Nat.factorization (pellNumber (n * p)) p = Nat.factorization (pellNumber n) p + 1 := by
      convert pell_valuation_mul_prime p n hp hp_odd hn h_dvd using 1

/-
If the p-adic valuation of one term in a sum is strictly smaller than the valuation of all other terms, then the valuation of the sum is equal to the valuation of that term.
-/
lemma valuation_of_sum_eq_valuation_of_first {ι : Type*} {s : Finset ι} {f : ι → ℕ} {p : ℕ} (hp : p.Prime) (i₀ : ι) (hi₀ : i₀ ∈ s)
    (h_min : ∀ i ∈ s, i ≠ i₀ → Nat.factorization (f i) p > Nat.factorization (f i₀) p)
    (h_nonzero : f i₀ ≠ 0) :
    Nat.factorization (∑ i ∈ s, f i) p = Nat.factorization (f i₀) p := by
      -- Let $m = \text{Nat.factorization} (f i₀) p$.
      set m := Nat.factorization (f i₀) p with hm;
      -- Then $p^m \mid f i₀$ but $p^{m+1} \nmid f i₀$, and for all $i \neq i₀$, $p^{m+1} \mid f i$.
      have h_div : p^m ∣ f i₀ ∧ ¬p^(m+1) ∣ f i₀ ∧ ∀ i ∈ s, i ≠ i₀ → p^(m+1) ∣ f i := by
        exact ⟨ Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd h_nonzero hp, fun i hi hi' => Nat.dvd_trans ( pow_dvd_pow _ ( Nat.succ_le_of_lt ( h_min i hi hi' ) ) ) ( Nat.ordProj_dvd _ _ ) ⟩;
      -- Therefore, $p^m \mid \sum_{i \in s} f i$ but $p^{m+1} \nmid \sum_{i \in s} f i$.
      have h_sum_div : p^m ∣ ∑ i ∈ s, f i ∧ ¬p^(m+1) ∣ ∑ i ∈ s, f i := by
        have h_sum_div : p^m ∣ ∑ i ∈ s, f i ∧ ¬p^(m+1) ∣ ∑ i ∈ s.erase i₀, f i + f i₀ := by
          refine' ⟨ _, _ ⟩;
          · exact Finset.dvd_sum fun i hi => if hi' : i = i₀ then hi'.symm ▸ h_div.1 else dvd_trans ( pow_dvd_pow _ ( Nat.le_succ _ ) ) ( h_div.2.2 i hi hi' );
          · rw [ Nat.dvd_add_right ( Finset.dvd_sum fun i hi => h_div.2.2 i ( Finset.mem_of_mem_erase hi ) ( Finset.ne_of_mem_erase hi ) ) ] ; aesop;
        simpa only [ ← Finset.sum_erase_add _ _ hi₀ ] using h_sum_div;
      exact le_antisymm ( Nat.le_of_not_lt fun h => h_sum_div.2 <| dvd_trans ( pow_dvd_pow _ h ) <| Nat.ordProj_dvd _ _ ) ( Nat.le_of_not_lt fun h => by exact absurd ( Nat.dvd_trans ( pow_dvd_pow _ h ) h_sum_div.1 ) <| Nat.pow_succ_factorization_not_dvd ( ne_of_gt <| Nat.pos_of_ne_zero <| by aesop ) hp )

/-
For any k, there exists a prime p whose rank of appearance in the Pell sequence is greater than k.
-/
theorem exists_prime_large_rank (k : ℕ) : ∃ p, ∃ (hp : Nat.Prime p), rankOfAppearance p hp > k := by
  -- By definition of $rankOfAppearance$, there exists a prime $p$ such that $rankOfAppearance p hp > k$.
  obtain ⟨p, hp_prime, hp_gt⟩ : ∃ p : ℕ, Nat.Prime p ∧ ¬∃ j ∈ Finset.Icc 1 k, p ∣ pellNumber j := by
    -- Since there are infinitely many primes, we can choose a prime $p$ greater than the product of all $P_j$ for $j \in \{1, \ldots, k\}$.
    obtain ⟨p, hp_prime, hp_gt⟩ : ∃ p : ℕ, Nat.Prime p ∧ p > ∏ j ∈ Finset.Icc 1 k, pellNumber j := by
      exact Exists.imp ( by tauto ) ( Nat.exists_infinite_primes ( ∏ j ∈ Finset.Icc 1 k, pellNumber j + 1 ) );
    refine' ⟨ p, hp_prime, fun ⟨ j, hj₁, hj₂ ⟩ => _ ⟩;
    exact hp_gt.not_le ( Nat.le_of_dvd ( Finset.prod_pos fun x hx => Nat.pos_of_ne_zero fun h => by have := pellNumber_strictMono ( show x > 0 from Finset.mem_Icc.mp hx |>.1 ) ; aesop ) ( dvd_trans hj₂ ( Finset.dvd_prod_of_mem _ hj₁ ) ) );
  use p, hp_prime;
  contrapose! hp_gt;
  exact ⟨ rankOfAppearance p hp_prime, Finset.mem_Icc.mpr ⟨ rankOfAppearance_pos p hp_prime, hp_gt ⟩, Nat.find_spec ( exists_pell_dvd p hp_prime ) |>.2 ⟩