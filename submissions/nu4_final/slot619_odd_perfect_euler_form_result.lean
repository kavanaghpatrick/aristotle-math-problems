/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2454ccf1-33a9-4458-bdaa-7b7902e2ef5b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves Euler's structural theorem for odd perfect numbers.
It defines the statement `odd_perfect_number_euler_form` which asserts that if `n` is an odd perfect number,
then `n` has the form `p^α * m^2` where `p` is a prime, `p ≡ 1 [ZMOD 4]`, `α ≡ 1 [ZMOD 4]`, and `p` is coprime to `m`.
The proof utilizes the properties of the sum of divisors function `σ` (sigma), specifically its multiplicativity and behavior modulo 4.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.Perfect
#check Nat.ModEq

/-
If n is an odd perfect number, then n = p^α · m² where p is prime, p ≡ 1 (mod 4), α ≡ 1 (mod 4), and gcd(p, m) = 1.
-/
theorem odd_perfect_number_euler_form (n : ℕ) (hn : Odd n) (hp : Nat.Perfect n) :
    ∃ (p m α : ℕ),
      p.Prime ∧
      p ≡ 1 [ZMOD 4] ∧
      α ≡ 1 [ZMOD 4] ∧
      p.Coprime m ∧
      n = p^α * m^2 := by
        have h_sigma : ∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) = 2 * n := by
          have h_sigma : ∑ d ∈ Nat.divisors n, d = ∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) := by
            have h_sigma : ∀ {m : ℕ}, m ≠ 0 → (∑ d ∈ Nat.divisors m, d) = (∏ p ∈ Nat.primeFactors m, (∑ i ∈ Finset.range (Nat.factorization m p + 1), p ^ i)) := by
              exact?;
            exact h_sigma hn.pos.ne';
          rw [ ← h_sigma, Nat.sum_divisors_eq_sum_properDivisors_add_self, hp.1, two_mul ];
        -- Let's choose any prime factor $p$ of $n$ such that the exponent of $p$ in the prime factorization of $n$ is odd.
        obtain ⟨p, hp_prime, hp_odd⟩ : ∃ p ∈ n.primeFactors, Odd (Nat.factorization n p) ∧ (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 2 := by
          -- Since $\sigma(n) = 2n$ and $n$ is odd, $\sigma(n)$ is even but not divisible by 4.
          have h_sigma_mod : (∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 2 := by
            grind;
          -- Since $\sigma(n) = 2n$ and $n$ is odd, $\sigma(n)$ is even but not divisible by 4. Therefore, there must be exactly one prime factor $p$ of $n$ such that $\sigma(p^{e_p}) \equiv 2 \pmod{4}$.
          obtain ⟨p, hp_prime, hp_mod⟩ : ∃ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 2 := by
            contrapose! h_sigma_mod;
            -- If for all prime factors $p$ of $n$, $\sigma(p^{e_p}) \not\equiv 2 \pmod{4}$, then $\sigma(p^{e_p}) \equiv 1 \pmod{4}$ or $\sigma(p^{e_p}) \equiv 3 \pmod{4}$.
            have h_sigma_mod_cases : ∀ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 1 ∨ (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 3 := by
              intro p hp; specialize h_sigma_mod p hp; have := Nat.mod_lt ( ∑ i ∈ Finset.range ( Nat.factorization n p + 1 ), p ^ i ) zero_lt_four; interval_cases _ : ( ∑ i ∈ Finset.range ( Nat.factorization n p + 1 ), p ^ i ) % 4 <;> simp_all +decide ;
              have := congr_arg ( · % 4 ) h_sigma; norm_num [ Finset.prod_eq_mul_prod_diff_singleton ( Nat.mem_primeFactors.mpr ⟨ hp.1, hp.2.1, hp.2.2 ⟩ ), Nat.mul_mod, ‹ ( ∑ i ∈ Finset.range ( Nat.factorization n p + 1 ), p ^ i ) % 4 = 0› ] at this;
              rw [ Nat.odd_iff ] at hn; rw [ ← Nat.mod_mod_of_dvd n ( by decide : 2 ∣ 4 ) ] at hn; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> contradiction;
            -- Since $\sigma(p^{e_p}) \equiv 1 \pmod{4}$ or $\sigma(p^{e_p}) \equiv 3 \pmod{4}$ for all prime factors $p$ of $n$, the product $\prod_{p \in n.primeFactors} \sigma(p^{e_p})$ is congruent to $1 \pmod{4}$ or $3 \pmod{4}$.
            have h_prod_mod_cases : (∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 1 ∨ (∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 3 := by
              have h_prod_mod_cases : ∀ {S : Finset ℕ}, (∀ p ∈ S, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 1 ∨ (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) % 4 = 3) → (∏ p ∈ S, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 1 ∨ (∏ p ∈ S, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 3 := by
                intros S hS; induction S using Finset.induction <;> norm_num at *;
                rw [ Finset.prod_insert ‹_› ] ; rcases ‹ ( ∀ p ∈ _, _ ) → _› hS.2 with h | h <;> rcases hS.1 with h' | h' <;> norm_num [ Nat.mul_mod, h, h' ] ;
              exact h_prod_mod_cases h_sigma_mod_cases;
            grind;
          refine ⟨ p, hp_prime, ?_, hp_mod ⟩ ; rcases Nat.even_or_odd' ( Nat.factorization n p ) with ⟨ k, hk | hk ⟩ <;> norm_num [ Nat.add_mod, Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ, hk ] at hp_mod ⊢;
          have := Nat.mod_lt p zero_lt_four; interval_cases _ : p % 4 <;> norm_num [ Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_nat_mod ] at hp_mod;
          · simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_iff_eq ];
          · norm_num [ ‹p % 4 = _› ] at hp_mod;
            omega;
          · have := Nat.Prime.eq_two_or_odd ( Nat.prime_of_mem_primeFactors hp_prime ) ; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
            simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ];
          · norm_num [ ‹p % 4 = _› ] at hp_mod; rcases k with ( _ | k ) <;> norm_num [ Nat.mul_succ, Finset.sum_range_succ ] at hp_mod;
            exact absurd hp_mod ( by exact Nat.recOn k ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
        -- Let's choose α such that α ≡ 1 (mod 4) and α is the exponent of p in the prime factorization of n.
        obtain ⟨α, hα⟩ : ∃ α, α ≡ 1 [ZMOD 4] ∧ Nat.factorization n p = α := by
          have h_mod : p ^ (Nat.factorization n p + 1) ≡ 1 [ZMOD 4] := by
            have h_mod : (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i) * (p - 1) ≡ 2 * (p - 1) [ZMOD 4] := by
              exact Int.ModEq.mul_right _ <| Int.natCast_modEq_iff.mpr hp_odd.2;
            have := geom_sum_mul ( p : ℤ ) ( Nat.factorization n p + 1 ) ; simp_all +decide [ Int.ModEq ] ;
            rcases Nat.even_or_odd' p with ⟨ k, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ] at *;
            · exact absurd ( hn.of_dvd_nat ( dvd_of_mul_left_dvd hp_prime.2.1 ) ) ( by norm_num );
            · grind;
          rcases Nat.even_or_odd' ( Nat.factorization n p ) with ⟨ k, hk | hk ⟩ <;> simp_all +decide [ pow_add, pow_mul, Int.ModEq ];
          · exact absurd hp_odd.1 ( by simp +decide [ parity_simps ] );
          · norm_cast at h_mod; rw [ ← Nat.mod_add_div p 4 ] at *; have := Nat.mod_lt p zero_lt_four; interval_cases p % 4 <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod ] at *;
            · norm_cast; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Finset.sum_nat_mod ] at *;
              have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> trivial;
            · cases k <;> norm_num at h_mod;
            · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Finset.sum_nat_mod ] at hp_odd;
              exact absurd hp_odd ( by exact Nat.recOn k ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
        -- Let's choose m such that m^2 is the product of the other prime factors of n.
        obtain ⟨m, hm⟩ : ∃ m, n = p ^ (Nat.factorization n p) * m ^ 2 := by
          have h_prod : ∏ q ∈ n.primeFactors \ {p}, q ^ (Nat.factorization n q) = (∏ q ∈ n.primeFactors \ {p}, q ^ (Nat.factorization n q / 2)) ^ 2 := by
            have h_prod : ∀ q ∈ n.primeFactors \ {p}, Even (Nat.factorization n q) := by
              intro q hq
              by_contra hq_odd
              have hq_mod : (∑ i ∈ Finset.range (Nat.factorization n q + 1), q ^ i) % 2 = 0 := by
                norm_num [ Nat.pow_mod, Finset.sum_nat_mod, Nat.odd_iff.mp ( show Odd ( Nat.factorization n q ) from by simpa using hq_odd ) ];
                cases Nat.Prime.eq_two_or_odd ( Nat.prime_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) <;> simp_all +decide [ Finset.sum_range_succ' ];
                · grind;
                · exact Nat.even_iff.mp ( by simpa [ *, parity_simps ] );
              have hq_mod : (∏ p ∈ n.primeFactors, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 4 = 0 := by
                have hq_mod : (∏ p ∈ n.primeFactors \ {p}, (∑ i ∈ Finset.range (Nat.factorization n p + 1), p ^ i)) % 2 = 0 := by
                  exact Nat.mod_eq_zero_of_dvd <| dvd_trans ( Nat.dvd_of_mod_eq_zero hq_mod ) <| Finset.dvd_prod_of_mem _ hq;
                rw [ ← Finset.prod_sdiff ( Finset.singleton_subset_iff.mpr hp_prime ) ];
                norm_num [ Nat.mul_mod, hp_odd.2, hq_mod ];
                rw [ ← Nat.mod_mod_of_dvd _ ( by decide : 2 ∣ 4 ) ] at hq_mod; have := Nat.mod_lt ( ∏ x ∈ n.primeFactors \ { p }, ∑ i ∈ Finset.range ( ( n.factorization x ) + 1 ), x ^ i ) zero_lt_four; interval_cases ( ∏ x ∈ n.primeFactors \ { p }, ∑ i ∈ Finset.range ( ( n.factorization x ) + 1 ), x ^ i ) % 4 <;> trivial;
              grind;
            rw [ ← Finset.prod_pow ] ; exact Finset.prod_congr rfl fun x hx => by rw [ ← pow_mul, Nat.div_mul_cancel <| even_iff_two_dvd.mp <| h_prod x hx ] ;
          have h_prod : n = p ^ (Nat.factorization n p) * (∏ q ∈ n.primeFactors \ {p}, q ^ (Nat.factorization n q)) := by
            conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn.pos.ne' ];
            rw [ Finsupp.prod_of_support_subset ] <;> norm_num [ Finset.subset_iff ];
            rw [ Finset.prod_eq_mul_prod_diff_singleton hp_prime ];
            aesop;
          grind;
        refine' ⟨ p, m, Nat.factorization n p, Nat.prime_of_mem_primeFactors hp_prime, _, _, _, hm ⟩;
        · rcases Nat.even_or_odd' p with ⟨ k, rfl | rfl ⟩ <;> norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod, pow_succ ] at *;
          · exact absurd ( hn.of_dvd_nat hp_prime.2.1 ) ( by norm_num );
          · norm_cast; rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
            · have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> trivial;
            · norm_num [ Finset.sum_nat_mod, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at hp_odd;
              have := Nat.mod_lt k zero_lt_four; interval_cases k % 4 <;> norm_num [ Finset.sum_range_succ' ] at hp_odd ⊢;
              · rcases Nat.even_or_odd' ( Nat.factorization n ( 2 * ( 2 * k + 1 ) + 1 ) ) with ⟨ c, d | d ⟩ <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ', d ] at hp_odd;
                · exact absurd hp_odd.1 ( by norm_num );
                · exact absurd hp_odd ( by exact Nat.recOn c ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
              · rcases Nat.even_or_odd' ( Nat.factorization n ( 2 * ( 2 * k + 1 ) + 1 ) ) with ⟨ c, d | d ⟩ <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ', d ] at hp_odd;
                · grind;
                · exact absurd hp_odd ( by exact Nat.recOn c ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
              · rcases Nat.even_or_odd' ( Nat.factorization n ( 2 * ( 2 * k + 1 ) + 1 ) ) with ⟨ c, d | d ⟩ <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ', d ] at hp_odd;
                · exact absurd hp_odd.1 ( by norm_num );
                · exact absurd hp_odd ( by exact Nat.recOn c ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
              · rcases Nat.even_or_odd' ( Nat.factorization n ( 2 * ( 2 * k + 1 ) + 1 ) ) with ⟨ c, d | d ⟩ <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ', d ] at hp_odd;
                · exact absurd hp_odd.1 ( by norm_num );
                · exact absurd hp_odd ( by exact Nat.recOn c ( by norm_num ) fun n ihn => by norm_num [ Nat.mul_succ, Nat.pow_succ', Nat.pow_mul, Nat.mul_mod, Nat.pow_mod, Finset.sum_range_succ ] at ihn ⊢ ; omega );
        · exact hα.2.symm ▸ hα.1;
        · refine' Nat.Prime.coprime_iff_not_dvd ( Nat.prime_of_mem_primeFactors hp_prime ) |>.2 _;
          intro hpm
          have h_div : p ^ (Nat.factorization n p + 2) ∣ n := by
            convert hm.symm ▸ mul_dvd_mul_left _ ( pow_dvd_pow_of_dvd hpm 2 ) using 1 ; ring;
          have := Nat.factorization_le_iff_dvd ( by exact pow_ne_zero _ ( Nat.ne_of_gt ( Nat.pos_of_mem_primeFactors hp_prime ) ) ) ( by exact hn.pos.ne' ) |>.2 h_div ; norm_num at this;
          replace := this p ; norm_num at this;
          norm_num [ Nat.Prime.factorization ( Nat.prime_of_mem_primeFactors hp_prime ) ] at this