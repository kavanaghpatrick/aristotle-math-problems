/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f04e6b36-6b19-4b5c-8f57-0900bd500019

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of A(q) = q^2 + q + 1
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

/-
q is a cube root of unity modulo A(q).
-/
theorem q_cubed_eq_one (q : ℕ) (hA : (A q).Prime) :
    (q : ZMod (A q)) ^ 3 = 1 := by
      -- We'll use that $q^3 - 1 = (q - 1)(q^2 + q + 1)$ and that $q^2 + q + 1 = A(q)$.
      have h_factor : (q : ℤ) ^ 3 - 1 = (q - 1) * (q ^ 2 + q + 1) := by
        ring;
      -- Since $q^2 + q + 1 = A(q)$, we have $q^3 - 1 = (q - 1)A(q)$.
      have h_eq : (q : ℤ) ^ 3 - 1 = (q - 1) * (A q : ℤ) := by
        exact h_factor.trans ( by rw [ show A q = q ^ 2 + q + 1 by rfl ] ; norm_cast );
      replace h_eq := congr_arg ( ( ↑ ) : ℤ → ZMod ( A q ) ) h_eq ; simp_all +decide [ sub_eq_iff_eq_add ];
      grind

/-
q is a primitive cube root of unity modulo A(q).
-/
theorem q_is_primitive_cube_root (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hA : (A q).Prime) : (q : ZMod (A q)) ≠ 1 ∧ (q : ZMod (A q)) ^ 3 = 1 := by
      have hq_mod_A : (q : ZMod (A q)) ^ 3 = 1 := by
        convert q_cubed_eq_one q hA using 1;
      refine' ⟨ _, hq_mod_A ⟩;
      intro hq_eq_one_mod_A
      have hq_eq_one : q ≡ 1 [MOD (A q)] := by
        simpa [ ← ZMod.natCast_eq_natCast_iff ] using hq_eq_one_mod_A;
      rw [ Nat.ModEq, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt ] at hq_eq_one <;> nlinarith! [ show A q > q from by nlinarith! [ show A q = q^2 + q + 1 from rfl ], show q > 1 from hq.one_lt ]

/-
Definition of the cubic residue character modulo A(q).
-/
def cubic_residue_char (q : ℕ) (x : ZMod (A q)) : ZMod (A q) := x ^ ((A q - 1) / 3)

/-
If 3^q ≡ 1 (mod A), then 3 is a cubic residue mod A.
-/
theorem three_is_cube_if_pow_q_eq_one (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime)
    (hpow : (3 : ZMod (A q)) ^ q = 1) :
    ∃ y : ZMod (A q), y ^ 3 = 3 := by
      have h_order : ∃ k : ℕ, k * 3 = q + 1 := by
        exact ⟨ ( q + 1 ) / 3, Nat.div_mul_cancel <| Nat.dvd_of_mod_eq_zero <| by rw [ Nat.ModEq ] at hmod3; omega ⟩;
      cases' h_order with k hk;
      use 3 ^ ((1 + q) / 3);
      rw [ ← pow_mul, Nat.div_mul_cancel ] <;> norm_num [ add_comm, hk ];
      · rw [ pow_succ', hpow, mul_one ];
      · exact hk ▸ dvd_mul_left _ _

/-
Helper function to check cubic non-residuacity for a specific q.
-/
def check_cubic_nonresidue (q : ℕ) : Bool :=
  if h : q.Prime ∧ 3 < q ∧ q % 3 == 2 ∧ (q + 1) % 9 ≠ 0 then
    let a := A q
    if ha : a.Prime then
      (3 : ZMod a) ^ (a / 3) ≠ 1
    else true
  else true

/-
Bounded verification of cubic non-residuacity for q < 50,000.
-/
theorem cubic_nonresidue_bounded :
    (List.range 50000).all check_cubic_nonresidue = true := by native_decide

/-
The cube of the cubic residue character is 1 (assuming q ≡ 2 mod 3).
-/
theorem cubic_residue_char_cube_eq_one (q : ℕ) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) (x : ZMod (A q)) (hx : x ≠ 0) :
    (cubic_residue_char q x) ^ 3 = 1 := by
      -- Since $A(q)$ is prime, we can apply Fermat's Little Theorem, which states that $x^{A(q)-1} = 1$ for any integer $x$ not divisible by $A(q)$.
      have h_fermat : x ^ (A q - 1) = 1 := by
        haveI := Fact.mk hA; exact ZMod.pow_card_sub_one_eq_one hx;
      simp_all +decide [ pow_mul, cubic_residue_char ];
      rw [ ← pow_mul, Nat.div_mul_cancel, h_fermat ];
      exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div ( A q ) 3 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, show A q % 3 = 1 from by rw [ show A q = q^2 + q + 1 from rfl ] ; rw [ Nat.ModEq ] at hmod3; norm_num [ Nat.add_mod, Nat.pow_mod, hmod3 ] ] )

/-
The cubic residue character takes values in {1, q, q^2}.
-/
theorem cubic_residue_char_values (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) (x : ZMod (A q)) (hx : x ≠ 0) :
    cubic_residue_char q x = 1 ∨ cubic_residue_char q x = q ∨ cubic_residue_char q x = q ^ 2 := by
      -- We know $(cubic\_residue\_char q x)^3 = 1$. The roots of $T^3 - 1$ in $ZMod A$ are $1, q, q^2$.
      have h_roots : ∀ y : ZMod (A q), y ^ 3 = 1 → y = 1 ∨ y = q ∨ y = q ^ 2 := by
        -- Since $A$ is prime, $ZMod A$ is a field. The polynomial $T^3 - 1$ has at most 3 roots in a field.
        have h_poly_roots : ∀ y : ZMod (A q), y ^ 3 = 1 → y = 1 ∨ y = q ∨ y = q ^ 2 := by
          intro y hy
          have h_poly : (y - 1) * (y - q) * (y - q ^ 2) = 0 := by
            -- Since $A(q) = q^2 + q + 1$, we have $1 + q + q^2 \equiv 0 \pmod{A(q)}$.
            have h_sum : (1 + q + q^2 : ZMod (A q)) = 0 := by
              norm_cast;
              erw [ ZMod.natCast_eq_zero_iff ] ; exact ⟨ 1, by unfold A; ring ⟩;
            grind
          haveI := Fact.mk hA; simp_all +decide [ sub_eq_iff_eq_add, mul_assoc ] ;
        assumption;
      exact h_roots _ ( by exact? )

/-
3 = (1-q)(1-q^2) in ZMod A(q).
-/
theorem three_eq_one_sub_q_mul_one_sub_q_sq (q : ℕ) (hA : (A q).Prime) :
    (3 : ZMod (A q)) = (1 - q) * (1 - q ^ 2) := by
      -- Since $q^3 = 1$ and $q^2 + q = -1$ (mod $A$), we have $1 - q^2 - q + q^3 = 1 - (-1) + 1 = 3$.
      have hq3 : (q : ZMod (A q))^3 = 1 := by
        exact?;
      have hq2 : (q : ZMod (A q))^2 + q + 1 = 0 := by
        norm_cast at *;
        erw [ ZMod.natCast_eq_zero_iff ] at * ; aesop;
      linear_combination' -hq3 + hq2 * 1

/-
3 = -q^2(1-q)^2 in ZMod A(q).
-/
theorem three_eq_neg_q_sq_mul_one_sub_q_sq (q : ℕ) (hA : (A q).Prime) :
    (3 : ZMod (A q)) = - (q : ZMod (A q))^2 * (1 - q)^2 := by
      -- Since $q^2 + q + 1 = 0$, we have $1 + q = -q^2$.
      have h1 : (1 + q : ZMod (A q)) = -q^2 := by
        have h1 : (q^2 + q + 1 : ZMod (A q)) = 0 := by
          norm_cast;
          erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
        linear_combination' h1;
      grind

/-
The cubic residue character is multiplicative.
-/
theorem cubic_residue_char_mul (q : ℕ) (x y : ZMod (A q)) :
    cubic_residue_char q (x * y) = cubic_residue_char q x * cubic_residue_char q y := by
      unfold cubic_residue_char;
      ring

/-
The cubic residue character of -1 is 1.
-/
theorem cubic_residue_char_neg_one (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) :
    cubic_residue_char q (-1) = 1 := by
      have h_even : Even (q * (q + 1) / 3) := by
        rw [ Nat.even_div ];
        rw [ ← Nat.mod_add_div q 6 ] ; have := Nat.mod_lt q ( by decide : 6 > 0 ) ; interval_cases _ : q % 6 <;> norm_num [ Nat.add_mod, Nat.mul_mod ] ;
      unfold cubic_residue_char;
      unfold A; norm_num [ h_even ] ;
      rw [ show q ^ 2 + q = q * ( q + 1 ) by ring, h_even.neg_one_pow ]

/-
The cubic residue character of q is q^(2(q+1)/3 mod 3).
-/
theorem cubic_residue_char_q (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) :
    cubic_residue_char q q = q ^ ((q + 1) / 3 * 2 % 3) := by
      have h_exp_mod : (q : ZMod (A q)) ^ ((A q - 1) / 3) = (q : ZMod (A q)) ^ ((q + 1) / 3 * 2 % 3) := by
        -- Since $q$ is a cube root of unity modulo $A(q)$, we have $q^3 \equiv 1 \pmod{A(q)}$.
        have h_q_cubed : (q : ZMod (A q)) ^ 3 = 1 := by
          exact?;
        rw [ ← Nat.mod_add_div ( ( A q - 1 ) / 3 ) 3 ] ; norm_num [ pow_add, pow_mul, h_q_cubed ] ;
        rw [ show A q = q^2 + q + 1 by rfl ] ; norm_num [ Nat.add_div ] ; ring;
        rw [ ← Nat.mod_add_div q 3, hmod3 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; ring;
        grind;
      convert h_exp_mod using 1

/-
(1+q)^3 = -1 in ZMod A(q).
-/
theorem one_add_q_cubed_eq_neg_one (q : ℕ) (hA : (A q).Prime) :
    (1 + (q : ZMod (A q))) ^ 3 = -1 := by
      -- By definition of $A(q)$, we know that $q^2 + q + 1 \equiv 0 \pmod{A(q)}$.
      have h_def : (q^2 + q + 1 : ZMod (A q)) = 0 := by
        norm_cast at *;
        erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
      grind

/-
Definition of Eisenstein integers as pairs of integers (a, b) representing a + bω.
-/
structure EisensteinInt where
  a : ℤ
  b : ℤ
deriving DecidableEq, Repr

/-
Addition of Eisenstein integers.
-/
def EisensteinInt.add (z1 z2 : EisensteinInt) : EisensteinInt :=
  ⟨z1.a + z2.a, z1.b + z2.b⟩

/-
Multiplication of Eisenstein integers.
-/
def EisensteinInt.mul (z1 z2 : EisensteinInt) : EisensteinInt :=
  ⟨z1.a * z2.a - z1.b * z2.b, z1.a * z2.b + z1.b * z2.a - z1.b * z2.b⟩

/-
Homomorphism from Eisenstein integers to ZMod A(q).
-/
def EisensteinInt.toZMod (q : ℕ) (z : EisensteinInt) : ZMod (A q) :=
  z.a + z.b * (q : ZMod (A q))

/-
toZMod is a multiplicative homomorphism.
-/
theorem EisensteinInt.toZMod_mul (q : ℕ) (z1 z2 : EisensteinInt) :
    toZMod q (z1.mul z2) = toZMod q z1 * toZMod q z2 := by
      -- Using the definition of multiplication in Eisenstein integers, we can simplify the expression.
      have h_simplify : (z1.a * z2.a - z1.b * z2.b) + (z1.a * z2.b + z1.b * z2.a - z1.b * z2.b) * (q : ZMod (A q)) = (z1.a + z1.b * (q : ZMod (A q))) * (z2.a + z2.b * (q : ZMod (A q))) := by
        have h_sub : (q : ZMod (A q)) ^ 2 + q + 1 = 0 := by
          norm_cast;
          erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
        grind;
      convert h_simplify using 1;
      unfold EisensteinInt.toZMod; ring;
      erw [ show ( z1.mul z2 ).a = z1.a * z2.a - z1.b * z2.b by rfl, show ( z1.mul z2 ).b = z1.a * z2.b + z1.b * z2.a - z1.b * z2.b by rfl ] ; norm_num ; ring

/-
Norm of an Eisenstein integer.
-/
def EisensteinInt.norm (z : EisensteinInt) : ℤ :=
  z.a ^ 2 - z.a * z.b + z.b ^ 2

/-
Conjugate of an Eisenstein integer.
-/
def EisensteinInt.conjugate (z : EisensteinInt) : EisensteinInt :=
  ⟨z.a - z.b, -z.b⟩

/-
Helper to check if 1-q is a cubic residue.
-/
def check_one_sub_q_residue (q : ℕ) : Bool :=
  if h : q.Prime ∧ 3 < q ∧ q % 3 == 2 then
    let a := A q
    if ha : a.Prime then
      (1 - (q : ZMod a)) ^ (a / 3) == 1
    else true
  else true

/-
Formula for the cubic residue character of 3.
-/
theorem cubic_residue_char_three_eq (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) :
    cubic_residue_char q 3 = (cubic_residue_char q q) ^ 2 * (cubic_residue_char q (1 - q)) ^ 2 := by
      -- By definition of cubic residue character, we have:
      have h_def : cubic_residue_char q 3 = cubic_residue_char q ((-1 : ZMod (A q)) * (q : ZMod (A q)) ^ 2 * (1 - (q : ZMod (A q))) ^ 2) := by
        have h_def : (3 : ZMod (A q)) = - (q : ZMod (A q)) ^ 2 * (1 - (q : ZMod (A q))) ^ 2 := by
          convert three_eq_neg_q_sq_mul_one_sub_q_sq q hA using 1;
        simp +decide [ h_def, mul_assoc ];
      -- By definition of cubic residue character, we have: $\chi(ab) = \chi(a)\chi(b)$.
      have h_mul : ∀ a b : ZMod (A q), cubic_residue_char q (a * b) = cubic_residue_char q a * cubic_residue_char q b := by
        exact?;
      have h_neg_one : cubic_residue_char q (-1) = 1 := by
        exact?;
      grind

/-
Definitions for Eisenstein power, divisibility, 1-ω, and π.
-/
def EisensteinInt.pow (z : EisensteinInt) (n : ℕ) : EisensteinInt :=
  match n with
  | 0 => ⟨1, 0⟩
  | n + 1 => z.mul (pow z n)

def EisensteinInt.dvd (z1 z2 : EisensteinInt) : Prop :=
  ∃ z3, z2 = z1.mul z3

def EisensteinInt.one_sub_omega : EisensteinInt := ⟨1, -1⟩

def EisensteinInt.pi (q : ℕ) : EisensteinInt := ⟨-1, -(q + 1)⟩

/-
toZMod is an additive homomorphism.
-/
theorem EisensteinInt.toZMod_add (q : ℕ) (z1 z2 : EisensteinInt) :
    toZMod q (z1.add z2) = toZMod q z1 + toZMod q z2 := by
      unfold EisensteinInt.toZMod;
      erw [ show ( z1.add z2 ).a = z1.a + z2.a by rfl, show ( z1.add z2 ).b = z1.b + z2.b by rfl ] ; push_cast ; ring

/-
1-omega maps to 1-q under toZMod.
-/
theorem EisensteinInt.toZMod_one_sub_omega (q : ℕ) :
    toZMod q one_sub_omega = 1 - (q : ZMod (A q)) := by
      -- By definition of toZMod, we have toZMod q (1 - ω) = 1 + (-1) * q = 1 - q.
      simp [EisensteinInt.toZMod, EisensteinInt.one_sub_omega];
      ring

/-
(1-q)^2 = -3q in ZMod A(q).
-/
theorem one_sub_q_sq_eq_neg_three_mul_q (q : ℕ) (hA : (A q).Prime) :
    (1 - (q : ZMod (A q))) ^ 2 = -3 * (q : ZMod (A q)) := by
      -- In ZMod A(q), we have q^2 ≡ -q - 1.
      have h_q_sq : (q : ZMod (A q)) ^ 2 = -(q : ZMod (A q)) - 1 := by
        -- Since $A(q) = q^2 + q + 1$, we have $q^2 \equiv -q - 1 \pmod{A(q)}$.
        have h_cong : (q : ℤ)^2 ≡ -q - 1 [ZMOD A q] := by
          exact Int.modEq_iff_dvd.mpr ⟨ -1, by push_cast [ A ] ; ring ⟩;
        erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
      linear_combination' h_q_sq

/-
Definitions of zero, one, and omega for Eisenstein integers.
-/
def EisensteinInt.zero : EisensteinInt := ⟨0, 0⟩
def EisensteinInt.one : EisensteinInt := ⟨1, 0⟩
def EisensteinInt.omega : EisensteinInt := ⟨0, 1⟩

instance : Zero EisensteinInt := ⟨EisensteinInt.zero⟩
instance : One EisensteinInt := ⟨EisensteinInt.one⟩

/-
Subtraction of Eisenstein integers.
-/
def EisensteinInt.sub (z1 z2 : EisensteinInt) : EisensteinInt :=
  ⟨z1.a - z2.a, z1.b - z2.b⟩

/-
Checking if EisensteinInt.sub exists.
-/
#check EisensteinInt.sub

/-
(1-omega)^2 = -3 * omega.
-/
theorem EisensteinInt.one_sub_omega_sq_eq_neg_three_mul_omega :
    (EisensteinInt.one_sub_omega.pow 2) = (EisensteinInt.mk (-3) 0).mul EisensteinInt.omega := by
      rfl

/-
A(q) is 1 mod 4 when q is 3 mod 4.
-/
theorem A_mod_four_eq_one (q : ℕ) (hq : q % 4 = 3) :
    A q % 4 = 1 := by
      -- Substitute $q \equiv 3 \pmod{4}$ into the expression for $A(q)$.
      have hA_mod : A q = q^2 + q + 1 := by
        rfl;
      norm_num [ hA_mod, Nat.add_mod, Nat.pow_mod, hq ]

/-
-1 is a square modulo A(q) when q is 3 mod 4.
-/
theorem neg_one_is_square_mod_A (q : ℕ) (hq : q % 4 = 3) (hA : (A q).Prime) :
    IsSquare (-1 : ZMod (A q)) := by
      -- By the first supplement to quadratic reciprocity, -1 is a square modulo p if p ≡ 1 (mod 4).
      have h_reciprocity : ∀ p : ℕ, Nat.Prime p → p % 4 = 1 → IsSquare (-1 : ZMod p) := by
        intro p hp hp_mod; haveI := Fact.mk hp; exact ZMod.exists_sq_eq_neg_one_iff.mpr ( by rw [ ← Nat.mod_add_div p 4, hp_mod ] ; norm_num ) ;
      exact h_reciprocity _ hA ( A_mod_four_eq_one _ hq )

/-
q is a square modulo A(q).
-/
theorem q_is_square_mod_A (q : ℕ) (hA : (A q).Prime) :
    IsSquare (q : ZMod (A q)) := by
      -- Since $q$ is a prime number, we have $q \equiv -1 \pmod{A(q)}$.
      have hq_mod : (q + 1 : ZMod (A q)) ^ 2 = q := by
        norm_cast;
        norm_num [ show ( q + 1 ) ^ 2 = A q + q by linarith [ show A q = q ^ 2 + q + 1 from rfl ] ];
      exact ⟨ q + 1, by linear_combination' hq_mod.symm ⟩

/-
-3 is a square modulo A(q).
-/
theorem neg_three_is_square_mod_A (q : ℕ) (hA : (A q).Prime) :
    IsSquare (-3 : ZMod (A q)) := by
      -- Since $A(q)$ is prime, we know that $4A(q)$ is divisible by $A(q)$.
      have h_div : (4 * (q^2 + q + 1) : ZMod (A q)) = 0 := by
        norm_cast;
        erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_mul_of_dvd_right ( by exact hA.dvd_iff_eq ( by aesop ) |>.2 rfl ) _;
      -- Since $A(q)$ is prime, we know that $(2q + 1)^2 = -3 \mod A(q)$.
      have h_cong : ((2 * q + 1 : ZMod (A q)) ^ 2 = -3) := by
        grind;
      exact ⟨ _, by rw [ ← h_cong, sq ] ⟩

/-
q+1 = -q^2 modulo A(q).
-/
theorem q_plus_one_eq_neg_q_sq (q : ℕ) (hA : (A q).Prime) :
    (q : ZMod (A q)) + 1 = - (q : ZMod (A q))^2 := by
      have h_congr : (q : ZMod (A q)) ^ 2 + (q : ZMod (A q)) + 1 = 0 := by
        norm_cast;
        erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
      linear_combination' h_congr

/-
3 is a square modulo A(q).
-/
theorem three_is_square_mod_A (q : ℕ) (hq : q % 4 = 3) (hA : (A q).Prime) :
    IsSquare (3 : ZMod (A q)) := by
      -- Since 3 = (-1) * (-3) and both -1 and -3 are squares modulo A(q), their product 3 must also be a square modulo A(q).
      have h3_sq : IsSquare ((-1 : ZMod (A q)) * (-3 : ZMod (A q))) := by
        exact IsSquare.mul ( neg_one_is_square_mod_A q hq hA ) ( neg_three_is_square_mod_A q hA );
      exact h3_sq.imp fun x hx => by linear_combination' hx;

/-
q+1 is a square modulo A(q) when q is 3 mod 4.
-/
theorem q_plus_one_is_square_mod_A (q : ℕ) (hq : q % 4 = 3) (hA : (A q).Prime) :
    IsSquare ((q : ZMod (A q)) + 1) := by
      -- Since $q^2$ is a square in $ZMod (A q)$, and $-1$ is a square (from $neg_one_is_square_mod_A$), their product $-q^2$ is also a square.
      have h_q_sq_square : IsSquare ((q : ZMod (A q))^2) := by
        exact ⟨ q, sq _ ⟩;
      convert h_q_sq_square.mul ( neg_one_is_square_mod_A q hq hA ) using 1;
      haveI := Fact.mk hA; norm_num [ ← ZMod.natCast_eq_zero_iff, Nat.cast_add, Nat.cast_pow, Nat.cast_one ] ;
      exact?

/-
m = (q+1)/3 is a square modulo A(q).
-/
theorem m_is_square_mod_A (q : ℕ) (hq : q % 4 = 3) (hmod3 : q % 3 = 2) (hA : (A q).Prime) :
    let m := (q + 1) / 3
    IsSquare (m : ZMod (A q)) := by
      -- Since $3$ is a square modulo $A(q)$ and $q+1$ is a square modulo $A(q)$, their product is also a square modulo $A(q)$.
      have h_prod_square : IsSquare ((3 : ZMod (A q)) * ((q + 1) : ZMod (A q))) := by
        have h_prod_square : IsSquare ((3 : ZMod (A q))) ∧ IsSquare ((q + 1 : ZMod (A q))) := by
          exact ⟨ by simpa using three_is_square_mod_A q hq hA, by simpa using q_plus_one_is_square_mod_A q hq hA ⟩;
        exact h_prod_square.1.mul h_prod_square.2;
      convert h_prod_square.mul ( show IsSquare ( ( 3 : ZMod ( A q ) ) ⁻¹ ^ 2 ) from ⟨ ( 3 : ZMod ( A q ) ) ⁻¹, by ring ⟩ ) using 1;
      haveI := Fact.mk hA; norm_num [ sq, mul_assoc, mul_comm, mul_left_comm ] ;
      rw [ Nat.cast_div ] <;> norm_num;
      · by_cases h : ( 3 : ZMod ( A q ) ) = 0 <;> simp_all +decide [ div_eq_mul_inv ];
      · omega;
      · erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by norm_num ) H; rcases q with ( _ | _ | _ | _ | _ | q ) <;> simp_all +arith +decide [ A ] ;

/-
Relation between integer division by 3 and modular inverse of 3.
-/
theorem m_eq_q_plus_one_mul_inv_three (q : ℕ) (hmod3 : q % 3 = 2) (hA : (A q).Prime) :
    ((((q + 1) / 3) : ℕ) : ZMod (A q)) = ((q : ZMod (A q)) + 1) * (3 : ZMod (A q))⁻¹ := by
      -- Let $m = (q + 1) / 3$. Then $3m = q + 1$.
      set m : ℕ := (q + 1) / 3
      have h3m : 3 * m = q + 1 := by
        omega;
      have h_inv : (3 : ZMod (A q)) * (3⁻¹ : ZMod (A q)) = 1 := by
        haveI := Fact.mk hA; erw [ ZMod.mul_inv_of_unit ] ; norm_num;
        erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by norm_num ) H; rcases q with ( _ | _ | _ | _ | q ) <;> simp_all +arith +decide [ A ] ;
      have h_eq : (3 : ZMod (A q)) * m = (q + 1) := by
        norm_cast;
        rw [h3m];
      rw [ ← h_eq, mul_right_comm, h_inv, one_mul ]

/-
m = (q+1)/3 is a square modulo A(q).
-/
theorem m_is_square_mod_A_v2 (q : ℕ) (hq : q % 4 = 3) (hmod3 : q % 3 = 2) (hA : (A q).Prime) :
    let m := (q + 1) / 3
    IsSquare (m : ZMod (A q)) := by
      exact?

/-
m = (q+1)/3 is a square modulo A(q).
-/
theorem m_is_square_mod_A_v3 (q : ℕ) (hq : q % 4 = 3) (hmod3 : q % 3 = 2) (hA : (A q).Prime) :
    let m := (q + 1) / 3
    IsSquare (m : ZMod (A q)) := by
      convert m_is_square_mod_A_v2 q hq hmod3 hA using 2

/-
The modular inverse of 3 is a square modulo A(q).
-/
theorem inv_three_is_square_mod_A (q : ℕ) (hq : q % 4 = 3) (hA : (A q).Prime) :
    IsSquare ((3 : ZMod (A q))⁻¹) := by
      -- By definition of $A$, we know that $3$ is a square modulo $A(q)$.
      have h3_square : IsSquare (3 : ZMod (A q)) := by
        exact?;
      haveI := Fact.mk hA; exact h3_square.inv;

/-
1-q = (2q+1)q^2 in ZMod A(q).
-/
theorem one_sub_q_eq_two_q_plus_one_mul_q_sq (q : ℕ) (hA : (A q).Prime) :
    (1 - (q : ZMod (A q))) = (2 * (q : ZMod (A q)) + 1) * (q : ZMod (A q)) ^ 2 := by
      have h_q_squared : (q : ZMod (A q))^2 = - (q : ZMod (A q)) - 1 := by
        have h_poly : (q : ZMod (A q))^2 + (q : ZMod (A q)) + 1 = 0 := by
          have h_poly : (q : ZMod (A q))^2 + (q : ZMod (A q)) + 1 = 0 := by
            have h_def : (A q : ZMod (A q)) = 0 := by
              norm_num +zetaDelta at *
            norm_cast at *;
          exact h_poly
        linear_combination' h_poly;
      grind

/-
The norm of 1-omega is 3.
-/
theorem EisensteinInt.norm_one_sub_omega :
    EisensteinInt.norm EisensteinInt.one_sub_omega = 3 := by
      rfl

/-
Definition of pi_q = q - omega.
-/
def EisensteinInt.pi_q (q : ℕ) : EisensteinInt := ⟨q, -1⟩

/-
The norm of pi_q is A(q).
-/
theorem EisensteinInt.norm_pi_q (q : ℕ) :
    EisensteinInt.norm (EisensteinInt.pi_q q) = A q := by
      exact show ( q : ℤ ) ^ 2 - q * ( -1 ) + ( -1 ) ^ 2 = q ^ 2 + q + 1 by ring;

/-
pi_q maps to 0 in ZMod A(q).
-/
theorem EisensteinInt.toZMod_pi_q (q : ℕ) :
    EisensteinInt.toZMod q (EisensteinInt.pi_q q) = 0 := by
      unfold EisensteinInt.pi_q; unfold EisensteinInt.toZMod; ring;
      norm_num