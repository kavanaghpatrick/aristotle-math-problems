/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2b124bcc-fe93-4cc4-a1ea-92963e0fad2d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Mahler-Popken complexity `‖n‖` as the minimum number of 1s needed to express `n` using addition and multiplication. We formalize this using the inductive predicate `Reachable` and the function `complexity`.

We provide a computable definition `complexity_computable` using `reachableSet` and prove it equivalent to the definition. This allows us to verify the conjecture `‖2^n‖ = 2n` for small `n` using `native_decide`.

We prove the following results:
1. **Bounded Verification**: `complexity (2^n) = 2*n` for `n ∈ {1, 2, 3, 4, 5, 6}` (i.e., up to 64).
2. **Multiplicative Lower Bound**: If `2^n = a * b` with `a, b > 1`, and the conjecture holds for smaller powers of 2, then `‖a‖ + ‖b‖ ≥ 2n`. This relies on the lemma `pow_two_mul_decomposition` which shows that factors of `2^n` are themselves powers of 2.
3. **Upper Bound**: `‖2^n‖ ≤ 2n` for all `n ≥ 1`.

This formalization covers the "Alternate Approach" suggested in the prompt, establishing the definitions, decidability, bounded verification, and the multiplicative case of the lower bound. The additive case remains an open problem.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Mahler-Popken complexity ‖n‖ is the minimum number of 1s needed to express n using addition and multiplication. We define Reachable c n to mean n can be formed with complexity c.
-/
inductive Reachable : ℕ → ℕ → Prop where
  | one : Reachable 1 1
  | add {c1 c2 n1 n2} : Reachable c1 n1 → Reachable c2 n2 → Reachable (c1 + c2) (n1 + n2)
  | mul {c1 c2 n1 n2} : Reachable c1 n1 → Reachable c2 n2 → Reachable (c1 + c2) (n1 * n2)

/-
Every positive integer is reachable. Complexity is the minimum number of 1s.
-/
theorem exists_reachable (n : ℕ) (h : n > 0) : ∃ c, Reachable c n := by
  induction' n using Nat.strongRecOn with n ih;
  -- If $n$ is 1, then we are done.
  by_cases hn : n = 1;
  · exact hn.symm ▸ ⟨ 1, Reachable.one ⟩;
  · -- If $n$ is not 1, then $n$ can be written as $k + 1$ for some $k$.
    obtain ⟨k, rfl⟩ : ∃ k, n = k + 1 := Nat.exists_eq_succ_of_ne_zero (by
    grind);
    exact Exists.elim ( ih k ( Nat.lt_succ_self k ) ( Nat.pos_of_ne_zero ( by aesop ) ) ) fun c hc => ⟨ c + 1, Reachable.add hc Reachable.one ⟩

noncomputable def complexity (n : ℕ) : ℕ :=
  if h : n > 0 then Nat.find (exists_reachable n h) else 0

/-
`reachableSet c` computes the list of all numbers with complexity `c`. This allows us to decide `Reachable c n`.
-/
def reachableSet (c : ℕ) : List ℕ :=
  match c with
  | 0 => []
  | 1 => [1]
  | c + 1 =>
    let prev := (List.range (c + 1)).flatMap (fun k =>
      if k > 0 ∧ k <= c then
        let s1 := reachableSet k
        let s2 := reachableSet (c + 1 - k)
        (s1.flatMap fun n1 => s2.map fun n2 => n1 + n2) ++
        (s1.flatMap fun n1 => s2.map fun n2 => n1 * n2)
      else [])
    prev.dedup
  termination_by c
  decreasing_by all_goals (simp_wf; grind)

/-
Forward direction of `reachableSet` characterization.
-/
theorem mem_reachableSet_succ_imp (c n : ℕ) (hc : c ≥ 1) :
  n ∈ reachableSet (c + 1) →
  ∃ k, 0 < k ∧ k ≤ c ∧
    ∃ n1 ∈ reachableSet k, ∃ n2 ∈ reachableSet (c + 1 - k),
      n = n1 + n2 ∨ n = n1 * n2 := by
        -- By definition of `reachableSet`, if `n ∈ reachableSet (c + 1)`, then `n` must be in the list generated by `flatMap` over `List.range (c + 1)`.
        intro hn
        have h_flatMap : n ∈ (List.range (c + 1)).flatMap (fun k =>
          if k > 0 ∧ k ≤ c then
            let s1 := reachableSet k
            let s2 := reachableSet (c + 1 - k)
            (s1.flatMap fun n1 => s2.map fun n2 => n1 + n2) ++
            (s1.flatMap fun n1 => s2.map fun n2 => n1 * n2)
          else []) := by
            unfold reachableSet at hn;
            exact List.mem_dedup.mp ( by cases c <;> tauto );
        rw [ List.mem_flatMap ] at h_flatMap;
        rcases h_flatMap with ⟨ k, hk₁, hk₂ ⟩ ; use k; split_ifs at hk₂ <;> simp_all +decide [ List.mem_append, List.mem_flatMap ] ;
        grind

/-
Reverse direction of `reachableSet` characterization.
-/
theorem mem_reachableSet_succ_of_split (c n : ℕ) (hc : c ≥ 1) :
  (∃ k, 0 < k ∧ k ≤ c ∧
    ∃ n1 ∈ reachableSet k, ∃ n2 ∈ reachableSet (c + 1 - k),
      n = n1 + n2 ∨ n = n1 * n2) →
  n ∈ reachableSet (c + 1) := by
    intro h
    obtain ⟨k, hk_pos, hk_le_c, n1, hn1, n2, hn2, h_eq⟩ := h
    have hk_range : k ∈ List.range (c + 1) := by
      exact List.mem_range.mpr ( by linarith );
    unfold reachableSet;
    convert List.mem_dedup.mpr _ using 1;
    any_goals exact List.flatMap ( fun k => if 0 < k ∧ k ≤ c then List.flatMap ( fun n1 => List.map ( fun n2 => n1 + n2 ) ( reachableSet ( c + 1 - k ) ) ) ( reachableSet k ) ++ List.flatMap ( fun n1 => List.map ( fun n2 => n1 * n2 ) ( reachableSet ( c + 1 - k ) ) ) ( reachableSet k ) else [] ) ( List.range ( c + 1 ) );
    all_goals try infer_instance;
    · grind;
    · rw [ List.mem_flatMap ];
      use k; aesop;

/-
The `reachableSet` function correctly computes the set of reachable numbers for a given complexity.
-/
theorem reachable_iff_mem_reachableSet (c n : ℕ) : Reachable c n ↔ n ∈ reachableSet c := by
  induction' c using Nat.strong_induction_on with c ih generalizing n;
  rcases c with ( _ | _ | c ) <;> simp_all +arith +decide;
  · -- By definition of `reachableSet`, `reachableSet 0` is the empty list.
    simp [reachableSet];
    -- By definition of Reachable, Reachable 0 n is impossible since there's no way to form n with 0 ones. We can prove this by induction on the structure of Reachable.
    have h_impossible : ∀ c n, Reachable c n → c > 0 := by
      intro c n h; induction h <;> aesop;
    exact fun h => by simpa using h_impossible 0 n h;
  · -- For the base case when $c = 1$, we see that $Reachable 1 n$ holds if and only if $n = 1$, since the only way to reach 1 with complexity 1 is to use the base case.
    simp [reachableSet];
    constructor <;> intro hn;
    · have h_one : ∀ {c n}, Reachable c n → c = 1 → n = 1 := by
        intros c n h_reachable h_eq_one
        induction' h_reachable with c n h_reachable h_eq_one ih;
        · rfl;
        · rcases c with ( _ | _ | c ) <;> rcases n with ( _ | _ | n ) <;> simp_all +arith +decide only;
          · unfold reachableSet at ih; aesop;
          · unfold reachableSet at * ; aesop;
        · rename_i k l hk hl ihk ihl;
          rename_i c1 c2 ; simp_all +arith +decide;
          rcases c1 with ( _ | _ | c1 ) <;> rcases c2 with ( _ | _ | c2 ) <;> simp_all +arith +decide only;
          · unfold reachableSet at hk; aesop;
          · unfold reachableSet at hl; aesop;
      exact h_one hn rfl;
    · exact hn.symm ▸ Reachable.one;
  · constructor;
    · intro hn;
      -- By definition of Reachable, if Reachable (c + 2) n, then there exist c1, c2, n1, n2 such that c1 + c2 = c + 2, Reachable c1 n1, Reachable c2 n2, and n = n1 + n2 or n = n1 * n2.
      obtain ⟨c1, c2, n1, n2, hc1c2, hn1, hn2, hn⟩ : ∃ c1 c2 n1 n2, c1 + c2 = c + 2 ∧ Reachable c1 n1 ∧ Reachable c2 n2 ∧ n = n1 + n2 ∨ c1 + c2 = c + 2 ∧ Reachable c1 n1 ∧ Reachable c2 n2 ∧ n = n1 * n2 := by
        have h_cases : ∀ {c n}, Reachable c n → c > 1 → ∃ c1 c2 n1 n2, c1 + c2 = c ∧ Reachable c1 n1 ∧ Reachable c2 n2 ∧ n = n1 + n2 ∨ c1 + c2 = c ∧ Reachable c1 n1 ∧ Reachable c2 n2 ∧ n = n1 * n2 := by
          intros c n hn hc; induction' hn with c1 c2 n1 n2 hc1 hc2 hn1 hn2 ih1 ih2; aesop;
          · exact ⟨ c1, c2, n1, n2, Or.inl ⟨ rfl, hc1, hc2, rfl ⟩ ⟩;
          · exact ⟨ ih1, ih2, _, _, Or.inr ⟨ rfl, by assumption, by assumption, rfl ⟩ ⟩;
        exact h_cases hn ( Nat.le_add_left _ _ );
      · by_cases hc1 : c1 > 0 <;> by_cases hc2 : c2 > 0 <;> simp_all +arith +decide [ Nat.add_comm ];
        · convert mem_reachableSet_succ_of_split ( c + 1 ) ( n1 + n2 ) ( by linarith ) _ using 1;
          use c1;
          grind;
        · unfold reachableSet at hn2; aesop;
        · exact absurd hn1 ( by unfold reachableSet; aesop );
      · rcases c1 with ( _ | c1 ) <;> rcases c2 with ( _ | c2 ) <;> simp_all +arith +decide;
        · unfold reachableSet at * ; aesop;
        · unfold reachableSet at * ; aesop;
        · apply mem_reachableSet_succ_of_split;
          · grind;
          · use c1 + 1;
            grind;
    · intro hn
      obtain ⟨k, hk_pos, hk_le, ⟨n1, hn1, n2, hn2, hn_eq⟩⟩ := mem_reachableSet_succ_imp (c + 1) n (by linarith) hn
      have h_reachable : Reachable (k) n1 ∧ Reachable (c + 2 - k) n2 := by
        exact ⟨ ih k hk_le n1 |>.2 hn1, ih ( c + 2 - k ) ( Nat.sub_le_of_le_add <| by linarith ) n2 |>.2 hn2 ⟩
      generalize_proofs at *; (
      rcases hn_eq with ( rfl | rfl ) <;> [ exact Reachable.add h_reachable.1 h_reachable.2 |> fun h => by convert h using 1; omega; ; exact Reachable.mul h_reachable.1 h_reachable.2 |> fun h => by convert h using 1; omega; ])

/-
Computable definition of complexity.
-/
def complexity_computable (n : ℕ) : ℕ :=
  (List.range (n + 1)).find? (fun c => n ∈ reachableSet c) |>.getD 0

theorem complexity_eq_complexity_computable (n : ℕ) (h : n > 0) : complexity n = complexity_computable n := by
  -- Since complexity n is the minimum c such that Reachable c n, and we have Reachable n n, then complexity n ≤ n.
  have h_le : complexity n ≤ n := by
    have h_reachable : Reachable n n := by
      induction' h with k hk;
      · constructor;
      · exact Reachable.add ( by assumption ) Reachable.one
    unfold complexity;
    aesop;
  unfold complexity_computable;
  -- By definition of `complexity`, we know that `complexity n` is the smallest `c` such that `Reachable c n`.
  have h_def : complexity n = Nat.find (exists_reachable n h) := by
    unfold complexity; aesop;
  -- By definition of `Nat.find`, we know that `Nat.find (exists_reachable n h)` is the smallest `c` such that `Reachable c n`.
  have h_find : Nat.find (exists_reachable n h) = Nat.find (exists_reachable n h) ∧ ∀ c < Nat.find (exists_reachable n h), ¬Reachable c n := by
    simp +zetaDelta at *;
    exact fun c hc => hc c le_rfl;
  -- By definition of `List.find?`, we know that `List.find? (fun c => n ∈ reachableSet c) (List.range (n + 1))` is the smallest `c` such that `n ∈ reachableSet c`.
  have h_find_list : List.find? (fun c => n ∈ reachableSet c) (List.range (n + 1)) = some (Nat.find (exists_reachable n h)) := by
    have h_find_list : ∀ {l : List ℕ}, List.Sorted (· < ·) l → ∀ c ∈ l, (List.find? (fun c => n ∈ reachableSet c) l = some c) ↔ (n ∈ reachableSet c ∧ ∀ c' ∈ l, c' < c → ¬n ∈ reachableSet c') := by
      intros l hl c hc; induction' l with hd tl ih generalizing c <;> simp_all +decide [ List.find? ] ;
      cases hc <;> simp_all +decide [ List.find? ];
      · grind;
      · by_cases h : n ∈ reachableSet hd <;> simp_all +decide;
        linarith [ hl.1 _ ‹_› ];
    apply (h_find_list (by
    simp +decide [ List.Sorted ];
    norm_num [ List.pairwise_iff_get ]) (Nat.find (exists_reachable n h)) (by
    grind)).mpr;
    exact ⟨ by simpa [ reachable_iff_mem_reachableSet ] using Nat.find_spec ( exists_reachable n h ), fun c' hc' hc'' => by simpa [ reachable_iff_mem_reachableSet ] using h_find.2 c' hc'' ⟩;
  grind

/-
Bounded verification of complexity for powers of 2 up to 64.
-/
theorem complexity_two_pow_bounded :
  complexity 2 = 2 ∧ complexity 4 = 4 ∧ complexity 8 = 6 ∧
  complexity 16 = 8 ∧ complexity 32 = 10 ∧ complexity 64 = 12 := by
  simp [complexity_eq_complexity_computable]
  native_decide

/-
If the product of two numbers is a power of 2, then each number is a power of 2.
-/
theorem pow_two_mul_decomposition {n a b : ℕ} (h : a * b = 2^n) :
  ∃ i j, a = 2^i ∧ b = 2^j ∧ i + j = n := by
    -- Since $a * b = 2^n$, $a$ and $b$ must both be powers of $2$.
    have ha : ∃ i : ℕ, a = 2^i := by
      have : a ∣ 2 ^ n := h ▸ dvd_mul_right _ _; ( rw [ Nat.dvd_prime_pow ] at this <;> norm_num at * ; aesop; )
    have hb : ∃ j : ℕ, b = 2^j := by
      have : b ∣ 2 ^ n := h.symm ▸ dvd_mul_left _ _; rw [ Nat.dvd_prime_pow ] at this <;> norm_num at * ; tauto;
    rcases ha with ⟨ i, rfl ⟩ ; rcases hb with ⟨ j, rfl ⟩ ; exact ⟨ i, j, rfl, rfl, Nat.pow_right_injective ( show 1 < 2 by decide ) <| by ring_nf at *; aesop ⟩ ;

/-
If `2^n` is formed by multiplication of `a` and `b`, and the complexity lower bound holds for smaller powers of 2, then the sum of complexities of `a` and `b` is at least `2n`.
-/
theorem mul_case_lower_bound (n : ℕ) (hn : 0 < n) (IH : ∀ k < n, complexity (2^k) ≥ 2 * k) :
  ∀ a b : ℕ, a > 1 → b > 1 → a * b = 2^n →
  complexity a + complexity b ≥ 2 * n := by
    intro a b ha hb hab
    obtain ⟨i, j, hi, hj, hsum⟩ : ∃ i j, a = 2^i ∧ b = 2^j ∧ i + j = n := pow_two_mul_decomposition hab;
    grind

/-
The complexity of `2^n` is at most `2n` for `n ≥ 1`.
-/
theorem complexity_pow_two_le (n : ℕ) (h : n ≥ 1) : complexity (2^n) ≤ 2 * n := by
  induction' h with k hk;
  · exact (by simpa using complexity_two_pow_bounded.left.le);
  · -- By the definition of complexity, we have `complexity (2^(k+1)) ≤ complexity 2 + complexity (2^k)`.
    have h_complexity_mul : complexity (2 ^ (k + 1)) ≤ complexity 2 + complexity (2 ^ k) := by
      -- By the definition of complexity, we have `complexity (2 * 2^k) ≤ complexity 2 + complexity (2^k)`.
      have h_complexity_mul : ∀ a b : ℕ, a > 0 → b > 0 → complexity (a * b) ≤ complexity a + complexity b := by
        intros a b ha hb
        have h_mul : Reachable (complexity a + complexity b) (a * b) := by
          apply Reachable.mul;
          · unfold complexity;
            grind;
          · convert Nat.find_spec ( exists_reachable b hb ) using 1;
            unfold complexity; aesop;
        unfold complexity at * ; aesop;
      simpa only [ pow_succ' ] using h_complexity_mul 2 ( 2 ^ k ) ( by decide ) ( by positivity );
    linarith! [ show complexity 2 = 2 from by rw [ show complexity 2 = complexity_computable 2 from by rw [ complexity_eq_complexity_computable ] ; decide ] ; native_decide ]