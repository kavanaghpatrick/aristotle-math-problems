/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 819cf573-4637-4278-b756-8c27c1977ab4

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined Leinster groups and proved that cyclic groups of perfect order are Leinster. We proved that if there are infinitely many perfect numbers, then there are infinitely many Leinster groups. We also exhibited specific examples: the cyclic group of order 6 and the non-abelian group D3 x Z5.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A finite group G is a Leinster group if the sum of the orders of all its normal subgroups equals twice the order of G.
-/
def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

/-
Checking IsCyclic and IsAddCyclic definitions.
-/
#check IsCyclic
#check IsAddCyclic

/-
Checking if IsCyclic transfers from AddGroup to Multiplicative Group.
-/
example (G : Type*) [AddGroup G] [IsAddCyclic G] : IsCyclic (Multiplicative G) := by infer_instance

/-
For a finite cyclic group G, the sum of the orders of its normal subgroups is equal to the sum of the divisors of the order of G.
-/
lemma sum_card_subgroup_eq_sigma_of_cyclic {G : Type*} [Group G] [Fintype G] [IsCyclic G] :
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = ∑ d ∈ Nat.divisors (Fintype.card G), d := by
  have h_bij : ∀ (d : ℕ), d ∣ Fintype.card G → ∃! H : Subgroup G, H.Normal ∧ Nat.card H = d := by
    have h_bij : ∀ (d : ℕ), d ∣ Fintype.card G → ∃ H : Subgroup G, H.Normal ∧ Nat.card H = d := by
      intro d hd
      obtain ⟨g, hg⟩ : ∃ g : G, orderOf g = d := by
        obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := G );
        use g ^ (Fintype.card G / d);
        rw [ orderOf_pow' ] <;> norm_num [ hd ];
        · rw [ orderOf_eq_card_of_forall_mem_zpowers hg ];
          simp +decide [ Nat.gcd_eq_right ( Nat.div_dvd_of_dvd hd ) ];
          rw [ Nat.div_div_self hd ( by aesop ) ];
        · exact ⟨ Nat.ne_of_gt ( Nat.pos_of_dvd_of_pos hd ( Fintype.card_pos ) ), Nat.le_of_dvd ( Fintype.card_pos ) hd ⟩;
      refine' ⟨ Subgroup.zpowers g, _, _ ⟩;
      · obtain ⟨ x, hx ⟩ := IsCyclic.exists_generator ( α := G );
        constructor;
        rintro _ ⟨ k, rfl ⟩ y; obtain ⟨ m, rfl ⟩ := hx y; group;
        obtain ⟨ n, rfl ⟩ := hx g; group; simp +decide [ zpow_mul ] ;
      · rw [ Nat.card_eq_fintype_card, Fintype.card_zpowers, hg ];
    have h_bij : ∀ (H K : Subgroup G), H.Normal → K.Normal → Nat.card H = Nat.card K → H = K := by
      intros H K hH hK h_card
      have h_eq : H = K := by
        have h_eq : ∀ (H : Subgroup G), H.Normal → ∀ (K : Subgroup G), K.Normal → Nat.card H = Nat.card K → H = K := by
          intros H hH K hK h_card
          have h_eq : ∀ (g : G), g ∈ H ↔ g ∈ K := by
            have h_cyclic : ∃ g : G, ∀ x : G, x ∈ Subgroup.zpowers g := by
              exact IsCyclic.exists_generator
            obtain ⟨ g, hg ⟩ := h_cyclic;
            have h_eq : ∀ (H : Subgroup G), H.Normal → ∃ d : ℕ, d ∣ Fintype.card G ∧ H = Subgroup.zpowers (g ^ (Fintype.card G / d)) := by
              intros H hH
              obtain ⟨d, hd⟩ : ∃ d : ℕ, d ∣ Fintype.card G ∧ H = Subgroup.zpowers (g ^ (Fintype.card G / d)) := by
                have h_subgroup : ∃ d : ℕ, H = Subgroup.zpowers (g ^ d) := by
                  have h_subgroup : ∃ d : ℕ, H = Subgroup.zpowers (g ^ d) := by
                    have h_subgroup : ∃ h : G, H = Subgroup.zpowers h := by
                      have h_subgroup : IsCyclic H := by
                        exact?;
                      obtain ⟨ h, hh ⟩ := h_subgroup.exists_generator;
                      use h.val;
                      ext x;
                      exact ⟨ fun hx => by obtain ⟨ n, hn ⟩ := hh ⟨ x, hx ⟩ ; exact ⟨ n, by simpa [ Subtype.ext_iff ] using hn ⟩, fun hx => by obtain ⟨ n, hn ⟩ := hx; exact hn.symm ▸ Subgroup.zpow_mem _ h.2 _ ⟩
                    obtain ⟨ h, rfl ⟩ := h_subgroup;
                    obtain ⟨ d, rfl ⟩ := hg h;
                    field_simp;
                    cases' Int.eq_nat_or_neg d with hd hd ; aesop;
                  exact h_subgroup
                obtain ⟨ d, rfl ⟩ := h_subgroup;
                refine' ⟨ Fintype.card G / Nat.gcd d ( Fintype.card G ), Nat.div_dvd_of_dvd ( Nat.gcd_dvd_right _ _ ), _ ⟩;
                rw [ Nat.div_div_self ] <;> norm_num [ Nat.gcd_dvd_left, Nat.gcd_dvd_right ];
                refine' le_antisymm _ _ <;> simp +decide [ Subgroup.zpowers_le ];
                · have h_subgroup : g ^ d = (g ^ (Nat.gcd d (Fintype.card G))) ^ (d / Nat.gcd d (Fintype.card G)) := by
                    rw [ ← pow_mul, Nat.mul_div_cancel' ( Nat.gcd_dvd_left _ _ ) ];
                  exact h_subgroup.symm ▸ Subgroup.pow_mem _ ( Subgroup.mem_zpowers _ ) _;
                · have := Nat.gcd_eq_gcd_ab d ( Fintype.card G );
                  simp +decide [ ← zpow_natCast, ← zpow_mul, this ];
                  simp +decide [ zpow_add, zpow_mul ];
              use d;
            obtain ⟨ d, hd₁, rfl ⟩ := h_eq H hH
            obtain ⟨ e, he₁, rfl ⟩ := h_eq K hK
            have h_eq_card : Fintype.card G / d = Fintype.card G / e := by
              simp_all +decide [ Nat.card_eq_fintype_card, Fintype.card_zpowers ];
              rw [ orderOf_pow, orderOf_pow ] at h_card;
              rw [ orderOf_eq_card_of_forall_mem_zpowers hg ] at h_card;
              simp_all +decide [ Nat.gcd_eq_right ( Nat.div_dvd_of_dvd hd₁ ), Nat.gcd_eq_right ( Nat.div_dvd_of_dvd he₁ ) ];
              rw [ Nat.div_div_self hd₁ ( by aesop ), Nat.div_div_self he₁ ( by aesop ) ] at h_card ; aesop;
            grind
          exact (by
          exact SetLike.ext h_eq);
        exact h_eq H hH K hK h_card
      exact h_eq;
    exact fun d hd => by obtain ⟨ H, hH₁, hH₂ ⟩ := ‹∀ d : ℕ, d ∣ Fintype.card G → ∃ H : Subgroup G, H.Normal ∧ Nat.card ↥H = d› d hd; exact ⟨ H, ⟨ hH₁, hH₂ ⟩, fun K hK => h_bij K H hK.1 hH₁ ( hK.2.trans hH₂.symm ) ⟩ ;
  choose! f hf₁ hf₂ using h_bij;
  -- By definition of $f$, we know that every normal subgroup of $G$ is of the form $f(d)$ for some divisor $d$ of $|G|$.
  have h_normal_subgroups : ∀ H : Subgroup G, H.Normal → ∃ d ∈ Nat.divisors (Fintype.card G), H = f d := by
    intro H hH
    obtain ⟨d, hd⟩ : ∃ d ∈ Nat.divisors (Fintype.card G), Nat.card H = d := by
      simpa using Subgroup.card_subgroup_dvd_card H;
    exact ⟨ d, hd.1, hf₂ d ( Nat.dvd_of_mem_divisors hd.1 ) H ⟨ hH, hd.2 ⟩ ⟩;
  have h_sum_eq : ∑ H ∈ Finset.filter (fun H : Subgroup G => H.Normal) (Finset.univ : Finset (Subgroup G)), Nat.card H = ∑ d ∈ Nat.divisors (Fintype.card G), Nat.card (f d) := by
    refine' Finset.sum_bij ( fun x hx => Nat.card x ) _ _ _ _ <;> simp +decide [ Finset.ext_iff ] at *;
    · exact fun H hH => by simpa using Subgroup.card_subgroup_dvd_card H;
    · intro H hH K hK h; obtain ⟨ d, hd₁, rfl ⟩ := h_normal_subgroups H hH; obtain ⟨ e, he₁, rfl ⟩ := h_normal_subgroups K hK; aesop;
    · exact fun d hd => ⟨ f d, hf₁ d hd |>.1, hf₁ d hd |>.2 ⟩;
    · intro H hH; obtain ⟨ d, hd₁, rfl ⟩ := h_normal_subgroups H hH; simp +decide [ hf₁ d hd₁ ] ;
  convert h_sum_eq using 1;
  · conv_rhs => rw [ ← Finset.sum_coe_sort ] ;
    refine' Finset.sum_bij ( fun x _ => ⟨ x, _ ⟩ ) _ _ _ _ <;> simp +decide;
    exact x.2;
  · exact Finset.sum_congr rfl fun x hx => hf₁ x ( Nat.dvd_of_mem_divisors hx ) |>.2.symm

/-
If n is a perfect number, then the cyclic group of order n is a Leinster group.
-/
lemma leinster_of_perfect (n : ℕ) [NeZero n] (hn : Nat.Perfect n) :
  IsLeinster (Multiplicative (ZMod n)) := by
  rw [IsLeinster]
  -- We know Multiplicative (ZMod n) is a cyclic group of order n
  have h_card : Fintype.card (Multiplicative (ZMod n)) = n := by
    rw [Fintype.card_congr (Multiplicative.toAdd), ZMod.card]
  rw [h_card]
  -- Apply the helper lemma for cyclic groups
  rw [sum_card_subgroup_eq_sigma_of_cyclic]
  -- Use the property of perfect numbers: sum of divisors is 2 * n
  rw [h_card]
  have h_perfect : ∑ d ∈ Nat.divisors n, d = 2 * n := by
    rw [Nat.perfect_iff_sum_divisors_eq_two_mul] at hn
    exact hn
    exact NeZero.pos n
  exact h_perfect

/-
Conditional on the existence of infinitely many perfect numbers, there are infinitely many Leinster groups.
-/
theorem infinitely_many_leinster_groups_conditional (h_inf_perfect : ∀ n, ∃ m ≥ n, Nat.Perfect m) :
    ¬∃ n : ℕ, ∀ G : Type, ∀ (_ : Group G) (_ : Fintype G),
      IsLeinster G → Fintype.card G < n := by
  push_neg
  intro n
  obtain ⟨m, hm_ge, hm_perf⟩ := h_inf_perfect n
  haveI : NeZero m := ⟨by
    have : 0 < m := hm_perf.2
    linarith⟩
  refine ⟨Multiplicative (ZMod m), inferInstance, inferInstance, ?_, ?_⟩
  · exact leinster_of_perfect m hm_perf
  · rw [Fintype.card_congr (Multiplicative.toAdd), ZMod.card]
    exact hm_ge

/-
The cyclic group of order 6 is a Leinster group.
-/
lemma leinster_zmod_6 : IsLeinster (Multiplicative (ZMod 6)) := by
  convert leinster_of_perfect 6 _;
  -- We can calculate the sum of the divisors of 6 directly.
  norm_cast

/-
If G and H have coprime orders, every subgroup of G × H is a product of subgroups.
-/
lemma subgroup_eq_prod_of_coprime {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H)) (K : Subgroup (G × H)) :
    ∃ (K₁ : Subgroup G) (K₂ : Subgroup H), K = K₁.prod K₂ := by
  -- By Lemma 25, every subgroup of G × H is a product of subgroups.
  have h_prod_subgroup : ∀ K : Subgroup (G × H), ∃ K₁ : Subgroup G, ∃ K₂ : Subgroup H, K = K₁.prod K₂ := by
    intro K
    use Subgroup.map (MonoidHom.fst G H) K, Subgroup.map (MonoidHom.snd G H) K;
    ext ⟨g, h⟩
    simp [Subgroup.mem_prod, Subgroup.mem_map];
    constructor <;> intro hgh;
    · exact ⟨ ⟨ h, hgh ⟩, ⟨ g, hgh ⟩ ⟩;
    · -- Since the orders of G and H are coprime, the order of any element in G is coprime to the order of any element in H. Therefore, (g, 1) and (1, h) are in K.
      have h_g1 : (g, 1) ∈ K := by
        -- Since the orders of G and H are coprime, the order of any element in G is coprime to the order of any element in H. Therefore, (g, 1) is in K.
        obtain ⟨x, hx⟩ := hgh.left
        have h_order_g : (g, x) ^ Fintype.card H = (g ^ Fintype.card H, 1) := by
          simp +decide [ Prod.ext_iff ];
        -- Since $g^{Fintype.card H}$ is in $K$ and $K$ is closed under taking powers, we have $(g, 1) \in K$.
        have h_g1 : (g ^ Fintype.card H, 1) ∈ K := by
          exact h_order_g ▸ K.pow_mem hx _;
        -- Since $g^{Fintype.card H}$ is in $K$ and $K$ is closed under taking powers, we have $(g, 1) \in K$ by definition of exponentiation.
        have h_g1_exp : ∃ k : ℕ, k * Fintype.card H ≡ 1 [MOD Fintype.card G] := by
          have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime.symm;
          rcases n : Fintype.card G with ( _ | _ | n ) <;> simp_all +decide [ mul_comm, Nat.ModEq ];
          exact ⟨ 0, by simp +decide ⟩;
        obtain ⟨ k, hk ⟩ := h_g1_exp;
        have h_g1_exp : (g ^ (k * Fintype.card H), 1) ∈ K := by
          convert K.pow_mem h_g1 k using 1 ; group;
          simp +decide [ zpow_mul' ];
        rw [ ← Nat.mod_add_div ( k * Fintype.card H ) ( Fintype.card G ), hk ] at h_g1_exp; simp_all +decide [ pow_add, pow_mul ] ;
      have h_1h : (1, h) ∈ K := by
        -- Since the orders of G and H are coprime, there exists some integer k such that k ≡ 1 (mod orderOf a) and k ≡ 0 (mod orderOf h).
        obtain ⟨k, hk⟩ : ∃ k : ℕ, k ≡ 1 [MOD orderOf (hgh.right.choose : G)] ∧ k ≡ 0 [MOD orderOf (h : H)] := by
          have h_coprime : Nat.Coprime (orderOf (hgh.right.choose : G)) (orderOf (h : H)) := by
            exact h_coprime.coprime_dvd_left ( orderOf_dvd_card ) |> Nat.Coprime.coprime_dvd_right ( orderOf_dvd_card );
          have := Nat.chineseRemainder h_coprime 1 0; aesop;
        -- Since $k \equiv 1 \pmod{\text{orderOf}(hgh.right.choose)}$, we have $(hgh.right.choose, h)^k = (hgh.right.choose^k, h^k) = (hgh.right.choose, 1)$.
        have h_k_pow : (hgh.right.choose, h)^k = (hgh.right.choose, 1) := by
          have h_k_pow : (hgh.right.choose : G)^k = hgh.right.choose ∧ h^k = 1 := by
            exact ⟨ by rw [ ← Nat.mod_add_div k ( orderOf ( hgh.2.choose : G ) ), hk.1 ] ; simp +decide [ pow_add, pow_mul, pow_orderOf_eq_one ], by rw [ ← Nat.mod_add_div k ( orderOf h ), hk.2 ] ; simp +decide [ pow_add, pow_mul, pow_orderOf_eq_one ] ⟩;
          aesop;
        have h_k_pow : (hgh.right.choose, h) ^ k ∈ K := by
          exact K.pow_mem ( hgh.2.choose_spec ) _;
        convert K.mul_mem ( K.inv_mem h_k_pow ) hgh.2.choose_spec using 1 ; aesop;
      simpa using K.mul_mem h_g1 h_1h;
  exact h_prod_subgroup K

/-
If G and H have coprime orders, every normal subgroup of G × H is a product of normal subgroups.
-/
lemma normal_subgroup_eq_prod_of_coprime {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H)) (K : Subgroup (G × H)) [hK : K.Normal] :
    ∃ (K₁ : Subgroup G) (K₂ : Subgroup H), K₁.Normal ∧ K₂.Normal ∧ K = K₁.prod K₂ := by
      -- By the lemma subgroup_eq_prod_of_coprime, we know that K = K₁ × K₂ for some subgroups K₁ of G and K₂ of H.
      obtain ⟨K₁, K₂, hK₁, hK₂⟩ : ∃ K₁ : Subgroup G, ∃ K₂ : Subgroup H, K = K₁.prod K₂ := by
        exact?;
      refine' ⟨ K₁, K₂, _, _, rfl ⟩;
      · constructor;
        intro n hn g
        have h_conj : (g * n * g⁻¹, 1) ∈ K₁.prod K₂ := by
          convert hK.conj_mem _ ( show ( n, 1 ) ∈ K₁.prod K₂ from ⟨ hn, K₂.one_mem ⟩ ) ( g, 1 ) using 1 ; simp +decide [ mul_assoc ];
        exact h_conj.1;
      · convert hK.comap ( MonoidHom.inr G H ) using 1;
        ext; simp [Subgroup.mem_prod, Subgroup.mem_comap]

/-
The sum of normal subgroup orders is multiplicative for coprime groups.
-/
lemma sum_normal_subgroup_prod_of_coprime {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H)) :
    ∑ K : {K : Subgroup (G × H) // K.Normal}, Nat.card K =
    (∑ N : {N : Subgroup G // N.Normal}, Nat.card N) * (∑ M : {M : Subgroup H // M.Normal}, Nat.card M) := by
      -- Let's express the sum over $G \times H$ as a product of sums over $G$ and $H$.
      have h_sum_product : ∑ K : {K : Subgroup (G × H) // K.Normal}, Nat.card K = ∑ N : {N : Subgroup G // N.Normal}, ∑ M : {M : Subgroup H // M.Normal}, Nat.card (N.val.prod M.val) := by
        have h_sum_product : ∀ K : {K : Subgroup (G × H) // K.Normal}, ∃ N : {N : Subgroup G // N.Normal}, ∃ M : {M : Subgroup H // M.Normal}, K.val = N.val.prod M.val := by
          rintro ⟨ K, hK ⟩;
          have := normal_subgroup_eq_prod_of_coprime h_coprime K;
          aesop;
        choose f g hfg using h_sum_product;
        have h_bij : ∀ N : {N : Subgroup G // N.Normal}, ∀ M : {M : Subgroup H // M.Normal}, ∃! K : {K : Subgroup (G × H) // K.Normal}, f K = N ∧ g K = M := by
          intro N M
          use ⟨N.val.prod M.val, by
            constructor;
            simp +decide [ Subgroup.mem_prod ];
            exact fun a b ha hb c d => ⟨ N.2.conj_mem _ ha _, M.2.conj_mem _ hb _ ⟩⟩
          generalize_proofs at *;
          refine' ⟨ ⟨ _, _ ⟩, _ ⟩;
          · specialize hfg ⟨ N.val.prod M.val, by assumption ⟩;
            simp_all +decide [ Subgroup.ext_iff ];
            ext a; specialize hfg a 1; simp_all +decide [ Subgroup.mem_prod ] ;
          · have := hfg ⟨ N.val.prod M.val, by assumption ⟩;
            simp +decide [ Subgroup.ext_iff ] at this ⊢;
            ext x; specialize this 1 x; simp +decide [ Subgroup.mem_prod ] at this ⊢; tauto;
          · rintro ⟨ K, hK ⟩ ⟨ rfl, rfl ⟩ ; exact Subtype.ext ( hfg _ );
        choose! K hK₁ hK₂ using h_bij;
        rw [ ← Finset.sum_product' ];
        refine' Finset.sum_bij ( fun x _ => ( f x, g x ) ) _ _ _ _ <;> simp +decide [ hK₁, hK₂ ];
        · grind;
        · exact fun N hN M hM => ⟨ _, K ⟨ N, hN ⟩ ⟨ M, hM ⟩ |>.2, hK₁ _ _ ⟩;
        · exact fun a b => by rw [ ← hfg ⟨ a, b ⟩ ] ;
      rw [ h_sum_product, Finset.sum_mul ];
      simp +decide [ Finset.mul_sum _ _ _, Nat.card_eq_fintype_card ];
      refine' Finset.sum_congr rfl fun N _ => Finset.sum_congr rfl fun M _ => _;
      rw [ Fintype.card_subtype, Fintype.card_subtype, Fintype.card_subtype ];
      rw [ ← Finset.card_product ] ; congr ; ext ; simp +decide [ Subgroup.mem_prod ] ;

/-
The product of subgroups is injective: N1 × M1 = N2 × M2 iff N1 = N2 and M1 = M2.
-/
lemma Subgroup.prod_inj {G H : Type*} [Group G] [Group H]
  (N1 N2 : Subgroup G) (M1 M2 : Subgroup H) :
  N1.prod M1 = N2.prod M2 ↔ N1 = N2 ∧ M1 = M2 := by
    simp +decide [ Subgroup.ext_iff, Set.ext_iff ];
    constructor <;> intro h <;> simp_all +decide [ Subgroup.mem_prod ];
    exact ⟨ fun x => by specialize h x 1; aesop, fun x => by specialize h 1 x; aesop ⟩

/-
The cardinality of the product of subgroups is the product of their cardinalities.
-/
lemma Subgroup.card_prod_eq {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
  (N : Subgroup G) (M : Subgroup H) :
  Nat.card (N.prod M) = Nat.card N * Nat.card M := by
  rw [Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]
  -- The type of N.prod M is isomorphic to N × M
  let e : N.prod M ≃ N × M :=
    { toFun := fun ⟨⟨g, h⟩, hgh⟩ => ⟨⟨g, (Subgroup.mem_prod.mp hgh).1⟩, ⟨h, (Subgroup.mem_prod.mp hgh).2⟩⟩
      invFun := fun ⟨⟨g, hg⟩, ⟨h, hh⟩⟩ => ⟨(g, h), Subgroup.mem_prod.mpr ⟨hg, hh⟩⟩
      left_inv := fun _ => rfl
      right_inv := fun _ => rfl }
  rw [Fintype.card_congr e]
  rw [Fintype.card_prod]

/-
The sum of normal subgroup orders is multiplicative for coprime groups.
-/
lemma sum_normal_subgroup_prod_of_coprime_eq {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H)) :
    ∑ K : {K : Subgroup (G × H) // K.Normal}, Nat.card K =
    (∑ N : {N : Subgroup G // N.Normal}, Nat.card N) * (∑ M : {M : Subgroup H // M.Normal}, Nat.card M) := by
      exact?

/-
The product of coprime groups is Leinster if the product of their Leinster sums is twice the product of their orders.
-/
lemma leinster_prod_of_coprime {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H))
    (h_ratio : (∑ N : {N : Subgroup G // N.Normal}, Nat.card N) * (∑ M : {M : Subgroup H // M.Normal}, Nat.card M) = 2 * (Fintype.card G * Fintype.card H)) :
    IsLeinster (G × H) := by
      -- By definition of IsLeinster, we need to show that the sum of the orders of the normal subgroups of G × H equals twice the order of G × H.
      unfold IsLeinster;
      convert sum_normal_subgroup_prod_of_coprime_eq h_coprime using 1;
      aesop

/-
The sum of orders of normal subgroups of D3 is 10.
-/
lemma sum_normal_subgroup_dihedral_3 :
  ∑ N : {N : Subgroup (DihedralGroup 3) // N.Normal}, Nat.card N = 10 := by
  -- The normal subgroups of D3 are {1}, A3 (rotations), and D3.
  -- Their orders are 1, 3, and 6.
  -- Sum = 1 + 3 + 6 = 10.
  -- The normal subgroups of $D_3$ are the trivial subgroup, the subgroup generated by $r$, and the entire group.
  have h_normal_subgroups : { N : Subgroup (DihedralGroup 3) | N.Normal } = {⊥, Subgroup.closure {DihedralGroup.r 1}, ⊤} := by
    ext N
    simp;
    constructor;
    · intro hN
      have h_order : Fintype.card N = 1 ∨ Fintype.card N = 3 ∨ Fintype.card N = 6 := by
        have := Subgroup.card_subgroup_dvd_card N; simp_all +decide [ Nat.dvd_prime ] ;
        have : Fintype.card N ≤ 6 := Nat.le_of_dvd ( by decide ) this; interval_cases _ : Fintype.card N <;> simp_all +decide ;
        -- If $N$ has order 2, then it must be generated by an element of order 2.
        obtain ⟨g, hg⟩ : ∃ g : DihedralGroup 3, g ∈ N ∧ orderOf g = 2 := by
          have := exists_prime_orderOf_dvd_card 2 ( by rw [ ‹Fintype.card N = 2› ] ) ; aesop;
        -- Since $N$ is normal, it must contain all conjugates of $g$.
        have h_conjugates : ∀ h : DihedralGroup 3, h * g * h⁻¹ ∈ N := by
          exact fun h => hN.conj_mem _ hg.1 h;
        have h_conjugates_card : Finset.card (Finset.image (fun h : DihedralGroup 3 => h * g * h⁻¹) Finset.univ) = 3 := by
          fin_cases g <;> simp +decide at hg ⊢;
          · simp_all +decide [ orderOf_eq_iff ];
          · simp_all +decide [ orderOf_eq_iff ];
          · simp_all +decide [ orderOf_eq_iff ];
        have h_conjugates_subset : Finset.image (fun h : DihedralGroup 3 => h * g * h⁻¹) Finset.univ ⊆ Finset.filter (fun x => x ∈ N) Finset.univ := by
          exact Finset.image_subset_iff.mpr fun h _ => by simpa using h_conjugates h;
        have := Finset.card_le_card h_conjugates_subset; simp_all +decide ;
        simp_all +decide [ Fintype.card_subtype ];
      rcases h_order with ( h | h | h );
      · simp_all +decide [ Fintype.card_eq_one_iff, Subgroup.eq_bot_iff_forall ];
        exact Or.inl fun x hx => h.choose_spec.2 x hx ▸ h.choose_spec.2 1 ( N.one_mem ) ▸ rfl;
      · -- Since $N$ is a subgroup of $D_3$ with order 3, it must be cyclic and generated by an element of order 3.
        obtain ⟨g, hg⟩ : ∃ g : DihedralGroup 3, orderOf g = 3 ∧ N = Subgroup.zpowers g := by
          have h_cyclic : IsCyclic N := by
            exact isCyclic_of_prime_card ( by aesop );
          obtain ⟨ g, hg ⟩ := h_cyclic.exists_generator;
          refine' ⟨ g, _, _ ⟩;
          · have := orderOf_eq_card_of_forall_mem_zpowers hg; aesop;
          · ext x;
            exact ⟨ fun hx => by obtain ⟨ k, hk ⟩ := hg ⟨ x, hx ⟩ ; exact ⟨ k, by simpa [ Subtype.ext_iff ] using hk ⟩, fun hx => by obtain ⟨ k, hk ⟩ := hx; exact hk.symm ▸ Subgroup.zpow_mem _ g.2 _ ⟩;
        fin_cases g <;> simp_all +decide [ orderOf_eq_iff ];
        · simp +decide [ Subgroup.zpowers_eq_closure ];
          exact Or.inl rfl;
        · refine' Or.inl ( le_antisymm _ _ );
          · simp +decide [ Subgroup.zpowers_le ];
            exact Subgroup.mem_closure_singleton.mpr ⟨ 2, by rfl ⟩;
          · simp +decide [ Subgroup.closure_le, Set.singleton_subset_iff ];
            exact ⟨ 2, by decide ⟩;
      · have := Subgroup.card_mul_index N; simp_all +decide ;
        have := Nat.le_of_lt_succ ( show N.index < 7 by linarith [ show Fintype.card ( DihedralGroup 3 ) = 6 by rfl ] ) ; interval_cases _ : N.index <;> simp_all +decide ;
    · rintro ( rfl | rfl | rfl );
      · infer_instance;
      · constructor;
        simp +decide [ Subgroup.mem_closure_singleton ];
        rintro a ⟨ ⟩ <;> simp +decide [ DihedralGroup.r_mul_r ];
        exact ⟨ -a, by simp +decide ⟩;
      · infer_instance;
  -- Let's calculate the cardinality of each normal subgroup.
  have h_card_subgroups : Nat.card (⊥ : Subgroup (DihedralGroup 3)) = 1 ∧ Nat.card (Subgroup.closure {DihedralGroup.r 1} : Subgroup (DihedralGroup 3)) = 3 ∧ Nat.card (⊤ : Subgroup (DihedralGroup 3)) = 6 := by
    rw [ show ( Subgroup.closure { DihedralGroup.r 1 } : Subgroup ( DihedralGroup 3 ) ) = Subgroup.zpowers ( DihedralGroup.r 1 ) by simp +decide [ Subgroup.zpowers_eq_closure ] ] ; simp +decide [ Fintype.card_zpowers ] ;
  -- Let's calculate the sum of the orders of the normal subgroups.
  have h_sum : ∑ N : { N : Subgroup (DihedralGroup 3) | N.Normal }, Nat.card (N : Subgroup (DihedralGroup 3)) = 1 + 3 + 6 := by
    have h_sum : ∑ N : { N : Subgroup (DihedralGroup 3) | N.Normal }, Nat.card (N : Subgroup (DihedralGroup 3)) = ∑ N ∈ ({⊥, Subgroup.closure {DihedralGroup.r 1}, ⊤} : Finset (Subgroup (DihedralGroup 3))), Nat.card N := by
      refine' Finset.sum_bij ( fun N _ => N ) _ _ _ _ <;> simp +decide [ h_normal_subgroups ];
      · exact fun N hN => by simpa using Set.ext_iff.mp h_normal_subgroups N |>.1 hN;
      · exact ⟨ by infer_instance, by exact h_normal_subgroups.symm.subset ( by simp +decide ), by infer_instance ⟩;
    rw [ h_sum, Finset.sum_insert, Finset.sum_insert ] <;> simp +decide [ h_card_subgroups ];
    · simp_all +decide [ Nat.card_eq_fintype_card ];
    · aesop;
    · exact Ne.symm ( by intro h; have := h_card_subgroups.2.1; simp_all +decide );
  convert h_sum using 1

/-
The sum of orders of normal subgroups of ZMod 5 is 6.
-/
lemma sum_normal_subgroup_zmod_5 :
  ∑ N : {N : Subgroup (Multiplicative (ZMod 5)) // N.Normal}, Nat.card N = 6 := by
    convert sum_card_subgroup_eq_sigma_of_cyclic using 8 ;
    exact inferInstance

/-
The group D3 × ZMod 5 is a Leinster group.
-/
lemma leinster_d3_prod_zmod5 : IsLeinster (DihedralGroup 3 × Multiplicative (ZMod 5)) := by
  -- Apply `leinster_prod_of_coprime`.
  apply leinster_prod_of_coprime;
  · native_decide +revert;
  · rw [ sum_normal_subgroup_dihedral_3, sum_normal_subgroup_zmod_5 ] ; decide