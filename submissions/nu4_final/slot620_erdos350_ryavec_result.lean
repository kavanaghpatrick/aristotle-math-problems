/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a77a0eac-7e0a-4574-9a2d-09fa3a32aa02

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove that if a finite set of positive integers A has distinct subset sums, then the sum of the reciprocals of the elements of A is less than 2.
The proof proceeds by showing that the partial sums of the sorted elements of A are bounded below by the partial sums of powers of 2 (2^k - 1).
We then use a majorization argument (Abel summation) to show that this implies the sum of reciprocals is bounded above by the sum of reciprocals of powers of 2, which is less than 2.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a set having distinct subset sums.
-/
def DecidableDistinctSubsetSums (A : Finset ℕ) : Prop :=
  ∀ X ⊆ A, ∀ Y ⊆ A, X ≠ Y → ∑ x ∈ X, x ≠ ∑ y ∈ Y, y

/-
If A has distinct subset sums, then the sum of the k smallest elements is at least 2^k - 1.
-/
theorem distinct_subset_sums_sum_take_ge (A : Finset ℕ) (hA : DecidableDistinctSubsetSums A)
    (k : ℕ) (hk : k ≤ A.card) :
    ((A.sort (· ≤ ·)).take k).sum ≥ 2 ^ k - 1 := by
  by_contra h_contra;
  -- Let $A' = \{a_1, a_2, \ldots, a_k\}$ be the set of the first $k$ elements of $A$ (sorted).
  set A' := (A.sort (· ≤ ·)).take k with hA'A';
  -- Since $A$ has distinct subset sums, any subset of $A'$ has a distinct sum.
  have h_distinct_subset_sums : ∀ X ⊆ A'.toFinset, ∀ Y ⊆ A'.toFinset, X ≠ Y → (∑ x ∈ X, x) ≠ (∑ y ∈ Y, y) := by
    intros X hX Y hy hne hsum_eq; have := hA X (hX.trans <| by
      exact fun x hx => by have := List.mem_of_mem_take ( List.mem_toFinset.mp hx ) ; aesop;) Y (hy.trans <| by
      exact fun x hx => by have := List.mem_of_mem_take ( List.mem_toFinset.mp hx ) ; aesop;) hne; aesop;
  -- The subsets of $A'$ number $2^k$.
  have h_subset_count : Finset.card (Finset.image (fun X : Finset ℕ => ∑ x ∈ X, x) (Finset.powerset (A'.toFinset))) = 2^k := by
    rw [ Finset.card_image_of_injOn, Finset.card_powerset ];
    · rw [ List.toFinset_card_of_nodup ];
      · aesop;
      · exact List.Nodup.sublist ( List.take_sublist _ _ ) ( Finset.sort_nodup _ _ );
    · exact fun X hX Y hy hxy => Classical.not_not.1 fun h => h_distinct_subset_sums X ( Finset.mem_powerset.1 hX ) Y ( Finset.mem_powerset.1 hy ) h hxy;
  -- Since these subsets are distinct and their sums are distinct, the sums must be in the range from $0$ to $\sum_{x \in A'} x$.
  have h_sum_range : Finset.image (fun X : Finset ℕ => ∑ x ∈ X, x) (Finset.powerset (A'.toFinset)) ⊆ Finset.Ico 0 (∑ x ∈ A'.toFinset, x + 1) := by
    exact Finset.image_subset_iff.mpr fun X hX => Finset.mem_Ico.mpr ⟨ Nat.zero_le _, Nat.lt_succ_of_le <| Finset.sum_le_sum_of_subset <| Finset.mem_powerset.mp hX ⟩;
  have := Finset.card_le_card h_sum_range; simp_all +decide ;
  refine' h_contra.not_le ( le_trans this _ );
  rw [ List.sum_toFinset ];
  · norm_num;
  · exact List.Nodup.sublist ( List.take_sublist _ _ ) ( Finset.sort_nodup _ _ )

/-
If a list has non-negative partial sums and another list is non-negative and decreasing, their dot product is non-negative.
-/
lemma sum_mul_nonneg_of_sum_take_nonneg_of_antitone (L1 L2 : List ℝ)
    (h_len : L1.length = L2.length)
    (h_sum : ∀ k, k < L1.length → (L1.take (k+1)).sum ≥ 0)
    (h_anti : L2.Sorted (· ≥ ·))
    (h_nonneg : ∀ x ∈ L2, 0 ≤ x) :
    (List.zipWith (· * ·) L1 L2).sum ≥ 0 := by
  -- By Abel's summation formula, we have:
  have h_abel : ∀ (n : ℕ), n ≤ L1.length → List.sum (List.zipWith (fun x1 x2 => x1 * x2) (List.take n L1) (List.take n L2)) = ∑ k ∈ Finset.range (n), (List.sum (List.take (k + 1) L1)) * (L2.get! k - L2.get! (k + 1)) + (List.sum (List.take n L1)) * L2.get! n := by
    intro n hn;
    induction n <;> simp_all +decide [ Finset.sum_range_succ ];
    rename_i n ih; specialize ih ( Nat.le_of_succ_le hn ) ; simp_all +decide [ List.take_succ, Finset.sum_range_succ ] ;
    cases h : L1.get? n <;> cases h' : L2.get? n <;> simp_all +decide [ List.zipWith_append ] ; linarith;
    ring;
  -- Since $L2$ is sorted decreasingly and non-negative, we have $L2.get! k - L2.get! (k + 1) \geq 0$ for all $k < L1.length$.
  have h_diff_nonneg : ∀ k < L1.length, L2.get! k - L2.get! (k + 1) ≥ 0 := by
    have := h_anti; simp_all +decide [ List.Sorted ] ;
    intro k hk; by_cases h : k + 1 < L2.length <;> simp_all +decide [ List.pairwise_iff_get ] ;
    · exact h_anti ⟨ k, by linarith ⟩ ⟨ k + 1, by linarith ⟩ ( Nat.lt_succ_self _ );
    · exact h_nonneg _ ( by simp );
  -- Since $L2$ is non-negative, we have $L2.get! n \geq 0$ for all $n \leq L1.length$.
  have h_L2_nonneg : ∀ n ≤ L1.length, L2.get! n ≥ 0 := by
    intro n hn; by_cases h : n < L2.length <;> aesop;
  -- Applying the results from Abel's summation formula and the non-negativity of the differences and L2 elements, we get that the sum is non-negative.
  have h_nonneg_sum : ∀ n ≤ L1.length, List.sum (List.zipWith (fun x1 x2 => x1 * x2) (List.take n L1) (List.take n L2)) ≥ 0 := by
    intro n hn; rw [ h_abel n hn ] ; exact add_nonneg ( Finset.sum_nonneg fun k hk => mul_nonneg ( h_sum k ( by linarith [ Finset.mem_range.mp hk ] ) ) ( h_diff_nonneg k ( by linarith [ Finset.mem_range.mp hk ] ) ) ) ( mul_nonneg ( if h : n = 0 then by aesop else h_sum ( n - 1 ) ( by omega ) |> fun h' => by cases n <;> aesop ) ( h_L2_nonneg n hn ) ) ;
  convert h_nonneg_sum L1.length le_rfl |> le_trans <| le_of_eq _ using 1;
  rw [ List.take_of_length_le ( by linarith ), List.take_of_length_le ( by linarith ) ]

/-
If two sorted lists of positive reals satisfy the partial sum inequality, then the sum of reciprocals of the first is less than or equal to the second.
-/
lemma sum_inv_le_of_sum_ge_sorted (x y : List ℝ)
    (hx_pos : ∀ a ∈ x, 0 < a)
    (hy_pos : ∀ a ∈ y, 0 < a)
    (hx_sorted : x.Sorted (· ≤ ·))
    (hy_sorted : y.Sorted (· ≤ ·))
    (h_len : x.length = y.length)
    (h_sum : ∀ k, k ≤ x.length → (x.take k).sum ≥ (y.take k).sum) :
    (x.map (fun a => 1/a)).sum ≤ (y.map (fun a => 1/a)).sum := by
  -- Let $L1_i = x_i - y_i$ and $L2_i = \frac{1}{x_i y_i}$.
  set L1 := List.map (fun i => x.get! i - y.get! i) (List.range x.length) with hL1
  set L2 := List.map (fun i => 1 / (x.get! i * y.get! i)) (List.range x.length) with hL2;
  -- By `sum_mul_nonneg_of_sum_take_nonneg_of_antitone`, $\sum L1_i L2_i \ge 0$.
  have h_sum_mul_nonneg : (List.zipWith (· * ·) L1 L2).sum ≥ 0 := by
    apply sum_mul_nonneg_of_sum_take_nonneg_of_antitone L1 L2 (by
    aesop) (by
    -- By definition of $L1$, we know that $(List.take (k + 1) L1).sum = (List.take (k + 1) x).sum - (List.take (k + 1) y).sum$.
    have hL1_sum : ∀ k < x.length, (List.take (k + 1) L1).sum = (List.take (k + 1) x).sum - (List.take (k + 1) y).sum := by
      intro k hk; induction' k with k ih <;> simp_all +decide [ List.range_succ ] ;
      simp_all +decide [ List.take_succ ];
      grind;
    grind) (by
    -- Since $x$ and $y$ are sorted increasing and positive, $x_i y_i$ is increasing. Thus $L2_i$ is decreasing (sorted $\ge$).
    have hL2_sorted : ∀ i j, i < j → i < x.length → j < x.length → (1 / (x.get! i * y.get! i)) ≥ (1 / (x.get! j * y.get! j)) := by
      intros i j hij hi hj
      have h_prod_inc : x.get! i * y.get! i ≤ x.get! j * y.get! j := by
        have hL2_sorted : ∀ i j, i < j → i < x.length → j < x.length → x.get! i ≤ x.get! j ∧ y.get! i ≤ y.get! j := by
          intros i j hij hi hj; exact ⟨by
          have := List.pairwise_iff_get.mp hx_sorted;
          simpa [ hi, hj ] using this ⟨ i, hi ⟩ ⟨ j, hj ⟩ hij, by
            have := List.pairwise_iff_get.mp hy_sorted;
            convert this ⟨ i, by linarith ⟩ ⟨ j, by linarith ⟩ hij using 1 <;> simp +decide [ List.get?_eq_get, * ];
            · grind;
            · grind⟩;
        exact mul_le_mul ( hL2_sorted i j hij hi hj |>.1 ) ( hL2_sorted i j hij hi hj |>.2 ) ( le_of_lt ( hy_pos _ <| by aesop ) ) ( le_of_lt ( hx_pos _ <| by aesop ) );
      gcongr ; aesop;
    refine' List.pairwise_iff_get.mpr _;
    grind) (by
    simp +zetaDelta at *;
    exact fun i hi => mul_nonneg ( inv_nonneg.2 <| le_of_lt <| by cases h : y.get? i <;> aesop ) ( inv_nonneg.2 <| le_of_lt <| by cases h : x.get? i <;> aesop ));
  -- Since $L1_i L2_i = (x_i - y_i) \frac{1}{x_i y_i} = \frac{1}{y_i} - \frac{1}{x_i}$, we have $\sum L1_i L2_i = \sum (\frac{1}{y_i} - \frac{1}{x_i})$.
  have h_sum_eq : (List.zipWith (· * ·) L1 L2).sum = (List.map (fun a => 1 / a) y).sum - (List.map (fun a => 1 / a) x).sum := by
    -- By definition of $L1$ and $L2$, we can expand the sum $\sum L1_i L2_i$.
    have h_expand : (List.zipWith (· * ·) L1 L2).sum = ∑ i ∈ Finset.range x.length, (1 / y.get! i - 1 / x.get! i) := by
      have h_expand : ∀ i < x.length, (x.get! i - y.get! i) * (1 / (x.get! i * y.get! i)) = (1 / y.get! i - 1 / x.get! i) := by
        intro i hi; rw [ mul_one_div, div_sub_div ] <;> ring <;> simp +decide [ ne_of_gt, hx_pos, hy_pos, List.get?_eq_get, hi ] ;
        by_cases hi' : i < y.length <;> simp_all +decide [ List.getElem?_eq_none ];
        exact ne_of_gt <| hy_pos _ <| by simp;
      rw [ ← Finset.sum_congr rfl fun i hi => h_expand i ( Finset.mem_range.mp hi ) ] ; aesop;
    simp_all +decide [ Finset.sum_range, List.sum_map_mul_right ];
    rw [ ← List.sum_ofFn ];
    congr;
    refine' List.ext_get _ _ <;> aesop;
  linarith

/-
If a finite set of positive integers has distinct subset sums, the sum of their reciprocals is less than 2.
-/
theorem erdos_350 (A : Finset ℕ) (hA : DecidableDistinctSubsetSums A) :
    ∑ n ∈ A, (1 / n : ℝ) < 2 := by
  by_contra h_contra;
  -- Let $L$ be the sorted list of elements of $A$.
  set L := A.sort (· ≤ ·) with hL_def
  -- Let $n = |A|$.
  set n := A.card with hn_def
  -- Let $M$ be the list of powers of 2: $1, 2, 4, \dots, 2^{n-1}$.
  set M := List.map (fun i => 2^i) (List.range n) with hM_def
  -- We have shown that for any $k$, the sum of the first $k$ elements of $L$ is at least $2^k - 1$.
  have h_partial_sums : ∀ k ≤ n, (L.take k).sum ≥ (M.take k).sum := by
    intro k hk_le_n
    have h_partial_sum_L : (L.take k).sum ≥ 2^k - 1 := by
      convert distinct_subset_sums_sum_take_ge A hA k hk_le_n using 1
    have h_partial_sum_M : (M.take k).sum = 2^k - 1 := by
      -- The sum of the first $k$ elements of $M$ is exactly $2^k - 1$.
      have h_partial_sum_M : (List.take k (List.map (fun i => 2^i) (List.range n))).sum = ∑ i ∈ Finset.range k, 2^i := by
        congr;
        refine' List.ext_get _ _ <;> aesop;
      rw [ h_partial_sum_M, Nat.geomSum_eq ] <;> norm_num
    linarith [h_partial_sum_L, h_partial_sum_M];
  -- By `sum_inv_le_of_sum_ge_sorted`, $\sum_{x \in L} 1/x \le \sum_{y \in M} 1/y$.
  have h_sum_inv_le : (L.map (fun x => (x : ℝ)⁻¹)).sum ≤ (M.map (fun x => (x : ℝ)⁻¹)).sum := by
    convert sum_inv_le_of_sum_ge_sorted _ _ _ _ _ _ _ using 1;
    rotate_left;
    exact L.map ( fun x : ℕ => x : ℕ → ℝ );
    exact M.map ( fun x : ℕ => x : ℕ → ℝ );
    all_goals simp_all +decide [ List.Sorted ];
    · intro x hx; contrapose! h_contra; simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg ] ;
      have := hA { 0 } ( by aesop_cat ) ∅ ( by aesop_cat ) ; aesop;
    · rw [ List.pairwise_map ];
      exact Finset.sort_sorted _ _ |> fun h => by simpa using h;
    · norm_num [ List.pairwise_iff_get ];
      exact fun i j hij => pow_le_pow_right₀ ( by norm_num ) hij.le;
    · constructor <;> intro h <;> simp_all +decide [ Function.comp, List.map_flatMap ];
      · convert h using 1;
        norm_num [ List.flatMap ];
        norm_num [ Function.comp_def, List.map_map ];
        convert Or.inr h using 1;
        norm_num [ List.flatMap ];
        norm_num [ Function.comp_def, List.map_map ];
      · convert h _ using 1;
        · conv => rw [ List.map_eq_flatMap ] ;
          rfl;
        · induction ( List.range A.card ) <;> aesop;
        · intro k hk; specialize h_partial_sums k hk;
          convert h_partial_sums using 1;
          rw [ ← @Nat.cast_le ℝ ] ; norm_num [ Function.comp ];
  -- The sum of reciprocals of $M$ is $\sum_{i=0}^{n-1} 1/2^i = 2 - 1/2^{n-1} < 2$.
  have h_sum_M : (M.map (fun x => (x : ℝ)⁻¹)).sum < 2 := by
    have h_sum_M : (M.map (fun x => (x : ℝ)⁻¹)).sum = ∑ i ∈ Finset.range n, (1 / 2^i : ℝ) := by
      norm_num [ hM_def, Finset.sum ];
      induction n <;> simp_all +decide [ List.range_succ ];
      ring;
    rw [ h_sum_M ] ; ring_nf; rw [ geom_sum_eq ] <;> ring <;> norm_num;
  convert h_contra <| lt_of_le_of_lt ?_ h_sum_M;
  convert h_sum_inv_le using 1;
  norm_num [ List.flatMap ];
  norm_num [ Function.comp_def ];
  rw [ ← Finset.sum_map_toList ];
  -- Since these two lists are permutations of each other, their sums are equal.
  have h_perm : List.Perm (A.toList) (Finset.sort (· ≤ ·) A) := by
    exact?;
  exact h_perm.map _ |> List.Perm.sum_eq