/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f4a15567-e973-4e8e-9b04-37357100e7d6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formally verified Carmichael's Totient Conjecture for all integers n < 10000.
Additionally, we have proven the conjecture for two infinite families of integers:
1. All odd positive integers.
2. All even integers of the form 2m where m is an odd integer greater than 1.

The main results are:
- `carmichael_bounded_10000_verified`: For every positive integer n < 10000, there exists m ≠ n such that φ(m) = φ(n).
- `carmichael_holds_for_odd`: The conjecture holds for all odd positive integers.
- `carmichael_holds_for_twice_odd`: The conjecture holds for all even integers of the form 2m where m is an odd integer greater than 1.
- `carmichael_partial_result`: Combines the above structural results.

The bounded verification was achieved by implementing an optimized check function `check_carmichael_optimized` that pre-computes totient values, proving its correctness in `check_carmichael_optimized_correct`, and executing it using `native_decide`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.totient_mul
#check Nat.totient_two

/-
If m is odd, then φ(2m) = φ(m).
-/
theorem totient_double_odd (m : ℕ) (hm : Odd m) : Nat.totient (2 * m) = Nat.totient m := by
  rw [ Nat.totient_mul ];
  · norm_num [ Nat.totient_prime ];
  · rcases hm with ⟨ k, rfl ⟩ ; norm_num

/-
For every odd positive integer n, there exists m ≠ n such that φ(m) = φ(n).
-/
theorem carmichael_odd (n : ℕ) (hn : 0 < n) (hodd : Odd n) : ∃ m, m ≠ n ∧ Nat.totient m = Nat.totient n := by
  exact ⟨ 2 * n, by linarith, totient_double_odd n hodd ⟩

/-
If m is an odd integer greater than 1, then there exists k ≠ 2m such that φ(k) = φ(2m).
-/
theorem carmichael_twice_odd (m : ℕ) (hm_odd : Odd m) (hm_gt_1 : 1 < m) :
    ∃ k, k ≠ 2 * m ∧ Nat.totient k = Nat.totient (2 * m) := by
      -- By the theorem totient_double_odd, since m is odd, we have φ(2m) = φ(m).
      have h_eq : Nat.totient (2 * m) = Nat.totient m := by
        exact?;
      exact ⟨ m, by linarith, h_eq.symm ⟩

/-
For every positive integer n < 1000, there exists m < 5000 such that m ≠ n and φ(m) = φ(n).
-/
def check_carmichael_range (n_max search_limit : ℕ) : Bool :=
  (List.range n_max).all fun n =>
    if n == 0 then true else
    (List.range search_limit).any fun m => m != n ∧ Nat.totient m == Nat.totient n

theorem carmichael_bounded_1000 : check_carmichael_range 1000 5000 = true := by native_decide

/-
If m is odd and there exists k ≠ 4m such that φ(k) = 2φ(m), then Carmichael's conjecture holds for n = 4m.
-/
theorem carmichael_4m_reduction (m : ℕ) (hm_odd : Odd m) (h_exists : ∃ k, k ≠ 4 * m ∧ Nat.totient k = 2 * Nat.totient m) :
    ∃ k, k ≠ 4 * m ∧ Nat.totient k = Nat.totient (4 * m) := by
      rw [ Nat.totient_mul ] ; aesop;
      obtain ⟨ k, rfl ⟩ := hm_odd; exact Nat.Coprime.pow_left 2 ( Nat.prime_two.coprime_iff_not_dvd.mpr <| by norm_num [ Nat.dvd_add_right ] ) ;

/-
A number n has the Carmichael property if there exists a number m ≠ n such that φ(m) = φ(n).
-/
def CarmichaelProperty (n : ℕ) : Prop := ∃ m, m ≠ n ∧ Nat.totient m = Nat.totient n

/-
The Carmichael property holds for all odd positive integers.
-/
theorem carmichael_holds_for_odd (n : ℕ) (hn : 0 < n) (hodd : Odd n) : CarmichaelProperty n := by
  -- Apply the theorem `carmichael_odd` to find such an `m`.
  apply carmichael_odd n hn hodd

/-
The Carmichael property holds for all even integers of the form 2m where m is an odd integer greater than 1.
-/
theorem carmichael_holds_for_twice_odd (m : ℕ) (hm_odd : Odd m) (hm_gt_1 : 1 < m) : CarmichaelProperty (2 * m) := by
  obtain ⟨ k, hk₁, hk₂ ⟩ := carmichael_twice_odd m hm_odd hm_gt_1; exact ⟨ k, by contrapose! hk₁; linarith, hk₂ ⟩ ;

/-
The Carmichael property holds for any integer n that is either odd, or of the form 2m where m is an odd integer greater than 1.
-/
theorem carmichael_partial_result (n : ℕ) (hn : 0 < n) (h : Odd n ∨ (∃ m, n = 2 * m ∧ Odd m ∧ 1 < m)) : CarmichaelProperty n := by
  exact h.elim ( fun h => carmichael_holds_for_odd n hn h ) fun ⟨ m, hm₁, hm₂, hm₃ ⟩ => hm₁.symm ▸ carmichael_holds_for_twice_odd m hm₂ hm₃

/-
If `check_carmichael_range` returns true, then for every positive integer n < n_max, there exists a partner m < search_limit.
-/
theorem check_carmichael_range_correct (n_max search_limit : ℕ)
    (h : check_carmichael_range n_max search_limit = true) :
    ∀ n, n < n_max → 0 < n → ∃ m, m < search_limit ∧ m ≠ n ∧ Nat.totient m = Nat.totient n := by
      unfold check_carmichael_range at h;
      simp +zetaDelta at *;
      exact fun n hn hn' => Or.resolve_left ( h n hn ) hn'.ne'

/-
For every positive integer n < 2000, there exists m < 5000 such that m ≠ n and φ(m) = φ(n).
-/
def check_carmichael_optimized (n_max search_limit : ℕ) : Bool :=
  let totients := (Array.range search_limit).map Nat.totient
  (List.range n_max).all fun n =>
    if n == 0 then true else
    let phi_n := totients.get! n
    (List.range search_limit).any fun m => m != n ∧ totients.get! m == phi_n

theorem carmichael_bounded_2000_optimized : check_carmichael_optimized 2000 5000 = true := by native_decide

/-
For every positive integer n < 10000, there exists m < 20000 such that m ≠ n and φ(m) = φ(n).
-/
theorem carmichael_bounded_10000_optimized : check_carmichael_optimized 10000 20000 = true := by native_decide

/-
For any k less than the search limit, the k-th element of the precomputed totient array is equal to φ(k).
-/
theorem totients_get_eq (search_limit k : ℕ) (hk : k < search_limit) :
    ((Array.range search_limit).map Nat.totient).get! k = Nat.totient k := by
      -- Since the array is constructed by mapping Nat.totient over the range of search_limit, the element at index k is indeed Nat.totient k.
      simp [Array.get!];
      rw [ Array.getElem?_range ] ; aesop

/-
If `check_carmichael_optimized` returns true and `n_max ≤ search_limit`, then for every positive integer n < n_max, there exists a partner m < search_limit.
-/
theorem check_carmichael_optimized_correct (n_max search_limit : ℕ)
    (h_le : n_max ≤ search_limit)
    (h : check_carmichael_optimized n_max search_limit = true) :
    ∀ n, n < n_max → 0 < n → ∃ m, m < search_limit ∧ m ≠ n ∧ Nat.totient m = Nat.totient n := by
      intro n hn hn_pos
      obtain ⟨k, hk⟩ : ∃ k < search_limit, k ≠ n ∧ ((Array.range search_limit).map Nat.totient).get! k = ((Array.range search_limit).map Nat.totient).get! n := by
        unfold check_carmichael_optimized at h;
        rw [ List.all_eq_true ] at h;
        specialize h n ( List.mem_range.mpr hn ) ; aesop;
      use k;
      convert hk using 1;
      simp +decide [ Array.get! ];
      grind

/-
For every positive integer n < 10000, the Carmichael property holds.
-/
theorem carmichael_bounded_10000_verified (n : ℕ) (hn : n < 10000) (hn_pos : 0 < n) :
    CarmichaelProperty n := by
      -- Apply the lemma `carmichael_bounded_10000_optimized` to obtain the existence of $m < 20000$ such that $m \ne n$ and $\phi(m) = \phi(n)$.
      have h_exists_m : ∃ m, m < 20000 ∧ m ≠ n ∧ Nat.totient m = Nat.totient n := by
        exact check_carmichael_optimized_correct 10000 20000 ( by norm_num ) carmichael_bounded_10000_optimized n hn hn_pos;
      exact ⟨ h_exists_m.choose, h_exists_m.choose_spec.2.1, h_exists_m.choose_spec.2.2 ⟩