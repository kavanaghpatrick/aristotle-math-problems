/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 51bcb217-d3e6-4f52-aa0e-ae5ad37aa8a6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of structural lemmas for Wall-Sun-Sun primes and Fibonacci congruences.

We prove:
1. Cassini's Identity: `cassini_identity`
2. The key Fibonacci congruence: `fib_mod_prime` stating $F_p \equiv (p/5) \pmod p$.
3. The Lucas congruence: `lucas_mod_prime` stating $L_p \equiv 1 \pmod p$.
4. The rank of apparition property: `fib_rank_apparition` stating $F_{p-(p/5)} \equiv 0 \pmod p$.
5. Pisano period properties: `fib_period_of_legendre_eq_one` and `fib_period_of_legendre_eq_neg_one`.
6. The Wall-Sun-Sun prime definition and its equivalence to $L_p \equiv 1 \pmod {p^2}$: `wall_sun_sun_prime_iff_lucas_congruence`.

These results build the formal infrastructure for studying Wall-Sun-Sun primes using algebraic number theory techniques (Frobenius endomorphism in quadratic extensions).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.fib_gcd

/-
Cassini's Identity: F_{n-1} * F_{n+1} - F_n^2 = (-1)^n for n > 0.
-/
theorem cassini_identity (n : ℕ) (hn : 0 < n) :
  (Nat.fib (n - 1) : ℤ) * Nat.fib (n + 1) - (Nat.fib n)^2 = (-1)^n := by
    induction hn <;> simp_all +decide [ Nat.fib_add_two, pow_succ' ] ; ring;
    cases ‹1 ≤ _› <;> norm_num [ Nat.fib_add_two, add_comm 1 ] at * ; nlinarith

/-
If (5/p) = 1, then F_p ≡ 1 (mod p).
-/
theorem fib_mod_prime_of_legendre_eq_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = 1) : (Nat.fib p : ZMod p) = 1 := by
      -- Let's denote $\alpha$ and $\beta$ as roots of $x^2 - x - 1$ in $\mathbb{Z}/p\mathbb{Z}$.
      obtain ⟨α, β, hαβ⟩ : ∃ α β : ZMod p, α ^ 2 = α + 1 ∧ β ^ 2 = β + 1 ∧ α ≠ β ∧ α + β = 1 ∧ α * β = -1 := by
        -- By definition of Legendre symbol, since $(5/p) = 1$, there exists $x \in \mathbb{Z}/p\mathbb{Z}$ such that $x^2 = 5$.
        obtain ⟨x, hx⟩ : ∃ x : ZMod p, x^2 = 5 := by
          rw [ legendreSym.eq_one_iff ] at h5;
          · exact Exists.elim h5 fun x hx => ⟨ x, by rw [ sq, ← hx ] ; norm_num ⟩;
          · simp +zetaDelta at *;
            erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases p <;> trivial;
        refine' ⟨ ( 1 + x ) / 2, ( 1 - x ) / 2, _, _, _, _, _ ⟩ <;> ring_nf <;> norm_num [ hx ];
        · rcases eq_or_ne ( 4 : ZMod p ) 0 with h4 | h4 <;> simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm ];
          · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h4 <;> trivial;
          · field_simp [h4]
            ring;
            grind;
        · rcases eq_or_ne ( 2 : ZMod p ) 0 with h2 | h2 <;> rcases eq_or_ne ( 4 : ZMod p ) 0 with h4 | h4 <;> simp_all +decide [ sq, mul_assoc ];
          · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h2 <;> contradiction;
          · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h2 <;> contradiction;
          · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h4 <;> contradiction;
          · grind;
        · rw [ eq_neg_iff_add_eq_zero ] ; ring ; norm_num [ ← ZMod.natCast_eq_zero_iff ] at *;
          exact ⟨ by rintro rfl; rcases p with ( _ | _ | _ | _ | _ | _ | p ) <;> cases hx <;> contradiction, by erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne hp.1.two_le ( Ne.symm hp2 ) ) ⟩;
        · rw [ inv_mul_cancel₀ ] ; norm_num [ hp2 ];
          erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne hp.1.two_le ( Ne.symm hp2 ) );
        · rcases eq_or_ne ( 4 : ZMod p ) 0 with h | h <;> simp_all +decide [ sq, mul_assoc ];
          · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h <;> contradiction;
          · field_simp [h]
            ring;
      -- Using the identity $F_p = \frac{\alpha^p - \beta^p}{\alpha - \beta}$, we substitute $\alpha^p = \alpha$ and $\beta^p = \beta$.
      have h_fib : (Nat.fib p : ZMod p) = (α ^ p - β ^ p) / (α - β) := by
        have h_fib : ∀ n : ℕ, (Nat.fib n : ZMod p) = (α ^ n - β ^ n) / (α - β) := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ] ;
          · rw [ div_self ( sub_ne_zero_of_ne hαβ.2.2.1 ) ];
          · rw [ ih n ( by linarith ) ] ; ring;
            rw [ hαβ.1, hαβ.2.1 ] ; ring;
        apply h_fib;
      simp_all +decide [ sub_eq_iff_eq_add ]

/-
If (5/p) = -1 and x^2 = 5 in a field K of char p, then x^p = -x.
-/
theorem frobenius_action_on_sqrt5 {p : ℕ} [Fact p.Prime] (hp2 : p ≠ 2) (h5 : legendreSym p 5 = -1)
    {K : Type*} [Field K] [CharP K p] (x : K) (hx : x^2 = 5) : x^p = -x := by
      have h_xp : x ^ (2 * (p - 1) / 2) = 5 ^ ((p - 1) / 2) := by
        rw [ ← hx, ← pow_mul, Nat.mul_div_cancel_left _ two_pos ];
        rw [ Nat.mul_div_cancel' ( even_iff_two_dvd.mp ( Nat.Prime.even_sub_one Fact.out hp2 ) ) ];
      -- By Euler's criterion, since $(5/p) = -1$, we have $5^{(p-1)/2} \equiv -1 \pmod{p}$.
      have h_euler : 5 ^ ((p - 1) / 2) ≡ -1 [ZMOD p] := by
        have h_euler : 5 ^ ((p - 1) / 2) ≡ legendreSym p 5 [ZMOD p] := by
          simp +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym.eq_pow ];
          -- Since $p$ is an odd prime, we have $p - 1 = 2k$ for some integer $k$, thus $(p - 1) / 2 = k$.
          have h_odd : p % 2 = 1 := by
            exact Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) |> Or.resolve_left <| hp2;
          grind;
        aesop;
      -- Since $5^{(p-1)/2} \equiv -1 \pmod{p}$, we have $5^{(p-1)/2} = -1$ in the field $K$.
      have h_field : (5 : K) ^ ((p - 1) / 2) = -1 := by
        obtain ⟨ k, hk ⟩ := h_euler.symm.dvd; replace hk := congr_arg ( ( ↑ ) : ℤ → K ) hk; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact eq_neg_of_add_eq_zero_left hk;
      rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> simp_all +decide [ pow_succ' ];
      exact absurd ( Nat.prime_mul_iff.mp ( Fact.out : Nat.Prime ( 2 * c ) ) ) ( by aesop )

/-
If (5/p) = -1, then F_p ≡ -1 (mod p).
-/
theorem fib_mod_prime_of_legendre_eq_neg_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = -1) : (Nat.fib p : ZMod p) = -1 := by
      -- Let α and β be the roots of the characteristic polynomial x² - x - 1 over the algebraic closure of ZMod p.
      obtain ⟨α, β, hαβ⟩ : ∃ α β : AlgebraicClosure (ZMod p), α + β = 1 ∧ α * β = -1 := by
        -- Let α be a root of the polynomial x² - x - 1 in the algebraic closure of ZMod p.
        obtain ⟨α, hα⟩ : ∃ α : AlgebraicClosure (ZMod p), α^2 - α - 1 = 0 := by
          -- By definition of algebraic closure, every non-constant polynomial over the algebraic closure has a root.
          have h_alg_closed : ∀ (f : Polynomial (AlgebraicClosure (ZMod p))), f.degree > 0 → ∃ α : AlgebraicClosure (ZMod p), f.eval α = 0 := by
            exact fun f hf => by simpa using @IsAlgClosed.exists_root ( AlgebraicClosure ( ZMod p ) ) _ _ f hf.ne';
          exact Exists.elim ( h_alg_closed ( Polynomial.X ^ 2 - Polynomial.X - 1 ) ( by erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num ) ) fun x hx => ⟨ x, by simpa using hx ⟩;
        exact ⟨ α, 1 - α, by ring, by linear_combination -hα ⟩;
      -- By definition of $F_p$, we have $F_p = \frac{\alpha^p - \beta^p}{\alpha - \beta}$.
      have hFp : (Nat.fib p : AlgebraicClosure (ZMod p)) = (α^p - β^p) / (α - β) := by
        -- By definition of $F_p$, we have $F_p = \frac{\alpha^p - \beta^p}{\alpha - \beta}$, where $\alpha$ and $\beta$ are the roots of the characteristic polynomial $t^2 - t - 1$.
        have h_fib_formula : ∀ n : ℕ, (Nat.fib n : AlgebraicClosure (ZMod p)) = (α^n - β^n) / (α - β) := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ] ; ring;
          · field_simp;
            rw [ div_self ];
            intro h; simp_all +decide [ sub_eq_iff_eq_add ] ;
            simp_all +decide [ ← two_mul ];
            have := congr_arg ( · ^ 2 ) hαβ.1; norm_num [ mul_pow, hαβ.2 ] at this; ring_nf at this;
            simp_all +decide [ sq ];
            rw [ neg_eq_iff_add_eq_zero ] at this;
            norm_cast at this;
            erw [ ← map_natCast ( algebraMap ( ZMod p ) ( AlgebraicClosure ( ZMod p ) ) ) ] at this ; simp_all +decide [ ZMod.natCast_eq_zero_iff ];
            erw [ ZMod.natCast_eq_zero_iff ] at this ; have := Nat.le_of_dvd ( by decide ) this ; interval_cases p <;> contradiction;
          · grind;
        apply h_fib_formula;
      -- Since $(5/p) = -1$, we have $\alpha^p = \beta$ and $\beta^p = \alpha$.
      have hαp : α^p = β := by
        have h_frobenius : (α - β)^p = -(α - β) := by
          have h_frobenius : (α - β)^2 = 5 := by
            linear_combination' hαβ.1 * hαβ.1 - 4 * hαβ.2;
          exact?;
        -- Since $(α - β)^p = -(α - β)$, we have $α^p - β^p = -(α - β)$.
        have h_diff_p : α^p - β^p = -(α - β) := by
          rw [ ← h_frobenius, sub_pow_char ];
        have h_sum_p : α^p + β^p = 1 := by
          have h_sum_p : (α + β)^p = α^p + β^p := by
            rw [ add_pow_char ];
          rw [ ← h_sum_p, hαβ.1, one_pow ];
        have h_eq : α^p = (1 - (α - β)) / 2 ∧ β^p = (1 + (α - β)) / 2 := by
          constructor <;> rw [ eq_div_iff ] <;> norm_num;
          · linear_combination' h_sum_p + h_diff_p;
          · intro h; have := CharP.cast_eq_zero_iff ( AlgebraicClosure ( ZMod p ) ) p 2; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
            rcases p with ( _ | _ | _ | p ) <;> cases this <;> contradiction;
          · linear_combination' h_sum_p - h_diff_p;
          · intro h; have := CharP.cast_eq_zero_iff ( AlgebraicClosure ( ZMod p ) ) p 2; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
            rcases p with ( _ | _ | _ | p ) <;> cases this <;> contradiction;
        grind
      have hβp : β^p = α := by
        -- Since α and β are roots of the polynomial x² - x - 1, we have α^p + β^p = (α + β)^p = 1^p = 1.
        have h_sum : α^p + β^p = 1 := by
          rw [ ← add_pow_char, hαβ.1, one_pow ];
        grind;
      -- Since $\alpha \neq \beta$, we have $\alpha - \beta \neq 0$, and thus we can simplify the expression for $F_p$.
      have h_nonzero : α - β ≠ 0 := by
        intro h; simp_all +decide [ sub_eq_iff_eq_add ] ;
        -- From $2β = 1$, we get $β = 1/2$. Substituting into $β^2 = -1$, we get $(1/2)^2 = -1$, which simplifies to $1/4 = -1$, or $1 = -4$, which is a contradiction.
        have h_contra : (1 : AlgebraicClosure (ZMod p)) = -4 := by
          grind;
        rw [ eq_neg_iff_add_eq_zero ] at h_contra;
        norm_cast at h_contra;
        erw [ ← map_natCast ( algebraMap ( ZMod p ) ( AlgebraicClosure ( ZMod p ) ) ) ] at h_contra ; simp_all +decide [ ZMod.natCast_eq_zero_iff ];
        erw [ ZMod.natCast_eq_zero_iff ] at h_contra ; have := Nat.le_of_dvd ( by decide ) h_contra ; interval_cases p <;> trivial
      have h_simplified : (Nat.fib p : AlgebraicClosure (ZMod p)) = -1 := by
        rw [ hFp, hαp, hβp, div_eq_iff h_nonzero ] ; ring;
      -- Since the map from $ZMod p$ to its algebraic closure is injective, we can conclude that $(Nat.fib p : ZMod p) = -1$.
      have h_injective : Function.Injective (algebraMap (ZMod p) (AlgebraicClosure (ZMod p))) := by
        exact RingHom.injective _;
      exact h_injective <| by simpa using h_simplified;

/-
For prime p ≠ 2, 5: F_p ≡ (5/p) (mod p)
-/
theorem fib_mod_prime (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5) :
  (Nat.fib p : ZMod p) = legendreSym p 5 := by
    -- By definition of Legendre symbol, we know that if $(5/p) = 1$, then $F_p \equiv 1 \pmod{p}$, and if $(5/p) = -1$, then $F_p \equiv -1 \pmod{p}$.
    by_cases h5 : legendreSym p 5 = 1 ∨ legendreSym p 5 = -1;
    · rcases h5 with h5 | h5;
      · have := fib_mod_prime_of_legendre_eq_one p hp2 hp5 h5; aesop;
      · convert fib_mod_prime_of_legendre_eq_neg_one p hp2 hp5 h5 using 1;
        rw [ legendreSym ] at * ; aesop;
    · simp_all +decide [ legendreSym ];
      simp_all +decide [ quadraticCharFun ];
      split_ifs at h5 <;> simp_all +decide;
      erw [ ZMod.natCast_eq_zero_iff ] at * ; have := Nat.le_of_dvd ( by decide ) ‹p ∣ 5› ; interval_cases p <;> trivial

/-
Lucas sequence definition and L_p ≡ 1 (mod p).
-/
def lucas : ℕ → ℕ
  | 0 => 2
  | 1 => 1
  | (n + 2) => lucas (n + 1) + lucas n

theorem lucas_mod_prime (p : ℕ) (hp : p.Prime) (hp2 : p ≠ 2) :
  (lucas p : ZMod p) = 1 := by
    -- By Binet's formula, we have $L_p = \phi^p + \psi^p$, where $\phi = \frac{1 + \sqrt{5}}{2}$ and $\psi = \frac{1 - \sqrt{5}}{2}$.
    have h_binet : lucas p = ((1 + Real.sqrt 5) / 2 : ℝ)^p + ((1 - Real.sqrt 5) / 2 : ℝ)^p := by
      -- We'll use the fact that the Lucas numbers can be expressed using Binet's formula.
      have h_binet : ∀ n, lucas n = ((1 + Real.sqrt 5) / 2 : ℝ)^n + ((1 - Real.sqrt 5) / 2 : ℝ)^n := by
        intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> norm_num [ lucas ] at *;
        rw [ ih _ <| Nat.lt_succ_self _, ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _ ] ; ring ; norm_num ; ring;
      apply h_binet;
    -- Using the binomial theorem, we expand $(1 + \sqrt{5})^p$ and $(1 - \sqrt{5})^p$.
    have h_expand : ((1 + Real.sqrt 5) / 2 : ℝ)^p + ((1 - Real.sqrt 5) / 2 : ℝ)^p = ∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((Real.sqrt 5) ^ k + (-Real.sqrt 5) ^ k) / 2 ^ p := by
      have h_expand : ((1 + Real.sqrt 5) / 2 : ℝ)^p + ((1 - Real.sqrt 5) / 2 : ℝ)^p = (∑ k ∈ Finset.range (p + 1), Nat.choose p k * (Real.sqrt 5)^k / 2^p) + (∑ k ∈ Finset.range (p + 1), Nat.choose p k * (-Real.sqrt 5)^k / 2^p) := by
        congr 1;
        · rw [ add_div, add_comm, add_pow ] ; congr ; ext ; ring;
          by_cases h : p ≤ ‹_› <;> simp_all +decide [ mul_assoc, ← pow_add ];
          · exact Classical.or_iff_not_imp_left.2 fun h' => Nat.choose_eq_zero_of_lt <| lt_of_le_of_ne h <| Ne.symm h';
          · exact Or.inl ( by rw [ ← mul_inv, ← pow_add, Nat.add_sub_of_le h.le ] );
        · rw [ sub_div, one_div ];
          rw [ sub_eq_neg_add, add_pow ] ; congr ; ext ; ring;
          rw [ show ( -1 / 2 : ℝ ) = -1 * ( 1 / 2 ) by norm_num, mul_pow ] ; ring;
          by_cases h : ‹_› ≤ p <;> simp_all +decide [ mul_assoc, ← pow_add ];
          · exact Or.inl ( by rw [ ← mul_inv, ← pow_add, Nat.add_sub_of_le h ] );
          · exact Or.inr <| Nat.choose_eq_zero_of_lt h;
      exact h_expand.trans ( by rw [ ← Finset.sum_add_distrib ] ; exact Finset.sum_congr rfl fun _ _ => by ring );
    -- Since $\sqrt{5}^k + (-\sqrt{5})^k$ is an integer for all $k$, we can simplify the expression modulo $p$.
    have h_simplify : ∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((Real.sqrt 5) ^ k + (-Real.sqrt 5) ^ k) / 2 ^ p = (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((if k % 2 = 0 then 2 * 5 ^ (k / 2) else 0) : ℝ)) / 2 ^ p := by
      rw [ Finset.sum_div _ _ _ ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rcases Nat.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
    -- Since $\binom{p}{k}$ is divisible by $p$ for $1 \leq k \leq p-1$, the sum simplifies to $2 \cdot 5^{p/2}$ modulo $p$.
    have h_div : (∑ k ∈ Finset.range (p + 1), Nat.choose p k * ((if k % 2 = 0 then 2 * 5 ^ (k / 2) else 0) : ℤ)) ≡ 2 [ZMOD p] := by
      haveI := Fact.mk hp; norm_num [ ← ZMod.intCast_eq_intCast_iff ] ;
      rw [ Finset.sum_range_succ ] ; norm_num [ Finset.sum_range_succ', Nat.choose_succ_succ ];
      rw [ Finset.sum_eq_single 0 ] <;> norm_num;
      · exact fun h => absurd ( Nat.Prime.eq_two_or_odd hp ) ( by aesop );
      · exact fun b hb hb' hb'' => Or.inl <| by rw [ ZMod.natCast_eq_zero_iff ] ; exact hp.dvd_choose_self ( by positivity ) ( by linarith ) ; ;
      · aesop;
    -- Therefore, $L_p \equiv \frac{2}{2^p} \equiv 2 \cdot 2^{-p} \equiv 2 \cdot 1 \equiv 2 \pmod{p}$.
    have h_final : (lucas p : ℤ) * 2 ^ p ≡ 2 [ZMOD p] := by
      convert h_div using 1;
      rw [ ← @Int.cast_inj ℝ ] ; push_cast ; rw [ h_binet, h_expand, h_simplify ] ; norm_num [ mul_div_cancel₀, hp.ne_zero ];
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
    exact mul_left_cancel₀ ( show ( 2 : ZMod p ) ≠ 0 by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt Nat.zero_lt_two <| lt_of_le_of_ne hp.two_le <| Ne.symm hp2 ) <| by linear_combination' h_final;

/-
If (5/p) = 1, then F_{p-1} ≡ 0 (mod p).
-/
theorem fib_pred_eq_zero_of_legendre_eq_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = 1) : (Nat.fib (p - 1) : ZMod p) = 0 := by
      -- By definition of $F_p$, we know that $F_p = \frac{\alpha^p - \beta^p}{\alpha - \beta}$ where $\alpha$ and $\beta$ are roots of $x^2 - x - 1$.
      -- Since $(5/p) = 1$, we have $\alpha, \beta \in \mathbb{F}_p$.
      obtain ⟨α, β, hαβ⟩ : ∃ α β : ZMod p, α ^ 2 = α + 1 ∧ β ^ 2 = β + 1 ∧ α ≠ β := by
        -- By definition of Legendre symbol, since $(5/p) = 1$, there exists $x \in \mathbb{Z}/p\mathbb{Z}$ such that $x^2 = 5$.
        obtain ⟨x, hx⟩ : ∃ x : ZMod p, x^2 = 5 := by
          rw [ legendreSym.eq_one_iff ] at h5;
          · exact Exists.elim h5 fun x hx => ⟨ x, by rw [ sq, ← hx ] ; norm_num ⟩;
          · simp +zetaDelta at *;
            erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases p <;> trivial;
        refine' ⟨ ( 1 + x ) / 2, ( 1 - x ) / 2, _, _, _ ⟩ <;> ring_nf at * <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
        · rcases eq_or_ne ( 2 : ZMod p ) 0 with h | h <;> simp_all +decide [ sq, mul_assoc ];
          · rcases p with ( _ | _ | _ | _ | p ) <;> cases h <;> contradiction;
          · field_simp [h]
            ring;
        · rcases eq_or_ne ( 2 : ZMod p ) 0 with h|h <;> simp_all +decide [ sq, mul_assoc ];
          · rcases p with ( _ | _ | _ | p ) <;> cases h <;> contradiction;
          · field_simp [h]
            ring;
        · rw [ eq_neg_iff_add_eq_zero ] ; ring ; norm_num [ hp2, hp5, hx ];
          exact ⟨ by rintro rfl; rcases p with ( _ | _ | _ | _ | _ | _ | p ) <;> cases hx <;> contradiction, by erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne hp.1.two_le ( Ne.symm hp2 ) ) ⟩;
      -- By definition of $F_p$, we know that $F_p = \frac{\alpha^p - \beta^p}{\alpha - \beta}$.
      have h_fib_alpha_beta : ∀ n : ℕ, (Nat.fib n : ZMod p) = (α ^ n - β ^ n) / (α - β) := by
        intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ] ;
        · rw [ div_self ( sub_ne_zero_of_ne hαβ.2.2 ) ];
        · rw [ ih n ( by linarith ) ] ; ring;
          rw [ hαβ.1, hαβ.2.1 ] ; ring;
      -- Since $\alpha$ and $\beta$ are roots of $x^2 - x - 1$, we have $\alpha^{p-1} = 1$ and $\beta^{p-1} = 1$.
      have h_alpha_beta_p_minus_1 : α ^ (p - 1) = 1 ∧ β ^ (p - 1) = 1 := by
        exact ⟨ ZMod.pow_card_sub_one_eq_one ( by rintro rfl; simp_all +decide [ sq ] ), ZMod.pow_card_sub_one_eq_one ( by rintro rfl; simp_all +decide [ sq ] ) ⟩;
      aesop

/-
If (5/p) = -1, then F_{p+1} ≡ 0 (mod p).
-/
theorem fib_succ_eq_zero_of_legendre_eq_neg_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = -1) : (Nat.fib (p + 1) : ZMod p) = 0 := by
      -- By Cassini's Identity: F_{p-1}F_{p+1} - F_p^2 = (-1)^p = -1.
      have h_cassini : (Nat.fib (p - 1) : ZMod p) * (Nat.fib (p + 1) : ZMod p) - (Nat.fib p : ZMod p)^2 = -1 := by
        -- By Cassini's identity, we know that $F_{n-1}F_{n+1} - F_n^2 = (-1)^n$.
        have h_cassini : ∀ n : ℕ, n > 0 → (Nat.fib (n - 1) * Nat.fib (n + 1) - Nat.fib n ^ 2 : ℤ) = (-1 : ℤ) ^ n := by
          exact?;
        convert congr_arg ( ( ↑ ) : ℤ → ZMod p ) ( h_cassini p ( Nat.Prime.pos ( Fact.out : Nat.Prime p ) ) ) using 1 ; norm_num [ ← ZMod.intCast_eq_intCast_iff ] ; ring; aesop;
      -- We know F_p ≡ -1 (mod p) from `fib_mod_prime_of_legendre_eq_neg_one`.
      have h_fib_p : (Nat.fib p : ZMod p) = -1 := by
        convert fib_mod_prime_of_legendre_eq_neg_one p hp2 hp5 h5 using 1;
      by_cases h : ( Nat.fib ( p - 1 ) : ZMod p ) = 0 <;> simp_all +decide;
      -- If $F_{p-1} \equiv 0 \pmod{p}$, then $L_p = F_{p-1} + F_{p+1} \equiv 0 + (-1) \equiv -1 \pmod{p}$.
      have h_lucas_p : (lucas p : ZMod p) = -1 := by
        rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.fib_add_two ];
        -- By definition of Lucas sequence, we know that $L_{p+2} = F_{p+1} + F_{p+3}$.
        have h_lucas_def : ∀ n, lucas (n + 2) = Nat.fib (n + 1) + Nat.fib (n + 3) := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ Nat.fib_add_two ] ;
          have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; simp_all +arith +decide [ Nat.fib_add_two, lucas ] ;
          linarith [ ih n ( by linarith ) ];
        simp_all +decide [ Nat.fib_add_two ];
      -- But we proved $L_p \equiv 1 \pmod{p}$ in `lucas_mod_prime`.
      have h_lucas_p_contradiction : (lucas p : ZMod p) = 1 := by
        convert lucas_mod_prime p hp.1 hp2 using 1;
      norm_num [ h_lucas_p ] at h_lucas_p_contradiction;
      rw [ neg_eq_iff_add_eq_zero ] at h_lucas_p_contradiction;
      rcases p with ( _ | _ | _ | p ) <;> cases h_lucas_p_contradiction <;> contradiction

/-
F_{p - (5/p)} ≡ 0 (mod p).
-/
theorem fib_rank_apparition (p : ℕ) [Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5) :
  (Nat.fib (if legendreSym p 5 = 1 then p - 1 else p + 1) : ZMod p) = 0 := by
    split_ifs;
    · convert fib_pred_eq_zero_of_legendre_eq_one p hp2 hp5 ‹_›;
    · convert fib_succ_eq_zero_of_legendre_eq_neg_one p hp2 hp5 _;
      -- Since $p$ is a prime and $5$ is not divisible by $p$, the Legendre symbol $(5/p)$ can only be $1$ or $-1$.
      have h_legendre_cases : legendreSym p 5 = 1 ∨ legendreSym p 5 = -1 := by
        have h_not_div : ¬(p ∣ 5) := by
          exact fun h => hp5 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial;
        rw [ legendreSym.eq_one_iff, legendreSym.eq_neg_one_iff ];
        · exact em _;
        · simpa [ ← ZMod.natCast_eq_zero_iff ] using h_not_div;
      exact h_legendre_cases.resolve_left ‹_›

#check Nat.fib_gcd

/-
Definition of Wall-Sun-Sun prime.
-/
def WallSunSunPrime (p : ℕ) : Prop :=
  if h : p.Prime then
    letI : Fact p.Prime := ⟨h⟩
    p ≠ 2 ∧ p ≠ 5 ∧ (Nat.fib (if legendreSym p 5 = 1 then p - 1 else p + 1) : ZMod (p^2)) = 0
  else False

theorem WallSunSunPrime_iff (p : ℕ) [hp : Fact p.Prime] :
    WallSunSunPrime p ↔ p ≠ 2 ∧ p ≠ 5 ∧ (Nat.fib (if legendreSym p 5 = 1 then p - 1 else p + 1) : ZMod (p^2)) = 0 := by
  simp [WallSunSunPrime, hp.1]

/-
Identity L_n^2 - 5 F_n^2 = 4(-1)^n.
-/
theorem lucas_sq_sub_five_fib_sq (n : ℕ) :
  (lucas n : ℤ)^2 - 5 * (Nat.fib n : ℤ)^2 = 4 * (-1)^n := by
    -- We will prove this using mathematical induction on $n$.
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | _ | n ) <;> norm_num [ Nat.fib_add_two, lucas ];
    have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ; norm_num [ pow_succ', Nat.fib_add_two, lucas ] at * ; linarith;

/-
Identity 2 F_{n-1} = L_n - F_n.
-/
theorem two_mul_fib_pred_eq_lucas_sub_fib (n : ℕ) (hn : n > 0) :
  2 * (Nat.fib (n - 1) : ℤ) = (lucas n : ℤ) - (Nat.fib n : ℤ) := by
    rcases n with ( _ | _ | n ) <;> norm_num at *;
    · decide +revert;
    · induction' n using Nat.strong_induction_on with n ih;
      rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ];
      have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ Nat.fib_add_two, lucas ] at * ; linarith;

/-
Identity 2 F_{n+1} = L_n + F_n.
-/
theorem two_mul_fib_succ_eq_lucas_add_fib (n : ℕ) :
  2 * (Nat.fib (n + 1) : ℤ) = (lucas n : ℤ) + (Nat.fib n : ℤ) := by
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two ];
    have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ; norm_num [ Nat.fib_add_two, lucas ] at * ; linarith;

/-
Unique lifting of square roots of 1 from mod p to mod p^2 for p ≠ 2.
-/
theorem sq_eq_one_mod_sq_of_eq_mod {p : ℕ} [Fact p.Prime] (hp2 : p ≠ 2) {x : ZMod (p^2)} {ε : ZMod (p^2)}
    (h_sq : x^2 = 1) (h_eps_sq : ε^2 = 1) (h_mod : (ZMod.cast x : ZMod p) = (ZMod.cast ε : ZMod p)) : x = ε := by
      -- Since $x$ and $\varepsilon$ are congruent modulo $p$, we can write $x = \varepsilon + kp$ for some integer $k$.
      obtain ⟨k, hk⟩ : ∃ k : ℤ, x = ε + k * p := by
        -- Since $x$ and $\varepsilon$ are congruent modulo $p$, we can write $x = \varepsilon + kp$ for some integer $k$ by definition of congruence modulo $p$.
        have h_cong : (x.val : ℤ) ≡ (ε.val : ℤ) [ZMOD p] := by
          erw [ ← ZMod.intCast_eq_intCast_iff ] ; aesop;
        obtain ⟨ k, hk ⟩ := h_cong.symm.dvd;
        use k; simp_all +decide [ sub_eq_iff_eq_add, mul_comm ] ;
        simpa [ add_comm, mul_comm ] using congr_arg ( ( ↑ ) : ℤ → ZMod ( p ^ 2 ) ) hk;
      -- Expanding $x^2 = (\varepsilon + kp)^2 = \varepsilon^2 + 2\varepsilon kp + k^2 p^2$, we get $1 = 1 + 2\varepsilon kp$.
      have h_expand : (1 : ZMod (p ^ 2)) = 1 + 2 * ε * k * p := by
        have h_expand : (ε + k * p) ^ 2 = 1 := by
          aesop;
        convert h_expand.symm using 1 ; ring;
        norm_num [ add_comm, h_eps_sq ];
        norm_cast;
        erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
      -- This implies $2\varepsilon kp = 0$, so $p \mid 2\varepsilon k$.
      have h_div : (p : ℤ) ∣ 2 * ε.val * k := by
        have h_div : (p ^ 2 : ℤ) ∣ 2 * ε.val * k * p := by
          norm_num [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] at *;
          erw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
        exact Exists.elim h_div fun x hx => ⟨ x, by nlinarith [ show ( p : ℤ ) > 1 from mod_cast Nat.Prime.one_lt Fact.out ] ⟩;
      -- Since $p \neq 2$, we have $p \mid k$.
      have h_div_k : (p : ℤ) ∣ k := by
        have h_div_k : (p : ℤ) ∣ 2 * k := by
          have h_div_k : (p : ℤ) ∣ 2 * ε.val * k ∧ (p : ℤ) ∣ ε.val^2 - 1 := by
            have h_div_k : (ε.val : ℤ)^2 ≡ 1 [ZMOD p] := by
              have h_div_eps : (ε.val : ℤ)^2 ≡ 1 [ZMOD p^2] := by
                erw [ ← ZMod.intCast_eq_intCast_iff ] ; norm_num [ h_eps_sq ];
              exact h_div_eps.of_dvd <| dvd_pow_self _ two_ne_zero;
            exact ⟨ h_div, h_div_k.symm.dvd ⟩;
          haveI := Fact.mk ( Fact.out : Nat.Prime p ) ; simp +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] at *;
          grind;
        exact Or.resolve_left ( Int.Prime.dvd_mul' ( Fact.out : Nat.Prime p ) h_div_k ) ( by norm_cast; exact Nat.not_dvd_of_pos_of_lt Nat.zero_lt_two ( lt_of_le_of_ne ( Nat.Prime.two_le ( Fact.out : Nat.Prime p ) ) ( Ne.symm hp2 ) ) );
      obtain ⟨ m, hm ⟩ := h_div_k; norm_num [ hk, hm ] ;
      norm_cast; norm_num [ mul_assoc, mul_comm, mul_left_comm, sq ] ;
      norm_cast; norm_num [ ← mul_assoc, ← pow_two ] ;
      norm_cast;
      erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] ; exact dvd_mul_of_dvd_right ( by norm_num ) _

/-
If p is a Wall-Sun-Sun prime, then L_p ≡ 1 (mod p²).
-/
theorem lucas_congruence_of_wall_sun_sun_prime (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h : WallSunSunPrime p) : (lucas p : ZMod (p^2)) = 1 := by
      -- Let ε = (5/p). So F_{p-ε} ≡ 0 (mod p²).
      obtain ⟨ε, hε⟩ : ∃ ε : ℤ, (legendreSym p 5 = ε) ∧ (Nat.fib (if ε = 1 then p - 1 else p + 1) : ℤ) ≡ 0 [ZMOD p^2] := by
        -- By definition of WallSunSunPrime, we know that p is prime and satisfies the conditions.
        obtain ⟨h_prime, h_ne_2, h_ne_5, h_fib⟩ : p.Prime ∧ p ≠ 2 ∧ p ≠ 5 ∧ (Nat.fib (if legendreSym p 5 = 1 then p - 1 else p + 1) : ZMod (p^2)) = 0 := by
          unfold WallSunSunPrime at h; aesop;
        erw [ ZMod.natCast_eq_zero_iff ] at h_fib ; norm_cast at *;
        exact ⟨ _, rfl, Nat.modEq_zero_iff_dvd.mpr h_fib ⟩;
      -- Case 1: ε = 1. Then F_{p-1} ≡ 0 (mod p²).
      by_cases hε1 : ε = 1;
      · -- We have L_p = 2 F_{p-1} + F_p ≡ F_p (mod p²).
        have hLp : (lucas p : ℤ) ≡ (Nat.fib p : ℤ) [ZMOD p^2] := by
          -- Using the identity $L_p = 2 F_{p-1} + F_p$, we can rewrite $L_p$ modulo $p^2$.
          have hLp_identity : (lucas p : ℤ) = 2 * (Nat.fib (p - 1) : ℤ) + (Nat.fib p : ℤ) := by
            -- Using the identity $2 F_{n-1} = L_n - F_n$, we can rewrite $L_p$ modulo $p^2$.
            have hLp_identity : ∀ n > 0, (lucas n : ℤ) = 2 * (Nat.fib (n - 1) : ℤ) + (Nat.fib n : ℤ) := by
              intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.fib_add_two, lucas ] ;
              rcases n with ( _ | n ) <;> simp_all +decide [ Nat.fib_add_two, lucas ] ; linarith;
            exact hLp_identity p hp.1.pos;
          simp_all +decide [ Int.modEq_iff_dvd ];
          exact dvd_mul_of_dvd_right hε.2 _;
        -- Also L_p^2 - 5 F_p^2 = -4 (mod p²).
        have hLp_sq : (lucas p : ℤ)^2 - 5 * (Nat.fib p : ℤ)^2 ≡ -4 [ZMOD p^2] := by
          have hLp_sq : (lucas p : ℤ)^2 - 5 * (Nat.fib p : ℤ)^2 = 4 * (-1)^p := by
            convert lucas_sq_sub_five_fib_sq p using 1;
          by_cases h : Even p <;> simp_all +decide [ Nat.Prime.even_iff ];
          exact absurd ( hp.1.even_iff.mp h ) hp2;
        -- Substitute L_p ≡ F_p: F_p^2 - 5 F_p^2 ≡ -4 => -4 F_p^2 ≡ -4 => F_p^2 ≡ 1.
        have hFp_sq : (Nat.fib p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
          have hFp_sq : (Nat.fib p : ℤ)^2 - 5 * (Nat.fib p : ℤ)^2 ≡ -4 [ZMOD p^2] := by
            exact Eq.trans ( Int.ModEq.sub ( hLp.symm.pow 2 ) rfl ) hLp_sq;
          rw [ Int.modEq_iff_dvd ] at *;
          have hFp_sq : (p^2 : ℤ) ∣ 4 * (1 - (Nat.fib p : ℤ)^2) := by
            convert hFp_sq.neg_right using 1 ; ring;
          refine' Int.dvd_of_dvd_mul_right_of_gcd_one hFp_sq _;
          exact_mod_cast Nat.Coprime.pow_left 2 ( hp.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial );
        -- Since F_p ≡ 1 (mod p), F_p ≡ 1 (mod p²) by `sq_eq_one_mod_sq_of_eq_mod`.
        have hFp_mod : (Nat.fib p : ℤ) ≡ 1 [ZMOD p] := by
          haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          convert fib_mod_prime_of_legendre_eq_one p hp2 hp5 hε.1 using 1;
        have hFp_mod_sq : ∀ x : ZMod (p^2), x^2 = 1 → (x.val : ℤ) ≡ 1 [ZMOD p] → x = 1 := by
          intros x hx hx_mod
          have hx_sq : x^2 = 1 := by
            exact hx
          have hx_mod_sq : (x.val : ℤ) ≡ 1 [ZMOD p] := by
            exact hx_mod
          have hx_eq_one : x = 1 := by
            convert sq_eq_one_mod_sq_of_eq_mod hp2 _ _ _ using 1;
            · exact hx_sq;
            · norm_num;
            · convert hx_mod_sq using 1;
              erw [ ← ZMod.intCast_eq_intCast_iff ] ; norm_num
          exact hx_eq_one;
        norm_cast at *;
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      · -- Case 2: ε = -1. Then F_{p+1} ≡ 0 (mod p²).
        have hε_neg1 : ε = -1 := by
          have hε_neg1 : legendreSym p 5 = 1 ∨ legendreSym p 5 = -1 := by
            simp +decide [ legendreSym ];
            simp +decide [ quadraticCharFun ];
            split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
            erw [ ZMod.natCast_eq_zero_iff ] at * ; have := Nat.le_of_dvd ( by decide ) ‹p ∣ 5› ; interval_cases p <;> trivial;
          aesop
        have hF_p1 : (Nat.fib (p + 1) : ℤ) ≡ 0 [ZMOD p^2] := by
          aesop
        have hL_p : (lucas p : ℤ) ≡ - (Nat.fib p : ℤ) [ZMOD p^2] := by
          -- Using the identity $2 F_{n+1} = L_n + F_n$, we get $L_p = 2 F_{p+1} - F_p$.
          have hL_p_identity : (lucas p : ℤ) = 2 * (Nat.fib (p + 1) : ℤ) - (Nat.fib p : ℤ) := by
            have := two_mul_fib_succ_eq_lucas_add_fib p; norm_num at *; linarith;
          simpa [ hL_p_identity ] using hF_p1.mul_left 2 |> Int.ModEq.sub_right _ |> Int.ModEq.trans <| by ring_nf; norm_num;
        have hF_p : (Nat.fib p : ℤ) ≡ -1 [ZMOD p] := by
          have := fib_mod_prime_of_legendre_eq_neg_one p hp2 hp5; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        have hF_p_sq : (Nat.fib p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
          have hF_p_sq : (lucas p : ℤ)^2 - 5 * (Nat.fib p : ℤ)^2 = 4 * (-1)^p := by
            convert lucas_sq_sub_five_fib_sq p using 1
          have hF_p_sq_mod : (lucas p : ℤ)^2 ≡ (-Nat.fib p : ℤ)^2 [ZMOD p^2] := by
            convert hL_p.pow 2 using 1
          have hF_p_sq_mod_simplified : (-Nat.fib p : ℤ)^2 - 5 * (Nat.fib p : ℤ)^2 ≡ 4 * (-1)^p [ZMOD p^2] := by
            exact Eq.trans ( hF_p_sq_mod.symm.sub_right _ ) ( by simp +decide [ ← hF_p_sq ] ) ;
          have hF_p_sq_mod_final : -4 * (Nat.fib p : ℤ)^2 ≡ 4 * (-1)^p [ZMOD p^2] := by
            convert hF_p_sq_mod_simplified using 1 ; ring
          have hF_p_sq_mod_final_simplified : (Nat.fib p : ℤ)^2 ≡ (-1)^(p+1) [ZMOD p^2] := by
            have hF_p_sq_mod_final_simplified : 4 * (Nat.fib p : ℤ)^2 ≡ -4 * (-1)^p [ZMOD p^2] := by
              convert hF_p_sq_mod_final.neg using 1 <;> ring
            have hF_p_sq_mod_final_simplified_final : (Nat.fib p : ℤ)^2 ≡ -(-1)^p [ZMOD p^2] := by
              rw [ Int.modEq_iff_dvd ] at *;
              refine' Int.dvd_of_dvd_mul_right_of_gcd_one _ _;
              use 4;
              · convert hF_p_sq_mod_final_simplified using 1 ; ring;
              · exact_mod_cast Nat.Coprime.pow_left 2 ( hp.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial )
            have hF_p_sq_mod_final_simplified_final_final : (Nat.fib p : ℤ)^2 ≡ (-1)^(p+1) [ZMOD p^2] := by
              convert hF_p_sq_mod_final_simplified_final using 1 ; ring
            exact hF_p_sq_mod_final_simplified_final_final
          have hF_p_sq_mod_final_simplified_final : (Nat.fib p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
            by_cases h : Even p <;> simp_all +decide [ parity_simps ];
            exact absurd ( hp.1.even_iff.mp h ) hp2 |> False.elim;
          exact hF_p_sq_mod_final_simplified_final
        have hF_p_one : (Nat.fib p : ℤ) ≡ -1 [ZMOD p^2] := by
          have hF_p_one : ∀ x : ℤ, x^2 ≡ 1 [ZMOD p^2] → x ≡ 1 [ZMOD p] → x ≡ 1 [ZMOD p^2] := by
            intros x hx_sq hx_mod_p
            have hx_mod_p2 : x ≡ 1 [ZMOD p^2] := by
              have hx_mod_p2 : (x - 1) * (x + 1) ≡ 0 [ZMOD p^2] := by
                convert hx_sq.sub_right 1 using 1 ; ring
              -- Since $p$ is prime and $p \neq 2$, $p$ does not divide $x + 1$.
              have h_not_div : ¬(p : ℤ) ∣ (x + 1) := by
                intro h; haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, ← ZMod.intCast_eq_intCast_iff ] ;
                rcases p with ( _ | _ | _ | p ) <;> cases h <;> contradiction;
              -- Since $p$ is prime and $p \neq 2$, $p$ does not divide $x + 1$, so $p^2$ must divide $x - 1$.
              have h_div : (p : ℤ)^2 ∣ (x - 1) := by
                exact ( Int.dvd_of_dvd_mul_left_of_gcd_one ( Int.dvd_of_emod_eq_zero hx_mod_p2 ) <| by simpa [ Int.gcd, Int.natAbs_pow ] using hp.1.coprime_iff_not_dvd.mpr fun h => h_not_div <| Int.natCast_dvd.mpr h );
              exact Eq.symm <| Int.modEq_of_dvd h_div
            exact hx_mod_p2
          have hF_p_one : (Nat.fib p : ℤ) ≡ 1 [ZMOD p] → (Nat.fib p : ℤ) ≡ 1 [ZMOD p^2] := by
            exact fun h => hF_p_one _ hF_p_sq h
          have hF_p_one : (Nat.fib p : ℤ) ≡ -1 [ZMOD p] → (Nat.fib p : ℤ) ≡ -1 [ZMOD p^2] := by
            intro hF_p_neg_one
            have hF_p_neg_one_sq : (-Nat.fib p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
              simpa using hF_p_sq
            have hF_p_neg_one_one : (-Nat.fib p : ℤ) ≡ 1 [ZMOD p] := by
              simpa using hF_p_neg_one.neg
            have hF_p_neg_one_one : (-Nat.fib p : ℤ) ≡ 1 [ZMOD p^2] := by
              exact?
            have hF_p_neg_one_one : (Nat.fib p : ℤ) ≡ -1 [ZMOD p^2] := by
              simpa using hF_p_neg_one_one.neg
            exact hF_p_neg_one_one
          exact hF_p_one hF_p
        have hL_p_one : (lucas p : ℤ) ≡ 1 [ZMOD p^2] := by
          exact hL_p.trans ( hF_p_one.neg ) |> Int.ModEq.trans <| by norm_num;
        exact (by
        erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop)

/-
If L_p ≡ 1 (mod p²), then p is a Wall-Sun-Sun prime.
-/
theorem lucas_congruence_implies_wall_sun_sun_prime (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h : (lucas p : ZMod (p^2)) = 1) : WallSunSunPrime p := by
      -- Use the identity $L_p^2 - 5 F_p^2 = -4$ modulo $p^2$.
      have h_identity : (lucas p : ℤ)^2 - 5 * ((Nat.fib p : ℤ)^2) ≡ -4 [ZMOD p^2] := by
        -- Use the identity $L_p^2 - 5 F_p^2 = 4(-1)^p$.
        have h_identity : (lucas p : ℤ)^2 - 5 * ((Nat.fib p : ℤ)^2) = 4 * (-1 : ℤ)^p := by
          exact?;
        rcases hp.1.eq_two_or_odd' with rfl | ⟨ m, rfl ⟩ <;> simp_all +decide [ parity_simps ];
      -- Substitute $L_p \equiv 1 \mod p^2$ into the identity to get $1 - 5 F_p^2 \equiv -4 \mod p^2$, which simplifies to $5 F_p^2 \equiv 5 \mod p^2$, or $F_p^2 \equiv 1 \mod p^2$.
      have h_fib_sq : (Nat.fib p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
        -- Substitute $L_p \equiv 1 \mod p^2$ into the identity to get $1 - 5 F_p^2 \equiv -4 \mod p^2$, which simplifies to $5 F_p^2 \equiv 5 \mod p^2$.
        have h_fib_sq : 5 * (Nat.fib p : ℤ)^2 ≡ 5 [ZMOD p^2] := by
          -- Substitute $L_p \equiv 1$ into the identity to get $1 - 5 F_p^2 \equiv -4 \pmod{p^2}$, which simplifies to $5 F_p^2 \equiv 5 \pmod{p^2}$ by rearranging terms.
          have h_subst : (lucas p : ℤ)^2 ≡ 1 [ZMOD p^2] := by
            erw [ ← ZMod.intCast_eq_intCast_iff ] ; aesop;
          convert h_subst.sub h_identity using 1 ; ring;
        rw [ Int.modEq_iff_dvd ] at *;
        refine' Int.dvd_of_dvd_mul_right_of_gcd_one _ _;
        exacts [ 5, by convert h_fib_sq using 1; ring, by exact_mod_cast Nat.Coprime.pow_left 2 <| hp.1.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial ];
      -- Since $F_p \equiv \left(\frac{5}{p}\right) \mod p$, by `sq_eq_one_mod_sq_of_eq_mod`, $F_p \equiv \left(\frac{5}{p}\right) \mod p^2$.
      have h_fib_mod : (Nat.fib p : ZMod (p^2)) = legendreSym p 5 := by
        -- Since $F_p \equiv \left(\frac{5}{p}\right) \mod p$, we can use the fact that $F_p^2 \equiv 1 \mod p^2$ to conclude that $F_p \equiv \left(\frac{5}{p}\right) \mod p^2$.
        have h_fib_mod : (Nat.fib p : ZMod p) = legendreSym p 5 := by
          convert fib_mod_prime p hp2 hp5 using 1;
        convert sq_eq_one_mod_sq_of_eq_mod hp2 _ _ _;
        · erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
        · simp_all +decide [ legendreSym ];
          simp +decide [ quadraticCharFun ];
          erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases p <;> trivial;
        · simp_all +decide [ legendreSym ];
      -- Let's consider the two cases: $\left(\frac{5}{p}\right) = 1$ and $\left(\frac{5}{p}\right) = -1$.
      by_cases h_case : legendreSym p 5 = 1 ∨ legendreSym p 5 = -1;
      · cases h_case <;> simp_all +decide [ WallSunSunPrime ];
        · -- If $\left(\frac{5}{p}\right) = 1$, then $F_{p-1} = \frac{L_p - F_p}{2} \equiv \frac{1 - 1}{2} = 0 \mod p^2$.
          have h_fib_pred : (Nat.fib (p - 1) : ℤ) * 2 ≡ (lucas p : ℤ) - (Nat.fib p : ℤ) [ZMOD p^2] := by
            have h_fib_pred : (Nat.fib (p - 1) : ℤ) * 2 = (lucas p : ℤ) - (Nat.fib p : ℤ) := by
              rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.fib_add_two, lucas ];
              linarith! [ two_mul_fib_pred_eq_lucas_sub_fib ( p + 1 ) ( Nat.succ_pos _ ), two_mul_fib_succ_eq_lucas_add_fib p ];
            rw [h_fib_pred];
          -- Since $2$ is invertible modulo $p^2$, we can divide both sides of the congruence by $2$.
          have h_fib_pred_div : (Nat.fib (p - 1) : ℤ) ≡ 0 [ZMOD p^2] := by
            have h_fib_pred_div : (Nat.fib (p - 1) : ℤ) * 2 ≡ 0 [ZMOD p^2] := by
              erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
            rw [ Int.modEq_zero_iff_dvd ] at *;
            refine' Int.dvd_of_dvd_mul_left_of_gcd_one h_fib_pred_div _;
            exact_mod_cast Nat.Coprime.pow_left 2 ( hp.1.coprime_iff_not_dvd.mpr fun h => hp2 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial );
          exact ⟨ hp.1, by erw [ ← ZMod.intCast_eq_intCast_iff ] at *; aesop ⟩;
        · -- Using the identity $2 F_{p+1} = L_p + F_p$, we substitute $L_p \equiv 1$ and $F_p \equiv -1$ to get $2 F_{p+1} \equiv 1 - 1 \equiv 0 \mod p^2$.
          have h_fib_succ : 2 * (Nat.fib (p + 1) : ℤ) ≡ 0 [ZMOD p^2] := by
            have h_fib_succ : 2 * (Nat.fib (p + 1) : ℤ) ≡ (lucas p : ℤ) + (Nat.fib p : ℤ) [ZMOD p^2] := by
              exact congr_arg ( · % _ ) ( mod_cast two_mul_fib_succ_eq_lucas_add_fib p );
            erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
          -- Since $p$ is odd, $2$ is invertible modulo $p^2$, so we can divide both sides of $2 F_{p+1} \equiv 0 \mod p^2$ by $2$ to get $F_{p+1} \equiv 0 \mod p^2$.
          have h_fib_succ_div : (Nat.fib (p + 1) : ℤ) ≡ 0 [ZMOD p^2] := by
            rw [ Int.modEq_zero_iff_dvd ] at *;
            refine' Int.dvd_of_dvd_mul_right_of_gcd_one h_fib_succ _;
            exact_mod_cast Nat.Coprime.pow_left 2 ( hp.1.coprime_iff_not_dvd.mpr fun h => hp2 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial );
          exact ⟨ hp.1, by erw [ ← ZMod.intCast_eq_intCast_iff ] at *; aesop ⟩;
      · simp_all +decide [ legendreSym ];
        simp_all +decide [ quadraticCharFun ];
        split_ifs at h_case <;> simp_all +decide;
        erw [ ZMod.natCast_eq_zero_iff ] at * ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ];
        have := Nat.le_of_dvd ( by decide ) ‹p ∣ 5›; interval_cases p <;> trivial;

/-
Wall-Sun-Sun Prime iff L_p ≡ 1 (mod p²).
-/
theorem wall_sun_sun_prime_iff_lucas_congruence (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5) :
  WallSunSunPrime p ↔ (lucas p : ZMod (p^2)) = 1 := by
  constructor
  · exact lucas_congruence_of_wall_sun_sun_prime p hp2 hp5
  · exact lucas_congruence_implies_wall_sun_sun_prime p hp2 hp5

/-
Pisano period property for (5/p) = 1.
-/
def is_fib_period (m : ℕ) (p : ℕ) : Prop :=
  Nat.fib m ≡ 0 [MOD p] ∧ Nat.fib (m + 1) ≡ 1 [MOD p]

theorem fib_period_of_legendre_eq_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = 1) : is_fib_period (p - 1) p := by
      constructor;
      · simpa [ ← ZMod.natCast_eq_natCast_iff ] using fib_pred_eq_zero_of_legendre_eq_one p hp2 hp5 h5;
      · -- Since p is prime and (5/p) = 1, we can apply the theorem fib_mod_prime_of_legendre_eq_one.
        have h_fib_p : Nat.fib p ≡ 1 [ZMOD p] := by
          have := fib_mod_prime_of_legendre_eq_one p hp2 hp5 h5; erw [ ← ZMod.intCast_eq_intCast_iff ] at *; aesop;
        rw [ Nat.sub_add_cancel hp.1.pos ] ; simpa [ ← Int.natCast_modEq_iff ] using h_fib_p;

/-
Pisano period property for (5/p) = -1.
-/
theorem fib_period_of_legendre_eq_neg_one (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5)
    (h5 : legendreSym p 5 = -1) : is_fib_period (2 * (p + 1)) p := by
      -- We need F_{2(p+1)} ≡ 0 and F_{2(p+1)+1} ≡ 1.
      have h_fib_period : (Nat.fib (2 * (p + 1)) : ℕ) ≡ 0 [MOD p] ∧ (Nat.fib (2 * (p + 1) + 1) : ℕ) ≡ 1 [MOD p] := by
        have h_fib_p1 : (Nat.fib (p + 1) : ZMod p) = 0 := fib_succ_eq_zero_of_legendre_eq_neg_one p hp2 hp5 h5
        have h_fib_p : (Nat.fib p : ZMod p) = -1 := fib_mod_prime_of_legendre_eq_neg_one p hp2 hp5 h5
        -- Using double angle formulas, $F_{2(p+1)} = F_{p+1} L_{p+1} ≡ 0 * L_{p+1} = 0 (mod p)$ and $F_{2(p+1)+1} = F_{p+2}^2 + F_{p+1}^2 ≡ (-1)^2 + 0^2 = 1 (mod p)$.
        have h_fib_2p1 : Nat.fib (2 * (p + 1)) ≡ 0 [ZMOD p] := by
          simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
          simp_all +decide [ Nat.fib_two_mul ]
        have h_fib_2p1_1 : Nat.fib (2 * (p + 1) + 1) ≡ 1 [ZMOD p] := by
          -- Using double angle formulas, $F_{2(p+1)+1} = F_{p+2}^2 + F_{p+1}^2 ≡ (-1)^2 + 0^2 = 1 (mod p)$.
          have h_fib_2p1_1 : Nat.fib (2 * (p + 1) + 1) = Nat.fib (p + 2)^2 + Nat.fib (p + 1)^2 := by
            exact?
          generalize_proofs at *; (
          simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
          simp_all +decide [ Nat.fib_add_two ])
        exact (by
        simpa [ ← Int.natCast_modEq_iff ] using And.intro h_fib_2p1 h_fib_2p1_1)-- Using double angle formulas, $F_{2(p+1)} = F_{p+1} L_{p+1} ≡ 0 * L_{p+1} = 0 (mod p)$.
      have h_fib_2p1 : Nat.fib (2 * (p + 1)) ≡ 0 [ZMOD p] := by
        simpa [ ← Int.natCast_modEq_iff ] using h_fib_period.1

      -- Using double angle formulas, $F_{2(p+1)+1} = F_{p+2}^2 + F_{p+1}^2 ≡ (-1)^2 + 0^2 = 1 (mod p)$.
      have h_fib_2p1_1 : Nat.fib (2 * (p + 1) + 1) ≡ 1 [ZMOD p] := by
        simpa [ ← Int.natCast_modEq_iff ] using h_fib_period.2

      -- Thus, $is_fib_period (2(p+1)) p$ holds.
      exact ⟨by
      exact_mod_cast h_fib_2p1, by
        grind⟩

/-
There exists a multiple of p-1 that is a Fibonacci zero mod p.
-/
theorem fib_period_divides (p : ℕ) [hp : Fact p.Prime] (hp2 : p ≠ 2) (hp5 : p ≠ 5) :
  ∃ k, k > 0 ∧ Nat.fib (k * (p - 1)) ≡ 0 [MOD p] := by
    -- Apply the theorem that states $F_{p - \left(\frac{5}{p}\right)} \equiv 0 \pmod{p}$.
    have h_fib_rank : Nat.fib (if legendreSym p 5 = 1 then p - 1 else p + 1) ≡ 0 [MOD p] := by
      have := fib_rank_apparition p hp2 hp5
      simpa [ ← ZMod.natCast_eq_natCast_iff ] using this;
    split_ifs at h_fib_rank <;> simp_all +decide [ Nat.modEq_zero_iff_dvd ];
    · exact ⟨ 1, by norm_num, by simpa using h_fib_rank ⟩;
    · -- By definition of Fibonacci sequence, we know that $F_{(p+1)(p-1)} \equiv 0 \pmod{p}$.
      have h_fib_mul : Nat.fib ((p + 1) * (p - 1)) ≡ 0 [MOD p] := by
        rw [ Nat.modEq_zero_iff_dvd ];
        exact dvd_trans h_fib_rank ( by simpa [ Nat.fib_dvd ] );
      exact ⟨ p + 1, Nat.succ_pos _, Nat.dvd_of_mod_eq_zero h_fib_mul ⟩