/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a1a378a7-1942-4bf8-87e4-2c73d39b3884
-/

/-
We have determined that the diagonal exclusion hypothesis is FALSE.

We constructed a counterexample `G_ex` (a graph on 8 vertices) which satisfies all the conditions of a `Cycle4` configuration but contains a triangle `T1_ex = {0, 2, 6}` that includes both `v_ab` (vertex 2) and `v_cd` (vertex 6). This is formally proven in `diagonal_exclusion_false`.

Additionally, we disproved the related conjectures:
- `diagonal_non_adjacency_test` is FALSE (proven in `diagonal_non_adjacency_false` using `G_ex`).
- `shared_vertices_distinct` is FALSE (proven in `shared_vertices_distinct_false` using a "Star" graph counterexample `G_star`).
- `triangle_at_vab_shares_AB` is FALSE (proven in `triangle_at_vab_shares_AB_false` using `G_star`).

The counterexamples demonstrate that the `Cycle4` structure alone does not enforce the geometric intuition of "opposite corners" being far apart or distinct in the general graph setting.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

structure Cycle4 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  -- Triangles are 3-cliques
  hA_tri : A ∈ G.cliqueFinset 3
  hB_tri : B ∈ G.cliqueFinset 3
  hC_tri : C ∈ G.cliqueFinset 3
  hD_tri : D ∈ G.cliqueFinset 3
  -- Shared vertices
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  -- Intersection structure (cycle adjacencies)
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  -- Membership
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A

/-
A counterexample graph on 8 vertices.
-/
abbrev V_ex := Fin 8

def A_ex : Finset V_ex := {0, 1, 2}
def B_ex : Finset V_ex := {2, 3, 4}
def C_ex : Finset V_ex := {4, 5, 6}
def D_ex : Finset V_ex := {6, 7, 0}
def M_ex : Finset (Finset V_ex) := {A_ex, B_ex, C_ex, D_ex}

def cliqueEdges (s : Finset V_ex) : Finset (Sym2 V_ex) :=
  s.offDiag.image (fun x => Sym2.mk x)

def G_ex_edges : Finset (Sym2 V_ex) :=
  cliqueEdges A_ex ∪ cliqueEdges B_ex ∪ cliqueEdges C_ex ∪ cliqueEdges D_ex ∪ {Sym2.mk (2, 6)}

def G_ex : SimpleGraph V_ex where
  Adj a b := Sym2.mk (a, b) ∈ G_ex_edges
  symm a b h := by
    decide +revert
  loopless a h := by
    -- Since loops are not allowed, (a, a) cannot be in G_ex_edges.
    have h_no_loop : ¬(s(a, a) ∈ G_ex_edges) := by
      decide +revert;
    contradiction

instance : DecidableRel G_ex.Adj := fun a b => Finset.decidableMem _ _

/-
The set of triangles in G_ex is exactly {A, B, C, D, T1, T2}.
-/
def T1_ex : Finset V_ex := {0, 2, 6}
def T2_ex : Finset V_ex := {2, 4, 6}

lemma G_ex_triangles : G_ex.cliqueFinset 3 = {A_ex, B_ex, C_ex, D_ex, T1_ex, T2_ex} := by
  -- Since V_ex is finite (Fin 8), we can just decide equality of finsets
  -- However, `decide` might be too slow or hit recursion limits if not careful.
  -- Let's try `decide` first.
  rw [Finset.ext_iff]
  intro t
  -- We can expand the definition of cliqueFinset and the RHS
  -- But for Fin 8, `decide` should work if we have Decidable instances.
  -- We have DecidableRel G_ex.Adj.
  -- We need Decidable (t ∈ G_ex.cliqueFinset 3) and Decidable (t ∈ RHS).
  -- These should be inferable.
  native_decide +revert

/-
M_ex is a triangle packing in G_ex.
-/
lemma M_ex_is_packing : isTrianglePacking G_ex M_ex := by
  constructor;
  · native_decide +revert;
  · simp +decide [ Set.Pairwise ]

/-
The triangle packing number of G_ex is 4.
-/
lemma G_ex_packing_number : trianglePackingNumber G_ex = 4 := by
  unfold trianglePackingNumber;
  unfold isTrianglePacking;
  refine' le_antisymm _ _ <;> norm_num [ G_ex_triangles ];
  · native_decide +revert;
  · simp +decide [ Set.Pairwise ]

/-
The set of all triangles has size 6.
-/
def T_all : Finset (Finset V_ex) := {A_ex, B_ex, C_ex, D_ex, T1_ex, T2_ex}

lemma T_all_card : T_all.card = 6 := by
  simp [T_all, A_ex, B_ex, C_ex, D_ex, T1_ex, T2_ex]
  -- We need to show all elements are distinct.
  -- Since they are concrete Finsets of Fin 8, `decide` should work.
  decide

/-
A valid Cycle4 configuration for G_ex.
-/
def cfg_ex : Cycle4 G_ex M_ex := {
  A := A_ex
  B := B_ex
  C := C_ex
  D := D_ex
  hA := by
    native_decide +revert
  hB := by
    exact Finset.mem_insert_of_mem ( Finset.mem_insert_self _ _ )
  hC := by
    native_decide
  hD := by
    native_decide +revert
  hM_eq := rfl
  hA_tri := by
    simp +decide [ SimpleGraph.cliqueFinset ]
  hB_tri := by
    native_decide +revert
  hC_tri := by
    unfold C_ex; simp +decide [ G_ex ] ;
  hD_tri := by
    native_decide +revert
  v_ab := 2
  v_bc := 4
  v_cd := 6
  v_da := 0
  hAB := by
    native_decide
  hBC := by
    decide +revert
  hCD := by
    native_decide
  hDA := by
    native_decide
  h_vab_A := by
    decide
  h_vab_B := by
    decide
  h_vbc_B := by
    native_decide +revert
  h_vbc_C := by
    decide
  h_vcd_C := by
    decide +revert
  h_vcd_D := by
    decide
  h_vda_D := by
    native_decide +revert
  h_vda_A := by
    decide +revert
}

/-
The diagonal exclusion conjecture is false.
-/
theorem diagonal_exclusion_false : ¬ (∀ (G : SimpleGraph V_ex) [DecidableRel G.Adj]
    (M : Finset (Finset V_ex)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (h_diag_AC : (cfg.A ∩ cfg.C).card ≤ 1)
    (h_diag_BD : (cfg.B ∩ cfg.D).card ≤ 1)
    (t : Finset V_ex) (ht : t ∈ G.cliqueFinset 3),
    ¬(cfg.v_ab ∈ t ∧ cfg.v_cd ∈ t)) := by
      push_neg;
      use G_ex;
      refine' ⟨ inferInstance, M_ex, _, cfg_ex, _, _, _ ⟩;
      · constructor;
        · exact?;
        · rw [ G_ex_packing_number ];
          native_decide;
      · native_decide +revert;
      · native_decide +revert;
      · decide +kernel

/-
The diagonal non-adjacency conjecture is false.
-/
theorem diagonal_non_adjacency_false : ¬ (∀ (G : SimpleGraph V_ex) [DecidableRel G.Adj]
    (M : Finset (Finset V_ex)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (h_diag_AC : (cfg.A ∩ cfg.C).card ≤ 1)
    (h_diag_BD : (cfg.B ∩ cfg.D).card ≤ 1),
    ¬G.Adj cfg.v_ab cfg.v_cd) := by
      push_neg;
      use G_ex, inferInstance;
      refine' ⟨ M_ex, _, cfg_ex, _ ⟩;
      · constructor;
        · exact?;
        · exact Eq.symm ( G_ex_packing_number ▸ by native_decide );
      · native_decide +revert

/-
A Star graph counterexample.
-/
abbrev V_star := Fin 9

def A_star : Finset V_star := {0, 1, 2}
def B_star : Finset V_star := {0, 3, 4}
def C_star : Finset V_star := {0, 5, 6}
def D_star : Finset V_star := {0, 7, 8}
def M_star : Finset (Finset V_star) := {A_star, B_star, C_star, D_star}

def cliqueEdgesStar (s : Finset V_star) : Finset (Sym2 V_star) :=
  s.offDiag.image (fun x => Sym2.mk x)

def G_star_edges : Finset (Sym2 V_star) :=
  cliqueEdgesStar A_star ∪ cliqueEdgesStar B_star ∪ cliqueEdgesStar C_star ∪ cliqueEdgesStar D_star

def G_star : SimpleGraph V_star where
  Adj a b := Sym2.mk (a, b) ∈ G_star_edges
  symm a b h := by
    decide +revert
  loopless a h := by
    have h_no_loop : ¬(s(a, a) ∈ G_star_edges) := by
      decide +revert;
    contradiction

instance : DecidableRel G_star.Adj := fun a b => Finset.decidableMem _ _

/-
The set of triangles in G_star is exactly {A, B, C, D}.
-/
lemma G_star_triangles : G_star.cliqueFinset 3 = {A_star, B_star, C_star, D_star} := by
  native_decide

/-
M_star is a triangle packing in G_star.
-/
lemma M_star_is_packing : isTrianglePacking G_star M_star := by
  constructor;
  · native_decide +revert;
  · simp +decide [ Set.Pairwise ]

/-
The triangle packing number of G_star is 4.
-/
lemma G_star_packing_number : trianglePackingNumber G_star = 4 := by
  unfold trianglePackingNumber
  unfold isTrianglePacking
  -- The set of triangles is {A, B, C, D}.
  -- Any subset is a packing because pairwise intersection is {0} (card 1).
  -- So the max size is 4.
  refine' le_antisymm _ _ <;> norm_num [ G_star_triangles ];
  · native_decide +revert;
  · simp +decide [ Set.Pairwise ]

/-
A valid Cycle4 configuration for G_star.
-/
def cfg_star : Cycle4 G_star M_star := {
  A := A_star
  B := B_star
  C := C_star
  D := D_star
  hA := by
    exact Finset.mem_insert_self _ _
  hB := by
    native_decide +revert
  hC := by
    simp +decide [ M_star ]
  hD := by
    simp +decide [ M_star ]
  hM_eq := rfl
  hA_tri := by
    native_decide +revert
  hB_tri := by
    simp +decide [ SimpleGraph.cliqueFinset ]
  hC_tri := by
    native_decide +revert
  hD_tri := by
    native_decide
  v_ab := 0
  v_bc := 0
  v_cd := 0
  v_da := 0
  hAB := by
    native_decide +revert
  hBC := by
    native_decide
  hCD := by
    native_decide +revert
  hDA := by
    native_decide
  h_vab_A := by
    decide
  h_vab_B := by
    decide
  h_vbc_B := by
    decide
  h_vbc_C := by
    decide
  h_vcd_C := by
    decide
  h_vcd_D := by
    decide
  h_vda_D := by
    decide
  h_vda_A := by
    decide
}

/-
The shared vertices distinctness conjecture is false.
-/
theorem shared_vertices_distinct_false : ¬ (∀ (G : SimpleGraph V_star) [DecidableRel G.Adj]
    (M : Finset (Finset V_star)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (h_diag_AC : (cfg.A ∩ cfg.C).card ≤ 1)
    (h_diag_BD : (cfg.B ∩ cfg.D).card ≤ 1),
    cfg.v_ab ≠ cfg.v_bc ∧ cfg.v_ab ≠ cfg.v_cd ∧ cfg.v_ab ≠ cfg.v_da ∧
    cfg.v_bc ≠ cfg.v_cd ∧ cfg.v_bc ≠ cfg.v_da ∧
    cfg.v_cd ≠ cfg.v_da) := by
      simp +zetaDelta at *;
      refine' ⟨ G_star, _, M_star, _, _ ⟩;
      exact?;
      · constructor;
        · exact?;
        · rw [ G_star_packing_number ];
          native_decide;
      · exists cfg_star

/-
The 'triangle at v_ab shares edge with A or B' conjecture is false.
-/
theorem triangle_at_vab_shares_AB_false : ¬ (∀ (G : SimpleGraph V_star) [DecidableRel G.Adj]
    (M : Finset (Finset V_star)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M)
    (t : Finset V_star) (ht : t ∈ G.cliqueFinset 3) (h_vab : cfg.v_ab ∈ t),
    (t ∩ cfg.A).card ≥ 2 ∨ (t ∩ cfg.B).card ≥ 2) := by
      push_neg;
      use G_star;
      refine' ⟨ _, _, _, cfg_star, _ ⟩;
      · constructor;
        · exact?;
        · rw [ G_star_packing_number ];
          native_decide;
      · exists { 0, 5, 6 }