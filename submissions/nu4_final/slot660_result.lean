/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b4d580e8-2301-489a-bc99-7836cd53e22c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of IATA Rule 3015 missing items, including:
1. Updated Rule 4k with complete city lists for US/Canada transcontinental flights and Anchorage restriction.
2. Updated Rule 4l with Australia exceptions (A and B).
3. Updated Rule 4c with Middle East specific open jaw restriction.
4. Rule 4j codeshare rules, including OneWorldCarrier definitions, permitted carriers, and QF domestic restrictions.
5. Premium Economy surcharges and proof of positivity.
6. Booking code mappings (Rule 5b).
7. Sales restrictions (Rule 15) including ticketing stock and Cuba restrictions.
8. Voluntary changes and cancellation penalties (Rule 16), with proof that Business/First penalty is ≤ Economy.
9. Group travel rules (Rule 26) and proof of size bounds.
10. Proofs for child fare pricing, Cuba restriction validity, and transcontinental city list properties.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e3cbae52-db06-4c2c-a15b-4e3cf42a18d1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of IATA Rule 3015 constraints including backtracking, transit, intercontinental limits, international origin limits, surface sectors, segment limits, duplicate sectors, transcontinental limits, stopovers, minimum/maximum stay, open jaw, and children pricing.
Proved properties:
- Child fare is strictly less than adult fare.
- Fare basis is determined for any valid RTW itinerary.
- Minimum 2 stopovers implies minimum 3 segments.
- No duplicate sectors implies bounded segment count.
- Sum of intra-continent segment limits is 26.
- Ocean crossings imply visiting 3 TC areas.
- TC sequence for TC1 origin is TC1->TC2->TC3->TC1.
- Generalized loop (open jaw) preserves continent.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9ad82119-8077-465a-953f-e811983a7c3b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of IATA Rule 3015 (oneworld Explorer Round-the-World fare rules).
This module defines the necessary types (Continent, TCArea, CabinClass, FareBasis, City, Segment, Itinerary)
and the validity predicate `ValidRTW` which encodes the routing constraints.
It also includes proofs that any valid itinerary satisfies the ocean crossing, segment count, and continent count constraints,
and that the fare basis is uniquely determined for any valid itinerary and cabin class.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Continent and TCArea according to IATA Rule 3015.
Continents are: Europe-Middle East, Africa, Asia, South West Pacific, North America, South America.
TC Areas are:
TC1 = North America + South America
TC2 = Europe-Middle East + Africa
TC3 = Asia + South West Pacific
-/
inductive Continent
| EuropeMiddleEast
| Africa
| Asia
| SouthWestPacific
| NorthAmerica
| SouthAmerica
deriving Repr, DecidableEq, Inhabited

inductive TCArea
| TC1
| TC2
| TC3
deriving Repr, DecidableEq, Inhabited

def Continent.toTCArea : Continent → TCArea
| .NorthAmerica => .TC1
| .SouthAmerica => .TC1
| .EuropeMiddleEast => .TC2
| .Africa => .TC2
| .Asia => .TC3
| .SouthWestPacific => .TC3

/-
Define CabinClass and FareBasis.
Cabin classes: Economy, Business, First.
Fare bases: LONE3, IONE3, DONE3, AONE3, LONE4, DONE4, AONE4, LONE5, DONE5, AONE5, LONE6, DONE6, AONE6.
-/
inductive CabinClass
| Economy
| Business
| First
deriving Repr, DecidableEq, Inhabited

inductive FareBasis
| LONE3 | IONE3 | DONE3 | AONE3
| LONE4 | DONE4 | AONE4
| LONE5 | DONE5 | AONE5
| LONE6 | DONE6 | AONE6
deriving Repr, DecidableEq, Inhabited

/-
Define City, SegmentType, Segment, Itinerary, and Ocean.
A City has an id, a continent, and a country.
A SegmentType is either Flight or Surface.
A Segment has an origin, destination, type, and isStopover flag.
An Itinerary is a list of Segments.
Oceans are Atlantic and Pacific.
-/
structure City where
  id : String
  continent : Continent
  country : String
deriving Repr, DecidableEq, Inhabited

inductive SegmentType
| Flight
| Surface
deriving Repr, DecidableEq, Inhabited

structure Segment where
  origin : City
  destination : City
  type : SegmentType
  isStopover : Bool
deriving Repr, DecidableEq, Inhabited

def Itinerary := List Segment

inductive Ocean
| Atlantic
| Pacific
deriving Repr, DecidableEq, Inhabited

/-
Define helper functions:
- get_ocean: determines if a segment between two continents crosses an ocean.
- visited_continents: lists all unique continents visited, adding Asia if SWP-EME direct flight exists.
- continent_count: counts visited continents.
- ocean_crossings: lists all ocean crossings in the itinerary.
- fare_basis: determines the fare basis code from cabin class and continent count.
-/
def get_ocean (c1 c2 : Continent) : Option Ocean :=
  match c1.toTCArea, c2.toTCArea with
  | .TC1, .TC2 => some .Atlantic
  | .TC2, .TC1 => some .Atlantic
  | .TC1, .TC3 => some .Pacific
  | .TC3, .TC1 => some .Pacific
  | _, _ => none

def visited_continents (itin : Itinerary) : List Continent :=
  let origins := itin.map (fun s => s.origin.continent)
  let dests := itin.map (fun s => s.destination.continent)
  let all_points := origins ++ dests
  let unique := all_points.eraseDup
  let has_swp_eme := itin.any fun s =>
    (s.origin.continent == .SouthWestPacific && s.destination.continent == .EuropeMiddleEast) ||
    (s.origin.continent == .EuropeMiddleEast && s.destination.continent == .SouthWestPacific)
  if has_swp_eme && !unique.contains .Asia then .Asia :: unique else unique

def continent_count (itin : Itinerary) : Nat := (visited_continents itin).length

def ocean_crossings (itin : Itinerary) : List Ocean :=
  itin.filterMap fun s => get_ocean s.origin.continent s.destination.continent

def fare_basis (cabin : CabinClass) (itin : Itinerary) : Option FareBasis :=
  let cc := continent_count itin
  match cabin, cc with
  | .Economy, 3 => some .LONE3
  | .Business, 3 => some .DONE3
  | .First, 3 => some .AONE3
  | .Economy, 4 => some .LONE4
  | .Business, 4 => some .DONE4
  | .First, 4 => some .AONE4
  | .Economy, 5 => some .LONE5
  | .Business, 5 => some .DONE5
  | .First, 5 => some .AONE5
  | .Economy, 6 => some .LONE6
  | .Business, 6 => some .DONE6
  | .First, 6 => some .AONE6
  | _, _ => none

/-
Define is_continuous, is_loop, count_ocean, visited_tc_areas, and ValidRTW.
ValidRTW requires:
- Continuous itinerary
- Loop (start = end)
- 3 to 16 segments
- Exactly 1 Atlantic crossing
- Exactly 1 Pacific crossing
- Visits all 3 TC areas (implied by TC1-TC2-TC3 routing)
-/
def is_continuous (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | _ :: [] => True
  | s1 :: s2 :: rest => s1.destination = s2.origin ∧ is_continuous (s2 :: rest)

def is_loop (itin : Itinerary) : Prop :=
  match itin with
  | [] => False
  | s :: _ =>
    match itin.getLast? with
    | some last => s.origin = last.destination
    | none => False

def count_ocean (itin : Itinerary) (o : Ocean) : Nat :=
  (ocean_crossings itin).filter (· == o) |>.length

def visited_tc_areas (itin : Itinerary) : List TCArea :=
  (visited_continents itin).map Continent.toTCArea |>.eraseDup

structure ValidRTW (itin : Itinerary) : Prop where
  continuous : is_continuous itin
  loop : is_loop itin
  min_segments : itin.length ≥ 3
  max_segments : itin.length ≤ 16
  one_atlantic : count_ocean itin .Atlantic = 1
  one_pacific : count_ocean itin .Pacific = 1
  visits_all_tc : (visited_tc_areas itin).length = 3
  -- We assume the "continuous forward direction" and other constraints imply we visit them in order,
  -- but for the purpose of the requested proofs, visiting all 3 is the key structural property derived from the oceans + loop.
  -- Actually, let's just stick to what's needed for the proofs requested.
  -- The rule 4b says "Travel must be in a continuous forward direction between TC1 - TC2 - TC3".
  -- This implies we touch all three.

/-
Theorem: Any ValidRTW itinerary has exactly one Atlantic crossing and one Pacific crossing.
Proof: This follows directly from the definition of ValidRTW.
-/
theorem valid_rtw_ocean_crossings (itin : Itinerary) (h : ValidRTW itin) :
  count_ocean itin .Atlantic = 1 ∧ count_ocean itin .Pacific = 1 := by
  exact ⟨ h.one_atlantic, h.one_pacific ⟩

/-
Theorem: Any ValidRTW itinerary has between 3 and 16 segments.
Proof: This follows directly from the definition of ValidRTW.
-/
theorem valid_rtw_segment_count (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ itin.length ∧ itin.length ≤ 16 := by
  exact ⟨h.min_segments, h.max_segments⟩

/-
Theorem: The continent count for any valid RTW itinerary is between 3 and 6.
Proof:
1. Upper bound: There are only 6 continents defined. The `visited_continents` function returns a list of unique continents (potentially adding Asia if implied), so its length cannot exceed 6.
2. Lower bound: `ValidRTW` requires visiting all 3 TC areas. Since each TC area corresponds to a disjoint set of continents, visiting 3 distinct TC areas implies visiting at least 3 distinct continents.
-/
theorem valid_rtw_continent_count (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
  constructor;
  · -- Since the itinerary must visit all three TC areas, and each TC area corresponds to a disjoint set of continents, the itinerary must visit at least three distinct continents.
    have h_visited_continents : (visited_continents itin).length ≥ 3 := by
      have h_tc_areas : (visited_tc_areas itin).length = 3 := h.visits_all_tc
      unfold visited_tc_areas at h_tc_areas;
      -- Since `List.map` preserves the length of the list, we can conclude that the length of `visited_continents itin` is at least 3.
      have h_length : (List.map Continent.toTCArea (visited_continents itin)).length ≥ (List.map Continent.toTCArea (visited_continents itin)).eraseDup.length := by
        induction ( List.map Continent.toTCArea ( visited_continents itin ) ) <;> simp +decide [ * ];
        simp_all +decide [ List.eraseDup ];
        simp_all +decide [ List.pwFilter ];
        grind;
      aesop;
    exact h_visited_continents;
  · unfold continent_count;
    -- The list of continents is a subset of the set of all continents, which has 6 elements.
    have h_subset : (visited_continents itin).toFinset ⊆ {Continent.EuropeMiddleEast, Continent.Africa, Continent.Asia, Continent.SouthWestPacific, Continent.NorthAmerica, Continent.SouthAmerica} := by
      intro x hx;
      cases x <;> simp +decide;
    convert Finset.card_le_card h_subset using 1;
    rw [ List.toFinset_card_of_nodup ];
    -- The list of continents is a subset of the set of all continents, which has 6 elements. Therefore, the length of the list is at most 6.
    have h_nodup : ∀ (l : List Continent), List.Nodup (List.eraseDup l) := by
      intro l; induction l <;> simp_all +decide [ List.eraseDup ] ;
      simp_all +decide [ List.pwFilter ];
      grind;
    unfold visited_continents; aesop;

/-
Theorem: For any valid RTW itinerary and any cabin class, the fare basis is determined (i.e., not none).
Proof:
1. We know from `valid_rtw_continent_count` that the continent count is between 3 and 6.
2. The `fare_basis` function is defined for all cabin classes and continent counts from 3 to 6.
3. Therefore, `fare_basis` returns `some` value.
-/
theorem valid_rtw_fare_determined (itin : Itinerary) (cabin : CabinClass) (h : ValidRTW itin) :
  (fare_basis cabin itin).isSome := by
  have h_continent_count : 3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?;
  unfold fare_basis;
  rcases h_continent_count with ⟨ _, _ ⟩ ; interval_cases _ : continent_count itin <;> simp +decide [ * ] ;
  · cases cabin <;> trivial;
  · cases cabin <;> trivial;
  · cases cabin <;> trivial;
  · rcases cabin with ( _ | _ | _ ) <;> trivial

/-
Formalization of Rules 4b, 4d, and 4e.
-/
def is_hawaii (c : City) : Bool := c.id == "HNL"

def is_mainland_na (c : City) : Bool := c.continent == .NorthAmerica ∧ ¬is_hawaii c

def next_tc (t : TCArea) : TCArea :=
  match t with
  | .TC1 => .TC2
  | .TC2 => .TC3
  | .TC3 => .TC1

def is_forward_tc_move (t1 t2 : TCArea) : Bool :=
  t1 == t2 ∨ t2 == next_tc t1

def rule_4b_forward_direction (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | _ =>
    let areas := itin.map (fun s => s.origin.continent.toTCArea) ++ [itin.getLast!.destination.continent.toTCArea]
    List.all (List.zip areas (areas.drop 1)) (fun (a1, a2) => is_forward_tc_move a1 a2)

def rule_4b_hawaii_backtracking (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | _ =>
    let cities := itin.map (fun s => s.origin) ++ [itin.getLast!.destination]
    let triples := cities.zip (cities.drop 1 |>.zip (cities.drop 2))
    triples.all fun (c1, (c2, c3)) =>
      ¬(is_mainland_na c1 ∧ is_hawaii c2 ∧ is_mainland_na c3) ∧
      ¬(is_hawaii c1 ∧ is_mainland_na c2 ∧ is_hawaii c3)

def rule_4d_no_transit_origin (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | s :: _ =>
    let origin := s.origin
    let intermediates := itin.drop 1 |>.map (fun s => s.origin)
    ¬intermediates.contains origin

def count_intercontinental_departures (itin : Itinerary) (c : Continent) : Nat :=
  itin.filter (fun s => s.origin.continent == c ∧ s.destination.continent != c) |>.length

def count_intercontinental_arrivals (itin : Itinerary) (c : Continent) : Nat :=
  itin.filter (fun s => s.destination.continent == c ∧ s.origin.continent != c) |>.length

def is_mru_zaf (c : City) : Bool := c.country == "MU" ∨ c.country == "ZA"

def rule_4e_intercontinental_limits (itin : Itinerary) : Prop :=
  let continents := [Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific]
  continents.all fun c =>
    let deps := count_intercontinental_departures itin c
    let arrs := count_intercontinental_arrivals itin c
    match c with
    | .NorthAmerica => deps ≤ 2 ∧ arrs ≤ 2
    | .Asia =>
      let limit := if (visited_continents itin).contains .SouthWestPacific ∧ (visited_continents itin).contains .EuropeMiddleEast then 2 else 1
      deps ≤ limit ∧ arrs ≤ limit
    | .EuropeMiddleEast =>
      let limit := if (visited_continents itin).contains .Africa then 2 else 1
      let mru_zaf_constraint := if deps > 1 ∨ arrs > 1 then ¬itin.any (fun s => is_mru_zaf s.origin ∨ is_mru_zaf s.destination) else True
      deps ≤ limit ∧ arrs ≤ limit ∧ mru_zaf_constraint
    | _ => deps ≤ 1 ∧ arrs ≤ 1

/-
Formalization of Rules 4f, 4g, 4h, and 4i.
-/
def is_international (s : Segment) : Bool :=
  s.origin.country != s.destination.country ∧
  ¬((s.origin.country == "US" ∧ s.destination.country == "CA") ∨
    (s.origin.country == "CA" ∧ s.destination.country == "US"))

def is_transfer_at_origin (itin : Itinerary) (s : Segment) : Bool :=
  match itin.zip (itin.drop 1) |>.find? (fun (s1, s2) => s2 == s) with
  | some (prev, _) => prev.destination == s.origin ∧ prev.isStopover == false
  | none => false

def count_international_departures_from_country (itin : Itinerary) (country : String) : Nat :=
  itin.filter (fun s => s.origin.country == country ∧ is_international s) |>.length

def count_international_arrivals_to_country (itin : Itinerary) (country : String) : Nat :=
  itin.filter (fun s => s.destination.country == country ∧ is_international s) |>.length

def count_transfers_in_country (itin : Itinerary) (country : String) : Nat :=
  itin.filter (fun s => s.destination.country == country ∧ s.isStopover == false) |>.length

def rule_4f_international_origin (itin : Itinerary) : Prop :=
  match itin with
  | [] => True
  | s :: _ =>
    let origin_country := s.origin.country
    let intl_deps := itin.filter (fun s => s.origin.country == origin_country ∧ is_international s)
    let intl_arrs := count_international_arrivals_to_country itin origin_country
    let dep_ok :=
      if origin_country == "US" then
        intl_deps.length ≤ 1 ∨ (intl_deps.length == 2 ∧ intl_deps.any (fun s => is_transfer_at_origin itin s))
      else
        intl_deps.length ≤ 1
    let arr_ok := intl_arrs ≤ 1
    let transfers_ok :=
      (itin.map (fun s => s.destination.country)).eraseDup.all fun c =>
        count_transfers_in_country itin c ≤ 4
    dep_ok ∧ arr_ok ∧ transfers_ok

def is_transoceanic (s : Segment) : Bool :=
  get_ocean s.origin.continent s.destination.continent |>.isSome

def rule_4g_surface_sectors (itin : Itinerary) : Prop :=
  let surface_sectors := itin.filter (fun s => s.type == .Surface)
  let transoceanic_surfaces := surface_sectors.filter is_transoceanic
  let allowed_transoceanic := if itin.head?.map (fun s => s.origin.continent) == some .SouthWestPacific then 1 else 0
  let surface_ok := transoceanic_surfaces.length ≤ allowed_transoceanic
  let first_crossing_ok :=
    match itin.find? (fun s => s.origin.continent.toTCArea != s.destination.continent.toTCArea) with
    | some s => s.type == .Flight
    | none => True
  surface_ok ∧ first_crossing_ok

def segments_in_continent (itin : Itinerary) (c : Continent) : Nat :=
  itin.filter (fun s => s.origin.continent == c ∧ s.destination.continent == c) |>.length

def rule_4h_segment_limits (itin : Itinerary) : Prop :=
  segments_in_continent itin .Africa ≤ 4 ∧
  segments_in_continent itin .Asia ≤ 4 ∧
  segments_in_continent itin .EuropeMiddleEast ≤ 4 ∧
  segments_in_continent itin .NorthAmerica ≤ 6 ∧
  segments_in_continent itin .SouthAmerica ≤ 4 ∧
  segments_in_continent itin .SouthWestPacific ≤ 4

def rule_4i_no_duplicate_sectors (itin : Itinerary) : Prop :=
  let sectors := itin.map (fun s => (s.origin.id, s.destination.id))
  sectors.eraseDup.length == sectors.length

/-
Formalization of Rules 4k, 4l, 8, and 4c.
-/
def is_west_coast_na (c : City) : Bool :=
  c.continent == .NorthAmerica ∧ (c.id == "LAX" ∨ c.id == "SFO" ∨ c.id == "SEA" ∨ c.id == "YVR")

def is_east_coast_na (c : City) : Bool :=
  c.continent == .NorthAmerica ∧ (c.id == "NYC" ∨ c.id == "JFK" ∨ c.id == "EWR" ∨ c.id == "IAD" ∨ c.id == "BOS" ∨ c.id == "YYZ" ∨ c.id == "YUL")

def is_transcontinental_na (s : Segment) : Bool :=
  s.type == .Flight ∧
  ((is_west_coast_na s.origin ∧ is_east_coast_na s.destination) ∨
   (is_east_coast_na s.origin ∧ is_west_coast_na s.destination))

def rule_4k_us_canada_transcontinental (itin : Itinerary) : Prop :=
  (itin.filter is_transcontinental_na).length ≤ 1

def is_east_coast_au (c : City) : Bool :=
  c.country == "AU" ∧ (c.id == "SYD" ∨ c.id == "MEL" ∨ c.id == "BNE" ∨ c.id == "CBR")

def is_au_remote (c : City) : Bool :=
  c.country == "AU" ∧ (c.id == "PER" ∨ c.id == "DRW" ∨ c.id == "BME" ∨ c.id == "KTA")

def is_transcontinental_au (s : Segment) : Bool :=
  s.type == .Flight ∧
  ((is_east_coast_au s.origin ∧ is_au_remote s.destination) ∨
   (is_au_remote s.origin ∧ is_east_coast_au s.destination))

def rule_4l_australia_transcontinental (itin : Itinerary) : Prop :=
  (itin.filter is_transcontinental_au).length ≤ 1

def stopovers (itin : Itinerary) : List City :=
  itin.filter (fun s => s.isStopover) |>.map (fun s => s.destination)

def rule_8_stopovers (itin : Itinerary) : Prop :=
  let stops := stopovers itin
  let min_stops := stops.length ≥ 2
  let origin_continent := match itin.head? with | some s => s.origin.continent | none => .NorthAmerica
  let stops_in_origin := stops.filter (fun c => c.continent == origin_continent) |>.length
  let max_stops_origin := stops_in_origin ≤ 2
  min_stops ∧ max_stops_origin

def is_china (c : City) : Bool := c.country == "CN"
def is_hkg (c : City) : Bool := c.id == "HKG"
def is_malaysia (c : City) : Bool := c.country == "MY"
def is_sin (c : City) : Bool := c.id == "SIN"
def is_maldives (c : City) : Bool := c.country == "MV"
def is_sri_lanka (c : City) : Bool := c.country == "LK"
def is_india (c : City) : Bool := c.country == "IN"

def is_permitted_open_jaw (itin : Itinerary) (s : Segment) : Bool :=
  let c1 := s.origin
  let c2 := s.destination
  let origin_country := match itin.head? with | some s => s.origin.country | none => ""
  (c1.country == origin_country ∧ c2.country == origin_country) ∨
  (c1.continent == .EuropeMiddleEast ∧ c2.continent == .EuropeMiddleEast) ∨
  (c1.country == "US" ∧ c2.country == "CA") ∨ (c1.country == "CA" ∧ c2.country == "US") ∨
  (is_hkg c1 ∧ is_china c2) ∨ (is_china c1 ∧ is_hkg c2) ∨
  (is_malaysia c1 ∧ is_sin c2) ∨ (is_sin c1 ∧ is_malaysia c2) ∨
  (c1.continent == .Africa ∧ c2.continent == .Africa) ∨
  (is_maldives c1 ∧ (is_sri_lanka c2 ∨ is_india c2)) ∨ ((is_sri_lanka c1 ∨ is_india c1) ∧ is_maldives c2)

def rule_4c_open_jaw (itin : Itinerary) : Prop :=
  match itin.head? with
  | some first =>
    let origin := first.origin
    let surface_segs := itin.filter (fun s => s.type == .Surface)
    let origin_surface_segs := surface_segs.filter (fun s => s.origin == origin ∨ s.destination == origin)
    origin_surface_segs.all (is_permitted_open_jaw itin)
  | none => True

/-
Formalization of Rules 6, 7, and 19 (Date, TimedSegment, Pricing).
-/
structure Date where
  year : Nat
  month : Nat
  day : Nat
deriving Repr, DecidableEq, Inhabited

def Date.toDays (d : Date) : Int :=
  (d.year : Int) * 365 + (d.month : Int) * 30 + (d.day : Int)

def Date.le (d1 d2 : Date) : Bool :=
  d1.year < d2.year ∨ (d1.year == d2.year ∧ (d1.month < d2.month ∨ (d1.month == d2.month ∧ d1.day ≤ d2.day)))

structure TimedSegment extends Segment where
  departureDate : Date
  arrivalDate : Date
deriving Repr, DecidableEq, Inhabited

def TimedItinerary := List TimedSegment

def rule_6_minimum_stay (itin : TimedItinerary) : Prop :=
  match itin.head? with
  | some first =>
    if first.origin.continent.toTCArea == .TC1 then
      let intl_sectors := itin.filter (fun s => s.origin.country != s.destination.country) -- Simplified international check
      match intl_sectors.head?, intl_sectors.getLast? with
      | some first_intl, some last_intl =>
        let days_diff := last_intl.departureDate.toDays - first_intl.departureDate.toDays
        days_diff ≥ 10
      | _, _ => True
    else True
  | none => True

def rule_7_maximum_stay (itin : TimedItinerary) : Prop :=
  match itin.head?, itin.getLast? with
  | some first, some last =>
    let departure := first.departureDate
    let return_date := last.arrivalDate -- "Return from last stopover" - usually means the arrival of the last segment
    -- "Return from last stopover <= 12 months after departure"
    -- We'll check if return_date <= departure + 12 months
    let max_return_year := departure.year + 1
    let max_return := { departure with year := max_return_year }
    Date.le return_date max_return
  | _, _ => True

inductive PassengerType
| Adult
| Child
| Infant
deriving Repr, DecidableEq, Inhabited

def rule_19_children_pricing (base_fare : Rat) (p : PassengerType) : Rat :=
  match p with
  | .Adult => base_fare
  | .Child => base_fare * 0.75
  | .Infant => base_fare * 0.10

/-
Prove: child fare is strictly less than adult fare
-/
theorem child_fare_lt_adult (base_fare : Rat) (h : base_fare > 0) :
  rule_19_children_pricing base_fare .Child < rule_19_children_pricing base_fare .Adult := by
    exact mul_lt_of_lt_one_right h ( by norm_num )

/-
Checking List.eraseDup and List.mem_dedup
-/
#print List.eraseDup
#check List.mem_dedup

/-
Helper lemma: Membership in eraseDup is equivalent to membership in the original list.
-/
theorem mem_eraseDup {α} [DecidableEq α] (l : List α) (a : α) : a ∈ l.eraseDup ↔ a ∈ l := by
  induction' l with x l ih generalizing a;
  · simp [List.eraseDup];
  · by_cases hx : x = a <;> simp_all +decide [ List.eraseDup ];
    · simp +decide [ List.pwFilter ];
      split_ifs <;> simp_all +decide [ eq_comm ];
    · simp_all +decide [ List.pwFilter ];
      grind

/-
Helper lemma: The origin continent of any segment in the itinerary is in the visited continents list.
-/
lemma mem_visited_continents_of_origin (itin : List Segment) (s : Segment) (h : s ∈ itin) :
  s.origin.continent ∈ visited_continents itin := by
    -- By definition of `visited_continents`, the origin continent of any segment in the itinerary is included in the list of visited continents.
    have h_origin_continent : s.origin.continent ∈ (itin.map (fun s => s.origin.continent) ++ itin.map (fun s => s.destination.continent)).eraseDup := by
      rw [ mem_eraseDup ];
      grind;
    unfold visited_continents; aesop;

/-
Helper lemma: The destination continent of any segment in the itinerary is in the visited continents list.
-/
lemma mem_visited_continents_of_dest (itin : List Segment) (s : Segment) (h : s ∈ itin) :
  s.destination.continent ∈ visited_continents itin := by
    have h_dest_continent : s.destination.continent ∈ (itin.map (fun s => s.origin.continent) ++ itin.map (fun s => s.destination.continent)).eraseDup := by
      rw [ mem_eraseDup ];
      grind;
    unfold visited_continents; aesop;

/-
Helper lemmas: Characterize Atlantic and Pacific crossings by TC areas.
-/
lemma get_ocean_atlantic_iff (c1 c2 : Continent) :
  get_ocean c1 c2 = some .Atlantic ↔
  (c1.toTCArea = .TC1 ∧ c2.toTCArea = .TC2) ∨ (c1.toTCArea = .TC2 ∧ c2.toTCArea = .TC1) := by
  unfold get_ocean
  split <;> simp_all

lemma get_ocean_pacific_iff (c1 c2 : Continent) :
  get_ocean c1 c2 = some .Pacific ↔
  (c1.toTCArea = .TC1 ∧ c2.toTCArea = .TC3) ∨ (c1.toTCArea = .TC3 ∧ c2.toTCArea = .TC1) := by
  unfold get_ocean
  split <;> simp_all

/-
Helper lemma: If an ocean crossing exists, there is a corresponding segment (using List Segment to avoid type issues).
-/
lemma exists_segment_of_ocean_crossing (itin : List Segment) (o : Ocean) (h : o ∈ ocean_crossings itin) :
  ∃ s ∈ itin, get_ocean s.origin.continent s.destination.continent = some o := by
  unfold ocean_crossings at h
  rw [List.mem_filterMap] at h
  obtain ⟨s, hs_mem, hs_eq⟩ := h
  exact ⟨s, hs_mem, hs_eq⟩

/-
Lemma: A TC area is visited iff there is a visited continent in that area.
-/
lemma mem_visited_tc_areas_iff (itin : Itinerary) (t : TCArea) :
  t ∈ visited_tc_areas itin ↔ ∃ c ∈ visited_continents itin, c.toTCArea = t := by
  unfold visited_tc_areas
  rw [mem_eraseDup]
  rw [List.mem_map]

/-
Helper lemma: eraseDup returns a Nodup list.
-/
lemma nodup_eraseDup {α} [DecidableEq α] (l : List α) : l.eraseDup.Nodup := by
  induction' l with x l ih <;> simp_all +decide [ List.eraseDup ];
  simp_all +decide [ List.pwFilter ];
  grind

/-
Helper lemma: TCArea exhaustion.
-/
lemma tc_area_univ (t : TCArea) : t = .TC1 ∨ t = .TC2 ∨ t = .TC3 := by
  cases t <;> simp

/-
Debugging: Check TCArea and define a simple function.
-/
#check TCArea
def test_tc_area (l : List TCArea) : Nat := l.length

/-
Debugging: Check if `List TCArea` syntax is valid in a theorem.
-/
theorem test_syntax_tc_area (l : List TCArea) : l.length = l.length := rfl

/-
Debugging: Check List.Nodup availability.
-/
#check List.Nodup
theorem test_nodup (l : List Nat) (h : l.Nodup) : True := True.intro

/-
Debugging: Check if the signature with List.Nodup and membership parses correctly.
-/
theorem debug_signature (l : List TCArea) (h : List.Nodup l) (h1 : TCArea.TC1 ∈ l) : True := trivial

/-
Helper lemma: If a Nodup list of TCAreas contains all 3, its length is 3 (signature check).
-/
theorem tc_areas_aux (l : List TCArea) (h_nodup : l.Nodup)
  (h1 : TCArea.TC1 ∈ l) (h2 : TCArea.TC2 ∈ l) (h3 : TCArea.TC3 ∈ l) :
  l.length = 3 := by
    have h_unique : l.toFinset = {TCArea.TC1, TCArea.TC2, TCArea.TC3} := by
      ext t; have := tc_area_univ t; aesop;
    rw [ ← List.toFinset_card_of_nodup h_nodup, h_unique ] ; simp +decide

/-
Prove that having exactly 1 Atlantic and 1 Pacific crossing implies visiting all 3 TC areas.
-/
theorem ocean_implies_3_tc_areas (itin : Itinerary)
  (h_atl : count_ocean itin .Atlantic = 1)
  (h_pac : count_ocean itin .Pacific = 1) :
  (visited_tc_areas itin).length = 3 := by
    -- By definition of `visited_tc_areas`, if there is an Atlantic crossing, then there must be at least one continent in TC1 and one in TC2. Similarly, if there is a Pacific crossing, then there must be at least one continent in TC1 and one in TC3.
    have h_continent_in_tc1 : ∃ c ∈ visited_continents itin, c.toTCArea = .TC1 := by
      obtain ⟨ s, hs ⟩ := exists_segment_of_ocean_crossing itin .Atlantic ( by
        contrapose! h_atl;
        unfold count_ocean;
        rw [ List.filter_eq_nil_iff.mpr ] <;> aesop );
      cases h : s.origin.continent.toTCArea <;> cases h' : s.destination.continent.toTCArea <;> simp_all +decide only [get_ocean_atlantic_iff];
      all_goals have := mem_visited_continents_of_origin itin s hs.1; have := mem_visited_continents_of_dest itin s hs.1; aesop;
    have h_continent_in_tc2 : ∃ c ∈ visited_continents itin, c.toTCArea = .TC2 := by
      unfold count_ocean at h_atl;
      obtain ⟨ s, hs ⟩ := List.length_pos_iff_exists_mem.mp ( by linarith );
      obtain ⟨ s, hs ⟩ := exists_segment_of_ocean_crossing itin s ( by aesop );
      cases h : s.origin.continent.toTCArea <;> cases h' : s.destination.continent.toTCArea <;> simp_all +decide only [get_ocean];
      all_goals have := mem_visited_continents_of_origin itin s hs.1; have := mem_visited_continents_of_dest itin s hs.1; aesop;
    have h_continent_in_tc3 : ∃ c ∈ visited_continents itin, c.toTCArea = .TC3 := by
      obtain ⟨c, hc⟩ : ∃ c ∈ ocean_crossings itin, c = .Pacific := by
        unfold count_ocean at h_pac;
        obtain ⟨ c, hc ⟩ := List.length_pos_iff_exists_mem.mp ( by linarith ) ; aesop;
      obtain ⟨ s, hs ⟩ := exists_segment_of_ocean_crossing itin c hc.1;
      cases h : s.origin.continent.toTCArea <;> cases h' : s.destination.continent.toTCArea <;> simp_all +decide only [get_ocean];
      all_goals have := mem_visited_continents_of_origin itin s hs.1; have := mem_visited_continents_of_dest itin s hs.1; aesop;
    apply tc_areas_aux;
    · apply_rules [ nodup_eraseDup ];
    · exact mem_visited_tc_areas_iff _ _ |>.2 h_continent_in_tc1;
    · exact mem_visited_tc_areas_iff _ _ |>.2 h_continent_in_tc2;
    · exact mem_visited_tc_areas_iff _ _ |>.2 h_continent_in_tc3

/-
Helper lemma: If count_ocean > 0, then the ocean is in ocean_crossings.
-/
lemma mem_ocean_crossings_of_count_pos (itin : Itinerary) (o : Ocean) (h : count_ocean itin o > 0) :
  o ∈ ocean_crossings itin := by
  unfold count_ocean at h
  have h_not_nil : (ocean_crossings itin).filter (· == o) ≠ [] := by
    intro h_nil
    rw [h_nil] at h
    simp at h
  have h_mem : ∃ x, x ∈ (ocean_crossings itin).filter (· == o) := List.exists_mem_of_ne_nil _ h_not_nil
  obtain ⟨x, hx⟩ := h_mem
  rw [List.mem_filter] at hx
  have heq : x = o := by simp at hx; exact hx.2
  rw [←heq]
  exact hx.1

/-
Checking existence of theorems.
-/
#check ocean_implies_3_tc_areas
#check valid_rtw_continent_count

/-
Prove that the continent count is between 3 and 6 (renamed to avoid conflict).
-/
theorem valid_rtw_continent_count_proof (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?

/-
Add Fintype instances and prove visited_continents is Nodup.
-/
instance : Fintype Continent where
  elems := {Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific}
  complete := by intro x; cases x <;> simp

instance : Fintype TCArea where
  elems := {TCArea.TC1, .TC2, .TC3}
  complete := by intro x; cases x <;> simp

lemma visited_continents_nodup (itin : Itinerary) : (visited_continents itin).Nodup := by
  have h_eraseDup : ∀ l : List Continent, List.Nodup (List.eraseDup l) := by
    apply nodup_eraseDup;
  unfold visited_continents; aesop;

/-
Prove that the continent count is between 3 and 6 (using correct name and lemmas).
-/
theorem valid_rtw_continent_count_thm (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?

/-
Prove that the continent count is between 3 and 6 (final attempt with corrected name and proof).
-/
theorem valid_rtw_continent_count_final (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?

/-
Prove that the continent count is between 3 and 6 (renamed to avoid conflict).
-/
theorem valid_rtw_continent_count_proven (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?

/-
Prove that the continent count is between 3 and 6 (v2, corrected rewrite).
-/
theorem valid_rtw_continent_count_v2 (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
    exact?

/-
Prove that the continent count is between 3 and 6 (v3, with unfolding).
-/
theorem valid_rtw_continent_count_v3 (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
  unfold continent_count
  constructor
  · -- Lower bound
    have h_tc_len : (visited_tc_areas itin).length = 3 := ocean_implies_3_tc_areas itin h.one_atlantic h.one_pacific
    unfold visited_tc_areas at h_tc_len
    have h_sub : ((visited_continents itin).map Continent.toTCArea).eraseDup.Sublist ((visited_continents itin).map Continent.toTCArea) := List.pwFilter_sublist _
    have h_len_le := List.Sublist.length_le h_sub
    rw [h_tc_len] at h_len_le
    rw [List.length_map] at h_len_le
    exact h_len_le
  · -- Upper bound
    have h_subset : (visited_continents itin).toFinset ⊆ {Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} := by
      intro x hx
      fin_cases x <;> simp
    have h_card : (visited_continents itin).toFinset.card ≤ 6 := by
      trans ({Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} : Finset Continent).card
      · apply Finset.card_le_card h_subset
      · simp
    have h_nodup : (visited_continents itin).Nodup := visited_continents_nodup itin
    rw [List.toFinset_card_of_nodup h_nodup] at h_card
    exact h_card

/-
Prove that the continent count is between 3 and 6 (verification theorem).
-/
theorem valid_rtw_continent_count_verification (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
  unfold continent_count
  constructor
  · -- Lower bound
    have h_tc_len : (visited_tc_areas itin).length = 3 := ocean_implies_3_tc_areas itin h.one_atlantic h.one_pacific
    unfold visited_tc_areas at h_tc_len
    have h_sub : ((visited_continents itin).map Continent.toTCArea).eraseDup.Sublist ((visited_continents itin).map Continent.toTCArea) := List.pwFilter_sublist _
    have h_len_le := List.Sublist.length_le h_sub
    rw [h_tc_len] at h_len_le
    rw [List.length_map] at h_len_le
    exact h_len_le
  · -- Upper bound
    have h_subset : (visited_continents itin).toFinset ⊆ {Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} := by
      intro x hx
      fin_cases x <;> simp
    have h_card : (visited_continents itin).toFinset.card ≤ 6 := by
      trans ({Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} : Finset Continent).card
      · apply Finset.card_le_card h_subset
      · simp
    have h_nodup : (visited_continents itin).Nodup := visited_continents_nodup itin
    rw [List.toFinset_card_of_nodup h_nodup] at h_card
    exact h_card

/-
Prove that the continent count is between 3 and 6 (verification v1).
-/
theorem valid_rtw_continent_count_verification_v1 (itin : Itinerary) (h : ValidRTW itin) :
  3 ≤ continent_count itin ∧ continent_count itin ≤ 6 := by
  unfold continent_count
  constructor
  · -- Lower bound
    have h_tc_len : (visited_tc_areas itin).length = 3 := ocean_implies_3_tc_areas itin h.one_atlantic h.one_pacific
    unfold visited_tc_areas at h_tc_len
    let l := (visited_continents itin).map Continent.toTCArea
    have h_sub : l.eraseDup.Sublist l := List.pwFilter_sublist _
    have h_len : l.eraseDup.length ≤ l.length := List.Sublist.length_le h_sub
    rw [h_tc_len] at h_len
    rw [List.length_map] at h_len
    exact h_len
  · -- Upper bound
    have h_subset : (visited_continents itin).toFinset ⊆ {Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} := by
      intro x hx
      fin_cases x <;> simp
    have h_card : (visited_continents itin).toFinset.card ≤ 6 := by
      trans ({Continent.NorthAmerica, .SouthAmerica, .EuropeMiddleEast, .Africa, .Asia, .SouthWestPacific} : Finset Continent).card
      · apply Finset.card_le_card h_subset
      · simp
    have h_nodup : (visited_continents itin).Nodup := visited_continents_nodup itin
    rw [List.toFinset_card_of_nodup h_nodup] at h_card
    exact h_card

/-
Prove that the fare basis is determined (using unique name).
-/
theorem valid_rtw_fare_determined_proven (itin : Itinerary) (cabin : CabinClass) (h : ValidRTW itin) :
  (fare_basis cabin itin).isSome := by
    exact?

/-
Prove that the fare basis is determined (final attempt with unique name).
-/
theorem valid_rtw_fare_determined_final_v4 (itin : Itinerary) (cabin : CabinClass) (h : ValidRTW itin) :
  (fare_basis cabin itin).isSome := by
    exact?

/-
Prove: minimum 2 stopovers + continuous + loop + (last not stopover) → minimum 3 segments.
-/
theorem stopovers_implies_min_segments (itin : Itinerary)
  (h_cont : is_continuous itin)
  (h_loop : is_loop itin)
  (h_stops : (stopovers itin).length ≥ 2)
  (h_last_no_stop : match itin.getLast? with | some s => ¬s.isStopover | none => True) :
  itin.length ≥ 3 := by
    rcases itin with ( _ | ⟨ s, _ | ⟨ t, _ | ⟨ u, _ | itin ⟩ ⟩ ⟩ ) <;> simp_all +arith +decide [ stopovers ];
    rw [ List.filter_cons, List.filter_cons ] at h_stops ; aesop

/-
Prove that the fare basis is determined (v5, splitting on cabin).
-/
theorem valid_rtw_fare_determined_proven_v5 (itin : Itinerary) (cabin : CabinClass) (h : ValidRTW itin) :
  (fare_basis cabin itin).isSome := by
    exact?

/-
Helper lemma: fare basis is determined if continent count is in [3, 6].
-/
lemma fare_basis_isSome_of_bounds (cabin : CabinClass) (itin : Itinerary)
  (h_ge : 3 ≤ continent_count itin) (h_le : continent_count itin ≤ 6) :
  (fare_basis cabin itin).isSome := by
    interval_cases _ : continent_count itin <;> unfold fare_basis <;> simp_all +decide;
    · cases cabin <;> trivial;
    · cases cabin <;> trivial;
    · cases cabin <;> trivial;
    · cases cabin <;> tauto

/-
Definitions for compressing lists and extracting TC paths.
-/
def compress {α} [DecidableEq α] : List α → List α
| [] => []
| [x] => [x]
| x :: y :: xs => if x = y then compress (y :: xs) else x :: compress (y :: xs)

def itinerary_cities (itin : Itinerary) : List City :=
  itin.map (·.origin) ++ (itin.getLast? |>.map (fun s => [s.destination]) |>.getD [])

def tc_path (itin : Itinerary) : List TCArea :=
  (itinerary_cities itin).map (fun c => c.continent.toTCArea)

/-
Lemma: rule_4b implies the TC path is a forward list.
-/
def is_forward_tc_list (l : List TCArea) : Prop :=
  l.Chain' (fun a b => is_forward_tc_move a b)

lemma forward_direction_implies_forward_path (itin : Itinerary) (h : rule_4b_forward_direction itin) :
  is_forward_tc_list (tc_path itin) := by
    cases itin <;> simp_all +decide [ is_forward_tc_list ];
    · exact List.isChain_nil;
    · unfold rule_4b_forward_direction at h;
      unfold tc_path;
      unfold itinerary_cities;
      induction' ‹List Segment› using List.reverseRecOn with s itin ih <;> simp_all +decide [ List.isChain_append ];
      · exact List.isChain_cons_cons.mpr ⟨ h, List.isChain_singleton _ ⟩;
      · apply List.isChain_iff_get.mpr;
        intro i hi;
        convert h _ _ _ using 1;
        rw [ List.mem_iff_get ];
        use ⟨ i, by
          grind ⟩
        generalize_proofs at *;
        cases i <;> aesop

/-
Check the induction principle for compress.
-/
#check compress.induct

/-
Helper lemma: The head of a compressed list is the same as the head of the original list.
-/
lemma compress_head {α} [DecidableEq α] (x : α) (xs : List α) :
  (compress (x :: xs)).head? = some x := by
    induction' xs with y ys ih generalizing x;
    · rfl;
    · by_cases h : x = y <;> simp_all +decide [ compress ]

/-
Definition: A list of TC areas is strictly forward if each element is the `next_tc` of the previous one.
-/
def is_strict_forward_tc_list (l : List TCArea) : Prop :=
  l.Chain' (fun a b => b = next_tc a)

/-
Define count_ocean_list to count ocean crossings in a list of TC areas.
-/
def count_ocean_list (l : List TCArea) (o : Ocean) : Nat :=
  match l with
  | [] => 0
  | [_] => 0
  | a :: b :: rest =>
    let n := match get_ocean_tc a b with
      | some x => if x == o then 1 else 0
      | none => 0
    n + count_ocean_list (b :: rest) o
where
  get_ocean_tc (t1 t2 : TCArea) : Option Ocean :=
    match t1, t2 with
    | .TC1, .TC2 => some .Atlantic
    | .TC2, .TC1 => some .Atlantic
    | .TC1, .TC3 => some .Pacific
    | .TC3, .TC1 => some .Pacific
    | _, _ => none

/-
Lemma: compress of a forward list is a strict forward list (retry with compress_head).
-/
lemma compress_strict_forward (l : List TCArea) (h : is_forward_tc_list l) :
  is_strict_forward_tc_list (compress l) := by
    -- By definition of `compress`, we know that `compress (x :: xs) = x :: compress xs` if `x ≠ x`, which is a contradiction.
    by_contra h_contra;
    obtain ⟨l, hl⟩ : ∃ l : List TCArea, is_forward_tc_list l ∧ ¬is_strict_forward_tc_list (compress l) ∧ ∀ l' : List TCArea, is_forward_tc_list l' → l'.length < l.length → is_strict_forward_tc_list (compress l') := by
      have h_min : ∃ m : ℕ, m ∈ {n : ℕ | ∃ l : List TCArea, is_forward_tc_list l ∧ ¬is_strict_forward_tc_list (compress l) ∧ n = l.length} ∧ ∀ n ∈ {n : ℕ | ∃ l : List TCArea, is_forward_tc_list l ∧ ¬is_strict_forward_tc_list (compress l) ∧ n = l.length}, m ≤ n := by
        exact ⟨ Nat.find ⟨ _, ⟨ l, h, h_contra, rfl ⟩ ⟩, Nat.find_spec ( ⟨ _, ⟨ l, h, h_contra, rfl ⟩ ⟩ : ∃ n, ∃ l : List TCArea, is_forward_tc_list l ∧ ¬is_strict_forward_tc_list ( compress l ) ∧ n = l.length ), fun n hn => Nat.find_min' _ hn ⟩;
      obtain ⟨ m, ⟨ l, hl₁, hl₂, rfl ⟩, hm ⟩ := h_min; exact ⟨ l, hl₁, hl₂, fun l' hl₃ hl₄ => Classical.not_not.1 fun hl₅ => not_lt_of_ge ( hm _ ⟨ l', hl₃, hl₅, rfl ⟩ ) hl₄ ⟩ ;
    rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +decide [ is_forward_tc_list ];
    · cases hl.2 ( by tauto );
    · cases hl.2.1 ( by tauto );
    · rcases eq_or_ne x y with ( rfl | hne ) <;> simp_all +decide [ List.Chain', is_forward_tc_move ];
      · have h_compress : compress (x :: x :: l) = compress (x :: l) := by
          exact if_pos rfl;
        aesop;
      · have := hl.2.2 l ( by cases l <;> aesop ) ( by simp +arith +decide ) ; simp_all +decide [ is_strict_forward_tc_list ] ;
        convert hl.2.1 _ using 1;
        rw [ show compress ( x :: y :: l ) = x :: compress ( y :: l ) from _ ];
        · cases h : compress ( y :: l ) <;> simp_all +decide [ List.Chain' ];
          have h_head : (compress (next_tc x :: l)).head? = some (next_tc x) := by
            exact compress_head _ _;
          grind;
        · exact if_neg ( by aesop )

/-
Lemma: compressing a list does not change the ocean count (retry).
-/
lemma count_ocean_list_compress (l : List TCArea) (o : Ocean) :
  count_ocean_list (compress l) o = count_ocean_list l o := by
    induction' n : l.length using Nat.strong_induction_on with n ih generalizing l;
    rcases l with ( _ | ⟨ x, _ | ⟨ y, l ⟩ ⟩ ) <;> simp_all +arith +decide [ compress ];
    split_ifs <;> simp_all +decide [ count_ocean_list ];
    · -- Since y is equal to itself, the ocean crossing between y and y is none, so the count is 0.
      have h_none : count_ocean_list.get_ocean_tc y y = none := by
        cases y <;> rfl;
      rw [ h_none ] ; aesop;
    · -- Apply the induction hypothesis to the list `(y :: l)`.
      have h_ind : count_ocean_list (compress (y :: l)) o = count_ocean_list (y :: l) o := by
        exact ih _ ( by simp +arith +decide [ n.symm ] ) _ rfl;
      convert congr_arg ( fun z => count_ocean_list.get_ocean_tc x y |> fun w => ( match w with | some x => if x = o then 1 else 0 | none => 0 ) + z ) h_ind using 1;
      cases h : compress ( y :: l ) <;> simp +decide [ h, count_ocean_list ];
      · contrapose! h;
        exact ne_of_apply_ne List.head? ( by simp +decide [ compress_head ] );
      · have := compress_head y l; aesop;

/-
Lemma: A strictly forward list starting/ending at TC1 with 1 Atl/1 Pac is exactly [TC1, TC2, TC3, TC1].
-/
theorem tc_sequence_structure (l : List TCArea)
  (h_strict : is_strict_forward_tc_list l)
  (h_head : l.head? = some .TC1)
  (h_last : l.getLast? = some .TC1)
  (h_atl : count_ocean_list l .Atlantic = 1)
  (h_pac : count_ocean_list l .Pacific = 1) :
  l = [.TC1, .TC2, .TC3, .TC1] := by
    rcases l with ( _ | ⟨ a, _ | ⟨ b, _ | ⟨ c, _ | ⟨ d, _ | l ⟩ ⟩ ⟩ ⟩ ) <;> simp_all +decide [ is_strict_forward_tc_list ];
    · cases b <;> cases h_strict <;> contradiction;
    · cases b <;> cases c <;> simp_all +decide [ List.Chain' ];
    · cases h_strict ; simp_all +decide [ next_tc ];
      simp_all +decide [ count_ocean_list ];
      exact absurd h_atl ( by erw [ show count_ocean_list.get_ocean_tc TCArea.TC1 TCArea.TC2 = some .Atlantic from rfl, show count_ocean_list.get_ocean_tc TCArea.TC2 TCArea.TC3 = none from rfl, show count_ocean_list.get_ocean_tc TCArea.TC3 TCArea.TC1 = some .Pacific from rfl ] ; simp +decide )

/-
Lemma: get_ocean is equivalent to get_ocean_tc on mapped continents.
-/
lemma get_ocean_eq_get_ocean_tc (c1 c2 : Continent) :
  get_ocean c1 c2 = count_ocean_list.get_ocean_tc c1.toTCArea c2.toTCArea := by
  unfold get_ocean count_ocean_list.get_ocean_tc
  cases c1.toTCArea <;> cases c2.toTCArea <;> rfl

/-
Lemma: count_ocean on itinerary equals count_ocean_list on tc_path (assuming continuity).
-/
lemma count_ocean_eq_count_ocean_list (itin : Itinerary) (h_cont : is_continuous itin) (o : Ocean) :
  count_ocean itin o = count_ocean_list (tc_path itin) o := by
    -- We proceed by induction on the list `itin`.
    induction' itin with s itin ih;
    · cases o <;> rfl;
    · cases itin <;> simp_all +decide [ count_ocean, count_ocean_list ];
      · cases h_cont;
        simp +decide [ ocean_crossings, tc_path ];
        simp +decide [ get_ocean, count_ocean_list ];
        unfold itinerary_cities; simp +decide [ count_ocean_list ] ;
        cases h : s.origin.continent.toTCArea <;> cases h' : s.destination.continent.toTCArea <;> simp +decide [ h, h' ];
        all_goals cases o <;> rfl;
      · unfold ocean_crossings at *;
        unfold tc_path at *; simp_all +decide [ is_continuous ] ;
        unfold itinerary_cities at *; simp_all +decide [ List.filterMap_cons ] ;
        cases h : get_ocean s.origin.continent ‹Segment›.origin.continent <;> simp_all +decide [ count_ocean_list ];
        · rw [ ← get_ocean_eq_get_ocean_tc ] ; aesop;
        · rw [ ← ih ];
          rw [ show count_ocean_list.get_ocean_tc s.origin.continent.toTCArea _ = some _ from ?_ ];
          rotate_left;
          exact ‹Ocean›;
          · convert h using 1;
          · grind

/-
Helper lemma: count_ocean_list is invariant under adjacent duplication.
-/
lemma count_ocean_list_cons_cons_eq (x : TCArea) (xs : List TCArea) (o : Ocean) :
  count_ocean_list (x :: x :: xs) o = count_ocean_list (x :: xs) o := by
    cases xs <;> simp +decide [ count_ocean_list ];
    · cases x <;> rfl;
    · cases x <;> rfl

/-
Check if count_ocean_list_compress is defined.
-/
#check count_ocean_list_compress

/-
Helper lemma: compress preserves the last element (retry).
-/
lemma compress_getLast {α} [DecidableEq α] (l : List α) (h : l ≠ []) :
  (compress l).getLast? = l.getLast? := by
    induction' l with x xs ih;
    · grind;
    · induction' xs with y ys ih generalizing x;
      · rfl;
      · by_cases hxy : x = y <;> simp_all +decide [ compress ];
        grind

/-
Lemma: compress l is empty iff l is empty.
-/
lemma compress_eq_nil_iff {α} [DecidableEq α] (l : List α) :
  compress l = [] ↔ l = [] := by
    induction' l with x xs ih;
    · rfl;
    · cases xs <;> simp_all +decide [ compress ];
      split_ifs <;> simp_all +decide [ List.cons_eq_cons ]

/-
Check if compress_strict_forward is defined.
-/
#check compress_strict_forward

/-
Check existence and types of helper lemmas.
-/
#check compress_strict_forward
#check count_ocean_list_compress

/-
Prove: if origin is in TC1, the TC sequence must be TC1→TC2→TC3→TC1 (final attempt).
-/
theorem tc_sequence_tc1_origin (itin : Itinerary)
  (h_valid : ValidRTW itin)
  (h_fwd : rule_4b_forward_direction itin)
  (h_origin : match itin.head? with | some s => s.origin.continent.toTCArea = .TC1 | none => False) :
  compress (tc_path itin) = [.TC1, .TC2, .TC3, .TC1] := by
    have := h_valid.2;
    convert tc_sequence_structure ( compress ( tc_path itin ) ) _ _ _ _ _ using 1;
    · apply compress_strict_forward; exact forward_direction_implies_forward_path itin h_fwd;
    · convert compress_head _ _;
      rotate_left;
      exact?;
      exact ( tc_path itin ).drop 1;
      rcases itin <;> simp_all +decide [ tc_path ];
      unfold itinerary_cities; aesop;
    · have h_last : (tc_path itin).getLast? = some .TC1 := by
        unfold tc_path;
        unfold is_loop at this; aesop;
      rw [ ← h_last, compress_getLast ];
      aesop;
    · rw [ count_ocean_list_compress ];
      convert valid_rtw_ocean_crossings itin h_valid |>.1 using 1;
      convert count_ocean_eq_count_ocean_list itin ( h_valid.1 ) Ocean.Atlantic |> Eq.symm;
    · rw [ count_ocean_list_compress ];
      rw [ ← count_ocean_eq_count_ocean_list ];
      · exact valid_rtw_ocean_crossings itin h_valid |>.2;
      · exact h_valid.1

/-
Lemma: tc_path starts and ends with TC1.
-/
lemma tc_path_endpoints (itin : Itinerary) (h_valid : ValidRTW itin)
  (h_origin : match itin.head? with | some s => s.origin.continent.toTCArea = .TC1 | none => False) :
  (tc_path itin).head? = some .TC1 ∧ (tc_path itin).getLast? = some .TC1 := by
    obtain ⟨l, hl⟩ := h_valid;
    rcases itin <;> simp_all +decide [ tc_path ];
    unfold is_loop at hl; aesop;

/-
Check if the lemmas are already declared.
-/
#check count_ocean_list_compress
#check compress_strict_forward

/-
Helper lemma: If eraseDup preserves length, the list is Nodup.
-/
lemma nodup_of_eraseDup_length_eq {α} [DecidableEq α] (l : List α) :
  l.eraseDup.length = l.length → l.Nodup := by
    -- By definition of `eraseDup`, it removes all duplicates from the list.
    have h_eraseDup_def : ∀ (l : List α), List.eraseDup l = List.foldr (fun x xs => if x ∈ xs then xs else x :: xs) [] l := by
      simp +decide [ List.eraseDup ];
      intro l; induction l <;> simp +decide [ *, List.pwFilter ] ;
      grind;
    induction' l with x l ih <;> simp_all +decide [ List.eraseDup ];
    split_ifs <;> simp_all +decide [ List.Nodup ];
    · intro h;
      have h_foldr_length : ∀ (l : List α), List.length (List.foldr (fun x xs => if x ∈ xs then xs else x :: xs) [] l) ≤ List.length l := by
        intro l; induction' l with x l ih <;> simp +decide [ * ] ; split_ifs <;> simp_all +decide [ List.length ] ;
        grind;
      linarith [ h_foldr_length l ];
    · intro h; exact fun hx => ‹x∉List.foldr ( fun x xs => if x∈xs then xs else x::xs ) [] l› ( by
        have h_foldr : ∀ (l : List α), x ∈ l → x ∈ List.foldr (fun x xs => if x ∈ xs then xs else x :: xs) [] l := by
          intro l hl; induction l <;> aesop;
        exact h_foldr l hx ) ;

/-
Helper lemma: compress preserves the head of the list.
-/
lemma compress_head_eq {α} [DecidableEq α] (l : List α) :
  (compress l).head? = l.head? := by
  cases l with
  | nil => simp [compress]
  | cons x xs =>
    rw [compress_head]
    simp

/-
Prove: if origin is in TC1, the TC sequence must be TC1→TC2→TC3→TC1 (using helper lemmas).
-/
theorem tc_sequence_tc1_origin_proven (itin : Itinerary)
  (h_valid : ValidRTW itin)
  (h_fwd : rule_4b_forward_direction itin)
  (h_origin : match itin.head? with | some s => s.origin.continent.toTCArea = .TC1 | none => False) :
  compress (tc_path itin) = [.TC1, .TC2, .TC3, .TC1] := by
    convert tc_sequence_tc1_origin itin h_valid h_fwd h_origin using 1

/-
Prove: no duplicate same-direction sectors + finite city set → bounded segment count.
-/
theorem no_duplicate_sectors_bounded (itin : Itinerary) [Fintype City]
  (h_unique_ids : Function.Injective City.id)
  (h_no_dup : rule_4i_no_duplicate_sectors itin) :
  itin.length ≤ (Fintype.card City) ^ 2 := by
    convert Set.ncard_le_ncard ( show Set.range ( fun i : Fin itin.length => ( ( itin.get! ( i : ℕ ) ).origin, ( itin.get! ( i : ℕ ) ).destination ) ) ⊆ Set.univ from Set.subset_univ _ ) using 1;
    · rw [ Set.ncard_eq_toFinset_card' ];
      rw [ Set.toFinset_range ];
      rw [ Finset.card_image_of_injective ] <;> norm_num [ Function.Injective ];
      intro i j hi hj; have := h_no_dup; simp_all +decide [ List.eraseDup ] ;
      have h_eraseDup : List.length (List.eraseDup (List.map (fun s => (s.origin.id, s.destination.id)) itin)) = List.length itin := by
        unfold rule_4i_no_duplicate_sectors at this; aesop;
      have h_eraseDup : List.Nodup (List.map (fun s => (s.origin.id, s.destination.id)) itin) := by
        convert nodup_of_eraseDup_length_eq _ _;
        infer_instance;
        convert h_eraseDup using 1;
        · convert rfl;
        · rw [ List.length_map ];
      rw [ List.nodup_iff_injective_get ] at h_eraseDup;
      have := @h_eraseDup ⟨ i, by simp ⟩ ⟨ j, by simp ⟩ ; aesop;
    · norm_num [ Set.ncard_univ, pow_two ]

/-
Prove that the sum of intra-continental segments is at most 26.
-/
theorem sum_intra_continent_segments_le_26 (itin : Itinerary) (h : rule_4h_segment_limits itin) :
  ∑ c : Continent, segments_in_continent itin c ≤ 26 := by
    obtain ⟨h₁, h₂, h₃, h₄, h₅, h₆⟩ := h;
    rw [ show ( Finset.univ : Finset Continent ) = { Continent.NorthAmerica, Continent.SouthAmerica, Continent.EuropeMiddleEast, Continent.Africa, Continent.Asia, Continent.SouthWestPacific } by rfl ] ; simp +decide [ *, Finset.sum_insert, Finset.sum_singleton ] ; linarith

/-
Definitions for open jaw permitted cities and consistent world assumptions.
-/
def open_jaw_permitted_cities (c1 c2 : City) (origin_country : String) : Prop :=
  (c1.country = origin_country ∧ c2.country = origin_country) ∨
  (c1.continent = .EuropeMiddleEast ∧ c2.continent = .EuropeMiddleEast) ∨
  (c1.country = "US" ∧ c2.country = "CA") ∨ (c1.country = "CA" ∧ c2.country = "US") ∨
  (is_hkg c1 ∧ is_china c2) ∨ (is_china c1 ∧ is_hkg c2) ∨
  (is_malaysia c1 ∧ is_sin c2) ∨ (is_sin c1 ∧ is_malaysia c2) ∨
  (c1.continent = .Africa ∧ c2.continent = .Africa) ∨
  (is_maldives c1 ∧ (is_sri_lanka c2 ∨ is_india c2)) ∨ ((is_sri_lanka c1 ∨ is_india c1) ∧ is_maldives c2)

def consistent_world (c1 c2 : City) : Prop :=
  (c1.country = c2.country → c1.continent = c2.continent) ∧
  (c1.country = "US" → c1.continent = .NorthAmerica) ∧
  (c1.country = "CA" → c1.continent = .NorthAmerica) ∧
  (c1.country = "CN" → c1.continent = .Asia) ∧
  (c1.id = "HKG" → c1.continent = .Asia) ∧
  (c1.country = "MY" → c1.continent = .Asia) ∧
  (c1.id = "SIN" → c1.continent = .Asia) ∧
  (c1.country = "MV" → c1.continent = .Asia) ∧
  (c1.country = "LK" → c1.continent = .Asia) ∧
  (c1.country = "IN" → c1.continent = .Asia)

/-
Prove that permitted open jaw segments are intra-continental (assuming city consistency).
-/
def consistent_city (c : City) : Prop :=
  (c.country = "US" → c.continent = .NorthAmerica) ∧
  (c.country = "CA" → c.continent = .NorthAmerica) ∧
  (c.country = "CN" → c.continent = .Asia) ∧
  (c.id = "HKG" → c.continent = .Asia) ∧
  (c.country = "MY" → c.continent = .Asia) ∧
  (c.id = "SIN" → c.continent = .Asia) ∧
  (c.country = "MV" → c.continent = .Asia) ∧
  (c.country = "LK" → c.continent = .Asia) ∧
  (c.country = "IN" → c.continent = .Asia)

theorem open_jaw_implies_same_continent (itin : Itinerary) (s : Segment)
  (h_cons_orig : consistent_city s.origin)
  (h_cons_dest : consistent_city s.destination)
  (h_perm : is_permitted_open_jaw itin s)
  (h_same_country_same_continent : ∀ c1 c2 : City, c1.country = c2.country → consistent_city c1 → consistent_city c2 → c1.continent = c2.continent) :
  s.origin.continent = s.destination.continent := by
    -- By definition of `is_permitted_open_jaw`, if `is_permitted_open_jaw itin s = true`, then `s` must satisfy one of the conditions in the disjunction.
    unfold is_permitted_open_jaw at h_perm;
    unfold is_hkg is_china is_malaysia is_sin at h_perm; unfold is_maldives is_sri_lanka is_india at h_perm;
    contrapose! h_same_country_same_continent;
    use s.origin, s.destination;
    rcases s with ⟨ origin, destination, type, isStopover ⟩ ; unfold consistent_city at *; aesop;

/-
Prove that a generalized loop (open jaw at origin) preserves the continent.
-/
def is_generalized_loop (itin : Itinerary) : Prop :=
  match itin.head?, itin.getLast? with
  | some first, some last =>
    is_permitted_open_jaw itin { origin := last.destination, destination := first.origin, type := .Surface, isStopover := false }
  | _, _ => False

theorem generalized_loop_same_continent (itin : Itinerary)
  (h_gen_loop : is_generalized_loop itin)
  (h_cons_first : consistent_city (itin.head!.origin))
  (h_cons_last : consistent_city (itin.getLast!.destination))
  (h_same_country : ∀ c1 c2 : City, c1.country = c2.country → consistent_city c1 → consistent_city c2 → c1.continent = c2.continent) :
  (itin.head!.origin).continent = (itin.getLast!.destination).continent := by
    by_contra h_contra;
    convert open_jaw_implies_same_continent _ _ _ _ _ _ using 1;
    rotate_left;
    exact itin;
    exact ⟨ ( List.head! itin ).origin, ( List.getLast! itin ).destination, .Surface, false ⟩;
    · exact h_cons_first;
    · exact h_cons_last;
    · cases itin <;> simp_all +decide [ is_generalized_loop ];
      cases ‹List Segment› <;> simp_all +decide [ List.getLast? ];
      · unfold is_permitted_open_jaw at * ; aesop;
      · unfold is_permitted_open_jaw at * ; aesop;
    · assumption;
    · tauto

/-
Update Rule 4k with complete city lists for US/Canada transcontinental flights and add Anchorage restriction.
-/
def is_west_coast_na_v2 (c : City) : Bool :=
  c.continent == .NorthAmerica ∧
  (c.id == "LAX" ∨ c.id == "SFO" ∨ c.id == "SEA" ∨ c.id == "YVR" ∨
   c.id == "LAS" ∨ c.id == "LGB" ∨ c.id == "OAK" ∨ c.id == "PHX" ∨ c.id == "PDX" ∨
   c.id == "SAN" ∨ c.id == "SJC" ∨ c.id == "SNA")

def is_east_coast_na_v2 (c : City) : Bool :=
  c.continent == .NorthAmerica ∧
  (c.id == "NYC" ∨ c.id == "JFK" ∨ c.id == "EWR" ∨ c.id == "IAD" ∨ c.id == "BOS" ∨ c.id == "YYZ" ∨ c.id == "YUL" ∨
   c.id == "ATL" ∨ c.id == "BWI" ∨ c.id == "CLT" ∨ c.id == "CLE" ∨ c.id == "FLL" ∨
   c.id == "BDL" ∨ c.id == "MIA" ∨ c.id == "ORD" ∨ c.id == "MCO" ∨
   c.id == "PHL" ∨ c.id == "PIT" ∨ c.id == "RDU" ∨ c.id == "SJU" ∨
   c.id == "TPA" ∨ c.id == "DCA" ∨ c.id == "PBI")

def is_anchorage (c : City) : Bool := c.id == "ANC"

def is_transcontinental_na_v2 (s : Segment) : Bool :=
  s.type == .Flight ∧
  ((is_west_coast_na_v2 s.origin ∧ is_east_coast_na_v2 s.destination) ∨
   (is_east_coast_na_v2 s.origin ∧ is_west_coast_na_v2 s.destination))

def rule_4k_us_canada_transcontinental_v2 (itin : Itinerary) : Bool :=
  (itin.filter is_transcontinental_na_v2).length ≤ 1

def rule_anchorage_restriction (itin : Itinerary) : Bool :=
  let anc_flights := itin.filter (fun s => s.type == .Flight ∧ (is_anchorage s.origin ∨ is_anchorage s.destination))
  let to_anc := anc_flights.filter (fun s => is_anchorage s.destination)
  let from_anc := anc_flights.filter (fun s => is_anchorage s.origin)
  to_anc.length ≤ 1 ∧ from_anc.length ≤ 1

/-
Define Australia exceptions A and B and update Rule 4l.
Exception A: Origin PER, connecting to/from JNB or SHA.
Exception B: Origin NZ, connecting to/from JNB.
Exempt SYD/MEL-PER sectors from the count if exceptions apply.
-/
def is_per (c : City) : Bool := c.id == "PER"
def is_jnb (c : City) : Bool := c.id == "JNB"
def is_sha (c : City) : Bool := c.id == "SHA"
def is_nz (c : City) : Bool := c.country == "NZ"

def is_syd_mel (c : City) : Bool := c.id == "SYD" ∨ c.id == "MEL"

def is_syd_mel_per_sector (s : Segment) : Bool :=
  s.type == .Flight ∧
  ((is_syd_mel s.origin ∧ is_per s.destination) ∨
   (is_per s.origin ∧ is_syd_mel s.destination))

def has_jnb_or_sha (itin : Itinerary) : Bool :=
  itin.any fun s => is_jnb s.origin ∨ is_jnb s.destination ∨ is_sha s.origin ∨ is_sha s.destination

def has_jnb (itin : Itinerary) : Bool :=
  itin.any fun s => is_jnb s.origin ∨ is_jnb s.destination

def is_au_exception_a (itin : Itinerary) : Bool :=
  match itin.head? with
  | some first =>
    is_per first.origin ∧
    has_jnb_or_sha itin
  | none => false

def is_au_exception_b (itin : Itinerary) : Bool :=
  match itin.head? with
  | some first =>
    is_nz first.origin ∧
    has_jnb itin
  | none => false

def rule_4l_australia_transcontinental_v2 (itin : Itinerary) : Bool :=
  let trans_sectors := itin.filter is_transcontinental_au
  let is_exempt (s : Segment) :=
    is_syd_mel_per_sector s ∧ (is_au_exception_a itin ∨ is_au_exception_b itin)
  let counted_sectors := trans_sectors.filter (fun s => ¬is_exempt s)
  counted_sectors.length ≤ 1

/-
Define is_middle_east and update Rule 4c to restrict open jaws to within the Middle East (instead of the entire Europe-Middle East continent).
-/
def is_middle_east (c : City) : Bool :=
  let me_countries := ["AE", "BH", "IL", "IQ", "IR", "JO", "KW", "LB", "OM", "PS", "QA", "SA", "SY", "YE", "EG", "LY", "SD"]
  me_countries.contains c.country

def is_permitted_open_jaw_v2 (itin : Itinerary) (s : Segment) : Bool :=
  let c1 := s.origin
  let c2 := s.destination
  let origin_country := match itin.head? with | some s => s.origin.country | none => ""
  (c1.country == origin_country ∧ c2.country == origin_country) ∨
  (is_middle_east c1 ∧ is_middle_east c2) ∨
  (c1.country == "US" ∧ c2.country == "CA") ∨ (c1.country == "CA" ∧ c2.country == "US") ∨
  (is_hkg c1 ∧ is_china c2) ∨ (is_china c1 ∧ is_hkg c2) ∨
  (is_malaysia c1 ∧ is_sin c2) ∨ (is_sin c1 ∧ is_malaysia c2) ∨
  (c1.continent == .Africa ∧ c2.continent == .Africa) ∨
  (is_maldives c1 ∧ (is_sri_lanka c2 ∨ is_india c2)) ∨ ((is_sri_lanka c1 ∨ is_india c1) ∧ is_maldives c2)

def rule_4c_open_jaw_v2 (itin : Itinerary) : Bool :=
  match itin.head? with
  | some first =>
    let origin := first.origin
    let surface_segs := itin.filter (fun s => s.type == .Surface)
    let origin_surface_segs := surface_segs.filter (fun s => s.origin == origin ∨ s.destination == origin)
    origin_surface_segs.all (is_permitted_open_jaw_v2 itin)
  | none => true

/-
Define OneWorldCarrier, BookedSegment, and Rule 4j (codeshare rules).
Includes permitted carriers, affiliates, QF/JQ exception, and QF domestic USA restriction.
(Retrying with List.range and List.zip instead of List.enum)
-/
inductive OneWorldCarrier
| AA | AY | BA | CX | IB | JJ | JL | KA | LA | MH | NU | QF | QR | RJ | S7 | UL | XL | _4M
deriving Repr, DecidableEq, Inhabited

def OneWorldCarrier.fromString (s : String) : Option OneWorldCarrier :=
  match s with
  | "AA" => some .AA
  | "AY" => some .AY
  | "BA" => some .BA
  | "CX" => some .CX
  | "IB" => some .IB
  | "JJ" => some .JJ
  | "JL" => some .JL
  | "KA" => some .KA
  | "LA" => some .LA
  | "MH" => some .MH
  | "NU" => some .NU
  | "QF" => some .QF
  | "QR" => some .QR
  | "RJ" => some .RJ
  | "S7" => some .S7
  | "UL" => some .UL
  | "XL" => some .XL
  | "4M" => some ._4M
  | _ => none

def is_oneworld_carrier (s : String) : Bool := (OneWorldCarrier.fromString s).isSome

def is_affiliate (mc : OneWorldCarrier) (op : String) : Bool :=
  match mc with
  | .AA => op == "American Eagle"
  | .BA => op == "CityFlyer"
  | _ => false

structure BookedSegment extends Segment where
  marketingCarrier : String
  operatingCarrier : String
  bookingCode : Char
  isGroundTransport : Bool
deriving Repr, DecidableEq, Inhabited

def is_permitted_carrier (s : BookedSegment) : Bool :=
  match OneWorldCarrier.fromString s.marketingCarrier with
  | some mc =>
    let op := s.operatingCarrier
    let basic_check := (is_oneworld_carrier op) ∨ (is_affiliate mc op)
    let qf_jq := mc == .QF ∧ op == "JQ"
    let ground_restriction := (mc == .BA ∨ mc == .QF) ∧ s.isGroundTransport
    (basic_check ∨ qf_jq) ∧ ¬ground_restriction
  | none => false

def is_qf_domestic_usa (s : BookedSegment) : Bool :=
  s.marketingCarrier == "QF" ∧ s.origin.country == "US" ∧ s.destination.country == "US"

def is_qf_international (s : BookedSegment) : Bool :=
  s.marketingCarrier == "QF" ∧ s.origin.country != s.destination.country

def rule_4j_codeshare (itin : List BookedSegment) : Bool :=
  let all_permitted := itin.all is_permitted_carrier
  let indexed := (List.range itin.length).zip itin
  let qf_domestic_check :=
    indexed.all fun (i, s) =>
      if is_qf_domestic_usa s then
        let prev := indexed.find? (fun (j, _) => j == i - 1)
        let next := indexed.find? (fun (j, _) => j == i + 1)
        let connect_prev := match prev with
          | some (_, p) => is_qf_international p ∧ p.destination.id == "LAX" ∧ s.origin.id == "LAX"
          | none => false
        let connect_next := match next with
          | some (_, n) => is_qf_international n ∧ n.origin.id == "LAX" ∧ s.destination.id == "LAX"
          | none => false
        connect_prev ∨ connect_next
      else true
  all_permitted ∧ qf_domestic_check

/-
Define ExtendedCabinClass (including PremiumEconomy), regions (SE Asia, South Asian Subcontinent, Japan-Korea), and premium economy surcharges. Prove that the surcharge is always positive.
-/
inductive ExtendedCabinClass
| Economy
| PremiumEconomy
| Business
| First
deriving Repr, DecidableEq, Inhabited

def is_se_asia (c : City) : Bool :=
  ["BN", "KH", "ID", "LA", "MY", "MM", "PH", "SG", "TH", "VN"].contains c.country

def is_south_asian_subcontinent (c : City) : Bool :=
  ["BD", "BT", "IN", "MV", "NP", "PK", "LK"].contains c.country

def is_japan_korea (c : City) : Bool :=
  ["JP", "KR", "KP"].contains c.country

def get_premium_economy_surcharge (origin dest : City) : Nat :=
  let c1 := origin.continent
  let c2 := dest.continent
  let is_swp_intercontinental :=
    (c1 == .SouthWestPacific ∧ (c2 == .Africa ∨ c2 == .EuropeMiddleEast ∨ c2 == .NorthAmerica ∨ c2 == .SouthAmerica)) ∨
    (c2 == .SouthWestPacific ∧ (c1 == .Africa ∨ c1 == .EuropeMiddleEast ∨ c1 == .NorthAmerica ∨ c1 == .SouthAmerica))

  let is_se_asia_sas_jk :=
    ((is_se_asia origin ∧ (is_south_asian_subcontinent dest ∨ is_japan_korea dest)) ∨
     (is_se_asia dest ∧ (is_south_asian_subcontinent origin ∨ is_japan_korea origin)))

  let is_within_se_asia := is_se_asia origin ∧ is_se_asia dest
  let is_within_australia := origin.country == "AU" ∧ dest.country == "AU"
  let is_within_middle_east := is_middle_east origin ∧ is_middle_east dest

  if is_swp_intercontinental then 1450
  else if is_se_asia_sas_jk then 350
  else if is_within_se_asia ∨ is_within_australia ∨ is_within_middle_east then 250
  else 950

theorem premium_economy_surcharge_pos (o d : City) : get_premium_economy_surcharge o d > 0 := by
  unfold get_premium_economy_surcharge; norm_num;
  split_ifs <;> norm_num

/-
Define BookingClass and booking_code mapping (Rule 5b).
Define valid_ticketing_stock and cuba_restriction (Rule 15).
-/
inductive BookingClass
| First
| Business
| Economy
| LONE
deriving Repr, DecidableEq, Inhabited

def booking_code (carrier : OneWorldCarrier) (bc : BookingClass) : Char :=
  match carrier with
  | .S7 =>
    match bc with
    | .LONE => 'L'
    | _ => 'D'
  | .IB | .RJ | .UL =>
    match bc with
    | .First => 'D'
    | .Business => 'D'
    | .Economy => 'I'
    | .LONE => 'L'
  | _ => -- AA, BA, CX, KA, MH, QF, QR, and others assumed standard
    match bc with
    | .First => 'A'
    | .Business => 'D'
    | .Economy => 'I'
    | .LONE => 'L'

def has_jq_segment (itin : List BookedSegment) : Bool :=
  itin.any fun s => s.operatingCarrier == "JQ"

def valid_ticketing_stock (itin : List BookedSegment) (stock : OneWorldCarrier) : Bool :=
  if has_jq_segment itin then
    stock != .IB ∧ stock != .S7
  else true

def is_cuba (c : City) : Bool := c.country == "CU"

def has_cuba (itin : List BookedSegment) : Bool :=
  itin.any fun s => is_cuba s.origin ∨ is_cuba s.destination

def cuba_restriction (itin : List BookedSegment) : Bool :=
  if has_cuba itin then
    ¬(itin.any fun s => s.marketingCarrier == "AA")
  else true

/-
Define change fee and cancellation penalties. Prove Business/First penalty is less than or equal to Economy penalty for the same fare.
-/
def change_fee : Nat := 125

def cancellation_penalty (cabin : ExtendedCabinClass) (fare : Rat) : Rat :=
  match cabin with
  | .Economy => fare * 0.10
  | .PremiumEconomy => fare * 0.10 -- Assumption based on omission: treat as Economy
  | .Business => fare * 0.05
  | .First => fare * 0.05

theorem cancellation_penalty_business_le_economy (fare : Rat) (h : fare ≥ 0) :
  cancellation_penalty .Business fare ≤ cancellation_penalty .Economy fare := by
    unfold cancellation_penalty;
    norm_num; linarith

/-
Define GroupBooking, valid group sizes, and booking codes. Prove that valid groups satisfy the size bounds.
-/
structure GroupBooking where
  cabin : ExtendedCabinClass
  size : Nat
  itinerary : List BookedSegment
deriving Repr, DecidableEq, Inhabited

def is_valid_group_size (g : GroupBooking) : Bool :=
  match g.cabin with
  | .Economy => 10 ≤ g.size ∧ g.size ≤ 30
  | .Business => 10 ≤ g.size ∧ g.size ≤ 15
  | _ => false -- Only Economy and Business mentioned for groups

def group_booking_code (carrier : OneWorldCarrier) (cabin : ExtendedCabinClass) : Option Char :=
  match cabin with
  | .Business =>
    match carrier with
    | .S7 => some 'D'
    | _ => some 'I'
  | .Economy => some 'G'
  | _ => none

def group_travel_together (g : GroupBooking) : Bool :=
  -- "Group must travel together entire itinerary" implies all passengers are on the same segments.
  -- Since the structure has a single itinerary list, this is implicitly true for the group object.
  -- We can just return true or define it as a property of the data structure design.
  true

theorem group_size_bounds (g : GroupBooking) (h : is_valid_group_size g) :
  (g.cabin = .Economy → 10 ≤ g.size ∧ g.size ≤ 30) ∧
  (g.cabin = .Business → 10 ≤ g.size ∧ g.size ≤ 15) := by
    unfold is_valid_group_size at h; aesop;

/-
Prove that child fare + surcharge is strictly less than adult fare + surcharge (given positive base fare).
-/
theorem child_fare_plus_surcharge_lt_adult (base_fare : Rat) (surcharge : Rat) (h_pos : base_fare > 0) :
  rule_19_children_pricing base_fare .Child + surcharge < rule_19_children_pricing base_fare .Adult + surcharge := by
    unfold rule_19_children_pricing; norm_num; linarith;

/-
Prove that an itinerary with Cuba and an AA flight violates the Cuba restriction (returns false).
-/
theorem cuba_restriction_implies_invalid (itin : List BookedSegment)
  (h_cuba : has_cuba itin)
  (h_aa : itin.any fun s => s.marketingCarrier == "AA") :
  cuba_restriction itin = false := by
    unfold cuba_restriction; aesop;

/-
Prove that the West Coast and East Coast city lists are disjoint (no city is in both).
-/
theorem west_and_east_coast_disjoint (c : City) : ¬(is_west_coast_na_v2 c ∧ is_east_coast_na_v2 c) := by
  simp [is_west_coast_na_v2, is_east_coast_na_v2];
  intro h_cont h_id h_cont' ; rcases h_id with ( h | h | h | h | h | h | h | h | h | h | h | h ) <;> simp +decide [ h ] at h_cont' ⊢;

/-
Prove that a flight is transcontinental iff it connects West Coast and East Coast (in either direction).
-/
theorem transcontinental_iff_west_east (s : Segment) (h_flight : s.type = .Flight) :
  is_transcontinental_na_v2 s ↔
  (is_west_coast_na_v2 s.origin ∧ is_east_coast_na_v2 s.destination) ∨
  (is_east_coast_na_v2 s.origin ∧ is_west_coast_na_v2 s.destination) := by
    unfold is_transcontinental_na_v2; aesop;