/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3ab19d49-9906-4ae9-8b2d-322af88108ed

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined `IsHadamard` to represent the property of a matrix being a Hadamard matrix. We then stated the Hadamard conjecture as `HadamardConjectureProp`, which asserts that for every `k ≥ 0`, there exists a Hadamard matrix of size `4k`. We also proved the conjecture for the base cases `k=0` and `k=1` (size 4) in `HadamardConjecture_0` and `HadamardConjecture_1` respectively.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A Hadamard matrix of size n is a matrix with ±1 entries satisfying M^T M = n·I.
-/
def IsHadamard {n : ℕ} (M : Matrix (Fin n) (Fin n) ℝ) : Prop :=
  (∀ i j, M i j = 1 ∨ M i j = -1) ∧ M.transpose * M = (n : ℝ) • 1

/-
The statement of the Hadamard conjecture: for every k ≥ 0, there exists a Hadamard matrix of size 4k.
-/
def HadamardConjectureProp : Prop := ∀ k : ℕ, ∃ M, IsHadamard (n := 4 * k) M

/-
The Hadamard conjecture holds for k=0 (trivial).
-/
theorem HadamardConjecture_0 : ∃ M, IsHadamard (n := 0) M := by
  -- The empty matrix satisfies the conditions for being a Hadamard matrix.
  simp [IsHadamard];
  -- The empty matrix is equal to the zero matrix.
  ext i j; fin_cases i

/-
The Hadamard conjecture holds for k=1 (size 4).
-/
theorem HadamardConjecture_1 : ∃ M, IsHadamard (n := 4) M := by
  -- Consider the Hadamard matrix of order 4:
  use !![1, 1, 1, 1; 1, -1, 1, -1; 1, 1, -1, -1; 1, -1, -1, 1];
  constructor <;> norm_num +zetaDelta at *;
  · norm_num [ Fin.forall_fin_succ ];
  · ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ Matrix.mul_apply, Fin.sum_univ_succ ]