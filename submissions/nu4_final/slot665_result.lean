/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a1e4a74f-8109-4cac-90de-3b3143c82a72

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 20082f90-c088-48e5-b1cc-1c24b1fe33c7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#eval Nat.totient 0

/-
The sum of φ(n)/(2^n - 1) for n ≥ 1 is equal to 2.
-/
theorem totient_lambert_series : HasSum (fun n : ℕ => (Nat.totient (n + 1) : ℝ) / (2 ^ (n + 1) - 1)) 2 := by
  -- We'll use the fact that $\sum_{n=1}^{\infty} \frac{\phi(n)}{2^n - 1}$ converges to 2.
  have h_sum : ∑' n : ℕ, ((Nat.totient n) : ℝ) / ((2 : ℝ) ^ n - 1) = 2 := by
    -- We'll use the fact that $\sum_{n=1}^{\infty} \frac{\phi(n)}{2^n - 1} = \sum_{n=1}^{\infty} \frac{n}{2^n}$.
    have h_sum_eq : ∑' n : ℕ, (Nat.totient n : ℝ) / (2 ^ n - 1) = ∑' n : ℕ, (n : ℝ) / (2 ^ n) := by
      -- We'll use the fact that $\sum_{n=1}^{\infty} \frac{\phi(n)}{2^n - 1}$ is equal to $\sum_{n=1}^{\infty} \frac{n}{2^n}$ to conclude the proof.
      have h_sum_eq : ∑' (n : ℕ), ((Nat.totient n) : ℝ) / (2 ^ n - 1) = ∑' (n : ℕ), (∑' (k : ℕ), if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) := by
        -- Let's express the inner sum in terms of the harmonic series.
        have h_inner_sum : ∀ n : ℕ, n ≠ 0 → ∑' (k : ℕ), (if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) = (Nat.totient n : ℝ) / (2 ^ n - 1) := by
          intro n hn_ne_zero
          have h_inner_sum : ∑' (k : ℕ), (if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) = ∑' (m : ℕ), (Nat.totient n : ℝ) / (2 ^ (n * (m + 1))) := by
            have h_inner_sum : {k : ℕ | k ≠ 0 ∧ n ∣ k} = {k : ℕ | ∃ m : ℕ, k = n * (m + 1)} := by
              ext k
              simp [Set.mem_setOf_eq];
              exact ⟨ fun h => by obtain ⟨ m, rfl ⟩ := h.2; exact ⟨ m - 1, by cases m <;> aesop ⟩, fun h => by obtain ⟨ m, rfl ⟩ := h; exact ⟨ by aesop, by exact dvd_mul_right _ _ ⟩ ⟩;
            rw [ Set.ext_iff ] at h_inner_sum;
            rw [ tsum_eq_tsum_of_ne_zero_bij ];
            use fun x => n * ( x + 1 );
            · aesop_cat;
            · intro x hx; specialize h_inner_sum x; aesop;
            · aesop;
          -- Recognize that the sum $\sum_{m=0}^{\infty} \frac{1}{2^{n(m+1)}}$ is a geometric series with the first term $\frac{1}{2^n}$ and common ratio $\frac{1}{2^n}$.
          have h_geo_series : ∑' (m : ℕ), (1 : ℝ) / (2 ^ (n * (m + 1))) = (1 / (2 ^ n)) / (1 - 1 / (2 ^ n)) := by
            ring_nf;
            rw [ tsum_mul_left, ← tsum_geometric_of_lt_one ( by positivity ) ( by exact pow_lt_one₀ ( by positivity ) ( by norm_num ) ( by positivity ) ) ] ; norm_num [ pow_mul ];
          simp_all +decide [ div_eq_mul_inv, tsum_mul_left ];
          rw [ ← mul_inv, mul_sub, mul_one, mul_inv_cancel₀ ( by positivity ) ];
        exact tsum_congr fun n => if hn : n = 0 then by norm_num [ hn ] else h_inner_sum n hn ▸ rfl;
      -- By Fubini's theorem, we can interchange the order of summation.
      have h_fubini : ∑' (n : ℕ), (∑' (k : ℕ), if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) = ∑' (k : ℕ), (∑' (n : ℕ), if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) := by
        rw [ Summable.tsum_comm ];
        -- We'll use the fact that if the series $\sum_{k=1}^{\infty} a_k$ converges absolutely, then the double series $\sum_{k=1}^{\infty} \sum_{n=1}^{\infty} a_{k,n}$ also converges absolutely.
        have h_abs_conv : Summable (fun p : ℕ × ℕ => |(if p.1 ≠ 0 ∧ p.2 ∣ p.1 then (Nat.totient p.2 : ℝ) / (2 ^ p.1) else 0)|) := by
          -- We'll use the fact that if the series $\sum_{k=1}^{\infty} a_k$ converges absolutely, then the double series $\sum_{k=1}^{\infty} \sum_{n=1}^{\infty} a_{k,n}$ also converges absolutely. Hence, we can interchange the order of summation.
          have h_abs_conv : Summable (fun k : ℕ => (∑' (n : ℕ), if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0)) := by
            -- We'll use the fact that if the series $\sum_{k=1}^{\infty} a_k$ converges absolutely, then the double series $\sum_{k=1}^{\infty} \sum_{n=1}^{\infty} a_{k,n}$ also converges absolutely. Hence, we need to show that $\sum_{k=1}^{\infty} \frac{k}{2^k}$ converges.
            have h_abs_conv : Summable (fun k : ℕ => (k : ℝ) / (2 ^ k)) := by
              refine' summable_of_ratio_norm_eventually_le _ _;
              exact 3 / 4;
              · norm_num;
              · filter_upwards [ Filter.eventually_ge_atTop 4 ] with n hn using by rw [ Real.norm_of_nonneg ( by positivity ), Real.norm_of_nonneg ( by positivity ) ] ; rw [ div_mul_div_comm ] ; rw [ div_le_div_iff₀ ] <;> norm_cast <;> ring <;> nlinarith [ pow_pos ( zero_lt_two' ℕ ) n ] ;
            refine' .of_nonneg_of_le ( fun k => tsum_nonneg fun n => by positivity ) ( fun k => _ ) h_abs_conv;
            by_cases hk : k = 0 <;> simp_all +decide [ div_eq_mul_inv, tsum_mul_right ];
            rw [ tsum_eq_sum ];
            any_goals exact Nat.divisors k;
            · rw [ Finset.sum_congr rfl fun x hx => if_pos <| Nat.dvd_of_mem_divisors hx ];
              rw [ ← Finset.sum_mul _ _ _ ];
              exact mul_le_mul_of_nonneg_right ( mod_cast by rw [ Nat.sum_totient ] ) ( by positivity );
            · aesop;
          rw [ summable_prod_of_nonneg ];
          · refine' ⟨ _, _ ⟩;
            · intro x; by_cases hx : x = 0 <;> simp +decide [ hx ];
              · exact summable_zero;
              · refine' summable_of_ne_finset_zero _;
                exacts [ Finset.Iic x, fun n hn => by rw [ if_neg ( by exact fun h => hn <| Finset.mem_Iic.mpr <| Nat.le_of_dvd ( Nat.pos_of_ne_zero hx ) h ) ] ; norm_num ];
            · convert h_abs_conv using 1;
              exact funext fun k => tsum_congr fun n => by split_ifs <;> norm_num [ abs_of_nonneg, div_nonneg, Nat.cast_nonneg ] ;
          · exact fun _ => abs_nonneg _;
        exact h_abs_conv.of_abs;
      -- Let's simplify the inner sum.
      have h_inner : ∀ k : ℕ, k ≠ 0 → ∑' (n : ℕ), (if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) = (k : ℝ) / (2 ^ k) := by
        intro k hk_ne
        have h_inner_sum : ∑' (n : ℕ), (if k ≠ 0 ∧ n ∣ k then (Nat.totient n : ℝ) / (2 ^ k) else 0) = ∑ n ∈ Nat.divisors k, (Nat.totient n : ℝ) / (2 ^ k) := by
          rw [ tsum_eq_sum ];
          exacts [ Finset.sum_congr rfl fun x hx => if_pos ⟨ hk_ne, Nat.dvd_of_mem_divisors hx ⟩, fun x hx => if_neg <| by simpa [ hk_ne ] using hx ];
        rw [ h_inner_sum, ← Finset.sum_div _ _ _, ← Nat.cast_sum, Nat.sum_totient ];
      rw [ h_sum_eq, h_fubini, tsum_congr fun n => if hn : n = 0 then by aesop else h_inner n hn ];
    -- We'll use the fact that $\sum_{n=1}^{\infty} \frac{n}{2^n} = 2$.
    have h_sum : ∑' n : ℕ, (n : ℝ) * (1 / 2) ^ n = 2 := by
      -- Let's simplify the expression $\sum_{n=1}^{\infty} \frac{n}{2^n}$ using the formula for the sum of a geometric series.
      have h_geo_series : ∀ r : ℝ, |r| < 1 → ∑' n : ℕ, (n : ℝ) * r ^ n = r / (1 - r) ^ 2 := by
        exact?;
      rw [ h_geo_series ] <;> norm_num [ abs_of_pos ];
    aesop;
  rw [ Summable.tsum_eq_zero_add ] at h_sum <;> norm_num at *;
  · convert h_sum ▸ Summable.hasSum _;
    exact ( by contrapose! h_sum; erw [ tsum_eq_zero_of_not_summable h_sum ] ; norm_num );
  · exact ( by contrapose! h_sum; erw [ tsum_eq_zero_of_not_summable h_sum ] ; norm_num )

/-
The sum of φ(n)/2^n is strictly between 1 and 2.
-/
theorem erdos_249_bounds : 1 < (∑' n : ℕ, (Nat.totient n : ℝ) / 2 ^ n) ∧ (∑' n : ℕ, (Nat.totient n : ℝ) / 2 ^ n) < 2 := by
  constructor;
  · refine' lt_of_lt_of_le _ ( Summable.sum_le_tsum ( Finset.range ( 5 : ℕ ) ) ( fun _ _ => by positivity ) _ );
    · norm_num [ Finset.sum_range_succ, Nat.totient_prime ];
    · have h_summable : Summable (fun n : ℕ => (Nat.totient (n + 1) : ℝ) / (2 ^ (n + 1) - 1)) := by
        convert totient_lambert_series.summable using 1;
      rw [ ← summable_nat_add_iff 1 ];
      exact Summable.of_nonneg_of_le ( fun n => div_nonneg ( Nat.cast_nonneg _ ) ( by positivity ) ) ( fun n => div_le_div_of_nonneg_left ( by positivity ) ( by exact sub_pos.mpr ( one_lt_pow₀ ( by norm_num ) ( by linarith ) ) ) ( by linarith [ pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 2 ) ( by linarith : n + 1 ≥ 1 ) ] ) ) h_summable;
  · have h_sum : ∑' n : ℕ, (Nat.totient (n + 1) : ℝ) / (2 ^ (n + 1)) < ∑' n : ℕ, (Nat.totient (n + 1) : ℝ) / (2 ^ (n + 1) - 1) := by
      fapply Summable.tsum_lt_tsum;
      use 2;
      · intro n;
        field_simp;
        rw [ le_div_iff₀ ] <;> linarith [ pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 2 ) ( by linarith : n + 1 ≥ 1 ) ];
      · norm_num [ Nat.totient_prime ];
      · have h_sum : Summable (fun n : ℕ => (Nat.totient (n + 1) : ℝ) / (2 ^ (n + 1) - 1)) := by
          convert totient_lambert_series.summable using 1;
        exact Summable.of_nonneg_of_le ( fun n => div_nonneg ( Nat.cast_nonneg _ ) ( by positivity ) ) ( fun n => div_le_div_of_nonneg_left ( by positivity ) ( by exact sub_pos.mpr ( one_lt_pow₀ ( by norm_num ) ( by linarith ) ) ) ( by exact sub_le_self _ ( by positivity ) ) ) h_sum;
      · convert totient_lambert_series.summable using 1;
    convert h_sum using 1;
    · rw [ Summable.tsum_eq_zero_add ] ; norm_num;
      contrapose! h_sum;
      rw [ tsum_eq_zero_of_not_summable ];
      · exact tsum_nonneg fun _ => by positivity;
      · intro h;
        refine h_sum <| summable_nat_add_iff 1 |>.1 <| .of_nonneg_of_le ( fun n => by positivity ) ( fun n => ?_ ) h;
        gcongr <;> norm_num;
        exact one_lt_pow₀ ( by norm_num ) ( by norm_num );
    · convert totient_lambert_series.tsum_eq.symm using 1

/-
The tail sum satisfies the recurrence X_{N+1} = 2X_N - φ(N+1).
-/
noncomputable def tail_sum (N : ℕ) : ℝ := ∑' n : ℕ, (Nat.totient (N + n + 1) : ℝ) / 2 ^ (n + 1)

theorem tail_sum_recurrence (N : ℕ) : tail_sum (N + 1) = 2 * tail_sum N - (Nat.totient (N + 1) : ℝ) := by
  -- By definition of `tail_sum`, we have:
  have h_tail_def : ∀ N, tail_sum N = (∑' n : ℕ, (Nat.totient (n + N + 1) : ℝ) / 2 ^ (n + 1)) := by
    intro N
    unfold tail_sum;
    ac_rfl;
  rw [ h_tail_def, h_tail_def ];
  rw [ eq_comm, Summable.tsum_eq_zero_add ];
  · norm_num [ add_comm, add_left_comm, add_assoc, pow_succ, ← div_div, tsum_div_const ] ; ring;
  · -- We'll use the fact that if the denominator grows faster than the numerator, the series converges.
    have h_summable : Summable (fun n : ℕ => (Nat.totient (n + N + 1) : ℝ) / 2 ^ n) := by
      have h_summable : Summable (fun n : ℕ => (Nat.totient n : ℝ) / 2 ^ n) := by
        have := @erdos_249_bounds;
        exact ( by contrapose! this; rw [ tsum_eq_zero_of_not_summable this ] ; norm_num );
      convert h_summable.mul_left ( 2 ^ ( N + 1 ) ) |> Summable.comp_injective <| add_left_injective ( N + 1 ) using 2 ; norm_num ; ring;
      simp +zetaDelta at *;
    convert h_summable.mul_left ( 1 / 2 ) using 2 ; ring

/-
The tail sum is strictly between 1/2 and N+2.
-/
theorem tail_sum_bounds (N : ℕ) : 1 / 2 < tail_sum N ∧ tail_sum N < N + 2 := by
  -- The lower bound: The first term of the sum is $\phi(N+1)/2$, which is at least $1/2$ because $\phi(N+1) \geq 1$.
  have h_lower_bound : 1 / 2 < ∑' (n : ℕ), (Nat.totient (N + n + 1) : ℝ) / (2 ^ (n + 1)) := by
    refine' lt_of_lt_of_le _ ( Summable.sum_le_tsum ( Finset.range ( N + 3 ) ) ( fun _ _ => by positivity ) _ );
    · norm_num [ Finset.sum_range_succ' ];
      refine' lt_add_of_pos_of_le _ _;
      · exact add_pos_of_nonneg_of_pos ( add_nonneg ( Finset.sum_nonneg fun _ _ => by positivity ) ( by positivity ) ) ( by exact div_pos ( Nat.cast_pos.mpr ( Nat.totient_pos.mpr ( by linarith ) ) ) ( by positivity ) );
      · rw [ div_le_div_iff₀ ] <;> norm_cast ; linarith [ Nat.totient_pos.2 ( Nat.succ_pos N ) ];
    · -- We'll use the comparison test. Since \( \phi(n) \leq n \), we have \( \frac{\phi(n)}{2^n} \leq \frac{n}{2^n} \).
      have h_compare : ∀ n : ℕ, (Nat.totient (N + n + 1) : ℝ) / 2 ^ (n + 1) ≤ (N + n + 1 : ℝ) / 2 ^ (n + 1) := by
        exact fun n => by gcongr ; norm_cast ; exact Nat.totient_le _;
      refine' Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => h_compare n ) _;
      refine' summable_of_ratio_norm_eventually_le _ _ <;> norm_num +zetaDelta at *;
      exacts [ 3 / 4, by norm_num, ⟨ ⌈ ( N : ℝ ) * 4⌉₊ + 1, fun n hn => by rw [ div_mul_div_comm, div_le_div_iff₀ ] <;> norm_cast <;> ring <;> nlinarith [ Nat.le_ceil ( ( N : ℝ ) * 4 ), show 2 ^ n > 0 by positivity, show 2 ^ n * n > 0 by exact mul_pos ( pow_pos ( by decide ) _ ) ( by linarith ) ] ⟩ ];
  -- The sum $\sum_{n=0}^\infty (N+n+1)/2^{n+1}$ can be simplified to $(N+1) + 1 = N+2$.
  have h_sum_simplified : ∑' (n : ℕ), ((N + n + 1) : ℝ) / (2 ^ (n + 1)) = (N + 1) + 1 := by
    have h_sum_simplified : ∑' (n : ℕ), ((n + 1) : ℝ) / (2 ^ (n + 1)) = 2 := by
      -- Let's simplify the sum $\sum_{n=1}^\infty \frac{n}{2^n}$.
      have h_sum_simplified : ∑' (n : ℕ), (n : ℝ) / (2 ^ n) = 2 := by
        -- Let's simplify the expression $\sum_{n=1}^\infty \frac{n}{2^n}$ using the formula for the sum of a geometric series.
        have h_geo_series : ∀ r : ℝ, |r| < 1 → ∑' n : ℕ, (n : ℝ) * r ^ n = r / (1 - r) ^ 2 := by
          exact?;
        convert h_geo_series ( 1 / 2 ) ( by norm_num [ abs_of_pos ] ) using 1 <;> norm_num;
        exact tsum_congr fun n => by rw [ one_div_pow ] ; ring;
      rw [ Summable.tsum_eq_zero_add ] at h_sum_simplified <;> norm_num at *;
      · convert h_sum_simplified using 1;
      · exact ( by contrapose! h_sum_simplified; erw [ tsum_eq_zero_of_not_summable h_sum_simplified ] ; norm_num );
    have h_sum_simplified : ∑' (n : ℕ), ((N + n + 1) : ℝ) / (2 ^ (n + 1)) = (∑' (n : ℕ), ((n + 1) : ℝ) / (2 ^ (n + 1))) + (∑' (n : ℕ), ((N) : ℝ) / (2 ^ (n + 1))) := by
      rw [ ← Summable.tsum_add ] ; congr ; ext n ; ring;
      · exact ( by contrapose! h_sum_simplified; erw [ tsum_eq_zero_of_not_summable h_sum_simplified ] ; norm_num );
      · ring_nf;
        exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) );
    simp_all +decide [ div_eq_mul_inv, tsum_mul_left ];
    ring_nf; rw [ tsum_mul_right, tsum_geometric_of_lt_one ] <;> norm_num;
  -- Since there are composite numbers greater than $N$, there exists some $n$ such that $\phi(N+n+1) < N+n+1$.
  obtain ⟨n, hn⟩ : ∃ n : ℕ, Nat.totient (N + n + 1) < N + n + 1 := by
    exact ⟨ N + 1, Nat.totient_lt _ <| by linarith ⟩;
  -- Since $\phi(N+n+1) < N+n+1$, we have $\frac{\phi(N+n+1)}{2^{n+1}} < \frac{N+n+1}{2^{n+1}}$.
  have h_term_lt : (Nat.totient (N + n + 1) : ℝ) / (2 ^ (n + 1)) < (N + n + 1 : ℝ) / (2 ^ (n + 1)) := by
    gcongr ; norm_cast;
  have h_sum_lt : ∑' (n : ℕ), (Nat.totient (N + n + 1) : ℝ) / (2 ^ (n + 1)) < ∑' (n : ℕ), ((N + n + 1) : ℝ) / (2 ^ (n + 1)) := by
    apply_rules [ Summable.tsum_lt_tsum ];
    · exact fun n => by simpa using div_le_div_of_nonneg_right ( show ( Nat.totient ( N + n + 1 ) : ℝ ) ≤ N + n + 1 by exact_mod_cast Nat.totient_le _ ) ( by positivity ) ;
    · exact ( by contrapose! h_lower_bound; erw [ tsum_eq_zero_of_not_summable h_lower_bound ] ; norm_num );
    · exact ( by contrapose! h_sum_simplified; erw [ tsum_eq_zero_of_not_summable h_sum_simplified ] ; linarith );
  exact ⟨ h_lower_bound, by linarith! ⟩

/-
There exists a prime number greater than M that is congruent to 3 modulo 4.
-/
theorem exists_prime_mod_4_3 (M : ℕ) : ∃ p : ℕ, p > M ∧ Nat.Prime p ∧ p % 4 = 3 := by
  -- Consider the number $N = 4(M!) - 1$. Since $N$ is odd, all its prime factors are odd.
  let N := 4 * (M.factorial) - 1
  have hN_odd : Odd N := by
    simp +zetaDelta at *;
    norm_num [ Nat.one_le_iff_ne_zero, parity_simps, Nat.factorial_ne_zero ];
  -- If all prime factors of $N$ were congruent to 1 mod 4, then their product $N$ would be congruent to 1 mod 4.
  by_contra h_contra
  have h_prod_mod : ∀ p, Nat.Prime p → p ∣ N → p % 4 = 1 := by
    intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
    · have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
      exact absurd ( even_iff_two_dvd.mpr dp ) ( by simpa using hN_odd );
    · exact h_contra p ( not_le.mp fun contra => by have := Nat.dvd_sub' ( dvd_mul_of_dvd_right ( Nat.dvd_factorial ( Nat.pos_of_ne_zero pp.ne_zero ) contra ) 4 ) dp; rw [ Nat.sub_sub_self ( Nat.one_le_iff_ne_zero.mpr <| by positivity ) ] at this; aesop ) pp h;
  -- Then $N$ would be congruent to 1 modulo 4.
  have hN_mod : N % 4 = 1 := by
    rw [ ← Nat.prod_primeFactorsList hN_odd.pos.ne' ] ; rw [ List.prod_nat_mod ] ; ( ( erw [ List.prod_eq_one ] <;> intros <;> aesop ) );
  grind

/-
The Erdős sum is the sum of φ(n)/2^n over all natural numbers n.
-/
noncomputable def erdos_sum := ∑' n : ℕ, (Nat.totient n : ℝ) / 2 ^ n

/-
The tail sum is equal to 2^N times the Erdős sum minus a finite sum.
-/
theorem tail_sum_eq_erdos_shifted (N : ℕ) : tail_sum N = 2 ^ N * erdos_sum - ∑ n ∈ Finset.range N, (Nat.totient (n + 1) : ℝ) * 2 ^ (N - 1 - n) := by
  -- By definition of $erdos_sum$, we have $erdos_sum = \sum_{n=1}^\infty \frac{\phi(n)}{2^n} = \sum_{n=1}^N \frac{\phi(n)}{2^n} + \sum_{n=N+1}^\infty \frac{\phi(n)}{2^n}$.
  have h_split_sum : erdos_sum = ∑ n ∈ Finset.range (N + 1), (Nat.totient n : ℝ) / 2 ^ n + tail_sum N / 2 ^ N := by
    -- By definition of $erdos_sum$, we can split the sum into two parts: the sum up to $N$ and the tail starting from $N+1$.
    have h_split : erdos_sum = (∑ n ∈ Finset.range (N + 1), (Nat.totient n : ℝ) / 2 ^ n) + (∑' n : ℕ, (Nat.totient (n + N + 1) : ℝ) / 2 ^ (n + N + 1)) := by
      rw [ show erdos_sum = ∑' n : ℕ, ( Nat.totient n : ℝ ) / 2 ^ n by rfl, ← Summable.sum_add_tsum_nat_add ];
      congr! 1;
      have := @erdos_249_bounds;
      exact ( by contrapose! this; erw [ tsum_eq_zero_of_not_summable this ] ; norm_num );
    convert h_split using 2;
    unfold tail_sum; norm_num [ pow_add, div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, tsum_mul_left ] ;
    rw [ ← tsum_mul_left ] ; congr ; ext n ; ring;
  rw [ h_split_sum, mul_add, mul_div_cancel₀ ] <;> norm_num [ Finset.sum_range_succ' ];
  norm_num [ mul_div, mul_comm, Finset.mul_sum _ _ _, tsub_tsub ];
  rw [ eq_sub_iff_add_eq ] ; rw [ Finset.sum_congr rfl fun x hx => ?_ ] ; ring;
  rw [ show N = ( 1 + x ) + ( N - ( 1 + x ) ) by rw [ Nat.add_sub_cancel' ( by linarith [ Finset.mem_range.mp hx ] ) ] ] ; ring;
  norm_num [ mul_assoc, ← mul_pow ]

/-
If the Erdős sum is a dyadic rational, then the tail sums are eventually integers.
-/
theorem tail_sum_integer_of_dyadic (a k : ℕ) (h : erdos_sum = a / 2 ^ k) : ∃ N, ∀ m ≥ N, ∃ z : ℤ, tail_sum m = z := by
  use k + 1;
  intro m hm;
  -- Substitute the given Erdős sum into the expression for the tail sum.
  have h_tail_sum : tail_sum m = (a : ℝ) * 2^(m - k) - ∑ n ∈ Finset.range m, (Nat.totient (n + 1) : ℝ) * 2^(m - 1 - n) := by
    rw [ tail_sum_eq_erdos_shifted, h ];
    field_simp;
    rw [ show ( 2 : ℝ ) ^ m = 2 ^ k * 2 ^ ( m - k ) by rw [ ← pow_add, Nat.add_sub_of_le ( by linarith ) ] ] ; ring;
  exact ⟨ a * 2 ^ ( m - k ) - ∑ n ∈ Finset.range m, ( n + 1 |> Nat.totient ) * 2 ^ ( m - 1 - n ), by push_cast; exact h_tail_sum ⟩

/-
If N ≥ 2 and the tail sum at N is an integer, then the tail sum at N+1 is an even integer.
-/
theorem tail_sum_even_of_integer (N : ℕ) (h : ∃ z : ℤ, tail_sum N = z) : ∃ k : ℤ, tail_sum (N + 1) = 2 * k := by
  by_cases hN : N < 2;
  · interval_cases N;
    · -- By definition of $tail_sum$, we have $tail_sum 0 = X_0$ and $tail_sum 1 = X_1$.
      have h_tail_sum_0 : tail_sum 0 = erdos_sum := by
        convert tail_sum_eq_erdos_shifted 0 using 1 ; norm_num
      have h_tail_sum_1 : tail_sum 1 = 2 * tail_sum 0 - (Nat.totient 1 : ℝ) := by
        exact?;
      -- By definition of $erdos_sum$, we have $erdos_sum = X_0$.
      have h_erdos_sum_bounds : 1 < erdos_sum ∧ erdos_sum < 2 := by
        convert erdos_249_bounds using 1;
      rcases h with ⟨ z, hz ⟩ ; rcases z with ⟨ _ | _ | z ⟩ <;> norm_num at * <;> linarith;
    · -- Since the tail sum at 1 is an integer, let's call it z. Then the tail sum at 2 would be 2z - φ(2).
      obtain ⟨z, hz⟩ := h
      have h_tail_sum_2 : tail_sum 2 = 2 * z - 1 := by
        rw [ ← hz, tail_sum_recurrence ] ; norm_num;
      have h_tail_sum_3 : tail_sum 3 = 2 * (2 * z - 1) - 2 := by
        convert tail_sum_recurrence 2 using 1 ; norm_num [ h_tail_sum_2 ];
        norm_cast;
      have h_tail_sum_4 : tail_sum 4 = 2 * (2 * (2 * z - 1) - 2) - 2 := by
        rw [ ← h_tail_sum_3, tail_sum_recurrence ] ; norm_num [ Nat.totient_prime ];
        norm_cast;
      have := tail_sum_bounds 4; norm_num [ h_tail_sum_4 ] at this; rcases z with ⟨ _ | _ | _ | _ | _ | _ | z ⟩ <;> norm_num at * <;> linarith;
  · -- Since $N \geq 2$, we know that $\phi(N+1)$ is even.
    have h_phi_even : Even (Nat.totient (N + 1)) := by
      exact Nat.totient_even <| by linarith;
    obtain ⟨ k, hk ⟩ := h_phi_even; obtain ⟨ z, hz ⟩ := h; use z - k; simp_all +decide [ tail_sum_recurrence ] ; ring;

/-
If the tail sum at N is even and φ(N+1) is 2 mod 4, then the tail sum at N+1 is not divisible by 4.
-/
theorem tail_sum_not_div_4_of_even_and_phi_mod_4_2 (N : ℕ) (h : ∃ k : ℤ, tail_sum N = 2 * k) (h_phi : Nat.totient (N + 1) % 4 = 2) : ¬ ∃ m : ℤ, tail_sum (N + 1) = 4 * m := by
  have := tail_sum_recurrence N;
  -- Substitute h into the recurrence relation to get tail_sum (N + 1) = 4k - φ(N+1).
  obtain ⟨k, hk⟩ := h
  rw [this, hk]
  -- Now, show that 4k - φ(N+1) is not divisible by 4.
  intro h_div
  obtain ⟨m, hm⟩ := h_div
  have h_eq : 4 * m = 4 * k - (Nat.totient (N + 1) : ℤ) := by
    exact_mod_cast ( by linarith : ( 4 : ℝ ) * m = 4 * k - Nat.totient ( N + 1 ) );
  omega

/-
For a prime p congruent to 3 mod 4, if the tail sum at p-1 is even, then the tail sum at p is not divisible by 4.
-/
theorem tail_sum_mod_4_at_prime (p : ℕ) (hp : Nat.Prime p) (h_mod : p % 4 = 3) (h_even : ∃ k : ℤ, tail_sum (p - 1) = 2 * k) : ¬ ∃ m : ℤ, tail_sum p = 4 * m := by
  by_contra h_contra;
  convert tail_sum_not_div_4_of_even_and_phi_mod_4_2 ( p - 1 ) h_even _ using 1;
  · rw [ Nat.sub_add_cancel hp.pos ] ; aesop;
  · rw [ Nat.sub_add_cancel hp.pos, Nat.totient_prime hp ] ; omega;

/-
The Erdős sum is not an integer.
-/
theorem erdos_249_not_integer : ¬ ∃ z : ℤ, erdos_sum = z := by
  -- From the problem statement, we have 1 < erdos_sum < 2.
  have h_bounds : 1 < erdos_sum ∧ erdos_sum < 2 := by
    convert erdos_249_bounds using 1;
  rintro ⟨ z, hz ⟩ ; rcases z with ⟨ _ | _ | z ⟩ <;> norm_num at * <;> linarith;

/-
No integer sequence satisfies the recurrence and the bounds.
-/
theorem no_integer_seq_bounded : ¬ ∃ (X : ℕ → ℤ), (∀ n, X (n + 1) = 2 * X n - (Nat.totient (n + 1) : ℤ)) ∧ (∀ n, (1 : ℝ) / 2 < X n ∧ (X n : ℝ) < n + 2) := by
  by_contra h;
  -- Let's obtain such a sequence X.
  obtain ⟨X, hX⟩ := h;
  -- Let's obtain the initial term X(0) from the hypothesis.
  have hX0 : X 0 = 1 := by
    have := hX.2 0; norm_num at this; exact Int.le_antisymm ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith ) ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; linarith ) ;
  have := hX.2 10; norm_num [ hX.1, hX0 ] at this;
  norm_num [ show Nat.totient 3 = 2 by rfl, show Nat.totient 4 = 2 by rfl, show Nat.totient 5 = 4 by rfl, show Nat.totient 6 = 2 by rfl, show Nat.totient 7 = 6 by rfl, show Nat.totient 8 = 4 by rfl, show Nat.totient 9 = 6 by rfl, show Nat.totient 10 = 4 by rfl ] at this

/-
The difference between n and φ(n) can be arbitrarily large.
-/
theorem totient_diff_unbounded (M : ℕ) : ∃ n, n - Nat.totient n > M := by
  obtain ⟨ p, hp ⟩ := Nat.exists_prime_gt_modEq_one ( 2 * M + 2 ) ( by norm_num : 4 ≠ 0 );
  use p^2;
  rw [ Nat.totient_prime_pow ] <;> norm_num [ hp.1 ];
  exact lt_tsub_iff_left.mpr ( by nlinarith [ Nat.sub_add_cancel hp.1.pos ] )

/-
The difference sequence satisfies a transformed recurrence relation.
-/
def diff_seq (A : ℕ → ℤ) (q N : ℕ) (n : ℕ) : ℤ := A n - (q : ℤ) * (N + n)

theorem diff_seq_recurrence (A : ℕ → ℤ) (q N : ℕ) (hA : ∀ n, A (n + 1) = 2 * A n - (q : ℤ) * (Nat.totient (N + n + 1) : ℤ)) :
  ∀ n, diff_seq A q N (n + 1) = 2 * diff_seq A q N n + (q : ℤ) * ((N + n + 1 : ℤ) - 2 - (Nat.totient (N + n + 1) : ℤ)) := by
    -- Substitute the recurrence relation into the expression for D_{n+1}.
    intro n
    simp [diff_seq, hA]
    ring

/-
The gap sequence satisfies the recurrence G_{n+1} = 2G_n - (m - φ(m)).
-/
def gap_seq (A : ℕ → ℤ) (N : ℕ) (n : ℕ) : ℤ := (N + n + 2 : ℤ) - A n

theorem gap_seq_recurrence (A : ℕ → ℤ) (N : ℕ) (hA : ∀ n, A (n + 1) = 2 * A n - (Nat.totient (N + n + 1) : ℤ)) :
  ∀ n, gap_seq A N (n + 1) = 2 * gap_seq A N n - ((N + n + 1 : ℤ) - (Nat.totient (N + n + 1) : ℤ)) := by
    -- Substitute the recurrence relation for $A_{n+1}$ into the gap sequence definition.
    intro n
    simp [gap_seq, hA];
    ring

/-
The gap sequence is non-negative for all n.
-/
theorem gap_seq_nonneg (G : ℕ → ℤ) (N : ℕ) (hN : N ≥ 2)
  (h_rec : ∀ n, G (n + 1) = 2 * G n - ((N + n + 1 : ℤ) - Nat.totient (N + n + 1)))
  (h_lower : ∃ C : ℕ, ∀ n, G n ≥ - (n : ℤ) - C) :
  ∃ n₀, ∀ n ≥ n₀, G n ≥ 0 := by
    -- By contradiction, assume there exists some $k$ such that $G_k < 0$.
    by_contra h_contra
    obtain ⟨k, hk⟩ : ∃ k, G k < 0 := by
      exact not_forall_not.mp fun h => h_contra ⟨ 0, fun n hn => by linarith [ h n ] ⟩;
    -- By induction, we can show that $G_{k+m} \leq 2^m (G_k - 1) + 1$ for all $m \geq 0$.
    have h_ind : ∀ m ≥ 0, G (k + m) ≤ 2 ^ m * (G k - 1) + 1 := by
      intros m hm
      induction' m with m ih;
      · norm_num;
      · have h_ind_step : (Nat.totient (N + (k + m) + 1) : ℤ) ≤ (N + (k + m) + 1 : ℤ) - 1 := by
          exact le_tsub_of_add_le_right ( mod_cast Nat.succ_le_of_lt ( Nat.totient_lt _ ( by linarith ) ) );
        grind;
    -- Choose $m$ large enough such that $2^m > k + C + 1$.
    obtain ⟨m, hm⟩ : ∃ m, 2 ^ m > k + h_lower.choose + 1 := by
      exact pow_unbounded_of_one_lt _ one_lt_two;
    have := h_lower.choose_spec ( k + m );
    norm_num at *;
    nlinarith [ h_ind m, show ( 2 : ℤ ) ^ m > m by exact mod_cast Nat.recOn m ( by norm_num ) fun n ihn => by rw [ pow_succ' ] ; linarith [ ihn, Nat.one_le_pow n 2 zero_lt_two ] ]

/-
The generalized gap sequence satisfies the recurrence G_{n+1} = 2G_n - q(m - φ(m)).
-/
def gap_seq_general (A : ℕ → ℤ) (q N : ℕ) (n : ℕ) : ℤ := (q : ℤ) * (N + n + 2) - A n

theorem gap_seq_general_recurrence (A : ℕ → ℤ) (q N : ℕ) (hA : ∀ n, A (n + 1) = 2 * A n - (q : ℤ) * (Nat.totient (N + n + 1) : ℤ)) :
  ∀ n, gap_seq_general A q N (n + 1) = 2 * gap_seq_general A q N n - (q : ℤ) * ((N + n + 1 : ℤ) - (Nat.totient (N + n + 1) : ℤ)) := by
    -- By definition of gap_seq_general, we have:
    simp [gap_seq_general];
    intro n; rw [ hA ] ; ring;

/-
The epsilon sequence satisfies the recurrence ε_{n+1} = 2ε_n + n - 1 - φ(n+1).
-/
def epsilon_seq (A : ℕ → ℤ) (n : ℕ) : ℤ := A n - n

theorem epsilon_seq_recurrence (A : ℕ → ℤ) (hA : ∀ n, A (n + 1) = 2 * A n - (Nat.totient (n + 1) : ℤ)) :
  ∀ n, epsilon_seq A (n + 1) = 2 * epsilon_seq A n + ((n : ℤ) - 1 - (Nat.totient (n + 1) : ℤ)) := by
    exact fun n => by unfold epsilon_seq; push_cast [ hA ] ; ring;

/-
The shifted epsilon sequence satisfies the recurrence ε_{n+1} = 2ε_n + (N+n+1) - 2 - φ(N+n+1).
-/
def epsilon_seq_shifted (X : ℕ → ℤ) (N : ℕ) (n : ℕ) : ℤ := X n - (N + n)

theorem epsilon_seq_shifted_recurrence (X : ℕ → ℤ) (N : ℕ) (hX : ∀ n, X (n + 1) = 2 * X n - (Nat.totient (N + n + 1) : ℤ)) :
  ∀ n, epsilon_seq_shifted X N (n + 1) = 2 * epsilon_seq_shifted X N n + ((N + n + 1 : ℤ) - 2 - (Nat.totient (N + n + 1) : ℤ)) := by
    exact fun n => by unfold epsilon_seq_shifted; push_cast [ hX ] ; ring;

/-
Two sequences satisfying the same doubling recurrence and linear growth bounds must be identical.
-/
theorem recurrence_uniqueness (X Y : ℕ → ℝ) (f : ℕ → ℝ)
  (hX : ∀ n, X (n + 1) = 2 * X n - f n)
  (hY : ∀ n, Y (n + 1) = 2 * Y n - f n)
  (h_bound : ∃ C, ∀ n, |X n - Y n| < C * (n + 1)) :
  X = Y := by
    obtain ⟨ C, hC ⟩ := h_bound;
    -- By induction, we show that $|X_n - Y_n| = 2^n |X_0 - Y_0|$.
    have h_diff : ∀ n, |X n - Y n| = 2 ^ n * |X 0 - Y 0| := by
      intro n; induction n <;> simp_all +decide [ pow_succ', mul_assoc ] ;
      rw [ ← mul_sub, abs_mul, abs_two, ‹|X _ - Y _| = _› ];
    -- Since $\lim_{n \to \infty} \frac{C(n+1)}{2^n} = 0$, we must have $|X_0 - Y_0| = 0$.
    have h_lim : Filter.Tendsto (fun n : ℕ => (C * (n + 1)) / 2 ^ n) Filter.atTop (nhds 0) := by
      -- We can factor out $C$ and use the fact that $\frac{n+1}{2^n}$ tends to $0$ as $n$ tends to infinity.
      have h_lim : Filter.Tendsto (fun n : ℕ => (n + 1 : ℝ) / 2 ^ n) Filter.atTop (nhds 0) := by
        refine' squeeze_zero_norm' _ tendsto_inverse_atTop_nhds_zero_nat ; norm_num [ Nat.succ_div ];
        exact ⟨ 8, fun n hn => by rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_cast <;> induction hn <;> norm_num [ Nat.pow_succ ] at * ; nlinarith ⟩;
      simpa [ mul_div_assoc ] using h_lim.const_mul C;
    -- Since $|X_0 - Y_0| < C(n+1)/2^n$ for all $n$, and $\lim_{n \to \infty} C(n+1)/2^n = 0$, we must have $|X_0 - Y_0| = 0$.
    have h_zero : |X 0 - Y 0| = 0 := by
      exact le_antisymm ( le_of_tendsto_of_tendsto' tendsto_const_nhds h_lim fun n => by rw [ le_div_iff₀ ( by positivity ) ] ; nlinarith [ hC n, h_diff n, abs_nonneg ( X 0 - Y 0 ) ] ) ( abs_nonneg _ );
    exact funext fun n => by simpa [ sub_eq_iff_eq_add, h_zero ] using h_diff n;

/-
The gap sequence is given by the infinite sum of the K sequence terms divided by powers of 2.
-/
theorem gap_seq_formula (G : ℕ → ℤ) (K : ℕ → ℤ) (N : ℕ)
  (h_rec : ∀ n, G (n + 1) = 2 * G n - K n)
  (h_bound : ∀ n, |G n| ≤ N + n + 1)
  (h_K_bound : ∀ n, |K n| ≤ N + n + 1) :
  ∀ n, (G n : ℝ) = ∑' j : ℕ, (K (n + j) : ℝ) / 2 ^ (j + 1) := by
    -- Let $S_n = \sum_{j=0}^\infty \frac{K_{n+j}}{2^{j+1}}$.
    set S : ℕ → ℝ := fun n => ∑' j, (K (n + j) : ℝ) / 2 ^ (j + 1);
    -- We have $S_n = \frac{K_n}{2} + \frac{1}{2} S_{n+1}$.
    have h_S_rec : ∀ n, S n = (K n : ℝ) / 2 + S (n + 1) / 2 := by
      intro n
      simp [S];
      rw [ Summable.tsum_eq_zero_add ];
      · norm_num [ add_comm, add_left_comm, add_assoc, pow_succ, ← div_div, tsum_div_const ];
      · have h_summable : Summable (fun j : ℕ => (N + n + j + 1 : ℝ) / 2 ^ (j + 1)) := by
          refine' summable_of_ratio_norm_eventually_le _ _;
          exact 3 / 4;
          · norm_num;
          · norm_num [ pow_succ, div_eq_mul_inv ];
            exact ⟨ 2 * ( N + n + 1 ), fun m hm => by rw [ abs_of_nonneg ( by positivity ), abs_of_nonneg ( by positivity ) ] ; nlinarith [ inv_pos.mpr ( pow_pos ( zero_lt_two' ℝ ) m ), mul_inv_cancel₀ ( ne_of_gt ( pow_pos ( zero_lt_two' ℝ ) m ) ), pow_pos ( zero_lt_two' ℝ ) m, show ( m : ℝ ) ≥ 2 * ( N + n + 1 ) by exact_mod_cast hm ] ⟩;
        -- Since $|K(n + j)| \leq N + n + j + 1$, we have $|(K(n + j) : ℝ) / 2^(j + 1)| \leq (N + n + j + 1) / 2^(j + 1)$.
        have h_abs : ∀ j, |(K (n + j) : ℝ) / 2 ^ (j + 1)| ≤ (N + n + j + 1 : ℝ) / 2 ^ (j + 1) := by
          norm_num [ abs_div ];
          exact fun j => by gcongr ; exact_mod_cast h_K_bound _ |> le_trans <| by push_cast; linarith;
        -- Apply the comparison test with the summable series ∑' j, (N + n + j + 1 : ℝ) / 2 ^ (j + 1).
        have h_comparison : Summable (fun j : ℕ => |(K (n + j) : ℝ) / 2 ^ (j + 1)|) := by
          exact Summable.of_nonneg_of_le ( fun j => abs_nonneg _ ) h_abs h_summable;
        exact h_comparison.of_abs;
    -- Let $d_n = G_n - S_n$.
    set d : ℕ → ℝ := fun n => (G n : ℝ) - S n;
    -- We have $d_{n+1} = 2 d_n$.
    have h_d_rec : ∀ n, d (n + 1) = 2 * d n := by
      simp +zetaDelta at *;
      intro n; rw [ h_rec ] ; push_cast; linarith [ h_S_rec n ] ;
    -- We have $|d_n| \le C'' n$.
    have h_d_bound : ∃ C'' : ℝ, ∀ n, |d n| ≤ C'' * (n + 1) := by
      use ( N + 1 ) + ( ∑' j : ℕ, ( N + j + 1 : ℝ ) / 2 ^ ( j + 1 ) ) + 1;
      intro n
      have h_d_bound : |d n| ≤ (N + n + 1 : ℝ) + ∑' j : ℕ, (N + n + j + 1 : ℝ) / 2 ^ (j + 1) := by
        refine' le_trans ( abs_sub _ _ ) ( add_le_add _ _ );
        · exact_mod_cast h_bound n;
        · refine' le_trans ( le_of_eq <| by rw [ ← Real.norm_eq_abs ] ) ( le_trans ( norm_tsum_le_tsum_norm _ ) _ );
          · norm_num [ abs_div ];
            refine' Summable.of_nonneg_of_le ( fun i => div_nonneg ( abs_nonneg _ ) ( pow_nonneg ( by norm_num ) _ ) ) ( fun i => div_le_div_of_nonneg_right ( show |( K ( n + i ) : ℝ )| ≤ ( N + ( n + i ) + 1 : ℝ ) by exact_mod_cast h_K_bound _ ) ( pow_nonneg ( by norm_num ) _ ) ) _;
            ring_nf;
            refine' Summable.add ( Summable.add ( Summable.add _ _ ) _ ) _;
            · exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) );
            · exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) );
            · refine' summable_of_ratio_norm_eventually_le _ _;
              exact 3 / 4;
              · norm_num;
              · norm_num +zetaDelta at *;
                exact ⟨ 2, fun n hn => by rw [ abs_of_nonneg ( by positivity ) ] ; norm_num [ pow_succ' ] ; nlinarith [ ( by norm_cast : ( 2 : ℝ ) ≤ n ), pow_pos ( by norm_num : ( 0 : ℝ ) < 1 / 2 ) n ] ⟩;
            · exact Summable.mul_right _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) );
          · refine' Summable.tsum_le_tsum _ _ _;
            · norm_num +zetaDelta at *;
              exact fun i => by gcongr ; exact_mod_cast h_K_bound _ |> le_trans <| by norm_cast ; linarith;
            · norm_num [ abs_div ];
              refine' Summable.of_nonneg_of_le ( fun i => div_nonneg ( abs_nonneg _ ) ( pow_nonneg ( by norm_num ) _ ) ) ( fun i => div_le_div_of_nonneg_right ( show |( K ( n + i ) : ℝ )| ≤ ( N + ( n + i ) + 1 : ℝ ) by exact_mod_cast h_K_bound _ ) ( pow_nonneg ( by norm_num ) _ ) ) _;
              ring_nf;
              refine' Summable.add ( Summable.add ( Summable.add _ _ ) _ ) _;
              · exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) );
              · exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) );
              · refine' summable_of_ratio_norm_eventually_le _ _;
                exact 3 / 4;
                · norm_num;
                · norm_num +zetaDelta at *;
                  exact ⟨ 2, fun n hn => by rw [ abs_of_nonneg ( by positivity ) ] ; ring_nf; norm_num; nlinarith [ ( by norm_cast : ( 2 : ℝ ) ≤ n ), pow_pos ( by norm_num : ( 0 : ℝ ) < 1 / 2 ) n ] ⟩;
              · exact Summable.mul_right _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) );
            · refine' summable_of_ratio_norm_eventually_le _ _;
              exact 3 / 4;
              · norm_num;
              · norm_num [ pow_succ, div_eq_mul_inv ];
                exact ⟨ 2, fun m hm => by rw [ abs_of_nonneg ( by positivity ), abs_of_nonneg ( by positivity ) ] ; nlinarith [ inv_pos.mpr ( pow_pos ( zero_lt_two' ℝ ) m ), pow_pos ( zero_lt_two' ℝ ) m, mul_inv_cancel₀ ( ne_of_gt ( pow_pos ( zero_lt_two' ℝ ) m ) ), show ( m : ℝ ) ≥ 2 by norm_cast ] ⟩;
      refine le_trans h_d_bound ?_;
      rw [ show ( ∑' j : ℕ, ( ( N : ℝ ) + n + j + 1 ) / 2 ^ ( j + 1 ) ) = ( ∑' j : ℕ, ( ( N : ℝ ) + j + 1 ) / 2 ^ ( j + 1 ) ) + ( ∑' j : ℕ, ( n : ℝ ) / 2 ^ ( j + 1 ) ) by
            rw [ ← Summable.tsum_add ] ; congr ; ext j ; ring;
            · refine' summable_of_ratio_norm_eventually_le _ _;
              exact 3 / 4;
              · norm_num;
              · norm_num [ pow_succ, ← div_div ];
                exact ⟨ 2 * N + 2, fun n hn => by rw [ abs_of_nonneg ( by positivity ), abs_of_nonneg ( by positivity ) ] ; nlinarith [ show ( n : ℝ ) ≥ 2 * N + 2 by exact_mod_cast hn, pow_pos ( zero_lt_two' ℝ ) n, div_mul_cancel₀ ( ( N : ℝ ) + ( n + 1 ) + 1 ) ( show ( 2 : ℝ ) ^ n ≠ 0 by positivity ), div_mul_cancel₀ ( ( N : ℝ ) + n + 1 ) ( show ( 2 : ℝ ) ^ n ≠ 0 by positivity ) ] ⟩;
            · ring_nf;
              exact Summable.mul_right _ ( Summable.mul_left _ ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) ) ] ; ring_nf ; norm_num [ tsum_mul_left, tsum_geometric_two ] ; ring_nf ; norm_num [ tsum_mul_left, tsum_geometric_two ] ;
      norm_num [ tsum_mul_left, tsum_mul_right ] ; ring_nf ; norm_num [ tsum_geometric_two ] ; nlinarith [ show ( 0 : ℝ ) ≤ ∑' j : ℕ, ( ( N : ℝ ) * ( 1 / 2 ) ^ j * ( 1 / 2 ) + ( j : ℝ ) * ( 1 / 2 ) ^ j * ( 1 / 2 ) + ( 1 / 2 ) ^ j * ( 1 / 2 ) ) from tsum_nonneg fun _ => by positivity ] ;
    -- The only way $|d_0| 2^n \le C'' n$ for all $n$ is if $d_0 = 0$.
    obtain ⟨C'', hC''⟩ : ∃ C'' : ℝ, ∀ n, |d n| ≤ C'' * (n + 1) := h_d_bound
    have h_d_zero : d 0 = 0 := by
      contrapose! hC'';
      -- Since $|d_0| > 0$, we can choose $n$ such that $2^n > \frac{C'' (n + 1)}{|d_0|}$.
      obtain ⟨n, hn⟩ : ∃ n : ℕ, 2 ^ n > C'' * (n + 1) / |d 0| := by
        have h_exp_growth : Filter.Tendsto (fun n : ℕ => (C'' * (n + 1) / |d 0|) / 2 ^ n) Filter.atTop (nhds 0) := by
          -- We can factor out $C'' / |d 0|$ and use the fact that $n / 2^n$ tends to $0$ as $n$ tends to infinity.
          have h_factor : Filter.Tendsto (fun n : ℕ => (n + 1 : ℝ) / 2 ^ n) Filter.atTop (nhds 0) := by
            refine' squeeze_zero_norm' _ tendsto_inverse_atTop_nhds_zero_nat;
            norm_num;
            exact ⟨ 8, fun n hn => by rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_cast <;> induction hn <;> norm_num [ Nat.pow_succ ] at * ; nlinarith ⟩;
          convert h_factor.const_mul ( C'' / |d 0| ) using 2 <;> ring;
        have := h_exp_growth.eventually ( gt_mem_nhds zero_lt_one ) ; obtain ⟨ n, hn ⟩ := this.exists; exact ⟨ n, by rw [ div_lt_iff₀ ( by positivity ) ] at hn; linarith ⟩ ;
      use n;
      rw [ gt_iff_lt, div_lt_iff₀ ] at hn <;> norm_num at *;
      · exact hn.trans_le ( by rw [ show d n = 2 ^ n * d 0 by exact Nat.recOn n ( by norm_num ) fun n ihn => by rw [ pow_succ', mul_assoc, h_d_rec, ihn ] ] ; norm_num [ abs_mul ] );
      · exact hC'';
    intro n; exact sub_eq_zero.mp ( show d n = 0 from Nat.recOn n h_d_zero fun n ih => by rw [ h_d_rec, ih ] ; ring ) ;

/-
The K sequence is unbounded and takes the value 1 infinitely often.
-/
def K_seq (N : ℕ) (n : ℕ) : ℤ := (N + n + 1 : ℤ) - Nat.totient (N + n + 1)

theorem K_seq_properties (N : ℕ) :
  (∀ M, ∃ n, K_seq N n > M) ∧ (∀ n₀, ∃ n ≥ n₀, K_seq N n = 1) := by
    constructor;
    · intro M;
      -- By `totient_diff_unbounded`, for any $M$, there exists $m$ such that $m - \phi(m) > M$.
      obtain ⟨m, hm⟩ : ∃ m : ℕ, m - Nat.totient m > M.toNat ∧ m > N := by
        have := @totient_diff_unbounded ( Max.max ( M.toNat + 1 ) ( N + 1 ) );
        grind;
      use m - N - 1;
      unfold K_seq;
      grind;
    · intro n₀
      obtain ⟨p, hp_prime, hp_gt⟩ : ∃ p : ℕ, Nat.Prime p ∧ p > N + n₀ + 1 ∧ p % 4 = 3 := by
        exact Exists.imp ( by tauto ) ( exists_prime_mod_4_3 ( N + n₀ + 1 ) )
      generalize_proofs at *; (
      refine' ⟨ p - N - 1, _, _ ⟩ <;> norm_num [ K_seq ];
      · omega;
      · rw [ Nat.totient_prime ] <;> norm_num [ hp_prime ];
        convert hp_prime using 1 ; omega)

/-
If a natural number is divisible by 2 but not by 4, its 2-adic valuation is 1.
-/
theorem padicValNat_two_of_even_not_div_four (n : ℕ) (h2 : 2 ∣ n) (h4 : ¬ 4 ∣ n) : padicValNat 2 n = 1 := by
  -- Since 2 divides n but 4 does not, we can write n as 2k where k is odd.
  obtain ⟨k, rfl⟩ : ∃ k, n = 2 * k := h2
  have hk_odd : Odd k := by
    grind;
  rw [ padicValNat.mul ] <;> simp_all +decide;
  · exact Or.inr ( Nat.odd_iff.mp hk_odd );
  · grind

/-
If p is a prime congruent to 3 mod 4 and tail_sum(p-1) is even, then tail_sum(p) has 2-adic valuation 1.
-/
theorem v2_tail_sum_eq_one_of_even_pred (p : ℕ) (hp : Nat.Prime p) (h_mod : p % 4 = 3)
  (h_even : ∃ k : ℤ, tail_sum (p - 1) = 2 * k) :
  ∃ z : ℤ, tail_sum p = z ∧ padicValNat 2 z.toNat = 1 := by
    obtain ⟨ k, hk ⟩ := h_even;
    obtain ⟨ z, hz ⟩ : ∃ z : ℤ, tail_sum p = z ∧ 2 ∣ z ∧ ¬4 ∣ z := by
      have := tail_sum_recurrence ( p - 1 ) ; rcases p with ( _ | _ | p ) <;> simp_all +decide [ Nat.totient_prime ];
      refine' ⟨ 2 * ( 2 * k ) - ( p + 1 ), _, _, _ ⟩ <;> norm_num [ ← even_iff_two_dvd, parity_simps ];
      · exact Nat.odd_iff.mpr ( by omega );
      · rw [ Int.dvd_iff_emod_eq_zero ] ; omega;
    cases' hz.2.1 with w hw ; simp_all +decide [ Int.toNat ];
    rcases w with ( _ | _ | w ) <;> norm_num at *;
    · rcases Nat.even_or_odd' ‹_› with ⟨ b, rfl | rfl ⟩ <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] at *;
      · exact False.elim <| hz.2 ⟨ b, by ring ⟩;
      · use 2 * (2 * b + 1);
        norm_cast ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.dvd_iff_mod_eq_zero ];
        rw [ padicValNat.mul ] <;> norm_num;
    · linarith [ show 0 < tail_sum p from lt_of_le_of_lt ( by norm_num ) ( tail_sum_bounds p |>.1 ) ];
    · linarith [ show ( 0 : ℝ ) ≤ tail_sum p from tsum_nonneg fun _ => div_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg ( by norm_num ) _ ) ]

/-
If a sequence satisfies u_{n+1} >= 2 u_n and u_0 > 0, then u_n >= 2^n u_0.
-/
lemma seq_exp_growth (u : ℕ → ℝ) (h : ∀ n, u (n + 1) ≥ 2 * u n) (h0 : u 0 > 0) :
  ∀ n, u n ≥ 2 ^ n * u 0 := by
    exact fun n => Nat.recOn n ( by norm_num ) fun n ih => by rw [ pow_succ', mul_assoc ] ; linarith [ h n ] ;

/-
If a sequence grows at least exponentially (doubling) but is bounded by a linear function, it must be non-positive everywhere.
-/
lemma exp_growth_bounded_by_linear (u : ℕ → ℝ) (A B : ℝ)
  (h_rec : ∀ n, u (n + 1) ≥ 2 * u n)
  (h_bound : ∀ n, u n ≤ A * n + B) :
  ∀ n, u n ≤ 0 := by
    -- Let's choose any $n$ and derive a contradiction from the assumption that $u_n > 0$.
    by_contra h_pos
    obtain ⟨n₀, hn₀⟩ : ∃ n₀, u n₀ > 0 := by
      aesop
      skip
    generalize_proofs at *; (
    -- By induction, we can show that $u_{n₀ + k} \geq 2^k u_{n₀}$ for all $k$.
    have h_ind : ∀ k, u (n₀ + k) ≥ 2^k * u n₀ := by
      exact fun k => Nat.recOn k ( by norm_num ) fun k ih => by rw [ Nat.add_succ, pow_succ', mul_assoc ] ; linarith [ h_rec ( n₀ + k ) ] ;
    generalize_proofs at *; (
    -- Taking the limit as $k \to \infty$, we get $u n₀ \leq 0$.
    have h_lim : Filter.Tendsto (fun k : ℕ => (A * (n₀ + k) + B) / 2^k) Filter.atTop (nhds 0) := by
      -- We can factor out $2^{-k}$ and use the fact that $\lim_{k \to \infty} k / 2^k = 0$.
      have h_lim : Filter.Tendsto (fun k : ℕ => (k : ℝ) / 2^k) Filter.atTop (nhds 0) := by
        refine' squeeze_zero_norm' _ tendsto_inverse_atTop_nhds_zero_nat ; norm_num;
        exact ⟨ 8, fun n hn => by rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_cast <;> induction hn <;> norm_num [ Nat.pow_succ ] at * ; nlinarith ⟩
      generalize_proofs at *; (
      ring_nf at h_lim ⊢
      generalize_proofs at *; (
      simpa [ mul_assoc, mul_comm, mul_left_comm ] using Filter.Tendsto.add ( Filter.Tendsto.add ( tendsto_inv_atTop_zero.comp ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two ) |> Filter.Tendsto.mul_const ( A * n₀ ) ) ( h_lim.const_mul A ) ) ( tendsto_inv_atTop_zero.comp ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two ) |> Filter.Tendsto.mul_const B ) |> fun h => h.trans ( by norm_num ) ;))
    generalize_proofs at *; (
    exact absurd ( le_of_tendsto_of_tendsto' tendsto_const_nhds h_lim fun k => show ( A * ( n₀ + k ) + B ) / 2 ^ k ≥ u n₀ from by have := h_bound ( n₀ + k ) ; have := h_ind k; rw [ ge_iff_le ] at *; rw [ le_div_iff₀ ( by positivity ) ] at *; norm_num at * ; linarith ) ( by linarith ) ;)))