/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 01865c2a-95fd-4810-b4f6-5a7dff78ca32

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the Feit-Thompson conjecture for p=3 in the case q ≡ 2 (mod 9).
We defined the modulus A(q) = q^2 + q + 1 and the check function.
We proved that the conjecture holds for all primes q < 100,000 (by native_decide).
We also derived several structural consequences under the assumption that 3^q ≡ 1 (mod A):
1. The order of 3 modulo A is q.
2. The cubic character χ₃(1-q) is q.
3. 3 divides the order of (1-q) modulo A.
4. The integer k = (3^q - 1)/A satisfies k ≡ 2 (mod 6q).
5. Any odd prime factor of k is congruent to 1 modulo q.
6. k satisfies a congruence modulo q^2 involving the Fermat quotient of 3.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The modulus A(q) = q^2 + q + 1.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

/-
The conjecture 3^q ≢ 1 (mod q^2+q+1) holds for all primes q < 100,000 with q ≡ 2 (mod 9).
-/
def check_conjecture (q : ℕ) : Bool :=
  if q.Prime ∧ q % 9 == 2 then
    (3 ^ q) % (A q) != 1
  else
    true

theorem ft_p3_mod9_2_bounded_100k : ∀ q < 100000, check_conjecture q = true := by
  intro q hq;
  -- We'll use the fact that if the condition holds for all primes q less than 100000, then it holds for q itself.
  have h_check : ∀ q ∈ Finset.filter Nat.Prime (Finset.range 100000), (q % 9 = 2 → ¬(3 ^ q % (q^2 + q + 1) = 1)) := by
    native_decide +revert;
  unfold check_conjecture;
  unfold A; split_ifs <;> simp_all +contextual ;

/-
If 3^q ≡ 1 (mod A) and q is prime, then the order of 3 modulo A is q.
-/
theorem ord_3_eq_q (q : ℕ) (hq_prime : q.Prime) (hq_mod : q % 9 = 2) (h_contra : 3 ^ q % (A q) = 1) : orderOf (3 : ZMod (A q)) = q := by
  -- Since 3^q 1 (mod A), the order of  �3� divides q. Since q is prime, the order is either 1 or q.
  have h_order_div : orderOf (3 : ZMod (A q)) ∣ q := by
    -- Since 3^q 1 (mod A(q)), we have that the order of 3 modulo A(q) divides q.
    have h_order : 3 ^ q ≡ 1 [ZMOD A q] := by
      exact Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using ⟨ 3 ^ q / A q, by linarith [ Nat.mod_add_div ( 3 ^ q ) ( A q ) ] ⟩ ;
    exact orderOf_dvd_iff_pow_eq_one.mpr ( by erw [ ← ZMod.intCast_eq_intCast_iff ] at *; aesop );
  rw [ Nat.dvd_prime hq_prime ] at h_order_div;
  rcases h_order_div with h | h <;> simp_all +decide [ orderOf_eq_one_iff ];
  rcases q with ( _ | _ | _ | _ | _ | q ) <;> cases h ; trivial

/-
Algebraic identities modulo A(q): q^3 = 1, (1-q)^2 = -3q, and 3 = -q^2(1-q)^2.
-/
theorem algebraic_identities (q : ℕ) :
    let q_z : ZMod (A q) := q
    q_z ^ 3 = 1 ∧ (1 - q_z) ^ 2 = -3 * q_z ∧ 3 = - (q_z ^ 2) * (1 - q_z) ^ 2 := by
  -- Since $q^2 + q + 1 \equiv 0 \pmod{A(q)}$, we have $q^2 \equiv -q - 1 \pmod{A(q)}$.
  have hq2 : (q^2 : ZMod (A q)) = -q - 1 := by
    -- By definition of $A(q)$, we know that $q^2 + q + 1 \equiv 0 \pmod{A(q)}$.
    have h_cong : (q : ZMod (A q)) ^ 2 + (q : ZMod (A q)) + 1 = 0 := by
      norm_cast;
      erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
    linear_combination' h_cong;
  grind

/-
The cubic character χ₃(x) = x^((A-1)/3) modulo A.
-/
def cubic_char (q : ℕ) (x : ZMod (A q)) : ZMod (A q) :=
  x ^ ((A q - 1) / 3)

/-
For q ≡ 2 (mod 9), the cubic character of q is q^2.
-/
theorem cubic_char_q (q : ℕ) (hq_mod : q % 9 = 2) :
    cubic_char q q = q ^ 2 := by
  -- Since $q^3 1 [ZMOD (A q)]$, we have $(q^2) ∈ \{1, q, q^2\}$.
  have h_q3_equiv_1 : (q ^ 3 : ZMod (A q)) = 1 := by
    -- Apply the algebraic identity $q^ �3� = 1$ modulo $A(q)$.
    have := algebraic_identities q;
    aesop;
  -- Since $q \equiv 2 \pmod{9}$, we have $(A-1)/3 \equiv 2 \pmod{3}$.
  have h_exp_mod : ((A q - 1) / 3) % 3 = 2 := by
    unfold A; rw [ ← Nat.mod_add_div q 9, hq_mod ] ; ring_nf ;
    omega;
  unfold cubic_char; rw [ ← Nat.mod_add_div ( ( A q - 1 ) / 3 ) 3, h_exp_mod ] ; simp_all +decide [ pow_add, pow_mul ] ;

/-
If 3^q ≡ 1 (mod A), then the cubic character of 3 is 1.
-/
theorem cubic_char_three_eq_one (q : ℕ) (hq_mod : q % 9 = 2) (h_contra : 3 ^ q % (A q) = 1) :
    cubic_char q 3 = 1 := by
  -- Since $q \equiv 2 \pmod{9}$, we have $q(q+1)/3 = q*k$, where $k$ is an integer $k$.
  set k := (q + 1) / 3 with hk_def;
  -- Then 3^((A-1)/3) = 3^(q*k) = (3^q)^k.
  have h_expansion : cubic_char q 3 = (3 ^ q) ^ k := by
    unfold cubic_char; ring;
    rw [ show A q = q ^ 2 + q + 1 from rfl ] ; rw [ show ( q ^ 2 + q + 1 - 1 ) / 3 = q * k from Nat.div_eq_of_eq_mul_left zero_lt_three <| by nlinarith [ Nat.div_mul_cancel ( show 3 ∣ q + 1 from Nat.dvd_of_mod_eq_zero <| by omega ), Nat.sub_add_cancel ( show 1 ≤ q ^ 2 + q + 1 from Nat.succ_pos _ ) ] ] ;
  -- Since $3^q \equiv 1 \pmod{A}$, we have $(3^q)^k \equiv 1^k \equiv 1 \pmod{A}$.
  have h_mod : (3 ^ q) ^ k ≡ 1 ^ k [MOD A q] := by
    exact Nat.ModEq.pow _ <| Nat.ModEq.symm <| Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using ⟨ 3 ^ q / A q, by linarith [ Nat.mod_add_div ( 3^q ) ( A q ) ] ⟩ ;
  simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

/-
The cubic character of -1 is 1 for primes q > 3.
-/
theorem cubic_char_neg_one (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) :
    cubic_char q (-1) = 1 := by
  -- The exponent is $(A-1)/3 = q(q+1)/3$.
  have h_exp : (A q - 1) / 3 = q * (q + 1) / 3 := by
    exact congrArg ( · / 3 ) ( Nat.sub_eq_of_eq_add <| by unfold A; ring );
  -- Since q is a prime > 3, q is odd, so q(q+1) is even.
  have h_even : Even (q * (q + 1) / 3) := by
    rw [ Nat.even_div ];
    rw [ ← Nat.mod_add_div q 6 ] ; have := Nat.mod_lt q ( by decide : 6 > 0 ) ; interval_cases _ : q % 6 <;> norm_num [ Nat.add_mod, Nat.mul_mod ] ;
  unfold cubic_char; aesop;

/-
The cubic character is multiplicative.
-/
theorem cubic_char_mul (q : ℕ) (x y : ZMod (A q)) :
    cubic_char q (x * y) = cubic_char q x * cubic_char q y := by
  convert mul_pow _ _ _

/-
Under the assumptions, the cubic character of (1-q) is q.
-/
theorem cubic_char_one_sub_q (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 9 = 2)
    (hA_prime : (A q).Prime) (h_contra : 3 ^ q % (A q) = 1) :
    cubic_char q (1 - q) = q := by
  -- Apply cubic character properties:(3) =(-1) *(q^2) *((1-q)^2).
  have h_cubic_char : cubic_char q 3 = cubic_char q (-1) * (cubic_char q q) ^ 2 * (cubic_char q (1 - q)) ^ 2 := by
    have h_cubic_char : cubic_char q 3 = cubic_char q (-1) * cubic_char q (q ^ 2) * cubic_char q ((1 - q) ^ 2) := by
      have h_cubic_char : cubic_char q 3 = cubic_char q (-1 * q ^ 2 * (1 - q) ^ 2) := by
        exact congr_arg _ ( by haveI := Fact.mk hA_prime; exact by { have := algebraic_identities q; norm_num at *; linear_combination this.2.2 } );
      rw [ h_cubic_char, ← cubic_char_mul, ← cubic_char_mul ];
    convert h_cubic_char using 2 ; ring;
    · unfold cubic_char; ring;
    · unfold cubic_char; ring;
      rw [ pow_mul' ] ; ring;
  have h_cubic_char_simp : cubic_char q (-1) = 1 := by
    exact?
  have h_cubic_char_q : cubic_char q q = q ^ 2 := by
    exact?
  have h_cubic_char_1_q : cubic_char q (1 - q) ^ 2 = q ^ 2 := by
    have h_cubic_char_1_q : cubic_char q 3 = 1 := by
      exact?;
    have h_cubic_char_1_q : (q : ZMod (A q)) ^ 3 = 1 := by
      convert algebraic_identities q |>.1 using 1;
    grind;
  have h_cubic_char_1_q_final : cubic_char q (1 - q) ^ 3 = 1 := by
    have h_cubic_char_1_q_final : ∀ x : ZMod (A q), x ≠ 0 → x ^ (A q - 1) = 1 := by
      haveI := Fact.mk hA_prime; exact fun x hx => ZMod.pow_card_sub_one_eq_one hx;
    convert h_cubic_char_1_q_final ( 1 - q ) _ using 1;
    · unfold cubic_char; ring;
      rw [ Nat.div_mul_cancel ];
      exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div ( A q ) 3 ] ; unfold A; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; rw [ ← Nat.mod_add_div q 9, hq_mod ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] );
    · intro h; simp_all +decide [ sub_eq_iff_eq_add ] ;
      rw [ eq_comm ] at h;
      erw [ ZMod.natCast_eq_natCast_iff ] at h;
      rw [ Nat.ModEq, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt ] at h <;> nlinarith [ show A q > q by exact Nat.lt_succ_of_le ( Nat.le_add_left _ _ ) ];
  have h_cubic_char_1_q_final : (q : ZMod (A q)) ^ 3 = 1 := by
    convert algebraic_identities q |>.1 using 1;
  grind

/-
3 divides the order of (1-q) modulo A(q).
-/
theorem three_dvd_order_one_sub_q (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 9 = 2)
    (hA_prime : (A q).Prime) (h_contra : 3 ^ q % (A q) = 1) :
    3 ∣ orderOf ((1 - q) : ZMod (A q)) := by
  by_contra h_contra;
  -- Since $3$ does not divide the order of $(1-q)$ modulo $A(q)$, we have $(1-q)^{(A-1)/3} \equiv 1 \pmod{A(q)}$.
  have h_order_one : (1 - q : ZMod (A q)) ^ ((A q - 1) / 3) = 1 := by
    rw [ ← orderOf_dvd_iff_pow_eq_one ];
    refine' Nat.Coprime.dvd_of_dvd_mul_left _ _;
    exact 3;
    · exact Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr h_contra );
    · rw [ Nat.mul_div_cancel' ];
      · rw [ orderOf_dvd_iff_pow_eq_one ];
        haveI := Fact.mk hA_prime; exact ZMod.pow_card_sub_one_eq_one ( by erw [ Ne.eq_def, sub_eq_zero ] ; norm_cast; aesop ) ;
      · exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div ( A q ) 3 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, show A q = q ^ 2 + q + 1 from rfl ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, show q % 3 = 2 from by omega ] );
  have h_cubic_char_one : cubic_char q (1 - q) = 1 := by
    exact h_order_one;
  have h_cubic_char_q : cubic_char q (1 - q) = q := by
    apply_rules [ cubic_char_one_sub_q ];
  have h_contra : (q : ZMod (A q)) = 1 := by
    exact h_cubic_char_q.symm.trans h_cubic_char_one;
  haveI := Fact.mk hA_prime; erw [ ZMod.natCast_eq_natCast_iff ] at h_contra; simp_all +decide [ Nat.modEq_iff_dvd ] ;

/-
If 3^q ≡ 1 (mod A) and q ≡ 2 (mod 9), then k = (3^q - 1)/A satisfies k ≡ 2 (mod 3).
-/
def k_val (q : ℕ) : ℕ := (3 ^ q - 1) / A q

theorem k_mod_three (q : ℕ) (hq_mod : q % 9 = 2) (h_contra : 3 ^ q % (A q) = 1) :
    k_val q % 3 = 2 := by
  unfold k_val;
  -- Substitute $3^q = 1 + k \cdot A(q)$ into the expression for $k$.
  have h_sub : 3 ^ q = 1 + ((3 ^ q - 1) / A q) * A q := by
    rw [ Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div ( 3^q ) ( A q ), h_contra ] ; norm_num ) ), add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
  replace h_sub := congr_arg ( · % 3 ) h_sub; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq_mod ] at h_sub; rcases q with ( _ | _ | _ | q ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod, hq_mod ] at *;
  · trivial;
  · norm_num [ Nat.pow_succ', Nat.mul_mod, Nat.add_mod, A ] at *;
    have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> norm_num at *;
    · omega;
    · omega

/-
If 3^q ≡ 1 (mod A) and q > 3 is prime, then k = (3^q - 1)/A satisfies k ≡ 2 (mod q).
-/
theorem k_mod_q (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (h_contra : 3 ^ q % (A q) = 1) :
    k_val q % q = 2 := by
  have hk_mod_q : 3 ^ q ≡ 1 + k_val q * A q [MOD q] := by
    rw [ Nat.ModEq, Nat.add_comm ];
    rw [ ← h_contra, ← Nat.div_add_mod ( 3^q ) ( A q ), mul_comm ];
    norm_num [ k_val ];
    rw [ show ( 3 ^ q - 1 ) / A q = 3 ^ q / A q from Nat.div_eq_of_eq_mul_left ( Nat.succ_pos _ ) <| by linarith [ Nat.mod_add_div ( 3 ^ q ) ( A q ), Nat.sub_add_cancel <| Nat.one_le_pow q 3 zero_lt_three ] ];
  haveI := Fact.mk hq_prime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
  norm_num [ show A q = q^2 + q + 1 from rfl ] at *;
  rw [ ← ZMod.val_natCast ] ; norm_num [ show ( k_val q : ZMod q ) = 2 by linear_combination' hk_mod_q.symm ] ;
  rcases q with ( _ | _ | _ | q ) <;> trivial

/-
If 3^q ≡ 1 (mod A), then k ≡ q(3Q - 2) + 2 (mod q^2), where Q is the Fermat quotient of 3.
-/
def fermat_quotient_3 (q : ℕ) : ℕ := (3 ^ (q - 1) - 1) / q

theorem k_mod_q_sq (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (h_contra : 3 ^ q % (A q) = 1) :
    k_val q % q^2 = (q * (3 * fermat_quotient_3 q - 2) + 2) % q^2 := by
  -- We have 3^q = 1 + k * A.
  have h_eq : 3 ^ q = 1 + k_val q * (A q) := by
    rw [ ← Nat.mod_add_div ( 3 ^ q ) ( A q ), h_contra ];
    rw [ mul_comm, show k_val q = 3 ^ q / A q from by rw [ show k_val q = ( 3 ^ q - 1 ) / A q from rfl ] ; exact Nat.div_eq_of_eq_mul_left ( Nat.succ_pos _ ) <| Nat.sub_eq_of_eq_add <| by linarith [ Nat.mod_add_div ( 3^q ) ( A q ) ] ];
  -- We have $3^q = 3 * 3^{q-1} � =� 3 * (1 + q * Q) = 3 + 3qQ$, so � $�3 + q(m + 2) 3 + 3qQ (mod q^2)$.
  have h_mod : 3 + q * (k_val q / q + 2) ≡ 3 + 3 * q * fermat_quotient_3 q [MOD q^2] := by
    -- We'll use that $3^{ �q�-1} = 1 + q * Q$ by definition of $Q$.
    have h3_q_minus_1 : 3 ^ (q - 1) ≡ 1 + q * fermat_quotient_3 q [MOD q^2] := by
      unfold fermat_quotient_3;
      rw [ Nat.mul_div_cancel' ];
      · rw [ add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
      · have := Nat.totient_prime hq_prime; erw [ ← this ] ; erw [ ← Nat.modEq_zero_iff_dvd ] ; simpa [ Nat.modEq_iff_dvd ] using Nat.ModEq.pow_totient <| Nat.coprime_comm.mp <| hq_prime.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( by positivity ) <| by linarith;
    -- We'll use that $3^q = 3 * 3^{q-1} = 3 * (1 + q * Q) = 3 + 3qQ$, � so� $3 + q(m + 2) 3 + 3qQ (mod q^2)$.
    have h_mod : 3 ^ q ≡ 3 + 3 * q * fermat_quotient_3 q [MOD q^2] := by
      convert h3_q_minus_1.mul_left 3 using 1 ; cases q <;> norm_num [ pow_succ' ] at * ; ring;
    -- We'll use that $k_val q = q * (k_val q / q) + 2$.
    have h_k_val : k_val q = q * (k_val q / q) + 2 := by
      have h_k_val : k_val q % q = 2 := by
        apply k_mod_q q hq_prime hq_gt_3 h_contra;
      rw [ ← h_k_val, Nat.div_add_mod ];
    rw [ h_k_val ] at h_eq;
    rw [ h_eq ] at h_mod;
    unfold A at h_mod; ring_nf at h_mod ⊢; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] at *;
    norm_num [ show q ^ 3 = q ^ 2 * q by ring, Nat.mul_mod_mul_left ] at * ; tauto;
  -- From the equivalence $3 + q(m + 2) 3 + 3qQ (mod q^2)$, we get $q(m + 2) 3qQ (mod q^2)$.
  have h_mod_simplified : q * (k_val q / q + 2) ≡ 3 * q * fermat_quotient_3 q [MOD q^2] := by
    simpa [ Nat.modEq_iff_dvd ] using h_mod;
  -- Dividing both sides of the congruence $q * (k_val q / q + 2) 3 * q * fermat_quotient_3 q [MOD q^2]$ by $q$, we get $ �k�_val q / q + 2 3 * fermat_quotient_3 q [MOD q]$.
  have h_div : k_val q / q + 2 ≡ 3 * fermat_quotient_3 q [MOD q] := by
    rw [ Nat.modEq_iff_dvd ] at *;
    exact h_mod_simplified.imp fun x hx => by push_cast at *; nlinarith;
  -- From the equivalence $k_val q / q + 2 3 * fermat_quotient �_�3 q [MOD q]$, we get $k_val q / q 3 * fermat_quotient_3 q - 2 [MOD q]$.
  have h_div_simplified : k_val q / q ≡ 3 * fermat_quotient_3 q - 2 [MOD q] := by
    cases le_total ( 3 * fermat_quotient_3 q ) 2 <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
    · interval_cases _ : 3 * fermat_quotient_3 q <;> simp_all +decide [ ZMod ];
      · haveI := Fact.mk hq_prime; simp_all +decide [ ← ZMod.val_natCast, fermat_quotient_3 ] ;
        rcases q with ( _ | _ | _ | q ) <;> simp_all +decide [ pow_succ' ];
        exact absurd ‹_› ( by rw [ tsub_lt_iff_left ] <;> linarith [ Nat.pow_le_pow_right ( show 1 ≤ 3 by decide ) hq_gt_3, show 3 ^ q > q by exact Nat.recOn q ( by norm_num ) fun n ihn => by rw [ pow_succ' ] ; linarith [ Nat.pow_le_pow_right ( show 1 ≤ 3 by decide ) n.zero_le ] ] );
      · grind;
    · exact eq_sub_of_add_eq h_div;
  rw [ ← Nat.mod_add_div ( k_val q ) q ];
  -- From the equivalence $k_val q % q = 2$, we get $k_val q = q * (k_val q / q) + 2$.
  have h_k_val : k_val q % q = 2 := by
    exact?;
  rw [ h_k_val, add_comm ];
  rw [ ← Nat.mod_add_div ( k_val q / q ) q, ← Nat.mod_add_div ( 3 * fermat_quotient_3 q - 2 ) q, h_div_simplified ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ;

/-
If 3^q ≡ 1 (mod A), then k ≡ 2 (mod 6q).
-/
theorem k_mod_six_q (q : ℕ) (hq_prime : q.Prime) (hq_gt_3 : q > 3) (hq_mod : q % 9 = 2) (h_contra : 3 ^ q % (A q) = 1) :
    k_val q % (6 * q) = 2 := by
  -- From Theorem � �1, we know that k 2 � (�mod 3) and k 2 (mod q).
  have h_k_mod_3 : k_val q % 3 = 2 := by
    exact?
  have h_k_mod_q : k_val q % q = 2 := by
    exact?;
  -- Since gcd(2, 3q) = 1 (3q is odd), we � can� apply the Chinese Remainder Theorem to combine the congruences modulo 3, q, and 2.
  have h_k_mod_6q : k_val q % (3 * q * 2) = 2 := by
    have h_k_mod_6q : k_val q % 2 = 0 := by
      refine Nat.mod_eq_zero_of_dvd ?_;
      -- Since $A$ is odd, $k$ must be even.
      have h_even_k : Even (k_val q) := by
        have h_even_k : Even (3 ^ q - 1) := by
          simp +decide [ Nat.one_le_iff_ne_zero, parity_simps ];
        exact even_iff_two_dvd.mpr ( Nat.dvd_div_of_mul_dvd ( Nat.Coprime.mul_dvd_of_dvd_of_dvd ( show Nat.Coprime ( A q ) 2 from Nat.Coprime.symm <| Nat.prime_two.coprime_iff_not_dvd.mpr fun h => by have := Nat.mod_eq_zero_of_dvd h; unfold A at this; norm_num [ Nat.add_mod, Nat.pow_mod, Nat.mul_mod ] at this; have := Nat.mod_lt q two_pos; interval_cases q % 2 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hq_prime.dvd_iff_eq ] ) ( show A q ∣ 3^q - 1 from by rw [ ← Nat.mod_add_div ( 3^q ) ( A q ), h_contra ] ; norm_num [ A ] ) ( show 2 ∣ 3^q - 1 from even_iff_two_dvd.mp h_even_k ) ) );
      exact even_iff_two_dvd.mp h_even_k;
    -- Since $q$ is prime and greater than 3, $q$ is odd, and thus $3q$ is also odd.
    have h_coprime : Nat.gcd (3 * q) 2 = 1 := by
      exact Nat.Coprime.mul_left ( by decide ) ( hq_prime.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases q );
    -- By the Chinese Remainder Theorem, � since� $3q$ and $2$ are coprime, we � can� combine the congruences modulo $3q$ and modulo $2$.
    have h_crt : k_val q ≡ 2 [MOD (3 * q)] ∧ k_val q ≡ 2 [MOD 2] := by
      simp_all +decide [ Nat.ModEq, Nat.mod_eq_of_lt ];
      rw [ Nat.ModEq.symm ];
      rw [ Nat.modEq_iff_dvd' ];
      · convert Nat.lcm_dvd ( Nat.dvd_of_mod_eq_zero ( show ( k_val q - 2 ) % 3 = 0 from ?_ ) ) ( Nat.dvd_of_mod_eq_zero ( show ( k_val q - 2 ) % q = 0 from ?_ ) ) using 1;
        · exact Eq.symm ( Nat.Coprime.lcm_eq_mul <| Nat.prime_three.coprime_iff_not_dvd.mpr fun h => by have := Nat.mod_eq_zero_of_dvd h; omega );
        · rw [ ← Nat.mod_add_div ( k_val q ) 3, h_k_mod_3 ] ; norm_num;
        · rw [ ← Nat.mod_add_div ( k_val q ) q, h_k_mod_q ] ; norm_num;
      · exact Nat.le_of_not_lt fun h => by interval_cases k_val q <;> contradiction;
    rw [ Nat.ModEq.symm ];
    exact Nat.mod_eq_of_lt ( by nlinarith : 2 < 3 * q * 2 );
    rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ] ; tauto;
    assumption;
  rwa [ show 6 * q = 3 * q * 2 by ring ]

/-
Any odd prime factor p of k satisfies p ≡ 1 (mod q), assuming 3^q ≡ 1 (mod A).
-/
theorem prime_factors_of_k_mod_q (q : ℕ) (hq_prime : q.Prime) (p : ℕ) (hp_prime : p.Prime) (hp_odd : p ≠ 2)
    (h_contra : 3 ^ q % (A q) = 1) (h_dvd : p ∣ k_val q) : p % q = 1 := by
  -- By Fermat's Little Theorem, this implies p 1 (mod q), since the order d must divide both p - 1 and q.
  have h_order_divides : orderOf (3 : ZMod p) ∣ q ∧ orderOf (3 : ZMod p) ∣ p - 1 := by
    -- Since $p$ divides $k$, we have $p \mid 3^q - 1$. Therefore, $3^q \equiv 1 \pmod{p}$.
    have h_mod_p : 3 ^ q ≡ 1 [ZMOD p] := by
      -- By definition of $k_val$, we know that $p \mid (3^q - 1)$.
      have h_div : p ∣ (3 ^ q - 1) := by
        exact h_dvd.trans ( Nat.div_dvd_of_dvd <| by rw [ ← Nat.mod_add_div ( 3 ^ q ) ( A q ), h_contra ] ; norm_num )
      generalize_proofs at *; (
      exact Eq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_div;);
    haveI := Fact.mk hp_prime; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, orderOf_dvd_iff_pow_eq_one ] ;
    rw [ ZMod.pow_card_sub_one_eq_one ] ; cases q <;> aesop;
  rw [ Nat.dvd_prime hq_prime ] at h_order_divides;
  rcases h_order_divides with ⟨ h|h, h' ⟩ <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
  · rcases p with ( _ | _ | _ | _ | _ | p ) <;> cases h <;> trivial;
  · rcases p with ( _ | _ | p ) <;> simp_all +decide [ ← ZMod.val_natCast ];
    rcases q with ( _ | _ | q ) <;> norm_cast