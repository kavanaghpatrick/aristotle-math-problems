/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7220b777-3ae8-4569-896a-536851f65595

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Bounded verification that 3 is not a cubic residue mod A for q < 100000.
-/
theorem cubic_supplement_bounded (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 100000) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
      -- Let's choose any $q$ such that $q < 100000$ and $q \equiv 2 \pmod{3}$.
      have h_cases : ∀ q ∈ Finset.filter (fun q => q.Prime ∧ 3 < q ∧ q % 3 = 2 ∧ q % 9 ≠ 8) (Finset.range 100000), ¬(3 ^ ((q ^ 2 + q) / 3) ≡ 1 [MOD (q ^ 2 + q + 1)]) := by
        simp +zetaDelta at *;
        -- We can use the fact that if the order of 3 modulo A is not 3, then 3^( (q^2 + q)/3 ) cannot be 1 modulo A. Hence, we need to check this condition for all primes q in the specified range.
        have h_check : ∀ q ∈ Finset.filter (fun q => q.Prime ∧ 3 < q ∧ q % 3 = 2 ∧ q % 9 ≠ 8) (Finset.range 100000), ¬(3 ^ ((q ^ 2 + q) / 3) ≡ 1 [MOD (q ^ 2 + q + 1)]) := by
          intro q hq
          have h_order : orderOf (3 : ZMod (q ^ 2 + q + 1)) ∣ (q ^ 2 + q) / 3 → False := by
            rw [ orderOf_dvd_iff_pow_eq_one ];
            native_decide +revert;
          simp_all +contextual [ ← ZMod.natCast_eq_natCast_iff, orderOf_dvd_iff_pow_eq_one ];
        exact fun q hq₁ hq₂ hq₃ hq₄ hq₅ => h_check q <| Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr hq₁, hq₂, hq₃, hq₄, hq₅ ⟩;
      simp_all +contextual [ ← ZMod.natCast_eq_natCast_iff ]

/-
q^2 + q + 1 = 0 in ZMod (q^2 + q + 1).
-/
theorem q_sq_add_q_add_one_eq_zero (q : ℕ) : (q^2 + q + 1 : ZMod (q^2 + q + 1)) = 0 := by
  norm_cast;
  erw [ ZMod.natCast_self ]

/-
q^3 = 1 in ZMod (q^2 + q + 1).
-/
theorem q_cube_eq_one (q : ℕ) : (q : ZMod (q^2 + q + 1))^3 = 1 := by
  -- We'll use that $q^3 - 1 = (q-1)(q^2+q+1)$ to show that $q^3 = 1$ in $ZMod (q^2 + q + 1)$.
  have h_factor : (q^3 - 1 : ZMod (q^2 + q + 1)) = 0 := by
    norm_cast;
    erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] ; exact ⟨ q - 1, by cases q <;> norm_num [ Int.subNatNat_eq_coe ] at * ; linarith ⟩;
  exact eq_of_sub_eq_zero h_factor

/-
3 = -(1-q)^2 * q^2 in ZMod (q^2 + q + 1).
-/
theorem three_eq_neg_one_minus_q_sq_mul_q_sq (q : ℕ) :
    (3 : ZMod (q^2 + q + 1)) = -((1 - q)^2) * q^2 := by
      set p : ℕ := q^2 + q + 1
      have hq_sq : (q^2 : ZMod p) = -q - 1 := by
        -- Since $q^2 + q + 1 = 0$ in $ZMod p$, we can rearrange it to get $q^2 = -q - 1$.
        have hq_sq : (q^2 + q + 1 : ZMod p) = 0 := by
          norm_cast; aesop;
        linear_combination' hq_sq
      have hq_cube : (q^3 : ZMod p) = 1 := by
        linear_combination' hq_sq * ( q - 1 );
      grind

/-
(q^2 + q) / 3 is even.
-/
theorem exponent_is_even (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) : Even ((q^2 + q) / 3) := by
  rw [ Nat.even_div ];
  rw [ ← Nat.mod_add_div q 6 ] at *; have := Nat.mod_lt q ( by decide : 6 > 0 ) ; interval_cases q % 6 <;> norm_num [ Nat.add_mod, Nat.pow_mod ] at *;

/-
(-1)^((q^2+q)/3) = 1 in ZMod (q^2+q+1).
-/
theorem chi_3_neg_one (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    ((-1 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3)) = 1 := by
      -- By `exponent_is_even`, `E` is even. We can write `E` as `2 * k` for some integer `k`.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, ((q ^ 2 + q) / 3) = 2 * k := by
        exact even_iff_two_dvd.mp ( by exact exponent_is_even q hq hq3 hmod );
      norm_num [ hk, pow_mul ]

/-
q^E = q^(E % 3) in ZMod (q^2+q+1).
-/
theorem chi_3_q (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    ((q : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3)) = (q : ZMod (q^2 + q + 1)) ^ (((q^2 + q) / 3) % 3) := by
      -- Since $q$ is a root of unity of order 3, we have $q^3 = 1$.
      have hq_cubed : (q : ZMod (q^2 + q + 1))^3 = 1 := by
        exact?;
      rw [ ← Nat.mod_add_div ( ( q^2 + q ) / 3 ) 3, pow_add, pow_mul ] ; aesop

/-
3^E = (1-q)^(2E) * q^(2E) in ZMod (q^2+q+1).
-/
theorem chi_3_three_eq (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) = ((1 - q) : ZMod (q^2 + q + 1)) ^ (2 * ((q^2 + q) / 3)) * (q : ZMod (q^2 + q + 1)) ^ (2 * ((q^2 + q) / 3)) := by
      -- By definition of exponentiation in modular arithmetic, we can rewrite the right-hand side.
      have h_exp : (3 : ZMod (q ^ 2 + q + 1)) ^ ((q ^ 2 + q) / 3) = (-1 : ZMod (q ^ 2 + q + 1)) ^ ((q ^ 2 + q) / 3) * ((1 - q) : ZMod (q ^ 2 + q + 1)) ^ (2 * ((q ^ 2 + q) / 3)) * (q : ZMod (q ^ 2 + q + 1)) ^ (2 * ((q ^ 2 + q) / 3)) := by
        have h_exp : (3 : ZMod (q ^ 2 + q + 1)) = (-1 : ZMod (q ^ 2 + q + 1)) * ((1 - q) : ZMod (q ^ 2 + q + 1)) ^ 2 * (q : ZMod (q ^ 2 + q + 1)) ^ 2 := by
          convert three_eq_neg_one_minus_q_sq_mul_q_sq q using 1;
          simp +zetaDelta at *;
        rw [ h_exp, mul_pow, mul_pow, pow_mul, pow_mul ];
      rw [ h_exp, chi_3_neg_one q hq hq3 hmod ] ; ring;

/-
q^(2E) = q^s where s = (q+1)/3.
-/
theorem q_pow_two_E_eq_q_pow_s (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    let s := (q + 1) / 3
    (q : ZMod (q^2 + q + 1)) ^ (2 * ((q^2 + q) / 3)) = (q : ZMod (q^2 + q + 1)) ^ s := by
      -- Since $q \equiv 2 \pmod{3}$, we have $2q \equiv 4 \equiv 1 \pmod{3}$.
      have h_exp : 2 * ((q^2 + q) / 3) ≡ (q + 1) / 3 [MOD 3] := by
        rw [ Nat.ModEq ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hmod ] ;
        rw [ ← Nat.mod_add_div q 3, hmod ] ; ring; norm_num [ Nat.add_div, Nat.mul_div_assoc ] ;
        norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; have := Nat.mod_lt ( q / 3 ) zero_lt_three; interval_cases q / 3 % 3 <;> trivial;
      rw [ ← Nat.mod_add_div ( 2 * ( ( q ^ 2 + q ) / 3 ) ) 3, ← Nat.mod_add_div ( ( q + 1 ) / 3 ) 3, h_exp ];
      -- Since $q^3 \equiv 1 \pmod{q^2 + q + 1}$, we have $q^{3k} \equiv 1^k \equiv 1 \pmod{q^2 + q + 1}$ for any integer $k$.
      have hq3_pow : (q : ZMod (q^2 + q + 1))^3 = 1 := by
        exact?;
      simp_all +decide [ pow_add, pow_mul ]

/-
-3 = (2q+1)^2 in ZMod (q^2+q+1).
-/
theorem neg_three_eq_square (q : ℕ) : (-3 : ZMod (q^2 + q + 1)) = (2 * q + 1)^2 := by
  -- Expanding $(2q + 1)^2$ gives $4q^2 + 4q + 1$.
  have h_expand : (2 * q + 1 : ZMod (q ^ 2 + q + 1)) ^ 2 = 4 * q ^ 2 + 4 * q + 1 := by
    grind;
  -- Since $q^2 + q + 1 \equiv 0 \pmod{q^2 + q + 1}$, we have $4(q^2 + q + 1) \equiv 0 \pmod{q^2 + q + 1}$.
  have h_zero : (4 * (q ^ 2 + q + 1) : ZMod (q ^ 2 + q + 1)) = 0 := by
    norm_cast;
    erw [ ZMod.natCast_eq_zero_iff ] ; norm_num;
  linear_combination' -h_zero + h_expand.symm

/-
2q+1 = q(1-q) in ZMod (q^2+q+1).
-/
theorem two_q_plus_one_eq (q : ℕ) : (2 * q + 1 : ZMod (q^2 + q + 1)) = q * (1 - q) := by
  -- Since $q^2 + q + 1 \equiv 0 \pmod{q^2 + q + 1}$, we have $q^2 \equiv -q - 1 \pmod{q^2 + q + 1}$ by definition of congruence modulo a ring element.
  have h_cong : (q^2 + q + 1 : ZMod (q^2 + q + 1)) = 0 := by
    norm_cast at * ; aesop;
  grind

/-
chi_3 is multiplicative.
-/
def chi_3 (q : ℕ) (x : ZMod (q^2 + q + 1)) : ZMod (q^2 + q + 1) := x ^ ((q^2 + q) / 3)

theorem chi_3_mul (q : ℕ) (x y : ZMod (q^2 + q + 1)) :
    chi_3 q (x * y) = chi_3 q x * chi_3 q y := by
      -- By definition of chi_3, we know that
      simp [chi_3];
      rw [ mul_pow ]

/-
chi_3(3) = chi_3(1-q)^2 * chi_3(q)^2.
-/
theorem chi_3_three_eq_chi (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    chi_3 q 3 = chi_3 q (1 - q) ^ 2 * chi_3 q q ^ 2 := by
      unfold chi_3;
      convert chi_3_three_eq q hq hq3 hmod using 1;
      ring

/-
Compute (A-1)/3 mod 3 in terms of k where q = 3k+2.
-/
theorem exponent_mod_three (q : ℕ) (hmod : q % 3 = 2) :
    ((q^2 + q) / 3) % 3 = (2 * ((q - 2) / 3) + 2) % 3 := by
      rw [ ← Nat.mod_add_div q 3, hmod ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ;
      norm_num [ Nat.add_mod, Nat.mul_mod, Nat.add_div, Nat.mul_div_assoc ]

/-
Norm of Eisenstein integers is multiplicative.
-/
structure EisensteinInt where
  re : ℤ
  im : ℤ
deriving DecidableEq, Repr

def EisensteinInt.add (a b : EisensteinInt) : EisensteinInt :=
  ⟨a.re + b.re, a.im + b.im⟩

def EisensteinInt.mul (a b : EisensteinInt) : EisensteinInt :=
  ⟨a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re - a.im * b.im⟩

instance : Add EisensteinInt := ⟨EisensteinInt.add⟩
instance : Mul EisensteinInt := ⟨EisensteinInt.mul⟩
instance : One EisensteinInt := ⟨⟨1, 0⟩⟩
instance : Zero EisensteinInt := ⟨⟨0, 0⟩⟩

def EisensteinInt.norm (a : EisensteinInt) : ℤ :=
  a.re ^ 2 - a.re * a.im + a.im ^ 2

theorem EisensteinInt.norm_mul (a b : EisensteinInt) : EisensteinInt.norm (a * b) = EisensteinInt.norm a * EisensteinInt.norm b := by
  simp +decide [ EisensteinInt.norm ];
  rw [ show ( a * b ).re = a.re * b.re - a.im * b.im by rfl, show ( a * b ).im = a.re * b.im + a.im * b.re + - ( a.im * b.im ) by rfl ] ; ring;

/-
Compute chi_3(q) based on q mod 9.
-/
theorem chi_3_q_mod_nine (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) :
    let E := (q^2 + q) / 3
    (q % 9 = 2 → (q : ZMod (q^2 + q + 1)) ^ E = q^2) ∧
    (q % 9 = 5 → (q : ZMod (q^2 + q + 1)) ^ E = q) ∧
    (q % 9 = 8 → (q : ZMod (q^2 + q + 1)) ^ E = 1) := by
      refine ⟨ ?_, ?_, ?_ ⟩;
      · intro hmod9
        have h_exp : ((q^2 + q) / 3) % 3 = 2 := by
          rw [ ← Nat.mod_add_div q 9, hmod9 ] ; ring_nf ;
          norm_num [ Nat.add_mod, Nat.add_div, Nat.mul_mod, Nat.mul_div_assoc, Nat.mul_comm ];
        rw [ ← Nat.mod_add_div ( ( q ^ 2 + q ) / 3 ) 3, h_exp ] ; norm_num [ pow_add, pow_mul ] ;
        have h_q3 : (q : ZMod (q^2 + q + 1))^3 = 1 := by
          exact?;
        aesop;
      · -- We use `chi_3_q` to reduce the exponent modulo 3.
        intro hmod9
        have h_exp : ((q^2 + q) / 3) % 3 = 1 := by
          rw [ ← Nat.mod_add_div q 9, hmod9 ] ; ring_nf ;
          grind;
        rw [ ← Nat.mod_add_div ( ( q ^ 2 + q ) / 3 ) 3, h_exp ] ; norm_num [ pow_add, pow_mul ];
        erw [ show ( q : ZMod ( q ^ 2 + q + 1 ) ) ^ 3 = 1 from ?_ ] ; norm_num;
        exact?;
      · have := chi_3_q q hq hq3 hmod;
        -- We need to show that when $q \equiv 8 \pmod{9}$, $(q^2 + q) / 3 \equiv 0 \pmod{3}$.
        have h_exp_mod : (q % 9 = 8) → (((q^2 + q) / 3) % 3 = 0) := by
          intro h; rw [ ← Nat.mod_add_div q 9, h ] ; ring_nf ;
          grind;
        aesop

/-
If chi_3(1-q) = 1, then chi_3(3) ≠ 1 for q ≢ 8 (mod 9).
-/
theorem chi_3_reduction (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8)
    (h_supp : chi_3 q (1 - q) = 1) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
      -- We have `chi_3(3) = chi_3(1-q)^2 * chi_3(q)^2`.
      have chi_3_3_eq : (3 : (ZMod (q ^ 2 + q + 1))) ^ ((q ^ 2 + q) / 3) = (chi_3 q (1 - q)) ^ 2 * (chi_3 q q) ^ 2 := by
        convert chi_3_three_eq_chi q hq hq3 hmod using 1;
      -- Since `chi_3(1-q)=1`, `chi_3(3) = chi_3(q)^2`.
      rw [chi_3_3_eq, h_supp]
      simp [chi_3] at *;
      -- We analyze `chi_3(q)^2` using `chi_3_q_mod_nine`.
      have h_cases : (q % 9 = 2 ∧ (q : (ZMod (q ^ 2 + q + 1))) ^ ((q ^ 2 + q) / 3) = q^2) ∨ (q % 9 = 5 ∧ (q : (ZMod (q ^ 2 + q + 1))) ^ ((q ^ 2 + q) / 3) = q) := by
        have := chi_3_q_mod_nine q hq hq3 hmod; ( rw [ ← Nat.mod_mod_of_dvd q ( by decide : 3 ∣ 9 ) ] at hmod; ( have := Nat.mod_lt q ( by decide : 0 < 9 ) ; interval_cases _ : q % 9 <;> simp_all +decide ; ) ) ;
      rcases h_cases with h_cases | h_cases <;> simp_all +decide [ pow_succ, mul_assoc ];
      · intro h; have := q_cube_eq_one q; simp_all +decide [ pow_succ', mul_assoc ] ;
        rw [ zero_pow ( Nat.ne_of_gt ( Nat.div_pos ( by nlinarith ) ( by norm_num ) ) ) ] at h_supp;
        rcases q with ( _ | _ | q ) <;> cases h_supp ; contradiction;
      · -- Since $q > 3$, we have $q^2 \neq 1$ in the field $\mathbb{Z}/(q^2 + q + 1)\mathbb{Z}$.
        have h_q_sq_ne_one : (q : ZMod (q ^ 2 + q + 1)) ^ 2 ≠ 1 := by
          intro h
          have h_contra : q ^ 2 ≡ 1 [MOD (q ^ 2 + q + 1)] := by
            erw [ ← ZMod.natCast_eq_natCast_iff ] ; aesop;
          rw [ Nat.ModEq, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt ] at h_contra <;> nlinarith only [ hq3, h_contra ] ;
        generalize_proofs at *; (
        simpa only [ sq ] using h_q_sq_ne_one)

/-
The map z -> z.re + z.im * q is a homomorphism from Eisenstein integers to ZMod A.
-/
def EisensteinInt.toZMod (q : ℕ) (z : EisensteinInt) : ZMod (q^2 + q + 1) :=
  z.re + z.im * q

theorem EisensteinInt.toZMod_mul (q : ℕ) (a b : EisensteinInt) :
    toZMod q (a * b) = toZMod q a * toZMod q b := by
      convert congr_arg _ ?_;
      rotate_left;
      exact ⟨ a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re - a.im * b.im ⟩;
      · exact?;
      · unfold EisensteinInt.toZMod;
        norm_num [ sub_mul, mul_assoc, mul_left_comm, mul_comm ] ; ring;
        erw [ show ( q : ZMod ( q ^ 2 + q + 1 ) ) ^ 2 = - ( q + 1 ) by { exact eq_neg_of_add_eq_zero_left <| by { norm_cast; simp +decide [ add_assoc ] } } ] ; ring

/-
Bounded verification for q < 100.
-/
theorem cubic_supplement_bounded_verified (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 100) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
      interval_cases q <;> norm_num at *;
      · native_decide +revert;
      · native_decide;
      · native_decide

/-
Correctness of the check function.
-/
def check_cubic_supplement (q : ℕ) : Bool :=
  if h : q.Prime ∧ 3 < q ∧ q % 3 = 2 ∧ q % 9 ≠ 8 then
    let A := q^2 + q + 1
    let E := (A - 1) / 3
    let res := Pow.pow (3 : ZMod A) E
    res ≠ 1
  else
    true

theorem check_cubic_supplement_correct (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime) :
    check_cubic_supplement q = true ↔ (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
      unfold check_cubic_supplement; aesop;

/-
toZMod preserves addition.
-/
theorem EisensteinInt.toZMod_add (q : ℕ) (a b : EisensteinInt) :
    toZMod q (a + b) = toZMod q a + toZMod q b := by
      -- By definition of toZMod, we have:
      simp [EisensteinInt.toZMod];
      have h_toZMod_add : (a + b).re = a.re + b.re ∧ (a + b).im = a.im + b.im := by
        exact ⟨ rfl, rfl ⟩
      have h_toZMod_mul : (a * b).re = a.re * b.re - a.im * b.im ∧ (a * b).im = a.re * b.im + a.im * b.re - a.im * b.im := by
        exact ⟨ rfl, rfl ⟩
        skip
      generalize_proofs at *; (
      simp +decide [ h_toZMod_add, h_toZMod_mul ] ; ring;)

/-
toZMod preserves one.
-/
theorem EisensteinInt.toZMod_one (q : ℕ) :
    toZMod q 1 = 1 := by
      -- By definition of toZMod, we have toZMod q 1 = 1 + 0 * q = 1. Since 1 is the multiplicative identity in any ring, we have 1 + 0 * q = 1.
      simp [EisensteinInt.toZMod];
      -- By definition of EisensteinInt, we know that EisensteinInt.re 1 = 1 and EisensteinInt.im 1 = 0.
      have h_re_im : EisensteinInt.re 1 = 1 ∧ EisensteinInt.im 1 = 0 := by
        exact ⟨ rfl, rfl ⟩;
      aesop

/-
Bounded verification for q < 500.
-/
theorem cubic_supplement_bounded_500 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 500) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
  interval_cases q <;> norm_num at *
  all_goals native_decide

/-
Bounded verification for q < 2000.
-/
theorem cubic_supplement_bounded_2000 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 2000) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
  interval_cases q <;> norm_num at *
  all_goals native_decide

/-
Checker for chi_3(1-q) = 1.
-/
def check_supplement_1_minus_q (q : ℕ) : Bool :=
  if h : q.Prime ∧ 3 < q ∧ q % 3 = 2 ∧ q % 9 ≠ 8 then
    let A := q^2 + q + 1
    let E := (A - 1) / 3
    let res := Pow.pow (1 - (q : ZMod A)) E
    res == 1
  else
    true

theorem check_supplement_1_minus_q_correct (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime) :
    check_supplement_1_minus_q q = true ↔ chi_3 q (1 - q) = 1 := by
      unfold check_supplement_1_minus_q; aesop;

/-
Bounded verification for q < 5000.
-/
theorem cubic_supplement_bounded_5000 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 5000) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
  interval_cases q <;> norm_num at *
  all_goals native_decide

/-
Bounded verification for q < 20000.
-/
theorem cubic_supplement_bounded_20000 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 20000) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
  interval_cases q <;> norm_num at *
  all_goals native_decide

/-
toZMod preserves multiplication.
-/
theorem EisensteinInt.toZMod_mul_correct (q : ℕ) (a b : EisensteinInt) :
    toZMod q (a * b) = toZMod q a * toZMod q b := by
      exact?

/-
Define negation and subtraction for Eisenstein integers.
-/
def EisensteinInt.neg (a : EisensteinInt) : EisensteinInt :=
  ⟨-a.re, -a.im⟩

instance : Neg EisensteinInt := ⟨EisensteinInt.neg⟩

def EisensteinInt.sub (a b : EisensteinInt) : EisensteinInt :=
  ⟨a.re - b.re, a.im - b.im⟩

instance : Sub EisensteinInt := ⟨EisensteinInt.sub⟩

/-
EisensteinInt.ext lemma.
-/
theorem EisensteinInt.ext (a b : EisensteinInt) : a.re = b.re → a.im = b.im → a = b := by
  intro h1 h2
  cases a
  cases b
  simp_all

/-
Associativity of addition for EisensteinInt.
-/
theorem EisensteinInt.add_assoc (a b c : EisensteinInt) : a + b + c = a + (b + c) := by
  -- By definition of addition in EisensteinInt, we can expand both sides.
  have h_expand : (a + b) + c = ⟨(a.re + b.re) + c.re, (a.im + b.im) + c.im⟩ ∧ a + (b + c) = ⟨a.re + (b.re + c.re), a.im + (b.im + c.im)⟩ := by
    aesop;
  grind

/-
Check existence of EisensteinInt.add_assoc.
-/
#check EisensteinInt.add_assoc

/-
Commutativity of addition.
-/
theorem EisensteinInt.add_comm (a b : EisensteinInt) : a + b = b + a := by
  -- By definition of addition in Eisenstein integers, we have:
  have h_add : a + b = ⟨a.re + b.re, a.im + b.im⟩ ∧ b + a = ⟨b.re + a.re, b.im + a.im⟩ := by
    exact ⟨ rfl, rfl ⟩;
  grind

/-
Zero add identity.
-/
theorem EisensteinInt.zero_add (a : EisensteinInt) : 0 + a = a := by
  -- By definition of addition for EisensteinInt, we have:
  have h_add : 0 + a = ⟨0 + a.re, 0 + a.im⟩ := by
    exact?;
  aesop

/-
Multiplication axioms for EisensteinInt.
-/
theorem EisensteinInt.mul_assoc (a b c : EisensteinInt) : a * b * c = a * (b * c) := by
  -- By definition of multiplication in the Eisenstein integers, we can expand both sides and show they are equal.
  have h_expand : ∀ (a b c : EisensteinInt), (a * b) * c = a * (b * c) := by
    intros a b c
    apply EisensteinInt.ext
    all_goals generalize_proofs at *;
    · exact show ( a.re * b.re - a.im * b.im ) * c.re - ( a.re * b.im + a.im * b.re - a.im * b.im ) * c.im = a.re * ( b.re * c.re - b.im * c.im ) - a.im * ( b.re * c.im + b.im * c.re - b.im * c.im ) by ring;
    · exact Eq.symm ( by rw [ show ( a * b * c ).im = ( a * b ).re * c.im + ( a * b ).im * c.re - ( a * b ).im * c.im by rfl, show ( a * ( b * c ) ).im = a.re * ( b * c ).im + a.im * ( b * c ).re - a.im * ( b * c ).im by rfl ] ; rw [ show ( a * b ).re = a.re * b.re - a.im * b.im by rfl, show ( a * b ).im = a.re * b.im + a.im * b.re - a.im * b.im by rfl, show ( b * c ).re = b.re * c.re - b.im * c.im by rfl, show ( b * c ).im = b.re * c.im + b.im * c.re - b.im * c.im by rfl ] ; ring );
  exact h_expand a b c

theorem EisensteinInt.mul_comm (a b : EisensteinInt) : a * b = b * a := by
  -- By commutativity of integer multiplication, we can rearrange the terms in the real and imaginary parts.
  have h_comm : a.re * b.re - a.im * b.im = b.re * a.re - b.im * a.im ∧ a.re * b.im + a.im * b.re - a.im * b.im = b.re * a.im + b.im * a.re - b.im * a.im := by
    constructor <;> ring;
  exact congr_arg₂ EisensteinInt.mk h_comm.1 h_comm.2

theorem EisensteinInt.one_mul (a : EisensteinInt) : 1 * a = a := by
  -- By definition of multiplication for Eisenstein integers, we have:
  have h_mul : ∀ a : EisensteinInt, 1 * a = ⟨1 * a.re - 0 * a.im, 1 * a.im + 0 * a.re - 0 * a.im⟩ := by
    exact?;
  aesop

theorem EisensteinInt.mul_one (a : EisensteinInt) : a * 1 = a := by
  -- By definition of multiplication in EisensteinInt, we have:
  have h_mul_def : a * ⟨1, 0⟩ = ⟨a.re * 1 - a.im * 0, a.re * 0 + a.im * 1 - a.im * 0⟩ := by
    exact?;
  aesop

/-
Define w and prove w^2+w+1=0.
-/
def EisensteinInt.w : EisensteinInt := ⟨0, 1⟩

def EisensteinInt.pow (a : EisensteinInt) (n : ℕ) : EisensteinInt :=
  match n with
  | 0 => 1
  | n + 1 => a * pow a n

instance : Pow EisensteinInt ℕ := ⟨EisensteinInt.pow⟩

theorem EisensteinInt.pow_zero (a : EisensteinInt) : a ^ 0 = 1 := by
  rfl
theorem EisensteinInt.pow_succ (a : EisensteinInt) (n : ℕ) : a ^ (n + 1) = a * a ^ n := by
  induction n <;> aesop

theorem EisensteinInt.w_sq_add_w_add_one : w ^ 2 + w + 1 = 0 := by
  exact?

/-
toZMod preserves powers.
-/
theorem EisensteinInt.toZMod_pow (q : ℕ) (a : EisensteinInt) (n : ℕ) :
    toZMod q (a ^ n) = (toZMod q a) ^ n := by
      induction n <;> simp_all +decide [ pow_succ' ];
      · exact EisensteinInt.toZMod_one q;
      · rename_i n ih;
        convert EisensteinInt.toZMod_mul q a ( a ^ n ) using 1;
        rw [ ih ]

/-
Bounded verification for q < 100000.
-/
theorem cubic_supplement_bounded_100k (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
    (hmod : q % 3 = 2) (hmod9 : q % 9 ≠ 8) (hA : (q^2 + q + 1).Prime)
    (hbound : q < 100000) :
    (3 : ZMod (q^2 + q + 1)) ^ ((q^2 + q) / 3) ≠ 1 := by
      convert cubic_supplement_bounded q hq hq3 hmod hmod9 hA hbound using 1