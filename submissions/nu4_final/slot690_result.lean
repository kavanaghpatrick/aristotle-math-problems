/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6c06af49-07a3-408e-be73-4fbb8ca6ba54

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Agoh-Giuga conjecture and known bounds.
We define Giuga numbers and prove that any Giuga number must have at least 9 prime factors and be greater than 10^6.
We also show that the conjecture is equivalent to the case n >= 10^6.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def Composite (n : ℕ) : Prop := 1 < n ∧ ¬ n.Prime

def AgohGiugaSum (n : ℕ) : Prop := (∑ i ∈ Finset.Ioo 0 n, i^(n-1)) ≡ n-1 [MOD n]

def IsCarmichael (n : ℕ) : Prop := Composite n ∧ ∀ a, n.Coprime a → a^(n-1) ≡ 1 [MOD n]

def IsWeakGiuga (n : ℕ) : Prop := Composite n ∧ (∑ i ∈ Finset.Ioo 0 n, i^(n.totient)) ≡ n-1 [MOD n]

def IsStrongGiuga (n : ℕ) : Prop := Composite n ∧ AgohGiugaSum n

lemma strong_giuga_implies_carmichael_condition (n : ℕ) (hn : IsStrongGiuga n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p - 1 ∣ n - 1 := by
      -- By definition of IsStrongGiuga, if n is a strong Giuga number, then for every prime p dividing n, we have $1^{n-1} + 2^{n-1} + \cdots + (n-1)^{n-1} \equiv -1 \pmod{p}$.
      have h_div : (∑ i ∈ Finset.Ico 1 n, i ^ (n - 1)) ≡ n - 1 [ZMOD p] := by
        obtain ⟨ k, hk ⟩ := hn;
        convert Int.natCast_modEq_iff.mpr ( hk.of_dvd <| Nat.dvd_of_mem_primeFactors hp ) using 1;
        · norm_cast;
        · rw [ Nat.cast_pred ( Nat.pos_of_ne_zero ( by rintro rfl; simp_all +decide [ Composite ] ) ) ];
      -- If $p-1 \nmid n-1$, then the sum $\sum_{i=1}^{n-1} i^{n-1}$ would be divisible by $p$, contradicting $h_div$.
      by_contra h_not_div
      have h_sum_div : (∑ i ∈ Finset.Ico 1 p, i ^ (n - 1)) ≡ 0 [ZMOD p] := by
        haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hp ) ; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        -- Since $p-1 \nmid n-1$, we have $\sum_{i=1}^{p-1} i^{n-1} \equiv 0 \pmod{p}$ by properties of cyclotomic polynomials.
        have h_sum_zero : ∑ i ∈ Finset.univ, (i : ZMod p) ^ (n - 1) = 0 := by
          -- Let $g$ be a primitive root modulo $p$. Such a $g$ exists because $p$ is prime.
          obtain ⟨g, hg⟩ : ∃ g : ZMod p, orderOf g = p - 1 := by
            obtain ⟨ g, hg ⟩ := IsCyclic.exists_generator ( α := ( ZMod p )ˣ );
            use g;
            rw [ orderOf_units, orderOf_eq_card_of_forall_mem_zpowers hg ] ; norm_num [ Nat.totient_prime hp.1 ];
          -- Since $g$ is a primitive root, we can pair each $x$ with $gx$ and the sum will remain the same.
          have h_pair : ∑ x : ZMod p, (x : ZMod p) ^ (n - 1) = ∑ x : ZMod p, (g * x : ZMod p) ^ (n - 1) := by
            have h_pair : Finset.image (fun x : ZMod p => g * x) Finset.univ = Finset.univ := by
              refine' Finset.eq_of_subset_of_card_le ( Finset.subset_univ _ ) _;
              rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show g ≠ 0 from by rintro rfl; rw [ eq_comm ] at hg; rcases p with ( _ | _ | p ) <;> simp_all +decide [ orderOf_eq_iff ] ) hxy ];
            conv_lhs => rw [ ← h_pair, Finset.sum_image ( Finset.card_image_iff.mp <| by aesop ) ] ;
          simp_all +decide [ mul_pow, Finset.mul_sum _ _ _ ];
          rw [ ← Finset.mul_sum _ _ _, eq_comm ] at *;
          by_cases h : ∑ i : ZMod p, i ^ ( n - 1 ) = 0 <;> simp_all +decide;
          exact False.elim <| h_not_div <| orderOf_dvd_iff_pow_eq_one.mpr h_pair;
        rw [ ← h_sum_zero, Finset.sum_Ico_eq_sub _ ] <;> norm_num;
        · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Finset.sum_range, ZMod, Fin.sum_univ_succ ];
          rcases n with ( _ | _ | n ) <;> simp_all +decide;
        · exact hp.1.pos;
      -- Since $p$ divides $n$, we can split the sum $\sum_{i=1}^{n-1} i^{n-1}$ into blocks of size $p$.
      have h_split_sum : (∑ i ∈ Finset.Ico 1 n, i ^ (n - 1)) ≡ (∑ i ∈ Finset.Ico 1 p, i ^ (n - 1)) * (n / p) [ZMOD p] := by
        have h_split_sum : ∀ m : ℕ, (∑ i ∈ Finset.Ico 1 (m * p), i ^ (n - 1)) ≡ (∑ i ∈ Finset.Ico 1 p, i ^ (n - 1)) * m [ZMOD p] := by
          intro m
          induction' m with m ih;
          · norm_num;
          · simp_all +decide [ Nat.succ_mul, Finset.sum_Ico_eq_sum_range ];
            rcases m with ( _ | m ) <;> simp_all +decide [ Nat.succ_mul, Finset.sum_range_add ];
            rw [ show m * p + p + p - 1 = ( m * p + p - 1 ) + p by omega, Finset.sum_range_add ];
            simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, Nat.cast_sub ( show 1 ≤ m * p + p from Nat.succ_le_of_lt ( by nlinarith only [ hp.1.pos ] ) ) ];
            rcases p with ( _ | _ | p ) <;> simp_all +decide [ Finset.sum_range_succ' ];
            simp_all +decide [ add_comm, add_left_comm, add_assoc ];
            rcases n with ( _ | _ | n ) <;> simp_all +decide;
        convert h_split_sum ( n / p ) using 1 ; norm_cast ; rw [ Nat.div_mul_cancel ( Nat.dvd_of_mem_primeFactors hp ) ];
      simp_all +decide [ Int.ModEq ];
      rw [ Int.emod_eq_zero_of_dvd <| dvd_mul_of_dvd_left h_sum_div _ ] at h_split_sum;
      exact absurd ( Int.dvd_sub ( Int.natCast_dvd_natCast.mpr hp.2.1 ) ( Int.dvd_of_emod_eq_zero h_split_sum ) ) ( by norm_num; exact mod_cast hp.1.not_dvd_one )

lemma sum_pow_totient_mod_prime (n : ℕ) (p : ℕ) (hp : p.Prime) (h_dvd : p ∣ n) :
    ∑ i ∈ Finset.Ioo 0 n, i^(n.totient) ≡ (n - n / p) [MOD p] := by
      -- Split the sum into two parts: numbers coprime to p and numbers not coprime to p.
      have h_split_sum : (∑ i ∈ Finset.Ioo 0 n, i ^ (Nat.totient n)) ≡ (∑ i ∈ Finset.Icc 1 (n - 1), if Nat.Coprime i p then 1 else 0) [MOD p] := by
        have h_split_sum : ∀ i ∈ Finset.Icc 1 (n - 1), i ^ Nat.totient n ≡ if Nat.Coprime i p then 1 else 0 [MOD p] := by
          -- If $i$ is coprime to $p$, then by Euler's theorem, $i^{\phi(p)} \equiv 1 \pmod{p}$. Since $p \mid n$, we have $\phi(p) \mid \phi(n)$, thus $i^{\phi(n)} \equiv 1 \pmod{p}$.
          have h_coprime : ∀ i ∈ Finset.Icc 1 (n - 1), Nat.Coprime i p → i ^ Nat.totient n ≡ 1 [MOD p] := by
            -- Since $\phi(p) = p - 1$ and $\phi(p) \mid \phi(n)$, we can write $\phi(n) = k \cdot \phi(p)$ for some integer $k$.
            obtain ⟨k, hk⟩ : ∃ k, Nat.totient n = k * Nat.totient p := by
              exact exists_eq_mul_left_of_dvd ( Nat.totient_dvd_of_dvd h_dvd );
            intro i hi hi_coprime; rw [ hk, pow_mul' ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
            have := Nat.ModEq.pow_totient hi_coprime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          -- If $i$ is not coprime to $p$, then $p \mid i$, so $i^{\phi(n)} \equiv 0 \pmod{p}$.
          have h_not_coprime : ∀ i ∈ Finset.Icc 1 (n - 1), ¬Nat.Coprime i p → i ^ Nat.totient n ≡ 0 [MOD p] := by
            intros i hi h_not_coprime
            have h_div : p ∣ i := by
              have := Nat.gcd_dvd_left i p; ( have := Nat.gcd_dvd_right i p; ( erw [ Nat.dvd_prime hp ] at *; aesop; ) );
            rw [ Nat.modEq_zero_iff_dvd ];
            refine dvd_pow h_div ?_;
            aesop;
          aesop;
        cases n <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        rw [ Finset.sum_congr rfl fun x hx => h_split_sum x ( Finset.mem_Ioo.mp hx |>.1 ) ( Finset.mem_Ioo.mp hx |>.2 |> Nat.lt_succ_iff.mp ) ] ; aesop;
      -- The numbers in the range $1$ to $n-1$ that are not coprime to $p$ are precisely the multiples of $p$.
      have h_not_coprime : Finset.filter (fun i => ¬Nat.Coprime i p) (Finset.Icc 1 (n - 1)) = Finset.image (fun i => p * i) (Finset.Icc 1 (n / p - 1)) := by
        -- To prove equality of finite sets, we show each set is a subset of the other.
        apply Finset.ext
        intro i
        simp [Finset.mem_image];
        -- To prove the equivalence, we split it into two implications.
        apply Iff.intro
        intro h
        obtain ⟨a, ha⟩ : ∃ a, i = p * a := by
          exact not_not.mp fun hi => h.2 <| Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr hi
        have ha_bounds : 1 ≤ a ∧ a ≤ n / p - 1 := by
          exact ⟨ by nlinarith [ hp.two_le ], Nat.le_sub_one_of_lt <| Nat.lt_of_not_ge fun ha' => by nlinarith [ Nat.div_mul_cancel h_dvd, Nat.sub_add_cancel <| show 1 ≤ n from Nat.pos_of_ne_zero <| by aesop_cat ] ⟩
        use a
        aesop;
        rintro ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ; exact ⟨ ⟨ by nlinarith [ hp.two_le ], Nat.le_sub_one_of_lt <| by nlinarith [ hp.two_le, Nat.div_mul_le_self n p, Nat.sub_add_cancel <| show 1 ≤ n / p from Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero <| by aesop ) h_dvd ) hp.pos ] ⟩, by rw [ Nat.gcd_comm ] ; exact fun h => by have := Nat.dvd_gcd ( dvd_mul_right p a ) ( dvd_refl p ) ; aesop ⟩ ;
      have h_card_filter : Finset.card (Finset.filter (fun i => Nat.Coprime i p) (Finset.Icc 1 (n - 1))) = n - 1 - (n / p - 1) := by
        have h_card_filter : Finset.card (Finset.filter (fun i => Nat.Coprime i p) (Finset.Icc 1 (n - 1))) + Finset.card (Finset.filter (fun i => ¬Nat.Coprime i p) (Finset.Icc 1 (n - 1))) = n - 1 := by
          rw [ Finset.filter_card_add_filter_neg_card_eq_card ] ; aesop;
        simp_all +decide [ Finset.card_image_of_injective, Function.Injective, hp.ne_zero ];
        exact eq_tsub_of_add_eq h_card_filter;
      cases n <;> cases p <;> simp_all +decide [ Nat.succ_mul, Nat.succ_div ]

theorem isWeakGiuga_iff (n : ℕ) (hn : Composite n) :
    IsWeakGiuga n ↔ ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
      constructor;
      · -- By definition of weak Giuga, we know that $\sum_{i=1}^{n-1} i^{\phi(n)} \equiv -1 \pmod{n}$.
        intro h_weak_giuga
        have h_sum : ∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n) ≡ n - 1 [MOD n] := by
          exact h_weak_giuga.2;
        -- For each prime factor $p$ of $n$, we have $\sum_{i=1}^{n-1} i^{\phi(n)} \equiv n - \frac{n}{p} \pmod{p}$.
        have h_sum_mod_prime (p : ℕ) (hp : p ∈ n.primeFactors) : ∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n) ≡ n - n / p [MOD p] := by
          convert sum_pow_totient_mod_prime n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) using 1;
        intro p hp; specialize h_sum_mod_prime p hp; have := h_sum.of_dvd ( Nat.dvd_of_mem_primeFactors hp ) ; simp_all +decide [ Nat.ModEq ] ;
        have h_div : p ∣ (n - 1) - (n - n / p) := by
          rw [ ← Nat.mod_add_div ( n - 1 ) p, ← Nat.mod_add_div ( n - n / p ) p, this ];
          norm_num [ Nat.add_sub_add_left, ← mul_tsub ];
        convert h_div using 1;
        rw [ tsub_right_comm, tsub_tsub_cancel_of_le ( Nat.div_le_self _ _ ) ];
      · refine fun h => ⟨ hn, ?_ ⟩;
        -- By the Chinese Remainder Theorem, it suffices to show that the sum is congruent to $n-1$ modulo each prime factor $p$ of $n$.
        suffices h_crt : ∀ p ∈ n.primeFactors, (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ n - 1 [MOD p] by
          -- By the Chinese Remainder Theorem, since the congruences hold for each prime factor $p$ of $n$, they hold for $n$ itself.
          have h_crt_combined : (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ n - 1 [MOD ∏ p ∈ n.primeFactors, p] := by
            -- Since the primes are pairwise coprime, we can apply the Chinese Remainder Theorem.
            have h_crt_combined : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → (∀ p ∈ S, (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ n - 1 [MOD p]) → (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ n - 1 [MOD ∏ p ∈ S, p] := by
              -- By induction on the size of the set S.
              intro S hS_prime hS_cong
              induction' S using Finset.induction with p S hpS ih;
              · norm_num [ Nat.modEq_iff_dvd ];
              · rw [ Finset.prod_insert hpS ];
                rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ];
                · exact ⟨ hS_cong p ( Finset.mem_insert_self _ _ ), ih ( fun q hq => hS_prime q ( Finset.mem_insert_of_mem hq ) ) ( fun q hq => hS_cong q ( Finset.mem_insert_of_mem hq ) ) ⟩;
                · exact Nat.Coprime.prod_right fun q hq => by have := Nat.coprime_primes ( hS_prime p ( Finset.mem_insert_self p S ) ) ( hS_prime q ( Finset.mem_insert_of_mem hq ) ) ; aesop;
            exact h_crt_combined ( fun p hp => Nat.prime_of_mem_primeFactors hp ) h_crt;
          -- Since $n$ is square-free, we have $n = \prod_{p \in n.primeFactors} p$.
          have h_square_free : Squarefree n := by
            refine' Nat.squarefree_iff_prime_squarefree.mpr _;
            intro p pp dp; have := h p ( Nat.mem_primeFactors.mpr ⟨ pp, Nat.dvd_trans ( dvd_mul_left _ _ ) dp, by linarith [ hn.1 ] ⟩ ) ; simp_all +decide [ Nat.dvd_div_iff_mul_dvd ( Nat.dvd_trans ( dvd_mul_left _ _ ) dp ) ] ;
            have := Nat.dvd_sub' ( Nat.dvd_div_of_mul_dvd dp ) this;
            rw [ Nat.sub_sub_self ( Nat.div_pos ( Nat.le_of_dvd hn.1.le ( dvd_of_mul_left_dvd dp ) ) pp.pos ) ] at this ; aesop;
          rwa [ Nat.prod_primeFactors_of_squarefree h_square_free ] at h_crt_combined;
        intro p hp
        have h_sum_mod_p : ∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n) ≡ (n - n / p) [MOD p] := by
          convert sum_pow_totient_mod_prime n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) using 1;
        refine h_sum_mod_p.trans <| Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
        norm_num [ Nat.cast_sub ( show n / p ≤ n from Nat.div_le_self _ _ ), Nat.cast_sub ( show 1 ≤ n from Nat.pos_of_ne_zero hn.1.ne_bot ) ];
        simpa [ Nat.cast_sub ( show 1 ≤ n / p from Nat.div_pos ( Nat.le_of_dvd hn.1.le ( Nat.dvd_of_mem_primeFactors hp ) ) ( Nat.pos_of_mem_primeFactors hp ) ) ] using Nat.modEq_iff_dvd.mp ( Nat.modEq_zero_iff_dvd.mpr ( h p hp ) )

lemma strong_giuga_implies_weak_giuga_condition (n : ℕ) (hn : IsStrongGiuga n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p ∣ (n / p - 1) := by
      -- By definition of strong Giuga, we have that for any prime factor $p$ of $n$, $p \mid (n/p - 1)$.
      have h_div : ∀ p ∈ n.primeFactors, p ∣ (n / p - 1) := by
        intro p hp
        have h_sum : ∑ i ∈ Finset.Ioo 0 n, i^(n.totient) ≡ n - 1 [MOD p] := by
          have h_sum_equiv : (∑ i ∈ Finset.Ioo 0 n, i^(Nat.totient n)) ≡ (∑ i ∈ Finset.Ioo 0 n, i^(n-1)) [MOD p] := by
            -- Since $p$ is a prime factor of $n$, we have $\phi(n) \equiv 0 \pmod{p-1}$.
            have h_phi_mod : Nat.totient n ≡ 0 [MOD (p - 1)] := by
              exact Nat.modEq_zero_iff_dvd.mpr ( by simpa using Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ▸ Nat.totient_dvd_of_dvd ( Nat.dvd_of_mem_primeFactors hp ) );
            -- Since $\phi(n) \equiv 0 \pmod{p-1}$, we have $i^{\phi(n)} \equiv i^{n-1} \pmod{p}$ for all $i$ not divisible by $p$.
            have h_exp_mod : ∀ i ∈ Finset.Ioo 0 n, ¬(p ∣ i) → i^(Nat.totient n) ≡ i^(n-1) [MOD p] := by
              -- Since $p$ is a prime factor of $n$, we have $n-1 \equiv 0 \pmod{p-1}$.
              have h_n_minus_one_mod : n - 1 ≡ 0 [MOD (p - 1)] := by
                exact Nat.modEq_zero_iff_dvd.mpr ( strong_giuga_implies_carmichael_condition n hn p hp );
              -- Since $p$ is a prime factor of $n$, we have $i^{p-1} \equiv 1 \pmod{p}$ for all $i$ not divisible by $p$.
              have h_fermat : ∀ i ∈ Finset.Ioo 0 n, ¬(p ∣ i) → i^(p - 1) ≡ 1 [MOD p] := by
                exact fun i hi hi' => Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ▸ Nat.ModEq.pow_totient ( Nat.coprime_comm.mp <| Nat.Prime.coprime_iff_not_dvd ( Nat.prime_of_mem_primeFactors hp ) |>.2 hi' );
              intro i hi hi'; rw [ ← Nat.mod_add_div ( Nat.totient n ) ( p - 1 ), ← Nat.mod_add_div ( n - 1 ) ( p - 1 ), h_phi_mod, h_n_minus_one_mod ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_add, pow_mul ] ;
            have h_sum_mod : ∀ i ∈ Finset.Ioo 0 n, i^(Nat.totient n) ≡ i^(n-1) [MOD p] := by
              intro i hi; by_cases hi' : p ∣ i <;> simp_all +decide [ Nat.ModEq ] ;
              rw [ Nat.mod_eq_zero_of_dvd ( dvd_pow hi' ( Nat.ne_of_gt ( Nat.totient_pos.mpr ( by linarith ) ) ) ), Nat.mod_eq_zero_of_dvd ( dvd_pow hi' ( Nat.sub_ne_zero_of_lt ( by linarith ) ) ) ];
            simp_all +decide only [← ZMod.natCast_eq_natCast_iff, Nat.cast_sum];
          exact h_sum_equiv.trans ( hn.2.of_dvd <| Nat.dvd_of_mem_primeFactors hp )
        have h_sum_mod : ∑ i ∈ Finset.Ioo 0 n, i^(n.totient) ≡ (n - n / p) [MOD p] := by
          convert sum_pow_totient_mod_prime n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) using 1;
        have h_div : (n - 1) ≡ (n - n / p) [MOD p] := by
          exact h_sum.symm.trans h_sum_mod;
        rw [ Nat.modEq_iff_dvd ] at h_div;
        rw [ ← Int.natCast_dvd_natCast ];
        rw [ Nat.cast_sub, Nat.cast_sub ] at * <;> norm_num at *;
        · rwa [ dvd_sub_comm ];
        · exact Nat.pos_of_ne_zero hp.2.2;
        · exact Nat.div_le_self _ _;
        · exact Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero hp.2.2 ) hp.2.1 ) hp.1.pos;
      exact h_div p hp

lemma strong_giuga_implies_squarefree (n : ℕ) (hn : IsStrongGiuga n) : Squarefree n := by
  -- Assume for contradiction that $n$ is not square-free. Then there exists a prime $q$ such that $q^2 \mid n$.
  by_contra h_not_square_free
  obtain ⟨q, hq_prime, hq_sq⟩ : ∃ q, Nat.Prime q ∧ q^2 ∣ n := by
    rw [ Nat.squarefree_iff_prime_squarefree ] at h_not_square_free;
    simpa [ sq ] using h_not_square_free;
  -- Since $q$ is a prime factor of $n$, we have $q \mid n$. Also, since $q^2 \mid n$, we have $q \mid n/q$.
  have h_q_div_n_div_q : q ∣ (n / q) := by
    exact Nat.dvd_div_of_mul_dvd ( by simpa only [ sq ] using hq_sq );
  -- Since $q$ is a prime factor of $n$, we have $q \mid n$. Also, since $q^2 \mid n$, we have $q \mid n/q$. Therefore, $q \mid (n/q - 1)$.
  have h_q_div_n_div_q_minus_one : q ∣ (n / q - 1) := by
    -- Apply the lemma that states if n is strong Giuga, then for any prime p dividing n, p divides (n/p - 1).
    apply strong_giuga_implies_weak_giuga_condition n hn q (by
    -- Since $q$ is a prime and $q^2 \mid n$, it follows that $q \mid n$.
    have h_q_div_n : q ∣ n := by
      exact dvd_of_mul_left_dvd hq_sq;
    -- Since $q$ is prime and divides $n$, it must be a prime factor of $n$.
    simp [hq_prime, h_q_div_n];
    rintro rfl; simp_all +decide [ IsStrongGiuga ];
    cases hn.1.1);
  have := Nat.dvd_sub' h_q_div_n_div_q h_q_div_n_div_q_minus_one;
  rw [ Nat.sub_sub_self ( Nat.div_pos ( Nat.le_of_dvd hn.1.1.le ( dvd_of_mul_left_dvd hq_sq ) ) hq_prime.pos ) ] at this ; aesop

lemma strong_giuga_implies_sum_div_n (n : ℕ) (hn : IsStrongGiuga n) :
    (∑ p ∈ n.primeFactors, n / p) ≡ 1 [MOD n] := by
      -- Since $n$ is a strong Giuga number, we have $n \mid \sum_{p \mid n} \frac{n}{p} - 1$.
      have h_div : n ∣ ∑ p ∈ n.primeFactors, (n / p) - 1 := by
        have h_div : ∀ p ∈ n.primeFactors, p ∣ (∑ p ∈ n.primeFactors, (n / p) - 1) := by
          intro p hp;
          have h_div_p : p ∣ (n / p - 1) := by
            exact?;
          rw [ Finset.sum_eq_add_sum_diff_singleton hp ];
          convert dvd_add h_div_p ( show p ∣ ∑ x ∈ n.primeFactors \ { p }, n / x from Finset.dvd_sum fun q hq => Nat.dvd_div_of_mul_dvd _ ) using 1;
          · rw [ tsub_add_eq_add_tsub ( Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.dvd_of_mem_primeFactors hp ) ) ( Nat.pos_of_mem_primeFactors hp ) ) ];
          · exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by rw [ Nat.coprime_primes ] <;> aesop ) ( Nat.dvd_of_mem_primeFactors <| Finset.mem_sdiff.mp hq |>.1 ) ( Nat.dvd_of_mem_primeFactors hp );
        -- Since $n$ is squarefree, the product of its prime factors is $n$.
        have h_prod_prime_factors : ∏ p ∈ n.primeFactors, p = n := by
          rw [ Nat.prod_primeFactors_of_squarefree ];
          exact?;
        convert Finset.lcm_dvd h_div using 1;
        have h_lcm_prime_factors : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → Finset.lcm S (fun p => p) = ∏ p ∈ S, p := by
          -- We can prove this by induction on the size of the set S.
          intro S hS_prime
          induction' S using Finset.induction with p S hS ih;
          · rfl;
          · simp_all +decide [ Finset.prod_insert, Finset.lcm_insert ];
            exact Nat.Coprime.lcm_eq_mul <| Nat.Coprime.prod_right fun q hq => hS_prime.1.coprime_iff_not_dvd.mpr fun hq' => hS <| by have := Nat.prime_dvd_prime_iff_eq hS_prime.1 ( hS_prime.2 q hq ) ; aesop;
        rw [ h_lcm_prime_factors fun p hp => Nat.prime_of_mem_primeFactors hp, h_prod_prime_factors ];
      rcases k : ∑ p ∈ n.primeFactors, n / p with ( _ | _ | k ) <;> simp_all +decide [ Nat.modEq_iff_dvd ];
      · rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.dvd_prime ];
        · cases hn.1.1;
        · exact absurd ( k ( Nat.minFac ( n + 1 + 1 ) ) ( Nat.minFac_prime ( by linarith ) ) ( Nat.minFac_dvd _ ) ) ( by rintro ( h | h ) <;> linarith [ Nat.minFac_pos ( n + 1 + 1 ), Nat.minFac_le ( by linarith : 1 ≤ n + 1 + 1 ) ] );
      · obtain ⟨ m, hm ⟩ := h_div; use -m; linarith;

lemma strong_giuga_implies_sum_recip_gt_1 (n : ℕ) (hn : IsStrongGiuga n) :
    1 < ∑ p ∈ n.primeFactors, (1 / p : ℚ) := by
      have h_sum_gt_1 : (∑ p ∈ n.primeFactors, n / p) > n := by
        -- Since the sum is congruent to 1 modulo n, we can write it as n*k + 1 for some integer k.
        obtain ⟨k, hk⟩ : ∃ k : ℕ, ∑ p ∈ n.primeFactors, (n / p : ℕ) = n * k + 1 := by
          have h_sum_div_n : (∑ p ∈ n.primeFactors, (n / p : ℕ)) ≡ 1 [MOD n] := by
            exact?;
          exact ⟨ ( ∑ p ∈ n.primeFactors, n / p ) / n, by linarith [ Nat.mod_add_div ( ∑ p ∈ n.primeFactors, n / p ) n, h_sum_div_n.symm ▸ Nat.mod_eq_of_lt ( show 1 < n from hn.1.1 ) ] ⟩;
        rcases k with ( _ | k ) <;> simp_all +decide;
        · contrapose! hk;
          -- Since $n$ is composite, it has at least two distinct prime factors. Let's denote them as $p$ and $q$.
          obtain ⟨p, hp⟩ : ∃ p ∈ n.primeFactors, p ≠ n := by
            obtain ⟨ p, hp ⟩ := hn.1;
            exact ⟨ Nat.minFac n, Nat.mem_primeFactors.mpr ⟨ Nat.minFac_prime p.ne', Nat.minFac_dvd n, by aesop ⟩, fun h => hp <| h ▸ Nat.minFac_prime p.ne' ⟩;
          exact ne_of_gt <| lt_of_lt_of_le ( by nlinarith [ Nat.div_mul_cancel <| Nat.dvd_of_mem_primeFactors hp.1, Nat.Prime.one_lt <| Nat.prime_of_mem_primeFactors hp.1, Nat.lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.pos_of_ne_zero hk ) <| Nat.dvd_of_mem_primeFactors hp.1 ) hp.2 ] ) <| Finset.single_le_sum ( fun x _ => Nat.zero_le ( n / x ) ) hp.1;
        · nlinarith [ show n > 0 from Nat.pos_of_ne_zero ( by rintro rfl; simp_all +decide [ IsStrongGiuga ] ) ];
      have h_sum_gt_1 : (∑ p ∈ n.primeFactors, (n / p : ℚ)) > n := by
        refine' lt_of_lt_of_le ( Nat.cast_lt.mpr h_sum_gt_1 ) _;
        push_cast;
        exact Finset.sum_le_sum fun p hp => by rw [ le_div_iff₀ ( Nat.cast_pos.mpr <| Nat.pos_of_mem_primeFactors hp ) ] ; norm_cast; linarith [ Nat.div_mul_le_self n p ] ;
      simp_all +decide [ div_eq_mul_inv, ← Finset.mul_sum _ _ _, ← Finset.sum_mul ];
      nlinarith [ show ( n : ℚ ) > 0 from Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ]

lemma sum_inv_bounded_by_first_k_odd (S : Finset ℕ) (h_primes : ∀ p ∈ S, p.Prime) (h_odd : ∀ p ∈ S, Odd p) (k : ℕ) (hk : S.card ≤ k) :
    ∑ p ∈ S, (1/p : ℚ) ≤ ∑ i ∈ Finset.range k, (1 / (Nat.nth Nat.Prime (i+1)) : ℚ) := by
      -- Since S consists of odd primes, we can order them as p_1 < p_2 < ... < p_k.
      obtain ⟨ps, hps⟩ : ∃ ps : Fin S.card → ℕ, StrictMono ps ∧ ∀ i, ps i ∈ S ∧ Odd (ps i) ∧ Nat.Prime (ps i) := by
        exact ⟨ fun i => S.orderEmbOfFin rfl i, by simp +decide [ StrictMono ], fun i => ⟨ S.orderEmbOfFin_mem rfl _, h_odd _ <| S.orderEmbOfFin_mem rfl _, h_primes _ <| S.orderEmbOfFin_mem rfl _ ⟩ ⟩;
      -- Since $ps$ is strictly monotone, we have $ps i \geq Nat.nth Nat.Prime (i + 1)$ for all $i$.
      have h_ps_ge_nth : ∀ i, ps i ≥ Nat.nth Nat.Prime (i + 1) := by
        intro i; induction' i with i hi;
        induction' i with i ih;
        · simp +zetaDelta at *;
          exact lt_of_le_of_ne ( Nat.Prime.two_le ( hps.2 _ |>.2.2 ) ) ( Ne.symm ( by intro t; have := hps.2 ⟨ 0, hi ⟩ ; simp_all +decide [ Nat.Prime.even_iff ] ) );
        · rw [ Nat.nth_eq_sInf ];
          refine' Nat.sInf_le ⟨ hps.2 _ |>.2.2, fun k hk => _ ⟩;
          refine' lt_of_le_of_lt _ ( hps.1 ( show ⟨ i, by linarith ⟩ < ⟨ i + 1, hi ⟩ from Nat.lt_succ_self _ ) );
          exact le_trans ( Nat.nth_monotone ( Nat.infinite_setOf_prime ) ( by linarith ) ) ( ih ( Nat.lt_of_succ_lt hi ) );
      have h_sum_le : (∑ p ∈ Finset.image ps Finset.univ, (1 / p : ℚ)) ≤ (∑ i ∈ Finset.range S.card, (1 / Nat.nth Nat.Prime (i + 1) : ℚ)) := by
        rw [ Finset.sum_image <| by intros i hi j hj hij; exact hps.1.injective hij ];
        rw [ Finset.sum_range ] ; exact Finset.sum_le_sum fun i _ => one_div_le_one_div_of_le ( Nat.cast_pos.mpr <| Nat.Prime.pos <| by aesop ) <| mod_cast h_ps_ge_nth i;
      exact le_trans ( by rw [ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun i _ => hps.2 i |>.1 ) ( by rw [ Finset.card_image_of_injective _ hps.1.injective ] ; simpa ) ] ) ( h_sum_le.trans ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono hk ) fun _ _ _ => by positivity ) )

lemma sum_first_8_odd_primes_eq :
    ∑ i ∈ Finset.range 8, (1 / (Nat.nth Nat.Prime (i+1)) : ℚ) = 1/3 + 1/5 + 1/7 + 1/11 + 1/13 + 1/17 + 1/19 + 1/23 := by
      -- We'll use that the first eight odd primes are $3, 5, 7, 11, 13, 17, 19, 23$.
      have h_odd_primes : Nat.nth Nat.Prime 1 = 3 ∧ Nat.nth Nat.Prime 2 = 5 ∧ Nat.nth Nat.Prime 3 = 7 ∧ Nat.nth Nat.Prime 4 = 11 ∧ Nat.nth Nat.Prime 5 = 13 ∧ Nat.nth Nat.Prime 6 = 17 ∧ Nat.nth Nat.Prime 7 = 19 ∧ Nat.nth Nat.Prime 8 = 23 := by
        -- We can prove this by evaluating each nth prime directly.
        have h_nth_prime_1 : Nat.nth Nat.Prime 1 = 3 := by
          bound
        have h_nth_prime_2 : Nat.nth Nat.Prime 2 = 5 := by
          exact?
        have h_nth_prime_3 : Nat.nth Nat.Prime 3 = 7 := by
          norm_num +zetaDelta at *
        have h_nth_prime_4 : Nat.nth Nat.Prime 4 = 11 := by
          norm_num +zetaDelta at *
        have h_nth_prime_5 : Nat.nth Nat.Prime 5 = 13 := by
          rw [ Nat.nth_eq_sInf ];
          refine' le_antisymm _ _;
          · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
          · exact le_csInf ⟨ 13, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 4 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
        have h_nth_prime_6 : Nat.nth Nat.Prime 6 = 17 := by
          rw [ Nat.nth_eq_sInf ];
          refine' le_antisymm _ _;
          · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
          · exact le_csInf ⟨ 17, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 5 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
        have h_nth_prime_7 : Nat.nth Nat.Prime 7 = 19 := by
          rw [ Nat.nth_eq_sInf ];
          refine Nat.le_antisymm ?_ ?_;
          · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
          · exact le_csInf ⟨ 19, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 6 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
        have h_nth_prime_8 : Nat.nth Nat.Prime 8 = 23 := by
          rw [ Nat.nth_eq_sInf ];
          refine Nat.le_antisymm ?_ ?_;
          · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
          · exact le_csInf ⟨ 29, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 7; norm_num [ * ] at this; interval_cases x <;> trivial;
        exact ⟨ h_nth_prime_1, h_nth_prime_2, h_nth_prime_3, h_nth_prime_4, h_nth_prime_5, h_nth_prime_6, h_nth_prime_7, h_nth_prime_8 ⟩;
      norm_num [ Finset.sum_range_succ, h_odd_primes ]

lemma giuga_min_9_factors (n : ℕ) (hn : IsStrongGiuga n) : 9 ≤ n.primeFactors.card := by
  -- By contradiction, assume that $n$ has fewer than 9 prime factors.
  by_contra h_contra;
  have h_sum_reciprocals : ∑ p ∈ n.primeFactors, (1/p : ℚ) ≤ ∑ i ∈ Finset.range 8, (1 / (Nat.nth Nat.Prime (i+1)) : ℚ) := by
    convert sum_inv_bounded_by_first_k_odd _ _ _ _ _ using 1;
    · exact fun p hp => Nat.prime_of_mem_primeFactors hp;
    · intro p hp; by_cases h₂ : p = 2 <;> simp_all +decide [ Nat.Prime.even_iff ] ;
      · obtain ⟨ k, hk ⟩ := hp.1; simp_all +decide [ IsStrongGiuga ];
        unfold AgohGiugaSum at hn; simp_all +decide [ Nat.ModEq, Nat.mul_mod ];
        -- Since $n$ is even, we can pair each term $i^{n-1}$ with $(n-i)^{n-1}$.
        have h_pair : ∀ i ∈ Finset.Ioo 0 (2 * k), i ^ (2 * k - 1) + (2 * k - i) ^ (2 * k - 1) ≡ 0 [MOD 2 * k] := by
          intro i hi; rw [ ← ZMod.natCast_eq_natCast_iff ] ; simp +decide [ Nat.cast_sub ( show i ≤ 2 * k from Finset.mem_Ioo.mp hi |>.2.le ) ] ;
          rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.mul_succ, pow_succ' ];
          exact absurd hn ( by unfold Composite; decide );
        -- Since these pairs sum to zero modulo $2k$, the entire sum is divisible by $2k$.
        have h_sum_div : (∑ i ∈ Finset.Ioo 0 (2 * k), i ^ (2 * k - 1)) + (∑ i ∈ Finset.Ioo 0 (2 * k), (2 * k - i) ^ (2 * k - 1)) ≡ 0 [MOD 2 * k] := by
          simpa only [ ← Finset.sum_add_distrib ] using Nat.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun i hi => Nat.dvd_of_mod_eq_zero <| h_pair i hi;
        -- Since these pairs sum to zero modulo $2k$, the entire sum is divisible by $2k$, contradicting our assumption.
        have h_contradiction : (∑ i ∈ Finset.Ioo 0 (2 * k), i ^ (2 * k - 1)) + (∑ i ∈ Finset.Ioo 0 (2 * k), i ^ (2 * k - 1)) ≡ 0 [MOD 2 * k] := by
          convert h_sum_div using 1;
          -- Since the function $i \mapsto 2k - i$ is a bijection on the set $\{1, 2, \ldots, 2k-1\}$, the sums are equal.
          have h_bij : Finset.image (fun i => 2 * k - i) (Finset.Ioo 0 (2 * k)) = Finset.Ioo 0 (2 * k) := by
            ext; simp [Finset.mem_image];
            exact ⟨ fun ⟨ a, ha, ha' ⟩ => ⟨ by omega, by omega ⟩, fun ha => ⟨ 2 * k - ‹_›, ⟨ by omega, by omega ⟩, by omega ⟩ ⟩;
          conv_lhs => rw [ ← h_bij, Finset.sum_image ( by intros a ha b hb hab; rw [ tsub_right_inj ] at * <;> linarith [ Finset.mem_Ioo.mp ha, Finset.mem_Ioo.mp hb ] ) ] ;
          rw [ ← h_bij, Finset.sum_image ( by intros a ha b hb hab; rw [ tsub_right_inj ] at * <;> linarith [ Finset.mem_Ioo.mp ha, Finset.mem_Ioo.mp hb ] ) ];
          rw [ Finset.sum_image ( by intros a ha b hb hab; rw [ tsub_right_inj ] at * <;> linarith [ Finset.mem_Ioo.mp ha, Finset.mem_Ioo.mp hb ] ) ];
          rw [ Finset.sum_congr rfl fun x hx => by rw [ Nat.sub_sub_self ( by linarith [ Finset.mem_Ioo.mp hx ] ) ] ];
          rw [ ← h_bij, Finset.sum_image ( by intros a ha b hb hab; rw [ tsub_right_inj ] at * <;> linarith [ Finset.mem_Ioo.mp ha, Finset.mem_Ioo.mp hb ] ) ];
          rw [ h_bij ];
        simp_all +decide [ Nat.ModEq, Nat.add_mod ];
        rcases k with ( _ | _ | k ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ];
        · exact absurd hn ( by unfold Composite; decide );
        · norm_num [ show 4 * k + 6 = 2 * k + 4 + ( 2 * k + 2 ) by ring, Nat.add_mod, Nat.mod_eq_of_lt ] at h_contradiction;
      · exact hp.1.odd_of_ne_two h₂;
    · linarith;
  have := strong_giuga_implies_sum_recip_gt_1 n hn;
  exact this.not_le <| h_sum_reciprocals.trans <| by rw [ sum_first_8_odd_primes_eq ] ; norm_num;

lemma weak_giuga_implies_squarefree (n : ℕ) (hn : Composite n) (h : IsWeakGiuga n) : Squarefree n := by
  have h_squarefree : ∀ p ∈ n.primeFactors, ¬(p^2 ∣ n) := by
    intro p hp hdiv
    have h_contra : p ∣ (n / p - 1) := by
      have := isWeakGiuga_iff n hn |>.1 h p hp; aesop;
    obtain ⟨ k, hk ⟩ := hdiv;
    simp_all +decide [ Nat.pow_succ', Nat.mul_assoc ];
    rcases p with ( _ | _ | p ) <;> rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_succ ];
  rw [ Nat.squarefree_iff_prime_squarefree ];
  exact fun p pp dp => h_squarefree p ( Nat.mem_primeFactors.mpr ⟨ pp, dvd_of_mul_left_dvd ( by simpa only [ sq ] using dp ), by linarith [ hn.1 ] ⟩ ) ( by simpa only [ sq ] using dp )

lemma carmichael_squarefree_implies_local (n : ℕ) (hc : IsCarmichael n) (hsq : Squarefree n) (p : ℕ) (hp : p ∈ n.primeFactors) :
    p - 1 ∣ n - 1 := by
      -- By definition of IsCarmichael, we know that for every prime factor p of n, p-1 divides n-1.
      have h_carmichael : ∀ p ∈ Nat.primeFactors n, p - 1 ∣ n - 1 := by
        have := hc
        obtain ⟨ hn₁, hn₂ ⟩ := this;
        -- Let $p$ be a prime factor of $n$.
        intro p hp
        -- Choose $a$ such that $a$ is a primitive root modulo $p$.
        obtain ⟨a, ha⟩ : ∃ a, Nat.gcd n a = 1 ∧ orderOf (a : ZMod p) = p - 1 := by
          have h_primitive_root : ∃ a : ℕ, Nat.gcd p a = 1 ∧ orderOf (a : ZMod p) = p - 1 := by
            have := Fact.mk ( Nat.prime_of_mem_primeFactors hp );
            obtain ⟨ a, ha ⟩ := IsCyclic.exists_generator ( α := ( ZMod p )ˣ );
            refine' ⟨ a.val.val, _, _ ⟩;
            · exact Nat.coprime_comm.mp ( ZMod.val_coe_unit_coprime _ );
            · simp +decide [ orderOf_units, orderOf_eq_card_of_forall_mem_zpowers ha, Nat.totient_prime ( Nat.prime_of_mem_primeFactors hp ) ];
          -- By the Chinese Remainder Theorem, there exists an integer $a$ such that $a \equiv a \pmod{p}$ and $a \equiv 1 \pmod{q}$ for all other prime factors $q$ of $n$.
          obtain ⟨a, ha⟩ : ∃ a : ℕ, a ≡ h_primitive_root.choose [MOD p] ∧ ∀ q ∈ n.primeFactors, q ≠ p → a ≡ 1 [MOD q] := by
            have h_crt : ∃ a : ℕ, a ≡ h_primitive_root.choose [MOD p] ∧ a ≡ 1 [MOD (∏ q ∈ n.primeFactors \ {p}, q)] := by
              have h_crt : Nat.gcd p (∏ q ∈ n.primeFactors \ {p}, q) = 1 := by
                exact Nat.Coprime.prod_right fun q hq => by have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors hp ) ( Nat.prime_of_mem_primeFactors ( Finset.mem_sdiff.mp hq |>.1 ) ) ; aesop;
              have := Nat.chineseRemainder h_crt;
              exact ⟨ _, this _ _ |>.2 ⟩;
            exact ⟨ h_crt.choose, h_crt.choose_spec.1, fun q hq hqp => h_crt.choose_spec.2.of_dvd <| Finset.dvd_prod_of_mem _ <| by aesop ⟩;
          refine' ⟨ a, _, _ ⟩;
          · refine' Nat.coprime_of_dvd' _;
            intro q hq hqn hqa; by_cases hqp : q = p <;> simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ] ;
            have := h_primitive_root.choose_spec.1; have := Nat.dvd_gcd ( dvd_refl p ) ( Nat.dvd_of_mod_eq_zero hqa ) ; aesop;
          · haveI := Fact.mk ( Nat.prime_of_mem_primeFactors hp ) ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
            exact h_primitive_root.choose_spec.2;
        rw [ ← ha.2, orderOf_dvd_iff_pow_eq_one ];
        simpa [ ← ZMod.natCast_eq_natCast_iff ] using hn₂ a ha.1 |> Nat.ModEq.of_dvd ( Nat.dvd_of_mem_primeFactors hp );
      exact h_carmichael p hp

lemma agoh_giuga_sum_false_of_even (n : ℕ) (h : Even n) (hn : 4 ≤ n) : ¬ AgohGiugaSum n := by
  unfold AgohGiugaSum;
  -- Since $n$ is even, we can pair each term $i^{n-1}$ with $(n-i)^{n-1}$.
  have h_pair : ∀ i ∈ Finset.Ioo 0 n, i ^ (n - 1) + (n - i) ^ (n - 1) ≡ 0 [MOD n] := by
    -- Since $n$ is even, we can pair each term $i^{n-1}$ with $(n-i)^{n-1}$ and show that their sum is divisible by $n$.
    intros i hi
    have h_pair : i ^ (n - 1) + (n - i) ^ (n - 1) ≡ i ^ (n - 1) + (-i) ^ (n - 1) [ZMOD n] := by
      exact Int.ModEq.add_left _ ( Int.ModEq.pow _ ( Int.modEq_iff_dvd.mpr ⟨ -1, by ring ⟩ ) );
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ ← Int.natCast_modEq_iff, parity_simps ];
    simp_all +decide [ Nat.cast_sub ( by linarith : i ≤ n + 1 + 1 ), parity_simps ];
    simp_all +decide [ Odd.neg_pow, parity_simps ];
  -- Since $n$ is even, we can pair each term $i^{n-1}$ with $(n-i)^{n-1}$ and sum them up.
  have h_sum_pair : ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) + ∑ i ∈ Finset.Ioo 0 n, (n - i) ^ (n - 1) ≡ 0 [MOD n] := by
    simpa only [ ← Finset.sum_add_distrib ] using Nat.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun i hi => Nat.dvd_of_mod_eq_zero <| h_pair i hi;
  -- Since $\sum_{i=1}^{n-1} (n-i)^{n-1} = \sum_{i=1}^{n-1} i^{n-1}$, we can simplify the expression.
  have h_sum_eq : ∑ i ∈ Finset.Ioo 0 n, (n - i) ^ (n - 1) = ∑ i ∈ Finset.Ioo 0 n, i ^ (n - 1) := by
    apply Finset.sum_bij (fun i hi => n - i);
    · exact fun i hi => Finset.mem_Ioo.mpr ⟨ Nat.sub_pos_of_lt <| Finset.mem_Ioo.mp hi |>.2, Nat.sub_lt ( by linarith ) <| Finset.mem_Ioo.mp hi |>.1 ⟩;
    · intro a₁ ha₁ a₂ ha₂ h_eq; rw [ tsub_right_inj ] at h_eq <;> linarith [ Finset.mem_Ioo.mp ha₁, Finset.mem_Ioo.mp ha₂ ] ;
    · exact fun i hi => ⟨ n - i, Finset.mem_Ioo.mpr ⟨ Nat.sub_pos_of_lt <| Finset.mem_Ioo.mp hi |>.2, Nat.sub_lt ( by linarith ) <| Finset.mem_Ioo.mp hi |>.1 ⟩, Nat.sub_sub_self <| Finset.mem_Ioo.mp hi |>.2.le ⟩;
    · exact?;
  simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
  rw [ Nat.cast_sub ( by linarith ) ] ; simp_all +decide [ ← two_mul ];
  intro H; simp_all +decide [ ← eq_sub_iff_add_eq ] ;
  rcases n with ( _ | _ | _ | n ) <;> cases h_sum_pair <;> contradiction

lemma prod_first_9_odd_primes_gt_1m :
    (3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 : ℕ) > 1000000 := by
      -- We can calculate this product directly.
      norm_num

lemma odd_of_strong_giuga (n : ℕ) (hn : IsStrongGiuga n) : Odd n := by
  -- Assume n is even and derive a contradiction.
  by_contra h_even
  have h_contradiction : ¬AgohGiugaSum n := by
    apply agoh_giuga_sum_false_of_even;
    · simpa using h_even;
    · rcases n with ( _ | _ | _ | _ | n ) <;> simp_all +arith +decide;
      · cases hn.1.1;
      · cases hn.1 ; contradiction;
  exact h_contradiction hn.2

theorem no_giuga_below_1m : ∀ n < 1000000, ¬ IsStrongGiuga n := by
  intro n hn_lt hn_strong_giuga
  have h_prime_factors_card : 9 ≤ n.primeFactors.card := by
    exact?;
  -- Since $n$ is a product of at least 9 distinct primes and $n < 10^6$, we can calculate the minimum possible value of $n$.
  have h_min_prod : ∏ p ∈ n.primeFactors, p ≥ ∏ i ∈ Finset.range 9, Nat.nth Nat.Prime i := by
    -- Since $n$ is a product of at least 9 distinct primes, we can order them as $p_1 < p_2 < \cdots < p_9$.
    obtain ⟨ps, hps⟩ : ∃ ps : Fin 9 → ℕ, StrictMono ps ∧ ∀ i, ps i ∈ n.primeFactors := by
      exact ⟨ fun i => n.primeFactors.orderEmbOfFin rfl ⟨ i, by linarith [ Fin.is_lt i ] ⟩, by simp +decide [ StrictMono ], fun i => by simp +decide ⟩;
    -- Since $ps$ is strictly monotone, we have $ps i \geq Nat.nth Nat.Prime i$ for all $i$.
    have h_ps_ge_nth : ∀ i, ps i ≥ Nat.nth Nat.Prime i := by
      intro i;
      induction' i using Fin.inductionOn with i IH;
      · simp +zetaDelta at *;
        exact Nat.Prime.two_le ( hps.2 0 |>.1 );
      · rw [ Nat.nth_eq_sInf ];
        refine' Nat.sInf_le ⟨ _, _ ⟩;
        · exact Nat.prime_of_mem_primeFactors ( hps.2 _ );
        · intro k hk; exact lt_of_le_of_lt ( Nat.nth_monotone ( Nat.infinite_setOf_prime ) ( Nat.le_of_lt_succ hk ) ) ( lt_of_le_of_lt IH ( hps.1 ( Fin.castSucc_lt_succ i ) ) ) ;
    have h_prod_ge_nth : ∏ p ∈ Finset.image ps Finset.univ, p ≥ ∏ i ∈ Finset.range 9, Nat.nth Nat.Prime i := by
      rw [ Finset.prod_image <| by intros i hi j hj hij; exact hps.1.injective hij ];
      simpa only [ Finset.prod_range ] using Finset.prod_le_prod' fun i _ => h_ps_ge_nth i;
    exact h_prod_ge_nth.trans ( Finset.prod_le_prod_of_subset_of_one_le' ( Finset.image_subset_iff.mpr fun i _ => hps.2 i ) fun _ _ _ => Nat.pos_of_mem_primeFactors ‹_› );
  -- Calculate the product of the first 9 primes.
  have h_prod_first_9 : ∏ i ∈ Finset.range 9, Nat.nth Nat.Prime i = 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 := by
    have h_prime_values : Nat.nth Nat.Prime 0 = 2 ∧ Nat.nth Nat.Prime 1 = 3 ∧ Nat.nth Nat.Prime 2 = 5 ∧ Nat.nth Nat.Prime 3 = 7 ∧ Nat.nth Nat.Prime 4 = 11 ∧ Nat.nth Nat.Prime 5 = 13 ∧ Nat.nth Nat.Prime 6 = 17 ∧ Nat.nth Nat.Prime 7 = 19 ∧ Nat.nth Nat.Prime 8 = 23 := by
      -- We can prove this by evaluating each nth prime directly.
      have h_prime2 : Nat.nth Nat.Prime 0 = 2 := by
        simp +zetaDelta at *
      have h_prime3 : Nat.nth Nat.Prime 1 = 3 := by
        bound
      have h_prime5 : Nat.nth Nat.Prime 2 = 5 := by
        bound
      have h_prime7 : Nat.nth Nat.Prime 3 = 7 := by
        exact?
      have h_prime11 : Nat.nth Nat.Prime 4 = 11 := by
        bound
      have h_prime13 : Nat.nth Nat.Prime 5 = 13 := by
        rw [ Nat.nth_eq_sInf ];
        refine Nat.le_antisymm ?_ ?_;
        · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
        · exact le_csInf ⟨ 13, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 4 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
      have h_prime17 : Nat.nth Nat.Prime 6 = 17 := by
        rw [ Nat.nth_eq_sInf ];
        refine Nat.le_antisymm ?_ ?_;
        · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
        · exact le_csInf ⟨ 17, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 5 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
      have h_prime19 : Nat.nth Nat.Prime 7 = 19 := by
        rw [ Nat.nth_eq_sInf ];
        refine Nat.le_antisymm ?_ ?_;
        · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
        · exact le_csInf ⟨ 19, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 6 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
      have h_prime23 : Nat.nth Nat.Prime 8 = 23 := by
        rw [ Nat.nth_eq_sInf ];
        refine Nat.le_antisymm ?_ ?_;
        · exact Nat.sInf_le ⟨ by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩;
        · exact le_csInf ⟨ 29, by norm_num, fun k hk => by interval_cases k <;> norm_num [ * ] ⟩ fun x hx => not_lt.1 fun contra => by have := hx.2 7 ( by norm_num ) ; interval_cases x <;> simp_all +decide only ;
      exact ⟨h_prime2, h_prime3, h_prime5, h_prime7, h_prime11, h_prime13, h_prime17, h_prime19, h_prime23⟩;
    norm_num [ Finset.prod_range_succ, h_prime_values ];
  linarith [ Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( Nat.prod_primeFactors_dvd n ) ]

theorem strong_giuga_lower_bound (n : ℕ) (hn : IsStrongGiuga n) : n ≥ 1000000 := by
  exact le_of_not_gt fun h => no_giuga_below_1m n h hn

theorem agoh_giuga_easy (p : ℕ) (hp : p.Prime) :
    p ∣ 1 + ∑ i ∈ Finset.Ioo 0 p, i^(p - 1) := by
      -- By Fermat's Little Theorem, we know that $i^{p-1} \equiv 1 \pmod{p}$ for any integer $i$ not divisible by $p$.
      have h_fermat_p : ∀ i ∈ Finset.Ioo 0 p, i ^ (p - 1) ≡ 1 [MOD p] := by
        -- By Fermat's Little Theorem, since $p$ is prime and $i$ is not divisible by $p$, we have $i^{p-1} \equiv 1 \pmod{p}$.
        intros i hi
        have h_not_div : ¬(p ∣ i) := by
          exact Nat.not_dvd_of_pos_of_lt ( Finset.mem_Ioo.mp hi |>.1 ) ( Finset.mem_Ioo.mp hi |>.2 );
        exact Nat.totient_prime hp ▸ Nat.ModEq.pow_totient ( Nat.coprime_comm.mp <| hp.coprime_iff_not_dvd.mpr h_not_div );
      -- Therefore, $\sum_{i=1}^{p-1} i^{p-1} \equiv p-1 \equiv -1 \pmod{p}$.
      have h_sum_mod_p : ∑ i ∈ Finset.Ioo 0 p, i ^ (p - 1) ≡ p - 1 [MOD p] := by
        simpa [ Nat.modEq_iff_dvd ] using Finset.dvd_sum fun x hx => Nat.modEq_iff_dvd.mp ( h_fermat_p x hx );
      rw [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, h_sum_mod_p ] ; rcases p with ( _ | _ | p ) <;> simp_all +arith +decide [ Nat.ModEq, Nat.mod_eq_of_lt ]

theorem agoh_giuga_conditional (h_open : ∀ n, 1000000 ≤ n → IsStrongGiuga n → n.Prime) :
    ∀ n : ℕ, 2 ≤ n → IsStrongGiuga n → n.Prime := by
      -- By combining the results from `no_giuga_below_1m` and `h_open`, we can conclude that for any $n \geq 2$, if $n$ is a strong Giuga number, then $n$ must be prime.
      intros n hn h_strong_giuga
      by_cases h_lt : n < 1000000;
      · exact absurd h_strong_giuga ( no_giuga_below_1m n h_lt );
      · exact h_open n ( le_of_not_gt h_lt ) h_strong_giuga

theorem agoh_giuga_iff_open :
    (∀ n : ℕ, 2 ≤ n → IsStrongGiuga n → n.Prime) ↔ (∀ n : ℕ, 1000000 ≤ n → IsStrongGiuga n → n.Prime) := by
  constructor
  · intro h n hn_ge_1m h_giuga
    exact h n (le_trans (by norm_num) hn_ge_1m) h_giuga
  · intro h n hn_ge_2 h_giuga
    by_cases h_lt : n < 1000000
    · exfalso
      exact no_giuga_below_1m n h_lt h_giuga
    · exact h n (le_of_not_lt h_lt) h_giuga

lemma sum_inv_first_8_odd_primes_lt_1 : (1/3 + 1/5 + 1/7 + 1/11 + 1/13 + 1/17 + 1/19 + 1/23 : ℚ) < 1 := by
  native_decide +revert

/-
The Agoh-Giuga conjecture states that a composite number n is a Giuga number if and only if sum_{i=1}^{n-1} i^{n-1} == -1 (mod n).
-/
def AgohGiugaConjecture : Prop := ∀ n : ℕ, 2 ≤ n → IsStrongGiuga n → n.Prime

theorem agoh_giuga_bounds :
    (∀ n < 1000000, ¬ IsStrongGiuga n) ∧
    (∀ n, IsStrongGiuga n → n.primeFactors.card ≥ 9) := by
  constructor
  · exact no_giuga_below_1m
  · exact giuga_min_9_factors