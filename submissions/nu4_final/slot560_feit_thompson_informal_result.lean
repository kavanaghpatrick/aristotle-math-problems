/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 86a83c3c-c395-4f41-8e00-2d421a124e1c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Feit-Thompson conjecture holds for p=2.
-/
theorem feit_thompson_primes_p_eq_2 (q : ℕ) (hq : q.Prime) (h : 2 < q) :
    ¬ (q ^ 2 - 1) / (q - 1) ∣ (2 ^ q - 1) / (2 - 1) := by
      norm_num [ show q ^ 2 - 1 = ( q - 1 ) * ( q + 1 ) by convert Nat.sq_sub_sq q 1 using 1 ; ring, Nat.mul_div_cancel_left _ ( Nat.sub_pos_of_lt hq.one_lt ) ];
      -- Since $q$ is a prime greater than 2, $q+1$ is even, and $2^q - 1$ is odd.
      have h_even_odd : Even (q + 1) ∧ Odd (2 ^ q - 1) := by
        simpa [ Nat.one_le_iff_ne_zero, hq.ne_zero, parity_simps ] using hq.eq_two_or_odd'.resolve_left h.ne';
      exact fun h => absurd ( even_iff_two_dvd.mpr ( dvd_trans ( even_iff_two_dvd.mp h_even_odd.1 ) h ) ) ( by simpa using h_even_odd.2 )

/-
If a prime r divides both cyclotomic polynomials Phi_p(q) and Phi_q(p), then r is congruent to 1 modulo pq.
-/
theorem feit_thompson_prime_divisor_congruence (p q r : ℕ) (hp : p.Prime) (hq : q.Prime) (hr : r.Prime) (hpq : p ≠ q)
    (h_div : r ∣ (q ^ p - 1) / (q - 1)) (h_div2 : r ∣ (p ^ q - 1) / (p - 1)) :
    r ≡ 1 [MOD p * q] := by
      -- From Lemma 2, we know that r ≡ 1 (mod p) and r ≡ 1 (mod q).
      have h_cong : r ≡ 1 [MOD p] ∧ r ≡ 1 [MOD q] := by
        constructor;
        · haveI := Fact.mk hp; haveI := Fact.mk hr; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub <| Nat.one_le_pow _ _ hq.pos ] ;
          -- Since $r$ divides $(q^p - 1)/(q - 1)$, we have $q^p ≡ 1 \mod r$.
          have h_q_p : q^p ≡ 1 [MOD r] := by
            rw [ ← Nat.geomSum_eq hq.one_lt ] at *;
            simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
            linear_combination' h_div * ( q - 1 ) - geom_sum_mul ( q : ZMod r ) p
          -- Thus, the order of $q$ modulo $r$ divides both $p$ and $r-1$.
          have h_order_divides : orderOf (q : ZMod r) ∣ p ∧ orderOf (q : ZMod r) ∣ r - 1 := by
            haveI := Fact.mk hr; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, orderOf_dvd_iff_pow_eq_one ] ;
            rw [ ZMod.pow_card_sub_one_eq_one ] ; cases p <;> aesop_cat;
          -- Since $p$ is prime, the order of $q$ modulo $r$ must be $1$ or $p$.
          have h_order : orderOf (q : ZMod r) = 1 ∨ orderOf (q : ZMod r) = p := by
            rw [ Nat.dvd_prime hp ] at h_order_divides ; tauto;
          -- If the order of $q$ modulo $r$ is $1$, then $q ≡ 1 \mod r$, which implies $r \mid q - 1$.
          by_cases h_order_one : orderOf (q : ZMod r) = 1
          ·
            haveI := Fact.mk hp; ( haveI := Fact.mk hq; ( erw [ ← Nat.geomSum_eq hq.one_lt ] at *; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ; ) );
            rw [ ZMod.natCast_eq_zero_iff ] at * ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ];
            rw [ ← Nat.geomSum_eq hp.one_lt ] at h_div2 ; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
          -- If the order of $q$ modulo $r$ is $p$, then by Fermat's Little Theorem, $p \mid r - 1$.
          have h_p_div_r_minus_1 : p ∣ r - 1 := by
            grind
          -- Therefore, $r ≡ 1 \mod p$.
          exact Nat.ModEq.symm (Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub hr.pos ] using h_p_div_r_minus_1);
        · -- By Fermat's Little Theorem, we know that $p^q \equiv 1 \pmod{r}$ implies $q \mid r - 1$.
          have h_fermat : q ∣ r - 1 := by
            have h_order : orderOf (p : ZMod r) = q := by
              have h_order : orderOf (p : ZMod r) ∣ q := by
                rw [ orderOf_dvd_iff_pow_eq_one ];
                haveI := Fact.mk hr; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub ( Nat.one_le_pow _ _ hp.pos ) ] ;have h_cong : p ^ q ≡ 1 [MOD r] := by
                  rw [ ← Nat.geomSum_eq hp.one_lt ] at *;
                  simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
                  linear_combination' h_div2 * ( p - 1 ) - geom_sum_mul ( p : ZMod r ) q;
                simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_cong
              have h_order_ne_one : orderOf (p : ZMod r) ≠ 1 := by
                intro H; haveI := Fact.mk hr; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.cast_sub <| Nat.one_le_pow _ _ hp.pos ] ;
                rw [ ← Nat.geomSum_eq hp.one_lt ] at * ; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
                rw [ ZMod.natCast_eq_zero_iff ] at * ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ];
                rw [ ← Nat.geomSum_eq hq.one_lt ] at h_div ; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;
                rcases p with ( _ | _ | p ) <;> rcases q with ( _ | _ | q ) <;> simp_all +decide [ ZMod ]
              have h_order_eq_q : orderOf (p : ZMod r) = q := by
                rw [ Nat.dvd_prime hq ] at h_order ; aesop
              exact h_order_eq_q;
            haveI := Fact.mk hr; rw [ ← h_order, orderOf_dvd_iff_pow_eq_one ];
            rw [ ZMod.pow_card_sub_one_eq_one ] ; cases p <;> aesop;
          exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, hr.pos ] using h_fermat );
      rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ] ; tauto;
      simpa [ hpq ] using Nat.coprime_primes hp hq

/-
If Phi_p(q) divides Phi_q(p), then q is not congruent to 1 modulo p.
-/
theorem feit_thompson_mod_p (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h : p < q)
    (h_div : (q ^ p - 1) / (q - 1) ∣ (p ^ q - 1) / (p - 1)) :
    ¬ (q ≡ 1 [MOD p]) := by
      -- Assume for contradiction that $q \equiv 1 \pmod{p}$.
      by_contra h_contra
      have hq_mod_p : q ^ p ≡ 1 [ZMOD p] := by
        simpa using Int.natCast_modEq_iff.mpr ( h_contra.pow _ );
      -- Since $(q^p - 1) / (q - 1) | (p^q - 1) / (p - 1)$, we have $p | (p^q - 1) / (p - 1)$.
      have hp_div : (p : ℤ) ∣ ((p ^ q - 1) / (p - 1)) := by
        have hp_div : (p : ℤ) ∣ ((q ^ p - 1) / (q - 1)) := by
          have hp_div : (p : ℤ) ∣ (∑ i ∈ Finset.range p, (q : ℤ) ^ i) := by
            simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, ← ZMod.natCast_eq_natCast_iff ];
          rwa [ ← geom_sum_mul, Int.mul_ediv_cancel _ ( sub_ne_zero_of_ne <| mod_cast hq.ne_one ) ] at *;
        norm_cast at *;
        rw [ Int.subNatNat_of_le ( Nat.one_le_pow _ _ hq.pos ), Int.subNatNat_of_le ( Nat.one_le_pow _ _ hp.pos ), Int.subNatNat_of_le hq.pos, Int.subNatNat_of_le hp.pos ] at * ; norm_cast at * ; exact dvd_trans hp_div h_div;
      -- But $(p^q - 1) / (p - 1) = 1 + p + p^2 + \cdots + p^{q-1}$, which is not divisible by $p$.
      have hp_not_div : ¬((p : ℤ) ∣ (∑ i ∈ Finset.range q, p ^ i)) := by
        haveI := Fact.mk hp; norm_num [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, geom_sum_mul ] ;
        grind;
      convert hp_not_div ?_; simp_all +decide [ ← geom_sum_mul, hp.ne_one ] ;
      exact hp_not_div ( by obtain ⟨ k, hk ⟩ := hp_div; exact ⟨ k, by nlinarith [ hp.two_le ] ⟩ )

/-
For primes p < q, q^(p-1) < p^q.
-/
lemma feit_thompson_size_lemma (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h : p < q) :
    q ^ (p - 1) < p ^ q := by
      -- For primes $p < q$, we have $p \geq 3$ and $q \geq 5$ because $p$ is odd and $q$ is prime.
      by_cases hp3 : p ≥ 3
      by_cases hq5 : q ≥ 5;
      · -- We want to show $q^{p-1} < p^q$.
        -- Since $p < q$, we have $p \geq 3$ and $q \geq 5$.
        -- The function $f(x) = \frac{\ln x}{x}$ is strictly decreasing for $x \geq 3$.
        have h_decreasing : (Real.log q) / q < (Real.log p) / p := by
          -- We need to show $\frac{\ln q}{q} < \frac{\ln p}{p}$ for $p < q$.
          -- Consider the function $f(x) = \frac{\ln x}{x}$.
          set f : ℝ → ℝ := fun x => Real.log x / x
          have h_f_deriv_neg : ∀ x ≥ 3, deriv f x < 0 := by
            intro x hx;
            simp +zetaDelta at *;
            norm_num [ show x ≠ 0 by linarith ];
            exact div_neg_of_neg_of_pos ( sub_neg_of_lt ( by rw [ Real.lt_log_iff_exp_lt ( by positivity ) ] ; exact Real.exp_one_lt_d9.trans_le ( by norm_num; linarith ) ) ) ( sq_pos_of_pos ( by positivity ) );
          -- Since $f$ is differentiable and its derivative is negative for $x \geq 3$, we can apply the Mean Value Theorem to $f$ on the interval $[p, q]$.
          have h_mvt : ∃ c ∈ Set.Ioo (p : ℝ) q, deriv f c = (f q - f p) / (q - p) := by
            apply_rules [ exists_deriv_eq_slope ];
            · norm_cast;
            · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div ( Real.continuousAt_log ( by linarith [ hx.1, show ( p : ℝ ) ≥ 3 by norm_cast ] ) ) continuousAt_id ( by linarith [ hx.1, show ( p : ℝ ) ≥ 3 by norm_cast ] );
            · exact DifferentiableOn.div ( DifferentiableOn.log differentiableOn_id fun x hx => ne_of_gt <| lt_trans ( by positivity ) hx.1 ) differentiableOn_id fun x hx => ne_of_gt <| lt_trans ( by positivity ) hx.1;
          obtain ⟨ c, hc₁, hc₂ ⟩ := h_mvt; have := h_f_deriv_neg c ( by linarith [ hc₁.1, show ( p : ℝ ) ≥ 3 by norm_cast ] ) ; rw [ hc₂, div_lt_iff₀ ] at this <;> aesop;
        -- So $p \ln q < q \ln p$, which implies $q^p < p^q$.
        have h_exp : q ^ p < p ^ q := by
          rw [ div_lt_div_iff₀ ( by positivity ) ( by positivity ) ] at h_decreasing;
          rw [ ← @Nat.cast_lt ℝ ] ; push_cast ; rw [ ← Real.log_lt_log_iff ( by norm_cast ; exact pow_pos hq.pos _ ) ( by norm_cast ; exact pow_pos hp.pos _ ) ] ; simpa [ mul_comm ] using h_decreasing;
        exact lt_of_le_of_lt ( Nat.pow_le_pow_right hq.pos ( Nat.pred_le _ ) ) h_exp;
      · interval_cases q <;> interval_cases p ; trivial;
      · interval_cases p <;> simp_all +decide;
        exact?

/-
If a prime r divides both cyclotomic polynomials, then r is congruent to 1 modulo q.
-/
theorem feit_thompson_prime_factor_mod_q (p q r : ℕ) (hp : p.Prime) (hq : q.Prime) (hr : r.Prime) (h : p < q)
    (h_div : r ∣ (q ^ p - 1) / (q - 1)) (h_div2 : r ∣ (p ^ q - 1) / (p - 1)) :
    r ≡ 1 [MOD q] := by
      have := feit_thompson_prime_divisor_congruence p q r hp hq hr ( ne_of_lt h ) h_div h_div2;
      exact this.of_dvd <| dvd_mul_left _ _

/-
If Phi_p(q) divides Phi_q(p), then Phi_p(q) is congruent to 1 modulo pq.
-/
theorem feit_thompson_congruence_1_mod_pq (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h : p < q)
    (h_div : (q ^ p - 1) / (q - 1) ∣ (p ^ q - 1) / (p - 1)) :
    (q ^ p - 1) / (q - 1) ≡ 1 [MOD p * q] := by
      -- By feit_thompson_prime_divisor_congruence, each prime factor of $(q^p - 1)/(q - 1)$ is congruent to 1 modulo pq.
      have h_prime_factors : ∀ r : ℕ, Nat.Prime r → r ∣ (q ^ p - 1) / (q - 1) → r ≡ 1 [MOD p * q] := by
        intro r hr hr_div
        have hr_div2 : r ∣ (p ^ q - 1) / (p - 1) := by
          exact dvd_trans hr_div h_div
        exact feit_thompson_prime_divisor_congruence p q r hp hq hr (by
        linarith) hr_div hr_div2;
      rw [ ← Nat.factorization_prod_pow_eq_self ( show ( q ^ p - 1 ) / ( q - 1 ) ≠ 0 from Nat.ne_of_gt ( Nat.div_pos ( Nat.le_sub_one_of_lt ( lt_of_lt_of_le ( Nat.sub_lt hq.pos zero_lt_one ) ( Nat.le_self_pow hp.ne_zero _ ) ) ) ( Nat.sub_pos_of_lt hq.one_lt ) ) ) ];
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      exact Finset.prod_eq_one fun x hx => by aesop;

/-
If the divisibility holds for p=3, then q^2+q+1 is prime.
-/
lemma feit_thompson_p_eq_3_A_prime (q : ℕ) (hq : q.Prime) (h : 3 < q)
    (h_div : (q ^ 3 - 1) / (q - 1) ∣ (3 ^ q - 1) / (3 - 1)) :
    (q ^ 2 + q + 1).Prime := by
      have := feit_thompson_prime_divisor_congruence 3 q;
      -- By contradiction, assume that $q^2 + q + 1$ is not prime.
      by_contra h_not_prime;
      -- Since $q^2 + q + 1$ is not prime, it must have at least two prime factors.
      obtain ⟨r, hr⟩ : ∃ r : ℕ, Nat.Prime r ∧ r ∣ q^2 + q + 1 ∧ r ≤ Nat.sqrt (q^2 + q + 1) := by
        obtain ⟨ r, hr₁, hr₂ ⟩ := Nat.exists_prime_and_dvd ( by nlinarith : q ^ 2 + q + 1 ≠ 1 );
        obtain ⟨ s, hs ⟩ := hr₂;
        cases le_total r s <;> [ exact ⟨ r, hr₁, hs.symm ▸ dvd_mul_right _ _, by rw [ Nat.le_sqrt ] ; nlinarith ⟩ ; exact ⟨ s.minFac, Nat.minFac_prime ( by aesop ), hs.symm ▸ dvd_mul_of_dvd_right ( Nat.minFac_dvd _ ) _, by rw [ Nat.le_sqrt ] ; nlinarith [ Nat.minFac_le ( Nat.pos_of_ne_zero ( by aesop : s ≠ 0 ) ) ] ⟩ ];
      -- Since $r$ divides $q^2 + q + 1$, we have $r \equiv 1 \pmod{3q}$.
      have hr_mod : r ≡ 1 [MOD 3 * q] := by
        apply this r (by norm_num) hq hr.left (by linarith);
        · exact hr.2.1.trans ( by rw [ show q ^ 3 - 1 = ( q ^ 2 + q + 1 ) * ( q - 1 ) by zify; cases q <;> norm_num ; linarith ] ; exact Nat.dvd_div_of_mul_dvd ( by exact ⟨ 1, by ring ⟩ ) );
        · exact dvd_trans hr.2.1 ( by rw [ show ( q ^ 3 - 1 ) / ( q - 1 ) = q ^ 2 + q + 1 from Nat.div_eq_of_eq_mul_left ( Nat.sub_pos_of_lt hq.one_lt ) <| Nat.sub_eq_of_eq_add <| by zify ; cases q <;> norm_num at * ; linarith ] at h_div ; aesop );
      -- Since $r \equiv 1 \pmod{3q}$, we have $r \geq 3q + 1$.
      have hr_ge : r ≥ 3 * q + 1 := by
        exact Nat.succ_le_of_lt ( Nat.lt_of_le_of_ne ( Nat.le_of_not_gt fun h => by rw [ Nat.ModEq ] at hr_mod; rw [ Nat.mod_eq_of_lt, Nat.mod_eq_of_lt ] at hr_mod <;> linarith [ hr.1.two_le ] ) ( Ne.symm <| by intro t; simp_all +decide [ Nat.ModEq ] ) );
      nlinarith only [ hr_ge, hr.2.2, Nat.sqrt_le ( q ^ 2 + q + 1 ), h ]

/-
If the divisibility holds for p=3, then q is congruent to 2 modulo 3.
-/
lemma feit_thompson_q_mod_3 (q : ℕ) (hq : q.Prime) (h : 3 < q)
    (h_div : (q ^ 3 - 1) / (q - 1) ∣ (3 ^ q - 1) / (3 - 1)) :
    q ≡ 2 [MOD 3] := by
      -- By feit_thompson_congruence_1_mod_pq (with p=3), (q^3 - 1) / (q - 1) ≡ 1 [MOD 3q]
      have h_cong : (q ^ 3 - 1) / (q - 1) ≡ 1 [MOD 3 * q] := by
        convert feit_thompson_congruence_1_mod_pq 3 q ( by decide ) hq ( by linarith ) h_div using 1
      norm_num [Nat.ModEq] at h_cong ⊢
      skip
      have h_mod3 : q ^ 2 + q + 1 ≡ 1 [MOD 3] := by
        have h_mod3 : (q ^ 3 - 1) / (q - 1) ≡ 1 [MOD 3] := by
          exact Nat.ModEq.of_dvd ( dvd_mul_right _ _ ) h_cong
        have h_mod3_eq : (q ^ 3 - 1) / (q - 1) = q ^ 2 + q + 1 := by
          exact Nat.div_eq_of_eq_mul_left ( Nat.sub_pos_of_lt hq.one_lt ) ( Nat.sub_eq_of_eq_add <| by cases q <;> norm_num at * ; linarith )
        rw [h_mod3_eq] at h_mod3
        exact h_mod3
      norm_num [Nat.ModEq] at h_mod3 ⊢
      skip
      have h_mod3_q : q ≡ 2 [MOD 3] := by
        rw [ Nat.ModEq ] ; norm_num [ Nat.add_mod, Nat.pow_mod ] at *; have := Nat.mod_lt q three_pos; interval_cases _ : q % 3 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hq.dvd_iff_eq ] ;
      exact h_mod3_q

/-
The term (p^q - 1)/(p - 1) is congruent to 1 modulo pq.
-/
theorem feit_thompson_B_cong_1_mod_pq (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h : p < q) :
    (p ^ q - 1) / (p - 1) ≡ 1 [MOD p * q] := by
      -- We can prove this using Fermat's Little Theorem.
      have h_flt_p : (p ^ q - 1) / (p - 1) ≡ 1 [MOD p] := by
        rw [ ← Nat.geomSum_eq hp.one_lt ];
        cases p <;> cases q <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Finset.sum_range_succ' ]
      have h_flt_q : (p ^ q - 1) / (p - 1) ≡ 1 [MOD q] := by
        haveI := Fact.mk hq; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Nat.cast_sub ( Nat.one_le_pow q p hp.pos ) ] ;
        rw [ ← Nat.geomSum_eq hp.one_lt ] ; norm_num;
        by_cases hpq : ( p : ZMod q ) = 1 <;> simp_all +decide [ geom_sum_eq ];
        · rcases p with ( _ | _ | p ) <;> simp_all +decide [ ZMod.natCast_eq_natCast_iff' ];
          norm_cast at hpq;
          rw [ ZMod.natCast_eq_zero_iff ] at hpq ; linarith [ Nat.le_of_dvd ( Nat.succ_pos _ ) hpq ];
        · exact div_self ( sub_ne_zero_of_ne hpq );
      rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ] ; tauto;
      simpa [ h.ne ] using Nat.coprime_primes hp hq

/-
If kq+1 divides q^2+q+1, then k=q+1 (assuming k>1 or p prime).
-/
lemma lemma_algebra_helper (q k : ℕ) (hq : q ≥ 4) (hk : k ≥ 1) (h_div_A : k * q + 1 ∣ q ^ 2 + q + 1) : k = q + 1 := by
  -- Let's consider the two cases when $k \leq q$ and $k > q$ separately.
  by_cases hk_le_q : k ≤ q;
  · obtain ⟨ m, hm ⟩ := h_div_A;
    rcases m with ( _ | _ | _ | m ) <;> rcases k with ( _ | _ | _ | k ) <;> norm_num at * <;> repeat nlinarith;
    · nlinarith only [ hm, hk_le_q, show q ≤ 2 * k + 5 by nlinarith only [ hm, hk_le_q ] ];
    · nlinarith [ show m + 2 = q by nlinarith ];
    · nlinarith only [ hm, show q = 2 * m + 5 by nlinarith only [ hm ] ];
    · nlinarith only [ hm, hk_le_q, show q < ( k + 3 ) * ( m + 3 ) by nlinarith only [ hm, hk_le_q ] ];
  · nlinarith [ Nat.le_of_dvd ( by positivity ) h_div_A ]

/-
If q is 1 mod 4 and 2 mod 3, then (3/A) = -1.
-/
lemma jacobi_three_eq_neg_one_of_q_mod_4_and_2_mod_3 (q : ℕ) (hq : q.Prime) (h_mod4 : q ≡ 1 [MOD 4]) (h_mod3 : q ≡ 2 [MOD 3]) :
    jacobiSym 3 (q ^ 2 + q + 1) = -1 := by
      rw [ jacobiSym.mod_right ];
      · rw [ ← Nat.mod_add_div q 12 ] at *; have := Nat.mod_lt q ( by decide : 0 < 12 ) ; interval_cases q % 12 <;> norm_num [ Nat.ModEq, Nat.add_mod, Nat.pow_mod ] at *;
        all_goals norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
      · simp +arith +decide [ parity_simps ]

/-
If 3^n = 1 mod A and n is odd, then 3 is a quadratic residue mod A.
-/
lemma is_quadratic_residue_of_pow_one_odd (n : ℕ) (A : ℕ) (h : 3^n ≡ 1 [MOD A]) (hn : n % 2 ≠ 0) :
    ∃ x : ZMod A, x^2 = 3 := by
      -- Since $n$ is odd, we can write $n+1=2k$ for some integer $k$.
      obtain ⟨k, hk⟩ : ∃ k, n + 1 = 2 * k := by
        exact Nat.dvd_of_mod_eq_zero ( by omega );
      use 3 ^ k;
      rw [ ← pow_mul' ] ; rw [ ← hk ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      rw [ ← hk, pow_add, pow_one, h, one_mul ]

/-
If q is 1 mod 4 and 2 mod 3, then 3^q is not 1 mod A.
-/
lemma three_pow_q_ne_one_mod_A_of_q_mod_4_eq_1 (q : ℕ) (hq : q.Prime) (h : 3 < q) (h_mod : q ≡ 2 [MOD 3]) (h_mod4 : q ≡ 1 [MOD 4]) (hA_prime : Nat.Prime (q^2+q+1)) :
    3 ^ q % (q ^ 2 + q + 1) ≠ 1 := by
      -- By `jacobi_three_eq_neg_one_of_q_mod_4_and_2_mod_3`, (3/A) = -1.
      have h_jacobi : jacobiSym 3 (q ^ 2 + q + 1) = -1 := by
        convert jacobi_three_eq_neg_one_of_q_mod_4_and_2_mod_3 q hq h_mod4 h_mod using 1;
      -- By `is_quadratic_residue_of_pow_one_odd`, 3 is a quadratic residue mod A.
      by_contra h_contra
      obtain ⟨x, hx⟩ : ∃ x : ZMod (q ^ 2 + q + 1), x^2 = 3 := by
        have h_quad_res : 3 ^ q ≡ 1 [MOD (q ^ 2 + q + 1)] := by
          rwa [ Nat.ModEq, Nat.mod_eq_of_lt hA_prime.two_le ];
        have h_quad_res : ∃ x : ZMod (q ^ 2 + q + 1), x^2 = 3 := by
          have h_odd_q : q % 2 = 1 := by
            exact hq.eq_two_or_odd.resolve_left ( by linarith ) |> fun h => h.symm ▸ rfl
          convert is_quadratic_residue_of_pow_one_odd q ( q ^ 2 + q + 1 ) _ _;
          · exact h_quad_res;
          · aesop;
        exact h_quad_res;
      -- By definition of jacobiSym, we know that if $x^2 = 3$, then $3$ is a quadratic residue modulo $q^2 + q + 1$.
      have h_quad_res : (∃ y : ℕ, y^2 ≡ 3 [MOD (q^2 + q + 1)]) := by
        exact ⟨ x.val, by simpa [ ← ZMod.natCast_eq_natCast_iff ] using hx ⟩;
      rw [ jacobiSym ] at h_jacobi;
      norm_num [ Nat.primeFactorsList_prime hA_prime ] at h_jacobi;
      haveI := Fact.mk hA_prime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, legendreSym.eq_neg_one_iff ] ;
      exact h_jacobi <| by obtain ⟨ y, hy ⟩ := h_quad_res; exact ⟨ y, by simpa [ sq, ← ZMod.intCast_eq_intCast_iff ] using hy.symm ⟩ ;

/-
If 3^q = 1 mod A and q is 2 mod 3, then 3 is a cubic residue mod A.
-/
def IsCube {R : Type*} [CommSemiring R] (x : R) := ∃ y : R, y^3 = x

lemma three_is_cubic_residue_of_pow_one (q : ℕ) (hq : q.Prime) (h_mod : q ≡ 2 [MOD 3]) (A : ℕ) (hA : A = q^2+q+1) (h_pow : 3^q ≡ 1 [MOD A]) :
    IsCube (3 : ZMod A) := by
      -- Let's choose $m$ such that $3m \equiv 1 \pmod{q}$.
      obtain ⟨m, hm⟩ : ∃ m : ℕ, 3 * m ≡ 1 [MOD q] := by
        exact ⟨ ( q + 1 ) / 3, by rw [ mul_comm, Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero <| by rw [ ← Nat.mod_add_div q 3, h_mod ] ; norm_num [ Nat.add_mod, Nat.mul_mod ] ) ] ; simp +decide [ Nat.ModEq ] ⟩;
      -- Since $3^{3m} \equiv 3 \pmod{A}$, we have $(3^m)^3 \equiv 3 \pmod{A}$.
      have h_cube : (3 ^ m) ^ 3 ≡ 3 [MOD A] := by
        -- Since $3^{3m} \equiv 3 \pmod{A}$, we have $(3^m)^3 \equiv 3 \pmod{A}$ by properties of modular arithmetic.
        have h_cube : 3 ^ (3 * m) ≡ 3 [MOD A] := by
          -- Since $3m \equiv 1 \pmod{q}$, we can write $3m = kq + 1$ for some integer $k$.
          obtain ⟨k, hk⟩ : ∃ k : ℕ, 3 * m = k * q + 1 := by
            exact ⟨ ( 3 * m ) / q, by linarith [ Nat.mod_add_div ( 3 * m ) q, hm.symm ▸ Nat.mod_eq_of_lt hq.two_le ] ⟩;
          simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, pow_add, pow_mul' ];
        rwa [ pow_mul' ] at h_cube;
      use 3 ^ m;
      simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_cube