/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0ba3794b-1fcc-42e7-b39d-b9fcbd4ec014

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized Lemoine's Conjecture and verified it for all odd integers $n$ with $7 \le n \le 1000$ using a computable checker and `native_decide`. Additionally, we have proven two structural sufficient conditions: if $n-4$ is prime, or if $(n-3)/2$ is prime (for odd $n$), then $n$ satisfies the conjecture. These results cover the requested bounded verification and structural partial results.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of Lemoine's property and a computable checker for it.
-/
def isLemoine (n : ℕ) : Prop :=
  ∃ p q, p.Prime ∧ q.Prime ∧ p + 2 * q = n

def checkLemoine (n : ℕ) : Bool :=
  (List.range (n / 2 + 1)).any fun q =>
    Nat.Prime q ∧ Nat.Prime (n - 2 * q)

theorem of_checkLemoine {n : ℕ} (h : checkLemoine n = true) : isLemoine n := by
  contrapose! h with h_contra;
  unfold checkLemoine; simp +decide [ h_contra ] ;
  intro x hx₁ hx₂ hx₃; exact h_contra ⟨ n - 2 * x, x, hx₃, hx₂, by omega ⟩ ;

/-
Lemoine's Conjecture holds for all odd n <= 100.
-/
theorem lemoine_upto_100 (n : ℕ) (h1 : 6 < n) (h2 : n ≤ 100) (h3 : Odd n) : isLemoine n := by
  -- By definition of $checkLemoine$, we know that if $checkLemoine n = true$, then $n$ is Lemoine.
  have h_check : checkLemoine n = true := by
    interval_cases n <;> trivial;
  exact of_checkLemoine h_check

/-
Lemoine's Conjecture holds for all odd n <= 1000.
-/
def checkLemoineUpto (N : ℕ) : Bool :=
  (List.range (N + 1)).all fun n =>
    if 6 < n ∧ n % 2 = 1 then checkLemoine n else true

theorem lemoine_upto_1000 : ∀ n, 6 < n → n ≤ 1000 → Odd n → isLemoine n := by
  -- We'll use the fact that if the condition holds for all numbers up to 1000, then it holds for any number up to 1000.
  have h_check : ∀ n ∈ Finset.Icc 7 1000, Odd n → checkLemoine n = true := by
    native_decide;
  exact fun n hn₁ hn₂ hn₃ => of_checkLemoine <| h_check n ( Finset.mem_Icc.mpr ⟨ hn₁, hn₂ ⟩ ) hn₃

/-
Lemoine's Conjecture holds for all odd n <= 1000.
-/
def checkLemoineRange (N : ℕ) : Bool :=
  (List.range (N + 1)).all fun n =>
    if 6 < n ∧ n % 2 = 1 then checkLemoine n else true

theorem lemoine_upto_1000_corrected : ∀ n, 6 < n → n ≤ 1000 → Odd n → isLemoine n := by
  exact?

/-
Checking if Nat.odd_iff exists and has the expected type.
-/
#check Nat.odd_iff

/-
Lemoine's Conjecture holds for all odd n <= 1000.
-/
theorem lemoine_upto_1000_final : ∀ n, 6 < n → n ≤ 1000 → Odd n → isLemoine n := by
  have h : checkLemoineRange 1000 = true := by native_decide
  intro n h_gt h_le h_odd
  have h_mod : n % 2 = 1 := Nat.odd_iff.mp h_odd
  rw [checkLemoineRange, List.all_eq_true] at h
  specialize h n (List.mem_range.mpr (Nat.lt_succ_of_le h_le))
  simp [h_gt, h_mod] at h
  exact of_checkLemoine h

/-
Structural sufficient conditions for Lemoine's conjecture: if $n-4$ is prime, or if $(n-3)/2$ is prime (for odd $n$), then $n$ satisfies the conjecture.
-/
lemma lemoine_of_sub_four_prime (n : ℕ) (h : (n - 4).Prime) : isLemoine n := by
  rcases n with ( _ | _ | _ | _ | _ | _ | n ) <;> simp_all +arith +decide;
  exact ⟨ n + 2, 2, h, by norm_num, by ring ⟩

lemma lemoine_of_half_sub_three_prime (n : ℕ) (h_odd : Odd n) (h : ((n - 3) / 2).Prime) : isLemoine n := by
  rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide [ Nat.even_add ];
  exact ⟨ 3, n / 2, by norm_num, h, by linarith [ Nat.div_mul_cancel ( show 2 ∣ n from even_iff_two_dvd.mp ( by simpa [ parity_simps ] using h_odd ) ) ] ⟩