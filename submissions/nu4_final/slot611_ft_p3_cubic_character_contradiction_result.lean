/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: fa8be15e-ef5b-43be-a89d-6fc465b80934

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves the Feit-Thompson theorem for p=3 for all primes q such that q ≡ 2 (mod 3) and q ≢ 8 (mod 9), assuming that A = q^2 + q + 1 is prime. The proof relies on the unproven key claim that (1-q) is always a cubic residue modulo A.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of A and chi3, and Fact 1: q^3 = 1 mod A and q != 1 mod A.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

def chi3 (q : ℕ) (x : ZMod (A q)) : ZMod (A q) := x ^ ((A q - 1) / 3)

theorem fact1 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) :
  (q : ZMod (A q))^3 = 1 ∧ (q : ZMod (A q)) ≠ 1 := by
    -- By definition of $A$, we know that $q^3 \equiv 1 \pmod{A}$ and $q \not\equiv 1 \pmod{A}$.
    have h_cong : q^3 ≡ 1 [MOD A q] ∧ ¬(q ≡ 1 [MOD A q]) := by
      constructor;
      · unfold A;
        exact Nat.ModEq.symm ( Nat.modEq_of_dvd ⟨ q - 1, by cases q <;> norm_num at * ; linarith ⟩ );
      · rw [ Nat.ModEq, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt ] <;> linarith [ hq.two_le, show A q > q from by { unfold A; nlinarith } ];
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

/-
Fact 2: (1-q)^2 = -3q mod A.
-/
theorem fact2 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) :
  ((1 - q : ZMod (A q))^2) = -3 * (q : ZMod (A q)) := by
    -- Since $q^2 = -(q+1) \mod A$, we have:
    have h_neg : (q^2 : ZMod (A q)) = -(q + 1) := by
      erw [ eq_neg_iff_add_eq_zero ] ; norm_cast ; aesop;
    linear_combination' h_neg

/-
Fact 3: (1-q)(q+2) = 3 mod A.
-/
theorem fact3 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) :
  (1 - q : ZMod (A q)) * (q + 2 : ZMod (A q)) = 3 := by
    -- Simplify the expression using the fact that $q^2 = -q - 1$ in $ZMod (q^2 + q + 1)$.
    have h_simplify : (q^2 : ZMod (q^2 + q + 1)) = -q - 1 := by
      exact eq_sub_of_add_eq <| by rw [ eq_neg_iff_add_eq_zero ] ; norm_cast; erw [ ZMod.natCast_eq_zero_iff ] ; exact ⟨ 1, by ring ⟩ ;
    grind

/-
Fact 4: The value of chi3(q) depends on q mod 9.
-/
theorem fact4 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) (h_mod : q % 3 = 2) :
  (q % 9 = 2 → chi3 q q = q^2) ∧
  (q % 9 = 5 → chi3 q q = q) ∧
  (q % 9 = 8 → chi3 q q = 1) := by
    constructor;
    · intro hq9
      have h_exp : (A q - 1) / 3 ≡ 2 [MOD 3] := by
        unfold A; rw [ ← Nat.mod_add_div q 9, hq9 ] ; ring_nf; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] ;
        grind;
      -- Since $q^3 \equiv 1 \pmod{A q}$, we have $q^{(A q - 1) / 3} \equiv q^2 \pmod{A q}$.
      have h_q3 : (q : ZMod (A q))^3 = 1 := by
        convert fact1 q hq hq3 hA |>.1 using 1;
      -- Since $q^3 \equiv 1 \pmod{A q}$, we have $q^{(A q - 1) / 3} \equiv q^2 \pmod{A q}$ by properties of exponents.
      have h_exp : (q : ZMod (A q))^((A q - 1) / 3) = (q : ZMod (A q))^2 := by
        rw [ ← Nat.mod_add_div ( ( A q - 1 ) / 3 ) 3, h_exp ] ; norm_num [ pow_add, pow_mul, h_q3 ] ;
      exact h_exp;
    · constructor;
      · -- Since $q \equiv 5 \mod 9$, we have $q(q+1)/3 \equiv 1 \mod 3$.
        intro hq5
        have h_exp : (A q - 1) / 3 ≡ 1 [MOD 3] := by
          unfold A; rw [ ← Nat.mod_add_div q 9, hq5 ] ; ring_nf; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] ;
          grind +ring;
        -- Since $q^3 \equiv 1 \mod A$, we have $q^{(A-1)/3} \equiv q \mod A$.
        have h_cong : (q : ZMod (A q)) ^ ((A q - 1) / 3) = (q : ZMod (A q)) ^ ((A q - 1) / 3 % 3) := by
          have h_cong : (q : ZMod (A q)) ^ 3 = 1 := by
            have := fact1 q hq hq3 hA;
            exact this.1;
          rw [ ← Nat.mod_add_div ( ( A q - 1 ) / 3 ) 3, pow_add, pow_mul ] ; aesop;
        rw [ h_exp ] at h_cong; aesop;
      · intro hq9;
        -- Since $q \equiv 8 \pmod{9}$, we have $q(q+1)/3 \equiv 0 \pmod{3}$.
        have h_exp : (A q - 1) / 3 % 3 = 0 := by
          unfold A; rw [ ← Nat.mod_add_div q 9, hq9 ] ; ring_nf ;
          grind;
        -- Since $q^3 \equiv 1 \pmod{A}$, we have $q^{(A-1)/3} \equiv 1 \pmod{A}$.
        have h_chi3_q : (q : ZMod (A q)) ^ ((A q - 1) / 3) = 1 := by
          have h_chi3_q : (q : ZMod (A q)) ^ 3 = 1 := by
            have := fact1 q hq hq3 hA; aesop;
          rw [ ← Nat.mod_add_div ( ( A q - 1 ) / 3 ) 3, h_exp ] ; norm_num [ pow_add, pow_mul, h_chi3_q ] ;
        exact h_chi3_q

/-
(A-1)/3 is even.
-/
theorem exp_is_even (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  2 ∣ (A q - 1) / 3 := by
    -- Let $q = 3k + 2$ for some integer $k$.
    obtain ⟨k, rfl⟩ : ∃ k, q = 3 * k + 2 := by
      exact ⟨ q / 3, by rw [ ← h_mod, Nat.div_add_mod ] ⟩;
    unfold A; norm_num [ Nat.add_mod, Nat.mul_mod ] ; ring_nf;
    norm_num [ show 6 + k * 15 + k ^ 2 * 9 = 3 * ( 2 + k * 5 + k ^ 2 * 3 ) by ring, Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ];
    cases Nat.mod_two_eq_zero_or_one k <;> simp +decide [ *, Nat.pow_mod ]

/-
(A-1) is divisible by 6.
-/
theorem exp_div_six (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  6 ∣ (A q - 1) := by
    unfold A; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.pow_mod, h_mod ] ; rw [ ← Nat.mod_add_div q 6 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; have := Nat.mod_lt q ( by decide : 6 > 0 ) ; interval_cases _ : q % 6 <;> simp_all +decide ;
    · omega;
    · exact absurd ( Nat.Prime.eq_two_or_odd hq ) ( by omega )

/-
Define m = (A-1)/6. Prove 6*m = A-1.
-/
def m (q : ℕ) : ℕ := (A q - 1) / 6

theorem m_is_integer (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  6 * m q = A q - 1 := by
    -- Since 6 divides A q - 1, we can apply the definition of m.
    have h_div : 6 ∣ (A q - 1) := by
      exact?;
    unfold m; exact Nat.mul_div_cancel' h_div;

/-
Prove chi3(1-q) = (-3q)^m.
-/
theorem chi3_eq_pow_m (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  chi3 q (1 - q) = ((-3 * q : ZMod (A q)) ^ m q) := by
    convert congr_arg ( fun x : ZMod ( A q ) => x ^ m q ) ( fact2 q hq hq3 ) using 1 ; ring;
    unfold chi3 m; ring;
    rw [ show ( A q - 1 ) / 3 = 2 * ( ( A q - 1 ) / 6 ) by rw [ Nat.div_eq_of_eq_mul_left zero_lt_three ] ; linarith [ Nat.div_mul_cancel ( show 6 ∣ A q - 1 from exp_div_six q hq hq3 h_mod ) ] ] ; ring;
    rw [ pow_mul' ] ; ring;

/-
m mod 3 depends on q mod 9.
-/
theorem m_mod_3 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  (q % 9 = 2 → m q % 3 = 1) ∧
  (q % 9 = 5 → m q % 3 = 2) ∧
  (q % 9 = 8 → m q % 3 = 0) := by
    unfold m;
    unfold A; rw [ ← Nat.mod_mod_of_dvd q ( by decide : 3 ∣ 9 ) ] at h_mod; have := Nat.mod_lt q ( by decide : 0 < 9 ) ; interval_cases h : q % 9 <;> norm_num [ h, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ;
    · -- If q = 9k + 2, then m = (9k+2)(9k+3)/6 = (9k+2)(3k+1)/2.
      have h_case2 : ∃ k, q = 9 * k + 2 := by
        exact ⟨ q / 9, by rw [ ← h, Nat.div_add_mod ] ⟩;
      rcases h_case2 with ⟨ k, rfl ⟩ ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Nat.add_div ] ;
      rw [ ← Nat.mod_add_div k 6 ] ; have := Nat.mod_lt k ( by decide : 6 > 0 ) ; interval_cases k % 6 <;> norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Nat.div_add_mod ] ;
      all_goals ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Nat.div_add_mod ] ;
      all_goals norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod, Nat.pow_mod ] ;
    · rw [ ← Nat.mod_add_div q 9, h ] ; ring_nf ;
      norm_num [ Nat.add_div, Nat.add_mod, Nat.mul_div_assoc, Nat.mul_mod, Nat.pow_mod ];
      rw [ ← Nat.mod_add_div ( q / 9 ) 6 ] ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; have := Nat.mod_lt ( q / 9 ) ( by decide : 6 > 0 ) ; interval_cases q / 9 % 6 <;> norm_num;
      all_goals ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ;
      all_goals norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.pow_mod ] ;
      · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
      · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
      · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
      · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
      · norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
    · rw [ ← Nat.mod_add_div q 9, h ] ; ring_nf ;
      rw [ ← Nat.mod_add_div ( q / 9 ) 6 ] ; norm_num [ Nat.pow_mod, Nat.mul_mod, Nat.add_mod, Nat.div_add_mod ] ; have := Nat.mod_lt ( q / 9 ) ( by decide : 6 > 0 ) ; interval_cases q / 9 % 6 <;> norm_num;
      all_goals ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod, Nat.div_add_mod ] ;
      all_goals norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod, Nat.pow_mod ] ;

/-
chi3(-1) = 1.
-/
theorem chi3_neg_one (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (h_mod : q % 3 = 2) :
  chi3 q (-1) = 1 := by
    -- Since $(A-1)/3$ is even (proved in exp_is_even), $(-1)^{(A-1)/3} = 1$.
    have h_even : Even ((A q - 1) / 3) := by
      exact even_iff_two_dvd.mpr ( exp_is_even q hq hq3 h_mod );
    unfold chi3; aesop;

/-
chi3(3) = chi3(1-q)^2 * chi3(q)^2.
-/
theorem chi3_3_eq (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) (h_mod : q % 3 = 2) :
  chi3 q 3 = (chi3 q (1 - q))^2 * (chi3 q q)^2 := by
    -- By definition of $chi3$, we know that $chi3(q)(1-q)^2 * chi3(q)(q)^2 = chi3(q)((1-q)^2 * q^2)$.
    have h1 : (chi3 q (1 - q)) ^ 2 * (chi3 q q) ^ 2 = chi3 q ((1 - q) ^ 2 * q ^ 2) := by
      unfold chi3;
      rw [ mul_pow ] ; ring;
      rw [ pow_mul', pow_mul' ] ; ring;
    -- Since $3 = (1-q)(q+2) = (1-q)(1-q^2) = (1-q)^2(1+q) = (1-q)^2(-q^2)$, we have $chi3(q)(3) = chi3(q)((1-q)^2 * (-q^2))$.
    have h2 : chi3 q 3 = chi3 q ((1 - q) ^ 2 * (-q ^ 2)) := by
      have h2 : (3 : ZMod (A q)) = ((1 - q : ZMod (A q)) * (q + 2 : ZMod (A q))) := by
        exact?;
      grind;
    have h3 : chi3 q (-1) = 1 := by
      convert chi3_neg_one q hq hq3 h_mod using 1;
    have h3 : chi3 q ((1 - q) ^ 2 * (-q ^ 2)) = chi3 q ((1 - q) ^ 2 * q ^ 2) * chi3 q (-1) := by
      unfold chi3; ring;
      rw [ ← mul_pow ] ; ring;
    grind

/-
Values of chi3(3) assuming Key Claim.
-/
theorem chi3_3_val (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) (h_mod : q % 3 = 2)
  (h_key : chi3 q (1 - q) = 1) :
  (q % 9 = 2 → chi3 q 3 = q) ∧
  (q % 9 = 5 → chi3 q 3 = q^2) ∧
  (q % 9 = 8 → chi3 q 3 = 1) := by
    -- Apply the fact3 theorem to rewrite chi3(3) in terms of chi3(q).
    have h3 : chi3 q 3 = (chi3 q q)^2 := by
      have := chi3_3_eq q hq hq3 hA h_mod; aesop;
    -- Apply the fact4 theorem to rewrite chi3(q) in terms of q mod 9.
    have h4 : (q % 9 = 2 → chi3 q q = q^2) ∧ (q % 9 = 5 → chi3 q q = q) ∧ (q % 9 = 8 → chi3 q q = 1) := by
      apply fact4 q hq hq3 hA h_mod;
    simp_all +decide [ pow_succ' ];
    intro h; have := fact1 q hq hq3 hA; simp_all +decide [ mul_assoc, pow_succ ] ;

/-
Main Theorem: 3^q is not 1 mod A, for q != 8 mod 9, assuming Key Claim.
-/
theorem ft_p3_q_not_8_mod_9 (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) (h_mod : q % 3 = 2)
  (h_not_8 : q % 9 ≠ 8) (h_key : chi3 q (1 - q) = 1) :
  (3 : ZMod (A q)) ^ q ≠ 1 := by
    -- Assume for contradiction that $3^q \equiv 1 \pmod{A}$.
    by_contra h_contra
    have h_ord : orderOf (3 : ZMod (A q)) = q := by
      have h_ord_div_q : orderOf (3 : ZMod (A q)) ∣ q := by
        exact orderOf_dvd_iff_pow_eq_one.mpr h_contra
      have h_ord_ne_1 : orderOf (3 : ZMod (A q)) ≠ 1 := by
        have h_ord_ne_1 : ¬(3 : ℕ) ≡ 1 [MOD A q] := by
          exact fun h => by rw [ Nat.modEq_iff_dvd ] at h; norm_num at h; nlinarith [ Int.le_of_dvd ( by linarith ) h, show A q > 3 by exact lt_add_of_le_of_pos ( by nlinarith ) ( by linarith ) ] ;
        generalize_proofs at *; (
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;)
      have h_ord_eq_q : orderOf (3 : ZMod (A q)) = q := by
        rwa [ Nat.dvd_prime hq, or_iff_right h_ord_ne_1 ] at h_ord_div_q
      exact h_ord_eq_q;
    -- Since $q | (A-1)/3$, we have $3^{(A-1)/3} \equiv 1 \pmod{A}$.
    have h_exp : 3 ^ ((A q - 1) / 3) ≡ 1 [ZMOD A q] := by
      have h_exp : q ∣ (A q - 1) / 3 := by
        unfold A; simp_all +decide [ Nat.dvd_add_right, sq ] ;
        exact Nat.dvd_div_of_mul_dvd ( by exact ⟨ ( q + 1 ) / 3, by nlinarith [ Nat.div_mul_cancel ( show 3 ∣ q + 1 from Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, h_mod ] ) ) ] ⟩ );
      obtain ⟨ k, hk ⟩ := h_exp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, pow_mul ] ;
    -- From chi3_3_val, we know that chi3 q 3 ≠ 1 for q ≢ 8 mod 9.
    have h_chi3_3_ne_one : chi3 q 3 ≠ 1 := by
      have := chi3_3_val q hq hq3 hA h_mod h_key; ( have := Nat.mod_lt q ( by decide : 0 < 9 ) ; interval_cases _ : q % 9 <;> simp_all +decide ; );
      any_goals omega;
      · -- Since $A q = q^2 + q + 1$, we have $q \equiv 1 \pmod{A q}$ implies $q^2 + q + 1 \mid q - 1$, which is impossible because $q^2 + q + 1 > q - 1$.
        have h_impossible : ¬(q^2 + q + 1 ∣ q - 1) := by
          exact Nat.not_dvd_of_pos_of_lt ( Nat.sub_pos_of_lt hq.one_lt ) ( by nlinarith only [ hq3, Nat.sub_add_cancel hq.pos ] );
        exact fun h => h_impossible <| by rw [ ← Int.natCast_dvd_natCast ] ; simpa [ Nat.cast_sub hq.pos ] using by erw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
      · intro h; haveI := Fact.mk hA; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        rcases h with ( h | h ) <;> have := fact1 q hq hq3 hA <;> simp_all +decide [ pow_succ' ];
    -- From chi3_3_val, we know that chi3 q 3 = 3 ^ ((A q - 1) / 3).
    have h_chi3_3_eq : chi3 q 3 = 3 ^ ((A q - 1) / 3) := by
      exact?;
    erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop

/-
q is a quadratic residue mod A.
-/
theorem q_is_quadratic_residue (q : ℕ) (hq : q.Prime) (hq3 : q > 3) [hA : Fact (Nat.Prime (A q))] :
  legendreSym (A q) q = 1 := by
    -- By quadratic reciprocity, we have $(A/q) * (q/A) = 1$.
    have h_recip : jacobiSym (A q) q * jacobiSym q (A q) = 1 := by
      -- Since $q$ is odd and $A q \equiv 1 \pmod{4}$, we have $(A q / q) = (q / A q)$.
      have h_jacobi_symm : jacobiSym (A q) q = jacobiSym q (A q) := by
        rw [ jacobiSym.quadratic_reciprocity ];
        · rcases Nat.even_or_odd' q with ⟨ c, rfl | rfl ⟩ <;> norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod ] at *;
          · simp_all +decide [ Nat.prime_mul_iff ];
          · unfold A; ring_nf; norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ] ;
            rcases Nat.even_or_odd' c with ⟨ d, rfl | rfl ⟩ <;> ring_nf <;> norm_num [ Nat.add_mod, Nat.mul_mod ];
        · exact hA.1.odd_of_ne_two <| by { unfold A; nlinarith };
        · exact hq.odd_of_ne_two <| by linarith;
      rw [ h_jacobi_symm, ← sq, jacobiSym.sq_one ];
      exact_mod_cast Nat.coprime_comm.mp ( hA.1.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt hq.pos <| by { unfold A; nlinarith } );
    -- Since $A q \equiv 1 \pmod{q}$, we have $(A/q) = 1$.
    have h_Aq_mod_q : jacobiSym (A q) q = 1 := by
      unfold A; norm_num [ jacobiSym.mod_left ] ;
      norm_num [ sq, Int.add_emod, Int.mul_emod ];
      rw [ Int.emod_eq_of_lt ] <;> norm_num ; linarith;
    simp_all +decide [ jacobiSym ];
    simp_all +decide [ Nat.primeFactorsList_prime hq, Nat.primeFactorsList_prime hA.1 ]

/-
chi3(3) = chi3(q)^2 assuming Key Claim.
-/
theorem chi3_3_eq_chi3_q_sq_conditional (q : ℕ) (hq : q.Prime) (hq3 : q > 3) (hA : (A q).Prime) (h_mod : q % 3 = 2)
  (h_key : chi3 q (1 - q) = 1) :
  chi3 q 3 = (chi3 q q)^2 := by
    convert chi3_3_eq q hq hq3 hA h_mod using 1;
    grind