/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7e40fb7c-17ca-4d03-8cf5-537ab2281463

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Sierpinski conjecture states that for all n ≥ 2, 5/n = 1/x + 1/y + 1/z has a solution in positive integers.
-/
def SierpinskiSolvable (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / n = 1 / x + 1 / y + 1 / z

/-
An integer n is exceptional if n ≡ 1 mod 1260 and all prime factors of (n-1)/1260 are ≡ 1 mod 4.
-/
def IsExceptional (n : ℕ) : Prop :=
  n % 1260 = 1 ∧ ∀ p ∈ ((n - 1) / 1260).primeFactors, p % 4 = 1

lemma sierpinski_mod_5_ne_1 (n : ℕ) (h_ge : n ≥ 2) (h_mod : n % 5 ≠ 1) : SierpinskiSolvable n := by
  -- We consider the four cases based on the residue of $n$ modulo 5.
  by_cases h_case : n % 5 = 0 ∨ n % 5 = 2 ∨ n % 5 = 3 ∨ n % 5 = 4;
  · rcases h_case with ( h | h | h | h );
    · -- If $n \equiv 0 \pmod{5}$, then $n = 5k$ for some integer $k$.
      obtain ⟨k, rfl⟩ : ∃ k, n = 5 * k := by
        exact Nat.dvd_of_mod_eq_zero h;
      exact ⟨ k * 2, k * 3, k * 6, by linarith, by linarith, by linarith, by simpa [ ( by ring : ( 5 * k : ℚ ) = k * 5 ) ] using by ring ⟩;
    · -- Let $n = 5q + 2$.
      obtain ⟨q, rfl⟩ : ∃ q, n = 5 * q + 2 := by
        exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩;
      -- We need to find $x, y, z$ such that $5/(5q+2) = 1/x + 1/y + 1/z$.
      -- Let's choose $x = q + 1$, $y = (q + 1)(5q + 2)/a$, and $z = (q + 1)(5q + 2)/(3 - a)$ for some $a$.
      obtain ⟨a, ha⟩ : ∃ a : ℕ, 1 ≤ a ∧ a ≤ 2 ∧ (q + 1) * (5 * q + 2) % a = 0 ∧ (q + 1) * (5 * q + 2) % (3 - a) = 0 := by
        by_cases hq : q % 3 = 0 ∨ q % 3 = 1 ∨ q % 3 = 2;
        · rcases hq with ( hq | hq | hq ) <;> use if q % 3 = 0 then 1 else if q % 3 = 1 then 2 else 1 <;> norm_num [ Nat.add_mod, Nat.mul_mod, hq ];
          · cases Nat.mod_two_eq_zero_or_one q <;> simp +decide [ * ];
          · cases Nat.mod_two_eq_zero_or_one q <;> simp +decide [ * ];
          · cases Nat.mod_two_eq_zero_or_one q <;> simp +decide [ * ];
        · have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> contradiction;
      use q + 1, (q + 1) * (5 * q + 2) / a, (q + 1) * (5 * q + 2) / (3 - a);
      rcases ha with ⟨ ha₁, ha₂, ha₃, ha₄ ⟩ ; interval_cases a <;> norm_num at *;
      · field_simp;
        exact ⟨ by nlinarith, by rw [ Nat.cast_div ( Nat.dvd_of_mod_eq_zero ha₄ ) ( by positivity ) ] ; push_cast; rw [ add_div', eq_div_iff ] <;> ring <;> positivity ⟩;
      · rw [ Nat.cast_div ] <;> norm_num;
        · field_simp
          ring;
          exact ⟨ by nlinarith, trivial ⟩;
        · exact Nat.dvd_of_mod_eq_zero ha₃;
    · -- Let $n = 5q + 3$.
      obtain ⟨q, rfl⟩ : ∃ q, n = 5 * q + 3 := by
        exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩;
      use q + 1, (q + 1) * (5 * q + 3), (q + 1) * (5 * q + 3);
      field_simp;
      exact ⟨ Nat.succ_pos _, by positivity, by positivity, by push_cast; ring ⟩;
    · -- Let $n = 5q + 4$.
      obtain ⟨q, rfl⟩ : ∃ q, n = 5 * q + 4 := by
        exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩;
      use q + 2, ( q + 1 ) * ( q + 2 ), ( q + 1 ) * ( 5 * q + 4 );
      field_simp;
      exact ⟨ Nat.succ_pos _, by positivity, by positivity, by push_cast; ring ⟩;
  · have := Nat.mod_lt n ( by decide : 5 > 0 ) ; interval_cases n % 5 <;> contradiction;

lemma sierpinski_div_2_or_3 (n : ℕ) (h_ge : n ≥ 2) (h : n % 2 = 0 ∨ n % 3 = 0) : SierpinskiSolvable n := by
  cases h <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero ];
  · -- If $2|n$, $n=2m$. $5/2m = 1/m + 1/m + 1/2m$ (Wait, $5/2m = 2.5/m$. $1/m+1/m+1/2m = 2.5/m$. Correct).
    obtain ⟨m, rfl⟩ : ∃ m, n = 2 * m := by
      exact Nat.dvd_of_mod_eq_zero ‹_›
    use m, m, 2 * m
    simp [Nat.cast_mul];
    exact ⟨ by linarith, by ring ⟩;
  · -- If $3|n$, $n=3m$. $5/3m = 1/m + 1/2m + 1/6m$.
    obtain ⟨m, rfl⟩ : ∃ m, n = 3 * m := by
      exact Nat.dvd_of_mod_eq_zero ‹_›
    use m, 2 * m, 6 * m
    simp [mul_assoc, mul_comm, mul_left_comm];
    exact ⟨ by linarith, by ring ⟩

/-
Definitions of the polynomials p1, p2, p3 used in the parametric reduction.
-/
def poly1 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y - 1) - y) - x
def poly2 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y - 1) - y) - y
def poly3 (x y z : ℕ) : ℤ := (z : ℤ) * ((x : ℤ) * (5 * y + 1) + y) - x

lemma poly1_identity_4term (x y z : ℕ) (hx : x > 0) (hy : y > 0) (hz : z > 0) :
  let n := poly1 x y z
  n > 0 → (5 : ℚ) / n = 1 / (x * n) + 1 / (y * n) + 1 / (x * y * z) + 1 / (y * z * n) := by
    unfold poly1; ring_nf; (
    intro h; field_simp; ring;
    push_cast; ring;);

/-
Structure capturing the assumption that the polynomials p1, p2, p3 produce Sierpinski solutions.
-/
structure ParametricSolvability where
  poly1_solvable : ∀ x y z : ℕ, x > 0 → y > 0 → z > 0 → poly1 x y z > 0 → SierpinskiSolvable (poly1 x y z).toNat
  poly2_solvable : ∀ x y z : ℕ, x > 0 → y > 0 → z > 0 → poly2 x y z > 0 → SierpinskiSolvable (poly2 x y z).toNat
  poly3_solvable : ∀ x y z : ℕ, x > 0 → y > 0 → z > 0 → poly3 x y z > 0 → SierpinskiSolvable (poly3 x y z).toNat

lemma coverage_p1_x1 (h_param : ParametricSolvability) (n : ℕ) (h_ge : n ≥ 2)
  (h_factor : ∃ k, k ∣ (n + 1) ∧ k % 4 = 3) : SierpinskiSolvable n := by
    -- Let $k$ be a factor of $n+1$ with $k \equiv 3 \pmod 4$, so $k = 4y - 1$.
    obtain ⟨k, hk_div, hk_mod⟩ : ∃ k, k ∣ n + 1 ∧ k % 4 = 3 := h_factor
    obtain ⟨y, z, hy_pos, hz_pos, rfl⟩ : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ n = z * (4 * y - 1) - 1 := by
      obtain ⟨ y, hy ⟩ := hk_div;
      -- Since $k \equiv 3 \pmod{4}$, we can write $k = 4m + 3$ for some $m$.
      obtain ⟨m, rfl⟩ : ∃ m, k = 4 * m + 3 := by
        exact ⟨ k / 4, by rw [ ← hk_mod, Nat.div_add_mod ] ⟩;
      exact ⟨ m + 1, y, Nat.succ_pos _, Nat.pos_of_ne_zero ( by aesop_cat ), eq_tsub_of_add_eq <| by norm_num [ Nat.mul_succ ] ; linarith ⟩;
    convert h_param.poly1_solvable 1 y z ( by norm_num ) hy_pos hz_pos _ using 1;
    · unfold poly1; zify; rcases y with ( _ | _ | y ) <;> norm_num at * ; ring;
      · norm_cast;
      · grind;
    · unfold poly1; norm_num; nlinarith [ Nat.sub_add_cancel ( show 1 ≤ 4 * y from by linarith ) ] ;

lemma coverage_p1_x2 (h_param : ParametricSolvability) (n : ℕ) (h_ge : n ≥ 2)
  (h_factor : ∃ k, k ∣ (n + 2) ∧ k % 9 = 7) : SierpinskiSolvable n := by
    obtain ⟨ k, hk₁, hk₂ ⟩ := h_factor
    obtain ⟨ y, hy ⟩ : ∃ y, k = 9 * y - 2 := by
      exact ⟨ k / 9 + 1, by omega ⟩;
    obtain ⟨ z, hz ⟩ := hk₁;
    convert h_param.poly1_solvable 2 y z ( by norm_num ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) _ using 1;
    · unfold poly1;
      rcases y with ( _ | _ | y ) <;> norm_num [ hy ] at *;
      · linarith [ Int.toNat_of_nonneg ( by linarith : 0 ≤ ( z : ℤ ) * 7 - 2 ) ];
      · grind;
    · rcases y with ( _ | _ | y ) <;> simp_all +decide [ poly1 ];
      · linarith;
      · nlinarith [ Nat.sub_add_cancel ( by linarith : 2 ≤ 9 * ( y + 1 + 1 ) ) ]

lemma coverage_p1_x3 (h_param : ParametricSolvability) (n : ℕ) (h_ge : n ≥ 2)
  (h_factor : ∃ k, k ∣ (n + 3) ∧ k % 14 = 11) : SierpinskiSolvable n := by
    -- Let's obtain such a factor $k$ and express $n + 3$ as $k * m$ for some $m$.
    obtain ⟨k, hk₁, hk₂⟩ := h_factor
    set m := (n + 3) / k with hm;
    -- We need to find $y$ and $z$ such that $n = p₁(3, y, z)$.
    have h_eq : ∃ y z : ℕ, n = (z * (14 * y - 3) - 3 : ℤ) := by
      -- Since $k \equiv 11 \mod 14$, we can write $k = 14y - 3$ for some $y$.
      obtain ⟨y, hy⟩ : ∃ y : ℕ, k = 14 * y - 3 := by
        exact ⟨ k / 14 + 1, by omega ⟩;
      use y, m;
      nlinarith [ Nat.div_mul_cancel hk₁, Nat.sub_add_cancel ( show 3 ≤ 14 * y from by linarith [ show y > 0 from Nat.pos_of_ne_zero ( by rintro rfl; norm_num [ hy ] at * ) ] ), hy ▸ Nat.sub_add_cancel ( show 3 ≤ 14 * y from by linarith [ show y > 0 from Nat.pos_of_ne_zero ( by rintro rfl; norm_num [ hy ] at * ) ] ) ];
    obtain ⟨ y, z, h ⟩ := h_eq; have := h_param.poly1_solvable 3 y z; simp_all +decide [ poly1 ] ;
    grind