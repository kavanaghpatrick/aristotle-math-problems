/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 86b3254b-9322-4261-95d0-8108efffea68

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved the Sierpinski conjecture for n ≡ 2 mod 5 (sierpinski_mod_5_2), completing the user's specific request. We also proved the conjecture for all n ≢ 1 mod 5 (sierpinski_except_1_mod_5). The full conjecture is reduced to the open case n ≡ 1 mod 5 (sierpinski_conjecture_reduction).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def SierpinskiSolvable (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 / (n : ℚ) = 1 / x + 1 / y + 1 / z

lemma sierpinski_div_2 (n : ℕ) (h_ge : n ≥ 2) (h : 2 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use m, m, 2 * m
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

lemma sierpinski_div_3 (n : ℕ) (h_ge : n ≥ 2) (h : 3 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use m, 2 * m, 6 * m
  constructor; · exact Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge)
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

lemma sierpinski_div_5 (n : ℕ) (h_ge : n ≥ 2) (h : 5 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨m, rfl⟩ := h
  use 2 * m, 3 * m, 6 * m
  constructor; · exact Nat.mul_pos zero_lt_two (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  constructor; · exact Nat.mul_pos (by decide) (Nat.pos_of_ne_zero (by rintro rfl; simp at h_ge))
  field_simp
  ring
  norm_num [ show m ≠ 0 by linarith ];
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  rw [ mul_inv_cancel₀ ] <;> norm_cast ; linarith

lemma sierpinski_mod_5_4 (q : ℕ) : SierpinskiSolvable (5 * q + 4) := by
  -- We can choose $x = q + 2$, $y = (q + 1)(q + 2)$, and $z = (q + 1)(5q + 4)$.
  use q + 2, (q + 1) * (q + 2), (q + 1) * (5 * q + 4);
  exact ⟨ Nat.succ_pos _, Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ), Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ), by push_cast; rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> ring <;> positivity ⟩

lemma sierpinski_mod_5_3 (q : ℕ) : SierpinskiSolvable (5 * q + 3) := by
  -- Let's choose $x = q + 1$, $y = (q + 1)(5q + 3)$, and $z = (q + 1)(5q + 3)$.
  use (q + 1), (q + 1) * (5 * q + 3), (q + 1) * (5 * q + 3);
  -- Simplify the right-hand side of the equation.
  field_simp
  ring;
  grind

lemma sierpinski_mod_5_2 (q : ℕ) : SierpinskiSolvable (5 * q + 2) := by
  -- If $q$ is even, then $5q + 2$ is even, and we can use the lemma sierpinski_div_2.
  by_cases h_even : Even q;
  · exact sierpinski_div_2 _ ( by linarith ) ( even_iff_two_dvd.mp ( by simpa [ parity_simps ] using h_even ) );
  · -- If $q$ is odd, then $q = 2k + 1$ for some integer $k$.
    obtain ⟨k, rfl⟩ : ∃ k, q = 2 * k + 1 := by
      exact q.even_or_odd.resolve_left h_even;
    -- Let's simplify the expression $5 / (5 * (2 * k + 1) + 2)$ by finding a common denominator.
    suffices h_simp : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 * (x * y * z) = (10 * k + 7) * (y * z + x * z + x * y) by
      obtain ⟨ x, y, z, hx, hy, hz, h ⟩ := h_simp;
      exact ⟨ x, y, z, hx, hy, hz, by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> norm_cast <;> first |linarith|aesop ⟩;
    -- Let's choose $x = 2(k + 1)$, $y = (10k + 7)(k + 1)$, and $z = 2(10k + 7)(k + 1)$.
    use 2 * (k + 1), (10 * k + 7) * (k + 1), 2 * (10 * k + 7) * (k + 1);
    exact ⟨ by positivity, by positivity, by positivity, by ring ⟩

theorem sierpinski_except_1_mod_5 (n : ℕ) (h_ge : n ≥ 4) (h_mod : n % 5 ≠ 1) : SierpinskiSolvable n := by
  rw [ ← Nat.mod_add_div n 5 ] at *;
  have := Nat.mod_lt n ( by decide : 5 > 0 ) ; interval_cases n % 5 <;> simp_all +arith +decide;
  · exact sierpinski_div_5 _ ( by linarith ) ( by norm_num );
  · exact sierpinski_mod_5_2 _;
  · exact?;
  · exact sierpinski_mod_5_4 _

def SierpinskiDecomp := SierpinskiSolvable

def SierpinskiConjectureOpenCase (n : ℕ) : Prop := n % 5 = 1

theorem sierpinski_conjecture_reduction (h_open : ∀ n, 4 ≤ n → SierpinskiConjectureOpenCase n → SierpinskiDecomp n) :
  ∀ n, 4 ≤ n → SierpinskiDecomp n := by
  intro n h_ge
  by_cases h_mod : n % 5 = 1
  · exact h_open n h_ge h_mod
  · exact sierpinski_except_1_mod_5 n h_ge h_mod