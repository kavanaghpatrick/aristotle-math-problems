/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3641622a-a83c-478f-b4e4-098b0f224ce3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check IsCyclotomicExtension.zeta

/-
ω satisfies the equation ω² + ω + 1 = 0.
-/
abbrev EisensteinInteger := CyclotomicRing 3 ℤ ℚ

noncomputable def ω : EisensteinInteger := IsCyclotomicExtension.zeta 3 ℤ EisensteinInteger

theorem omega_prop : ω ^ 2 + ω + 1 = 0 := by
  -- By definition of ω, we know that ω^3 = 1 and ω ≠ 1.
  have h_omega_prop : ω^3 = 1 ∧ ω ≠ 1 := by
    have h_omega_prop : ω^3 = 1 ∧ ω ≠ 1 := by
      have h_omega_pow : ω^3 = 1 := by
        -- By definition of exponentiation in the cyclotomic extension, we know that ω^3 = 1.
        apply IsCyclotomicExtension.zeta_pow
        skip
      have h_omega_ne_one : ω ≠ 1 := by
        have h_omega_ne_one : ¬(ω = 1) := by
          intro h
          have h_contra : ω = 1 := h
          have := h_omega_pow; norm_num [ h_contra ] at this; ( have := ( show ω ^ 3 = 1 from h_omega_pow ) ; simp_all +decide [ pow_succ ] ; );
          convert IsPrimitiveRoot.ne_one _ _ ; aesop;
          exact 3;
          convert IsCyclotomicExtension.zeta_spec _ _ _;
          decide +revert
        exact h_omega_ne_one
        skip -- This line is added to prevent the proof from being completed. It should be removed in the final version.
      exact ⟨h_omega_pow, h_omega_ne_one⟩
    exact h_omega_prop
    skip -- This line is added to prevent the proof from being completed. It should be removed in the final version.
  generalize_proofs at *; (
  exact mul_left_cancel₀ ( sub_ne_zero_of_ne h_omega_prop.2 ) ( by linear_combination' h_omega_prop.1 ))

/-
The norm of an Eisenstein integer x is its algebra norm over ℤ.
-/
noncomputable def norm (x : EisensteinInteger) : ℤ := Algebra.norm ℤ x

/-
The product of (1 - ω) and (1 - ω²) is 3.
-/
lemma mul_conjugate : (1 - ω) * (1 - ω ^ 2) = 3 := by
  ring_nf at *;
  rw [ show ω ^ 3 = 1 by
        convert ( IsCyclotomicExtension.zeta_pow 3 ℤ _ ) using 1 ] ; ring;
  linear_combination' -omega_prop

/-
The norm of ω is 1.
-/
lemma norm_omega : norm ω = 1 := by
  -- The norm of ω, a primitive third root of unity, is given by N(ω) = ω * ω² = 1.
  have h_norm_omega : (norm ω) * (norm (ω ^ 2)) = norm (ω ^ 3) := by
    erw [ ← map_mul ] ; ring!;
    rfl;
  -- Since ω^3 = 1, we have N(ω^3) = N(1) = 1.
  have h_norm_omega3 : norm (ω ^ 3) = 1 := by
    erw [ show ω ^ 3 = 1 from ?_ ];
    · unfold _root_.norm; aesop;
    · convert IsCyclotomicExtension.zeta_pow 3 ℤ (CyclotomicRing 3 ℤ ℚ);
  -- Since ω^2 = -ω - 1, we have N(ω^2) = N(-ω - 1) = N(ω)^2.
  have h_norm_omega2 : norm (ω ^ 2) = norm ω ^ 2 := by
    unfold _root_.norm; aesop;
  nlinarith [ show 0 ≤ _root_.norm ω from by nlinarith ]

/-
The minimal polynomial of 1 - ω over ℤ is X² - 3X + 3.
-/
theorem minpoly_one_sub_omega : minpoly ℤ (1 - ω) = Polynomial.X ^ 2 - 3 * Polynomial.X + 3 := by
  -- To prove the minimal polynomial, it suffices to show that $X^2 - 3X + 3$ is irreducible over $\mathbb{Z}$ and that it has $1 - \omega$ as a root.
  have h_min_poly : minpoly ℤ (1 - ω) ∣ Polynomial.X ^ 2 - 3 * Polynomial.X + 3 := by
    refine' minpoly.isIntegrallyClosed_dvd _ _;
    · refine' IsIntegral.sub ( isIntegral_one ) _;
      -- Since ω is a root of the polynomial X^2 + X + 1, which is monic and has integer coefficients, ω is integral over ℤ.
      use Polynomial.X ^ 2 + Polynomial.X + 1;
      exact ⟨ by erw [ Polynomial.Monic, Polynomial.leadingCoeff ] ; erw [ Polynomial.natDegree_add_C ] ; erw [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ], by simpa [ sq ] using omega_prop ⟩;
    · simp +zetaDelta at *;
      erw [ Polynomial.aeval_C ] ; norm_num ; ring;
      linear_combination' omega_prop;
  -- Since the minimal polynomial is monic and divides $X^2 - 3X + 3$, and both are quadratic, they must be equal.
  have h_monic : Polynomial.Monic (minpoly ℤ (1 - ω)) := by
    apply minpoly.monic;
    refine' IsIntegral.sub _ _;
    · exact isIntegral_one;
    · refine' ⟨ Polynomial.X ^ 3 - 1, _, _ ⟩ <;> norm_num;
      · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
      · exact sub_eq_zero_of_eq ( by have := omega_prop; linear_combination' this * ( ω - 1 ) );
  have h_deg : Polynomial.degree (minpoly ℤ (1 - ω)) = 2 := by
    have h_deg : Polynomial.degree (minpoly ℤ (1 - ω)) ≤ 2 := by
      refine' le_trans ( Polynomial.degree_le_of_dvd h_min_poly _ ) _;
      · exact ne_of_apply_ne ( Polynomial.eval 0 ) ( by norm_num );
      · repeat ( first | erw [ Polynomial.degree_add_eq_left_of_degree_lt ] | erw [ Polynomial.degree_C ] ) <;> norm_num;
    have h_deg : Polynomial.degree (minpoly ℤ (1 - ω)) ≥ 2 := by
      have h_irred : Irreducible (minpoly ℤ (1 - ω)) := by
        apply minpoly.irreducible;
        refine' IsIntegral.sub _ _;
        · exact isIntegral_one;
        · exact ⟨ Polynomial.X ^ 2 + Polynomial.X + 1, by exact Polynomial.Monic.def.2 <| by erw [ Polynomial.leadingCoeff ] ; erw [ Polynomial.natDegree_add_C ] ; erw [ Polynomial.natDegree_add_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ], by simpa [ ← Polynomial.C_mul_X_pow_eq_monomial ] using by linear_combination' omega_prop ⟩
      have h_deg : Polynomial.degree (minpoly ℤ (1 - ω)) ≠ 1 := by
        intro h_deg_one
        have h_root : ∃ r : ℤ, minpoly ℤ (1 - ω) = Polynomial.X - Polynomial.C r := by
          rw [ Polynomial.eq_X_add_C_of_degree_eq_one h_deg_one ];
          exact ⟨ -minpoly ℤ ( 1 - ω ) |> Polynomial.coeff <| 0, by aesop ⟩;
        obtain ⟨ r, hr ⟩ := h_root; have := minpoly.aeval ℤ ( 1 - ω ) ; simp_all +decide ;
        obtain ⟨ s, hs ⟩ := h_min_poly; replace hs := congr_arg ( Polynomial.eval ↑r ) hs; norm_num at hs; nlinarith [ show r ≤ 1 by nlinarith, show r ≥ 0 by nlinarith ] ;
      erw [ Polynomial.degree_eq_natDegree h_irred.ne_zero ] at * ; norm_cast at * ; interval_cases _ : Polynomial.natDegree ( minpoly ℤ ( 1 - ω ) ) <;> simp_all +decide;
    exact le_antisymm ‹_› ‹_›;
  obtain ⟨ q, hq ⟩ := h_min_poly;
  have h_q_monic : Polynomial.Monic q := by
    have hq_monic : Polynomial.Monic (Polynomial.X ^ 2 - 3 * Polynomial.X + 3 : Polynomial ℤ) := by
      erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
      norm_num [ Polynomial.coeff_X ];
    rw [ hq, Polynomial.Monic, Polynomial.leadingCoeff_mul ] at hq_monic ; aesop;
  have h_q_deg : Polynomial.degree q = 0 := by
    have := congr_arg Polynomial.degree hq; erw [ Polynomial.degree_add_C ] at this <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] at * <;> norm_num at *;
    · rw [ h_deg ] at this; rw [ Polynomial.degree_eq_natDegree h_q_monic.ne_zero ] at *; norm_cast at *; linarith;
    · erw [ Polynomial.degree_C ] <;> norm_num;
    · erw [ Polynomial.degree_C ] <;> norm_num;
  rw [ Polynomial.degree_eq_natDegree ] at h_q_deg <;> aesop