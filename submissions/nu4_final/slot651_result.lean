/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d94555c4-f79e-4416-97a2-c3cdf5251251

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the attack on the Sierpinski Conjecture (Erdős-Straus for 5/n) for the case n ≡ 1 (mod 5).

Key results:
1. `sierpinski_div_2`, `sierpinski_div_3`: Solvability for n even or divisible by 3.
2. `sierpinski_mod_4_3`: Solvability for n ≡ 3 (mod 4).
3. `sierpinski_mod_60_21`, `sierpinski_mod_60_41`: Solvability for n ≡ 21, 41 (mod 60).
4. `sierpinski_reduction_final`: A reduction theorem proving that for n ≥ 4 with n ≡ 1 (mod 5), the conjecture holds for all cases except possibly n ≡ 1 (mod 60).
5. `sierpinski_bounded_verification_10000`: Verified the conjecture for all n < 10000 using `native_decide`.

We also proved auxiliary lemmas such as `sierpinski_mul_solvable` (multiplicative property) and `sierpinski_has_factor_mod_4_3` (solvability if n has a factor ≡ 3 mod 4). The remaining open case is n ≡ 1 (mod 60).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of SierpinskiSolvable: 5/n can be written as sum of three unit fractions.
-/
def SierpinskiSolvable (n : ℕ) : Prop := ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
If n is even and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_2 {n : ℕ} (h1 : n ≠ 0) (h2 : 2 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨ k, rfl ⟩ := h2;
  use 2 * k, k, k;
  grind

/-
If n is divisible by 3 and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_3 {n : ℕ} (h1 : n ≠ 0) (h2 : 3 ∣ n) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by $3$, we can write $n = 3k$ for some $k$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 3 * k := h2;
  -- We can write 5/(3k) = 1/k + 2/(3k).
  use k, 2 * k, 6 * k;
  exact ⟨ Nat.pos_of_ne_zero ( by aesop ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), by push_cast; ring ⟩

/-
If n = 5(2k+1) + 1, then SierpinskiSolvable n.
-/
theorem sierpinski_mod_5_q_odd {k : ℕ} : SierpinskiSolvable (5 * (2 * k + 1) + 1) := by
  convert sierpinski_div_2 _ _ using 1 <;> norm_num;
  grind

/-
Reduction lemma: if 4/(n(2k+1)) is solvable, then SierpinskiSolvable (10k+1).
-/
theorem sierpinski_mod_10_1_reduction {k : ℕ} (hk : k > 0)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((10 * k + 1 : ℚ) * (2 * k + 1)) = 1 / y + 1 / z) :
  SierpinskiSolvable (10 * k + 1) := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    -- Therefore, $5 / (10k + 1) = 1 / (2k + 1) + 1 / y + 1 / z$.
    have h_eq : (5 : ℚ) / (10 * k + 1) = 1 / (2 * k + 1) + 1 / y + 1 / z := by
      field_simp at h ⊢;
      grind;
    exact ⟨ 2 * k + 1, y, z, by positivity, by positivity, by positivity, by simpa [ ← @Rat.cast_inj ℝ ] using h_eq ⟩

/-
If n ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_4_3 {n : ℕ} (h : n % 4 = 3) : SierpinskiSolvable n := by
  -- Since n % 4 = 3, we can write n as 4k + 3 for some integer k.
  obtain ⟨k, rfl⟩ : ∃ k, n = 4 * k + 3 := by
    exact ⟨ n / 4, by rw [ ← h, Nat.div_add_mod ] ⟩;
  use 4 * k + 3, k + 1, ( k + 1 ) * ( 4 * k + 3 );
  field_simp
  ring;
  exact ⟨ by positivity, by positivity, by positivity, by push_cast; ring ⟩

/-
If we can solve the n ≡ 1 (mod 20) case, then we can solve all n ≡ 1 (mod 5).
-/
theorem sierpinski_reduction_to_mod_20 (h_mod_20 : ∀ n : ℕ, n % 20 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 5 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    by_cases h_even : Even n;
    · exact sierpinski_div_2 hn ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod4 : n % 4 = 3;
      · exact sierpinski_mod_4_3 ( by omega );
      · convert h_mod_20 n ( by rw [ ← Nat.mod_mod_of_dvd n ( by decide : 4 ∣ 20 ) ] at h_mod4; rw [ ← Nat.mod_mod_of_dvd n ( by decide : 5 ∣ 20 ) ] at hn_mod; rw [ Nat.not_even_iff ] at h_even; omega ) using 1

/-
Correctness of the heuristic check function.
-/
def checkSierpinski (n : ℕ) (limitX : ℕ) (limitK : ℕ) : Option (ℕ × ℕ × ℕ) :=
  let start := n / 5 + 1
  (List.range limitX).findSome? fun i =>
    let x := start + i
    let A := 5 * x - n
    let B := n * x
    (List.range limitK).findSome? fun j =>
      let k := j + 1
      if (B + k) % A == 0 then
        let y := (B + k) / A
        if (B * y) % k == 0 then
          let z := (B * y) / k
          some (x, y, z)
        else none
      else none

theorem checkSierpinski_correct {n : ℕ} {limitX limitK : ℕ} {x y z : ℕ}
  (hn : n ≠ 0)
  (h : checkSierpinski n limitX limitK = some (x, y, z)) :
  SierpinskiSolvable n := by
    unfold checkSierpinski at h;
    obtain ⟨i, hi⟩ : ∃ i ∈ List.range limitX, ∃ j ∈ List.range limitK, (n * (n / 5 + 1 + i) + (j + 1)) % (5 * (n / 5 + 1 + i) - n) = 0 ∧ (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) % (j + 1) = 0 ∧ (n / 5 + 1 + i, ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n)), (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) / (j + 1)) = (x, y, z) := by
      rw [ List.findSome?_eq_some_iff ] at h;
      obtain ⟨ l₁, a, l₂, h₁, h₂, h₃ ⟩ := h;
      rw [ List.findSome?_eq_some_iff ] at h₂;
      grind;
    rcases hi with ⟨ hi₁, j, hj₁, hj₂, hj₃, rfl, rfl, rfl ⟩;
    refine' ⟨ n / 5 + 1 + i, ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ), n * ( n / 5 + 1 + i ) * ( ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ) ) / ( j + 1 ), _, _, _, _ ⟩;
    · positivity;
    · exact Nat.div_pos ( Nat.le_of_dvd ( Nat.succ_pos _ ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by omega ) );
    · refine' Nat.div_pos _ ( Nat.succ_pos _ );
      refine' Nat.le_of_dvd _ ( Nat.dvd_of_mod_eq_zero hj₃ );
      exact Nat.mul_pos ( Nat.mul_pos ( Nat.pos_of_ne_zero hn ) ( by positivity ) ) ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) );
    · rw [ Nat.cast_div, Nat.cast_div ];
      · field_simp;
        rw [ Nat.cast_sub ] <;> push_cast;
        · rw [ add_div', mul_div_assoc' ];
          · rw [ eq_div_iff ];
            · rw [ Nat.cast_div ( Nat.dvd_of_mod_eq_zero hj₂ ) ] <;> norm_num;
              · field_simp;
                rw [ div_add', div_eq_div_iff ] <;> norm_cast <;> norm_num;
                · exact Or.inl ( by rw [ Nat.cast_sub ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ] ; push_cast; ring );
                · omega;
                · omega;
                · omega;
              · omega;
            · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
          · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
        · omega;
      · exact Nat.dvd_of_mod_eq_zero hj₃;
      · positivity;
      · exact Nat.dvd_of_mod_eq_zero hj₂;
      · exact ne_of_gt <| Nat.cast_pos.mpr <| Nat.sub_pos_of_lt <| by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ;

/-
If n ≡ 21 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_21 {n : ℕ} (h : n % 60 = 21) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by 3, we can apply the theorem `sierpinski_div_3`.
  have h_div_3 : 3 ∣ n := by
    omega
  exact sierpinski_div_3 (by
  grind) h_div_3

/-
Bounded verification of Sierpinski conjecture for n < 100.
-/
def verifySierpinskiStep (n : ℕ) : Bool :=
  if n % 5 == 1 && n >= 4 then
    (checkSierpinski n 100 1000).isSome
  else
    true

def verifySierpinskiUpTo (N : ℕ) : Bool :=
  (List.range N).all verifySierpinskiStep

theorem sierpinski_bounded_verification : verifySierpinskiUpTo 100 = true := by native_decide

/-
If k is SierpinskiSolvable, then any multiple k*m is also SierpinskiSolvable.
-/
theorem sierpinski_mul_solvable {k m : ℕ} (hm : m > 0) (h : SierpinskiSolvable k) : SierpinskiSolvable (k * m) := by
  obtain ⟨ x, y, z, hx, hy, hz, h' ⟩ := h;
  use x * m, y * m, z * m;
  simp_all +decide [ mul_comm, mul_assoc, mul_left_comm, div_eq_mul_inv ];
  linear_combination' h' * ( m : ℚ ) ⁻¹

/-
If n ≡ 41 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_41 {n : ℕ} (h : n % 60 = 41) : SierpinskiSolvable n := by
  -- Let $x = 12k + 9$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 60 * k + 41 := by
    exact ⟨ n / 60, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let $x = 12k + 9$, $y = (60k + 41)(4k + 3)$, and $z = (60k + 41)(12k + 9)$.
  use 12 * k + 9, (60 * k + 41) * (4 * k + 3), (60 * k + 41) * (12 * k + 9);
  field_simp;
  exact ⟨ by linarith, by positivity, by positivity, by push_cast; ring ⟩

/-
If n has a divisor d ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_has_factor_mod_4_3 {n : ℕ} (hn : n ≠ 0) (h : ∃ d, d ∣ n ∧ d % 4 = 3) : SierpinskiSolvable n := by
  -- Apply the sierpinski_mod_4_3 theorem to the divisor d.
  obtain ⟨d, hd_div, hd_mod⟩ := h;
  have hd_solvable : SierpinskiSolvable d := by
    exact sierpinski_mod_4_3 hd_mod;
  obtain ⟨ k, rfl ⟩ := hd_div; exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop ) ) hd_solvable;

/-
If we can solve n ≡ 1 (mod 60), we can solve all n ≡ 1 (mod 20).
-/
theorem sierpinski_reduction_to_mod_60_1 (h_mod_60_1 : ∀ n : ℕ, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 20 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    have h_cases : n % 60 = 1 ∨ n % 60 = 21 ∨ n % 60 = 41 := by
      omega;
    exact h_cases.elim ( fun h => h_mod_60_1 n h ) fun h => h.elim ( fun h => sierpinski_mod_60_21 h ) fun h => sierpinski_mod_60_41 h

/-
Reduction to the case where all prime factors are 1 mod 4.
-/
theorem sierpinski_reduction_hard_primes
  (h_hard : ∀ n, n ≥ 4 → (∀ p, p.Prime → p ∣ n → p % 4 = 1) → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → SierpinskiSolvable n := by
    intro n hn; by_cases h_even : Even n; simp_all +decide [ Nat.even_iff ] ;
    · exact sierpinski_div_2 ( by linarith ) ( Nat.dvd_of_mod_eq_zero h_even );
    · by_cases h_factor : ∃ p, Nat.Prime p ∧ p ∣ n ∧ p % 4 = 3;
      · exact sierpinski_has_factor_mod_4_3 ( by linarith ) ⟨ h_factor.choose, h_factor.choose_spec.2.1, h_factor.choose_spec.2.2 ⟩;
      · apply h_hard n hn;
        intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
        have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
        exact absurd ( even_iff_two_dvd.mpr dp ) ( by simpa using h_even )

/-
If SierpinskiSolvable holds for all primes, it holds for all n >= 2.
-/
theorem sierpinski_reduction_to_primes (h_primes : ∀ p : ℕ, p.Prime → SierpinskiSolvable p) :
  ∀ n : ℕ, n ≥ 2 → SierpinskiSolvable n := by
    intro n hn;
    obtain ⟨ p, hp ⟩ := Nat.exists_prime_and_dvd ( by linarith : n ≠ 1 );
    obtain ⟨ k, rfl ⟩ := hp.2;
    exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( h_primes p hp.1 )

/-
Greedy reduction: if 20/(n(n+4)) is sum of 2 unit fractions, then n is solvable.
-/
theorem sierpinski_greedy_reduction {n : ℕ} (hn : n ≠ 0) (h_mod : n % 5 = 1)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 20 / ((n : ℚ) * (n + 4)) = 1 / y + 1 / z) :
  SierpinskiSolvable n := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    use (n + 4) / 5, y, z;
    rw [ Nat.cast_div ] <;> norm_num;
    · field_simp at h ⊢;
      exact ⟨ by omega, hy, hz, by linarith ⟩;
    · omega

/-
Bounded verification of Sierpinski conjecture for n < 1000.
-/
theorem sierpinski_bounded_verification_1000 : verifySierpinskiUpTo 1000 = true := by native_decide

/-
Bounded verification of Sierpinski conjecture for n < 10000.
-/
theorem sierpinski_bounded_verification_10000 : verifySierpinskiUpTo 10000 = true := by native_decide

/-
Final reduction: The only open case for n ≡ 1 (mod 5) is n ≡ 1 (mod 60).
-/
theorem sierpinski_reduction_final (h_mod_60_1 : ∀ n, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → n % 5 = 1 → SierpinskiSolvable n := by
    intro n hn h;
    by_cases h_even : Even n;
    · exact sierpinski_div_2 ( by linarith ) ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod_4 : n % 4 = 3;
      · exact?;
      · by_cases h_mod_20 : n % 20 = 1;
        · exact sierpinski_reduction_to_mod_60_1 h_mod_60_1 n ( by linarith ) h_mod_20;
        · grind