/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a144d232-d801-457a-961a-2eb52daf35de
-/

/-
We define the triangle covering number τ(S) for a set of triangles S in a graph G.
We prove the subadditivity property: τ(S₁ ∪ S₂) ≤ τ(S₁) + τ(S₂).
This is done by showing that the union of optimal covers for S₁ and S₂ is a cover for S₁ ∪ S₂.
We also provide a version using sInf directly.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

/-- A cover of triangle set S: edges that hit every triangle in S -/
def isCoverOf (G : SimpleGraph V) [DecidableRel G.Adj]
    (E : Finset (Sym2 V)) (S : Finset (Finset V)) : Prop :=
  E ⊆ G.edgeFinset ∧ ∀ t ∈ S, ∃ e ∈ E, e ∈ t.sym2

/-- Triangle covering number for a subset of triangles -/
noncomputable def triangleCoveringOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) : ℕ :=
  if h : ∃ E : Finset (Sym2 V), isCoverOf G E S then
    ((Finset.range (Fintype.card (Sym2 V) + 1)).filter (fun n : ℕ => ∃ E : Finset (Sym2 V), E.card = n ∧ isCoverOf G E S)).min'
      (by
        obtain ⟨E, hE⟩ := h
        use E.card
        simp only [Finset.mem_filter, Finset.mem_range, true_and]
        constructor
        · exact Nat.lt_succ_of_le (Finset.card_le_univ E)
        · exact ⟨E, rfl, hE⟩)
  else 0

/-- Alternative direct definition using sInf -/
noncomputable def triangleCoveringOn' (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) : ℕ :=
  sInf { n | ∃ E : Finset (Sym2 V), E.card = n ∧ isCoverOf G E S }

lemma triangleCoveringOn_empty (G : SimpleGraph V) [DecidableRel G.Adj] :
    triangleCoveringOn G ∅ = 0 := by
      -- Since the empty set has no triangles, any set of edges is a cover. The smallest set is the empty set itself, which has size 0.
      simp [triangleCoveringOn];
      -- Since the set contains 0, the infimum is 0.
      intros x hx
      apply le_antisymm;
      · -- Since 0 is in the set, the infimum must be ≤ 0.
        apply Finset.inf'_le;
        simp [isCoverOf];
      · -- Since the infimum of a set of non-negative numbers is non-negative, we have:
        apply Nat.zero_le

lemma triangleCoveringOn_singleton (G : SimpleGraph V) [DecidableRel G.Adj]
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    triangleCoveringOn G {t} ≤ 1 := by
      -- Since $t$ is a triangle, any edge in $t$ covers $t$. Therefore, we can choose any edge from $t$ to form a cover of size 1.
      have h_cover : ∃ e ∈ t.sym2, isCoverOf G {e} {t} := by
        -- Since $t$ is a triangle, it must have exactly three edges. Let's pick any edge $e$ from $t$ and show that it covers $t$.
        obtain ⟨e, he⟩ : ∃ e ∈ t.sym2, e ∈ G.edgeFinset := by
          rw [ SimpleGraph.mem_cliqueFinset_iff ] at ht;
          rcases Finset.card_eq_three.mp ht.2 with ⟨ a, b, c, hab, hbc, hac ⟩ ; simp_all +decide [ SimpleGraph.isNClique_iff ];
          exact ⟨ Sym2.mk ( a, b ), by aesop ⟩;
        unfold isCoverOf; aesop;
      -- Since there exists an edge e in t.sym2 such that {e} is a cover of {t}, the minimum number of edges needed is 1.
      obtain ⟨e, he₁, he₂⟩ := h_cover;
      have h_min : triangleCoveringOn G {t} ≤ 1 := by
        unfold triangleCoveringOn;
        split_ifs <;> simp_all +decide [ Finset.min' ];
        exact ⟨ 1, ⟨ Nat.lt_succ_of_le ( Nat.succ_le_of_lt ( Fintype.card_pos_iff.mpr ⟨ e ⟩ ) ), { e }, by simp +decide, he₂ ⟩, by simp +decide ⟩;
      exact h_min

/-- Union of covers is a cover of the union -/
lemma cover_union (G : SimpleGraph V) [DecidableRel G.Adj]
    (E₁ E₂ : Finset (Sym2 V)) (S₁ S₂ : Finset (Finset V))
    (h₁ : isCoverOf G E₁ S₁) (h₂ : isCoverOf G E₂ S₂) :
    isCoverOf G (E₁ ∪ E₂) (S₁ ∪ S₂) := by
  constructor
  · -- (E₁ ∪ E₂) ⊆ G.edgeFinset
    intro e he
    simp only [Finset.mem_union] at he
    cases he with
    | inl h => exact h₁.1 h
    | inr h => exact h₂.1 h
  · -- Every triangle in S₁ ∪ S₂ is covered
    intro t ht
    simp only [Finset.mem_union] at ht
    cases ht with
    | inl h =>
      obtain ⟨e, he, het⟩ := h₁.2 t h
      exact ⟨e, Finset.mem_union_left _ he, het⟩
    | inr h =>
      obtain ⟨e, he, het⟩ := h₂.2 t h
      exact ⟨e, Finset.mem_union_right _ he, het⟩

/-- Subadditivity: τ(S₁ ∪ S₂) ≤ τ(S₁) + τ(S₂) -/
theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (S₁ S₂ : Finset (Finset V)) :
    triangleCoveringOn G (S₁ ∪ S₂) ≤ triangleCoveringOn G S₁ + triangleCoveringOn G S₂ := by
      by_contra h;
      -- By definition of `triangleCoveringOn`, there exist sets `E₁` and `E₂` such that `E₁` covers `S₁` with `|E₁| = triangleCoveringOn G S₁` and `E₂` covers `S₂` with `|E₂| = triangleCoveringOn G S₂`.
      obtain ⟨E₁, hE₁⟩ : ∃ E₁ : Finset (Sym2 V), isCoverOf G E₁ S₁ ∧ E₁.card = triangleCoveringOn G S₁ := by
        unfold triangleCoveringOn at *;
        split_ifs with h₁;
        · have := Finset.min'_mem ( Finset.filter ( fun n => ∃ E : Finset ( Sym2 V ), E.card = n ∧ isCoverOf G E S₁ ) ( Finset.range ( Fintype.card ( Sym2 V ) + 1 ) ) ) ⟨ _, Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( Nat.lt_succ_of_le ( show Fintype.card ( Sym2 V ) ≥ Finset.card ( h₁.choose : Finset ( Sym2 V ) ) from Finset.card_le_univ _ ) ), ⟨ h₁.choose, rfl, h₁.choose_spec ⟩ ⟩ ⟩;
          grind;
        · split_ifs at h <;> simp_all +decide;
          · obtain ⟨ E₁, hE₁ ⟩ := ‹∃ E : Finset ( Sym2 V ), isCoverOf G E ( S₁ ∪ S₂ ) ›;
            exact h₁ E₁ ( by exact ⟨ hE₁.1, fun t ht => by obtain ⟨ e, he₁, he₂ ⟩ := hE₁.2 t ( Finset.mem_union_left _ ht ) ; exact ⟨ e, he₁, he₂ ⟩ ⟩ );
          · rename_i h₂ h₃;
            exact h₃ _ ( h₂.choose_spec.2 |> fun h => ⟨ h₂.choose_spec.1, fun t ht => h t ( Finset.mem_union_right _ ht ) ⟩ )
      obtain ⟨E₂, hE₂⟩ : ∃ E₂ : Finset (Sym2 V), isCoverOf G E₂ S₂ ∧ E₂.card = triangleCoveringOn G S₂ := by
        unfold triangleCoveringOn;
        split_ifs with h₂;
        · have := Finset.min'_mem ( Finset.filter ( fun n => ∃ E : Finset ( Sym2 V ), E.card = n ∧ isCoverOf G E S₂ ) ( Finset.range ( Fintype.card ( Sym2 V ) + 1 ) ) ) ⟨ _, Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( Nat.lt_succ_of_le ( Finset.card_le_univ _ ) ), h₂.choose, rfl, h₂.choose_spec ⟩ ⟩ ; aesop;
        · unfold triangleCoveringOn at h;
          simp_all +decide [ Finset.min' ];
          split_ifs at h;
          · obtain ⟨ E, hE ⟩ := ‹∃ E : Finset ( Sym2 V ), isCoverOf G E ( S₁ ∪ S₂ ) ›;
            exact h₂ E ( by exact ⟨ hE.1, fun t ht => hE.2 t ( Finset.mem_union_right _ ht ) ⟩ );
          · exact h.not_le ( Nat.zero_le _ );
          · exact ‹¬∃ E, isCoverOf G E S₁› ⟨ E₁, hE₁.1 ⟩;
          · contradiction;
      -- By definition of `triangleCoveringOn`, we know that `E₁ ∪ E₂` covers `S₁ ∪ S₂`.
      have h_union : isCoverOf G (E₁ ∪ E₂) (S₁ ∪ S₂) := by
        exact cover_union G E₁ E₂ S₁ S₂ hE₁.1 hE₂.1;
      refine' h ( le_trans ( _ : _ ≤ _ ) ( Nat.le_trans ( Finset.card_union_le _ _ ) ( add_le_add hE₁.2.le hE₂.2.le ) ) );
      unfold triangleCoveringOn;
      split_ifs <;> simp_all +decide [ Finset.min' ];
      exact ⟨ _, ⟨ Nat.lt_succ_of_le ( Finset.card_le_univ _ ), _, rfl, h_union ⟩, le_rfl ⟩

/-- Simpler version using Nat.sInf directly -/
theorem tau_union_le_sum' (G : SimpleGraph V) [DecidableRel G.Adj]
    (S₁ S₂ : Finset (Finset V)) :
    triangleCoveringOn' G (S₁ ∪ S₂) ≤ triangleCoveringOn' G S₁ + triangleCoveringOn' G S₂ := by
      by_contra! h_contra;
      -- By definition of triangleCoveringOn', there exist covers E₁ and E₂ for S₁ and S₂ respectively, such that |E₁| ≤ triangleCoveringOn' G S₁ and |E₂| ≤ triangleCoveringOn' G S₂.
      obtain ⟨E₁, hE₁⟩ : ∃ E₁ : Finset (Sym2 V), E₁.card ≤ triangleCoveringOn' G S₁ ∧ isCoverOf G E₁ S₁ := by
        obtain ⟨E₁, hE₁⟩ : ∃ E₁ : Finset (Sym2 V), isCoverOf G E₁ S₁ := by
          have h_exists_cover : ∃ E : Finset (Sym2 V), isCoverOf G E (S₁ ∪ S₂) := by
            unfold triangleCoveringOn' at h_contra;
            by_cases h_empty : ∃ E : Finset (Sym2 V), isCoverOf G E (S₁ ∪ S₂);
            · exact h_empty;
            · simp_all +decide [ Nat.sInf_eq_zero.mpr ];
          exact ⟨ h_exists_cover.choose, ⟨ h_exists_cover.choose_spec.1, fun t ht => h_exists_cover.choose_spec.2 t ( Finset.mem_union_left _ ht ) ⟩ ⟩;
        have := Nat.sInf_mem ( show Set.Nonempty { n : ℕ | ∃ E : Finset ( Sym2 V ), E.card = n ∧ isCoverOf G E S₁ } from ⟨ E₁.card, ⟨ E₁, rfl, hE₁ ⟩ ⟩ ) ; aesop;
      obtain ⟨E₂, hE₂⟩ : ∃ E₂ : Finset (Sym2 V), E₂.card ≤ triangleCoveringOn' G S₂ ∧ isCoverOf G E₂ S₂ := by
        by_cases h₂ : ∃ E₂ : Finset (Sym2 V), isCoverOf G E₂ S₂;
        · have := Nat.sInf_mem ( show { n : ℕ | ∃ E : Finset ( Sym2 V ), E.card = n ∧ isCoverOf G E S₂ }.Nonempty from by obtain ⟨ E₂, hE₂ ⟩ := h₂; exact ⟨ _, ⟨ E₂, rfl, hE₂ ⟩ ⟩ ) ; aesop;
        · simp_all +decide [ triangleCoveringOn' ];
          contrapose! h_contra;
          rw [ Nat.sInf_eq_zero.mpr ];
          · exact Nat.zero_le _;
          · refine' Or.inr ( Set.eq_empty_of_forall_notMem fun n hn => _ );
            obtain ⟨ E, rfl, hE ⟩ := hn;
            exact h₂ E ( by exact ⟨ hE.1, fun t ht => by obtain ⟨ e, he₁, he₂ ⟩ := hE.2 t ( Finset.mem_union_right _ ht ) ; exact ⟨ e, he₁, he₂ ⟩ ⟩ );
      refine' h_contra.not_le ( le_trans ( Nat.sInf_le _ ) _ );
      exact ( E₁ ∪ E₂ ).card;
      · exact ⟨ _, rfl, cover_union G E₁ E₂ S₁ S₂ hE₁.2 hE₂.2 ⟩;
      · exact le_trans ( Finset.card_union_le _ _ ) ( add_le_add hE₁.1 hE₂.1 )