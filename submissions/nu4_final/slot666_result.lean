/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 38d45f19-6c33-4d4a-8bb1-1ccc5835e193

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4c46ee72-7b79-4bf8-b0d8-bec5575d8cd8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 15b6f5d1-46ac-4b9d-81b4-dc6c4927b234

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5b5bf303-ce30-4b18-93b8-95219874619e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d94555c4-f79e-4416-97a2-c3cdf5251251

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the attack on the Sierpinski Conjecture (Erdős-Straus for 5/n) for the case n ≡ 1 (mod 5).

Key results:
1. `sierpinski_div_2`, `sierpinski_div_3`: Solvability for n even or divisible by 3.
2. `sierpinski_mod_4_3`: Solvability for n ≡ 3 (mod 4).
3. `sierpinski_mod_60_21`, `sierpinski_mod_60_41`: Solvability for n ≡ 21, 41 (mod 60).
4. `sierpinski_reduction_final`: A reduction theorem proving that for n ≥ 4 with n ≡ 1 (mod 5), the conjecture holds for all cases except possibly n ≡ 1 (mod 60).
5. `sierpinski_bounded_verification_10000`: Verified the conjecture for all n < 10000 using `native_decide`.

We also proved auxiliary lemmas such as `sierpinski_mul_solvable` (multiplicative property) and `sierpinski_has_factor_mod_4_3` (solvability if n has a factor ≡ 3 mod 4). The remaining open case is n ≡ 1 (mod 60).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of SierpinskiSolvable: 5/n can be written as sum of three unit fractions.
-/
def SierpinskiSolvable (n : ℕ) : Prop := ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
If n is even and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_2 {n : ℕ} (h1 : n ≠ 0) (h2 : 2 ∣ n) : SierpinskiSolvable n := by
  obtain ⟨ k, rfl ⟩ := h2;
  use 2 * k, k, k;
  grind

/-
If n is divisible by 3 and non-zero, SierpinskiSolvable n is true.
-/
theorem sierpinski_div_3 {n : ℕ} (h1 : n ≠ 0) (h2 : 3 ∣ n) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by $3$, we can write $n = 3k$ for some $k$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 3 * k := h2;
  -- We can write 5/(3k) = 1/k + 2/(3k).
  use k, 2 * k, 6 * k;
  exact ⟨ Nat.pos_of_ne_zero ( by aesop ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), Nat.mul_pos ( by decide ) ( Nat.pos_of_ne_zero ( by aesop ) ), by push_cast; ring ⟩

/-
If n = 5(2k+1) + 1, then SierpinskiSolvable n.
-/
theorem sierpinski_mod_5_q_odd {k : ℕ} : SierpinskiSolvable (5 * (2 * k + 1) + 1) := by
  convert sierpinski_div_2 _ _ using 1 <;> norm_num;
  grind

/-
Reduction lemma: if 4/(n(2k+1)) is solvable, then SierpinskiSolvable (10k+1).
-/
theorem sierpinski_mod_10_1_reduction {k : ℕ} (hk : k > 0)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((10 * k + 1 : ℚ) * (2 * k + 1)) = 1 / y + 1 / z) :
  SierpinskiSolvable (10 * k + 1) := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    -- Therefore, $5 / (10k + 1) = 1 / (2k + 1) + 1 / y + 1 / z$.
    have h_eq : (5 : ℚ) / (10 * k + 1) = 1 / (2 * k + 1) + 1 / y + 1 / z := by
      field_simp at h ⊢;
      grind;
    exact ⟨ 2 * k + 1, y, z, by positivity, by positivity, by positivity, by simpa [ ← @Rat.cast_inj ℝ ] using h_eq ⟩

/-
If n ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_4_3 {n : ℕ} (h : n % 4 = 3) : SierpinskiSolvable n := by
  -- Since n % 4 = 3, we can write n as 4k + 3 for some integer k.
  obtain ⟨k, rfl⟩ : ∃ k, n = 4 * k + 3 := by
    exact ⟨ n / 4, by rw [ ← h, Nat.div_add_mod ] ⟩;
  use 4 * k + 3, k + 1, ( k + 1 ) * ( 4 * k + 3 );
  field_simp
  ring;
  exact ⟨ by positivity, by positivity, by positivity, by push_cast; ring ⟩

/-
If we can solve the n ≡ 1 (mod 20) case, then we can solve all n ≡ 1 (mod 5).
-/
theorem sierpinski_reduction_to_mod_20 (h_mod_20 : ∀ n : ℕ, n % 20 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 5 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    by_cases h_even : Even n;
    · exact sierpinski_div_2 hn ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod4 : n % 4 = 3;
      · exact sierpinski_mod_4_3 ( by omega );
      · convert h_mod_20 n ( by rw [ ← Nat.mod_mod_of_dvd n ( by decide : 4 ∣ 20 ) ] at h_mod4; rw [ ← Nat.mod_mod_of_dvd n ( by decide : 5 ∣ 20 ) ] at hn_mod; rw [ Nat.not_even_iff ] at h_even; omega ) using 1

/-
Correctness of the heuristic check function.
-/
def checkSierpinski (n : ℕ) (limitX : ℕ) (limitK : ℕ) : Option (ℕ × ℕ × ℕ) :=
  let start := n / 5 + 1
  (List.range limitX).findSome? fun i =>
    let x := start + i
    let A := 5 * x - n
    let B := n * x
    (List.range limitK).findSome? fun j =>
      let k := j + 1
      if (B + k) % A == 0 then
        let y := (B + k) / A
        if (B * y) % k == 0 then
          let z := (B * y) / k
          some (x, y, z)
        else none
      else none

theorem checkSierpinski_correct {n : ℕ} {limitX limitK : ℕ} {x y z : ℕ}
  (hn : n ≠ 0)
  (h : checkSierpinski n limitX limitK = some (x, y, z)) :
  SierpinskiSolvable n := by
    unfold checkSierpinski at h;
    obtain ⟨i, hi⟩ : ∃ i ∈ List.range limitX, ∃ j ∈ List.range limitK, (n * (n / 5 + 1 + i) + (j + 1)) % (5 * (n / 5 + 1 + i) - n) = 0 ∧ (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) % (j + 1) = 0 ∧ (n / 5 + 1 + i, ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n)), (n * (n / 5 + 1 + i) * ((n * (n / 5 + 1 + i) + (j + 1)) / (5 * (n / 5 + 1 + i) - n))) / (j + 1)) = (x, y, z) := by
      rw [ List.findSome?_eq_some_iff ] at h;
      obtain ⟨ l₁, a, l₂, h₁, h₂, h₃ ⟩ := h;
      rw [ List.findSome?_eq_some_iff ] at h₂;
      grind;
    rcases hi with ⟨ hi₁, j, hj₁, hj₂, hj₃, rfl, rfl, rfl ⟩;
    refine' ⟨ n / 5 + 1 + i, ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ), n * ( n / 5 + 1 + i ) * ( ( n * ( n / 5 + 1 + i ) + ( j + 1 ) ) / ( 5 * ( n / 5 + 1 + i ) - n ) ) / ( j + 1 ), _, _, _, _ ⟩;
    · positivity;
    · exact Nat.div_pos ( Nat.le_of_dvd ( Nat.succ_pos _ ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by omega ) );
    · refine' Nat.div_pos _ ( Nat.succ_pos _ );
      refine' Nat.le_of_dvd _ ( Nat.dvd_of_mod_eq_zero hj₃ );
      exact Nat.mul_pos ( Nat.mul_pos ( Nat.pos_of_ne_zero hn ) ( by positivity ) ) ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) );
    · rw [ Nat.cast_div, Nat.cast_div ];
      · field_simp;
        rw [ Nat.cast_sub ] <;> push_cast;
        · rw [ add_div', mul_div_assoc' ];
          · rw [ eq_div_iff ];
            · rw [ Nat.cast_div ( Nat.dvd_of_mod_eq_zero hj₂ ) ] <;> norm_num;
              · field_simp;
                rw [ div_add', div_eq_div_iff ] <;> norm_cast <;> norm_num;
                · exact Or.inl ( by rw [ Nat.cast_sub ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ] ; push_cast; ring );
                · omega;
                · omega;
                · omega;
              · omega;
            · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
          · exact mul_ne_zero ( mul_ne_zero ( Nat.cast_ne_zero.mpr hn ) ( by positivity ) ) ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( by positivity ) ( Nat.dvd_of_mod_eq_zero hj₂ ) ) ( Nat.sub_pos_of_lt ( by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ) ) ) ) );
        · omega;
      · exact Nat.dvd_of_mod_eq_zero hj₃;
      · positivity;
      · exact Nat.dvd_of_mod_eq_zero hj₂;
      · exact ne_of_gt <| Nat.cast_pos.mpr <| Nat.sub_pos_of_lt <| by linarith [ Nat.div_add_mod n 5, Nat.mod_lt n ( by decide : 5 > 0 ) ] ;

/-
If n ≡ 21 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_21 {n : ℕ} (h : n % 60 = 21) : SierpinskiSolvable n := by
  -- Since $n$ is divisible by 3, we can apply the theorem `sierpinski_div_3`.
  have h_div_3 : 3 ∣ n := by
    omega
  exact sierpinski_div_3 (by
  grind) h_div_3

/-
Bounded verification of Sierpinski conjecture for n < 100.
-/
def verifySierpinskiStep (n : ℕ) : Bool :=
  if n % 5 == 1 && n >= 4 then
    (checkSierpinski n 100 1000).isSome
  else
    true

def verifySierpinskiUpTo (N : ℕ) : Bool :=
  (List.range N).all verifySierpinskiStep

theorem sierpinski_bounded_verification : verifySierpinskiUpTo 100 = true := by native_decide

/-
If k is SierpinskiSolvable, then any multiple k*m is also SierpinskiSolvable.
-/
theorem sierpinski_mul_solvable {k m : ℕ} (hm : m > 0) (h : SierpinskiSolvable k) : SierpinskiSolvable (k * m) := by
  obtain ⟨ x, y, z, hx, hy, hz, h' ⟩ := h;
  use x * m, y * m, z * m;
  simp_all +decide [ mul_comm, mul_assoc, mul_left_comm, div_eq_mul_inv ];
  linear_combination' h' * ( m : ℚ ) ⁻¹

/-
If n ≡ 41 (mod 60), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_60_41 {n : ℕ} (h : n % 60 = 41) : SierpinskiSolvable n := by
  -- Let $x = 12k + 9$.
  obtain ⟨k, rfl⟩ : ∃ k, n = 60 * k + 41 := by
    exact ⟨ n / 60, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let $x = 12k + 9$, $y = (60k + 41)(4k + 3)$, and $z = (60k + 41)(12k + 9)$.
  use 12 * k + 9, (60 * k + 41) * (4 * k + 3), (60 * k + 41) * (12 * k + 9);
  field_simp;
  exact ⟨ by linarith, by positivity, by positivity, by push_cast; ring ⟩

/-
If n has a divisor d ≡ 3 (mod 4), then SierpinskiSolvable n.
-/
theorem sierpinski_has_factor_mod_4_3 {n : ℕ} (hn : n ≠ 0) (h : ∃ d, d ∣ n ∧ d % 4 = 3) : SierpinskiSolvable n := by
  -- Apply the sierpinski_mod_4_3 theorem to the divisor d.
  obtain ⟨d, hd_div, hd_mod⟩ := h;
  have hd_solvable : SierpinskiSolvable d := by
    exact sierpinski_mod_4_3 hd_mod;
  obtain ⟨ k, rfl ⟩ := hd_div; exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop ) ) hd_solvable;

/-
If we can solve n ≡ 1 (mod 60), we can solve all n ≡ 1 (mod 20).
-/
theorem sierpinski_reduction_to_mod_60_1 (h_mod_60_1 : ∀ n : ℕ, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n : ℕ, n ≠ 0 → n % 20 = 1 → SierpinskiSolvable n := by
    intros n hn hn_mod
    have h_cases : n % 60 = 1 ∨ n % 60 = 21 ∨ n % 60 = 41 := by
      omega;
    exact h_cases.elim ( fun h => h_mod_60_1 n h ) fun h => h.elim ( fun h => sierpinski_mod_60_21 h ) fun h => sierpinski_mod_60_41 h

/-
Reduction to the case where all prime factors are 1 mod 4.
-/
theorem sierpinski_reduction_hard_primes
  (h_hard : ∀ n, n ≥ 4 → (∀ p, p.Prime → p ∣ n → p % 4 = 1) → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → SierpinskiSolvable n := by
    intro n hn; by_cases h_even : Even n; simp_all +decide [ Nat.even_iff ] ;
    · exact sierpinski_div_2 ( by linarith ) ( Nat.dvd_of_mod_eq_zero h_even );
    · by_cases h_factor : ∃ p, Nat.Prime p ∧ p ∣ n ∧ p % 4 = 3;
      · exact sierpinski_has_factor_mod_4_3 ( by linarith ) ⟨ h_factor.choose, h_factor.choose_spec.2.1, h_factor.choose_spec.2.2 ⟩;
      · apply h_hard n hn;
        intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
        have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
        exact absurd ( even_iff_two_dvd.mpr dp ) ( by simpa using h_even )

/-
If SierpinskiSolvable holds for all primes, it holds for all n >= 2.
-/
theorem sierpinski_reduction_to_primes (h_primes : ∀ p : ℕ, p.Prime → SierpinskiSolvable p) :
  ∀ n : ℕ, n ≥ 2 → SierpinskiSolvable n := by
    intro n hn;
    obtain ⟨ p, hp ⟩ := Nat.exists_prime_and_dvd ( by linarith : n ≠ 1 );
    obtain ⟨ k, rfl ⟩ := hp.2;
    exact sierpinski_mul_solvable ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( h_primes p hp.1 )

/-
Greedy reduction: if 20/(n(n+4)) is sum of 2 unit fractions, then n is solvable.
-/
theorem sierpinski_greedy_reduction {n : ℕ} (hn : n ≠ 0) (h_mod : n % 5 = 1)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 20 / ((n : ℚ) * (n + 4)) = 1 / y + 1 / z) :
  SierpinskiSolvable n := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    use (n + 4) / 5, y, z;
    rw [ Nat.cast_div ] <;> norm_num;
    · field_simp at h ⊢;
      exact ⟨ by omega, hy, hz, by linarith ⟩;
    · omega

/-
Bounded verification of Sierpinski conjecture for n < 1000.
-/
theorem sierpinski_bounded_verification_1000 : verifySierpinskiUpTo 1000 = true := by native_decide

/-
Bounded verification of Sierpinski conjecture for n < 10000.
-/
theorem sierpinski_bounded_verification_10000 : verifySierpinskiUpTo 10000 = true := by native_decide

/-
Final reduction: The only open case for n ≡ 1 (mod 5) is n ≡ 1 (mod 60).
-/
theorem sierpinski_reduction_final (h_mod_60_1 : ∀ n, n % 60 = 1 → SierpinskiSolvable n) :
  ∀ n, n ≥ 4 → n % 5 = 1 → SierpinskiSolvable n := by
    intro n hn h;
    by_cases h_even : Even n;
    · exact sierpinski_div_2 ( by linarith ) ( even_iff_two_dvd.mp h_even );
    · by_cases h_mod_4 : n % 4 = 3;
      · exact?;
      · by_cases h_mod_20 : n % 20 = 1;
        · exact sierpinski_reduction_to_mod_60_1 h_mod_60_1 n ( by linarith ) h_mod_20;
        · grind

/-
Reduction lemma for n = 60q + 1: if 4/((60q+1)(12q+1)) is a sum of two unit fractions, then n is solvable.
-/
theorem sierpinski_mod_60_1_reduction {q : ℕ} (hq : q > 0)
  (h : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z) :
  SierpinskiSolvable (60 * q + 1) := by
    obtain ⟨ y, z, hy, hz, h ⟩ := h;
    use 12 * q + 1, y, z;
    field_simp at *;
    exact ⟨ by linarith, hy, hz, by push_cast; linarith ⟩

/-
If n ≡ 301 (mod 420), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_420_301 {n : ℕ} (h : n % 420 = 301) : SierpinskiSolvable n := by
  have h3 : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 7, Nat.dvd_of_mod_eq_zero ( by omega ), by norm_num ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by omega ) h3

/-
If n ≡ 121 (mod 660), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_660_121 {n : ℕ} (h : n % 660 = 121) : SierpinskiSolvable n := by
  -- Since 11 is a factor of n and 11 ≡ 3 (mod 4), by sierpinski_has_factor_mod_4_3, n is solvable.
  have h_factor : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 11, Nat.dvd_of_mod_eq_zero ( by omega ), by norm_num ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by aesop_cat ) h_factor

/-
If n ≡ 361 (mod 1140), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_1140_361 {n : ℕ} (h : n % 1140 = 361) : SierpinskiSolvable n := by
  -- Since $19 \mid n$ and $19 \equiv 3 \pmod{4}$, we can apply the theorem `sierpinski_has_factor_mod_4_3`.
  have h_factor : ∃ d, d ∣ n ∧ d % 4 = 3 := by
    exact ⟨ 19, Nat.dvd_of_mod_eq_zero ( by omega ), by decide ⟩;
  exact sierpinski_has_factor_mod_4_3 ( by aesop_cat ) h_factor

/-
Bounded verification of Sierpinski conjecture for n < 100000.
-/
theorem sierpinski_bounded_verification_100000 : verifySierpinskiUpTo 100000 = true := by native_decide

/-
If n has a divisor d ≡ 3 (mod 4), then 4/n is the sum of two unit fractions.
-/
lemma four_div_n_solvable_2_of_factor_mod_4_3 {n : ℕ} (hn : n > 0)
  (h : ∃ d, d ∣ n ∧ d % 4 = 3) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (n : ℚ) = 1 / y + 1 / z := by
    -- Let $p$ be a prime factor of $d$ such that $p \equiv 3 \pmod{4}$.
    obtain ⟨p, hp_prime, hp_div, hp_mod⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ∧ p % 4 = 3 := by
      obtain ⟨ d, hd₁, hd₂ ⟩ := h;
      by_contra h_no_prime;
      -- If $d$ has no prime factors congruent to $3 \mod 4$, then all prime factors of $d$ must be congruent to $1 \mod 4$.
      have h_all_prime_factors_1_mod_4 : ∀ p : ℕ, Nat.Prime p → p ∣ d → p % 4 = 1 := by
        intro p pp dp; have := Nat.mod_lt p zero_lt_four; interval_cases h : p % 4 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, pp.dvd_iff_eq ] ;
        · have := Nat.Prime.eq_two_or_odd pp; simp_all +decide [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 4 ) ] ;
          omega;
        · exact h_no_prime p pp ( dvd_trans dp hd₁ ) h;
      -- Since all prime factors of $d$ are congruent to $1 \mod 4$, $d$ itself must be congruent to $1 \mod 4$.
      have h_d_congruent_to_1_mod_4 : d % 4 = 1 := by
        rw [ ← Nat.prod_primeFactorsList ( show d ≠ 0 from by aesop_cat ) ] ; rw [ List.prod_nat_mod ] ; ( ( erw [ List.prod_eq_one ] <;> intros <;> aesop ) );
      cases h_d_congruent_to_1_mod_4.symm.trans hd₂;
    -- Let $n = p * k$.
    obtain ⟨k, rfl⟩ : ∃ k, n = p * k := hp_div;
    -- Let $m = \frac{p + 1}{4}$. Since $p \equiv 3 \pmod{4}$, $m$ is an integer.
    obtain ⟨m, hm⟩ : ∃ m : ℕ, p = 4 * m - 1 := by
      exact ⟨ p / 4 + 1, by omega ⟩;
    -- Let $y = kmp$ and $z = km$.
    use k * m * p, k * m;
    rcases m with ( _ | m ) <;> simp_all +decide [ Nat.mul_succ ];
    -- Combine and simplify the fractions on the right-hand side.
    field_simp
    ring

/-
If n ≡ 241 (mod 420), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_420_241 {n : ℕ} (h : n % 420 = 241) : SierpinskiSolvable n := by
  -- By the reduction lemma, if $4/((60q+1)(12q+1))$ is a sum of two unit fractions, then $n$ is solvable.
  have h_reduction : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * ((n - 1) / 60) + 1) * (12 * ((n - 1) / 60) + 1) : ℚ) = 1 / y + 1 / z := by
    convert four_div_n_solvable_2_of_factor_mod_4_3 _ _ using 1;
    case convert_1 => exact ( 60 * ( ( n - 1 ) / 60 ) + 1 ) * ( 12 * ( ( n - 1 ) / 60 ) + 1 );
    · cases n <;> norm_num at *;
      norm_num [ Nat.cast_div ( show 60 ∣ ( ‹_› : ℕ ) from Nat.dvd_of_mod_eq_zero ( by omega ) ) ];
    · positivity;
    · use 7;
      rw [ ← Nat.mod_add_div n 420, h ] ; norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ];
      norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.mul_mod, Nat.add_mod ];
      norm_num [ show 420 * ( n / 420 ) / 60 = 7 * ( n / 420 ) by rw [ Nat.div_eq_of_eq_mul_left ] <;> linarith ];
  have h_div : SierpinskiSolvable (60 * ((n - 1) / 60) + 1) := by
    convert sierpinski_mod_60_1_reduction ( show 0 < ( n - 1 ) / 60 from Nat.div_pos ( Nat.le_sub_one_of_lt ( by omega ) ) ( by decide ) ) _ using 1;
    convert h_reduction using 6;
    rw [ Nat.cast_div ( show 60 ∣ n - 1 from Nat.dvd_of_mod_eq_zero ( by omega ) ) ( by norm_num ) ] ; norm_num;
    rw [ Nat.cast_sub ( by omega ) ] ; push_cast ; ring;
  rw [ show n = 60 * ( ( n - 1 ) / 60 ) + 1 by omega ] ; exact h_div

/-
If n ≡ 601 (mod 660), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_660_601 {n : ℕ} (h : n % 660 = 601) : SierpinskiSolvable n := by
  obtain ⟨q, hq⟩ : ∃ q : ℕ, n = 660 * q + 601 := by
    exact ⟨ n / 660, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- We need to check if $4 / ((60 * (11 * q + 10) + 1 : ℚ) * (12 * (11 * q + 10) + 1)) = 1 / y + 1 / z$ has positive integer solutions $y, z$.
  have h_check : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * (11 * q + 10) + 1 : ℚ) * (12 * (11 * q + 10) + 1)) = 1 / y + 1 / z := by
    -- By the lemma, since $M = (60 * (11 * q + 10) + 1) * (12 * (11 * q + 10) + 1)$ has a factor $11$ which is $3 \mod 4$, $4 / M$ is a sum of two unit fractions.
    have h_factor : ∃ d, d ∣ ((60 * (11 * q + 10) + 1) * (12 * (11 * q + 10) + 1)) ∧ d % 4 = 3 := by
      exact ⟨ 11, Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, Nat.mul_mod ] ), by norm_num ⟩;
    convert four_div_n_solvable_2_of_factor_mod_4_3 _ h_factor using 1 ; norm_cast;
    positivity;
  convert sierpinski_mod_60_1_reduction _ _ using 1;
  rotate_left;
  exacts [ 11 * q + 10, by norm_num, by simpa using h_check, by linarith ]

/-
If n ≡ 661 (mod 1140), then SierpinskiSolvable n.
-/
theorem sierpinski_mod_1140_661 {n : ℕ} (h : n % 1140 = 661) : SierpinskiSolvable n := by
  -- Let n = 1140k + 661.
  obtain ⟨k, rfl⟩ : ∃ k, n = 1140 * k + 661 := by
    exact ⟨ n / 1140, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let x = 12(19k+11) + 1 = 228k + 133 = 19(12k+7).
  set x := 12 * (19 * k + 11) + 1
  set M := (1140 * k + 661) * x;
  -- By four_div_n_solvable_2_of_factor_mod_4_3, 4/M is a sum of two unit fractions.
  have h4M : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (M : ℚ) = 1 / y + 1 / z := by
    have h_factor : ∃ d, d ∣ M ∧ d % 4 = 3 := by
      simp +zetaDelta at *;
      exact ⟨ 19, Nat.dvd_of_mod_eq_zero ( by ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] ), by norm_num ⟩;
    convert four_div_n_solvable_2_of_factor_mod_4_3 ( show M > 0 from Nat.mul_pos ( Nat.succ_pos _ ) ( Nat.succ_pos _ ) ) h_factor using 1;
  convert sierpinski_mod_60_1_reduction _ _ using 1;
  rotate_left;
  exact 19 * k + 11;
  · grind;
  · grind;
  · ring

/-
General reduction: if p is a prime ≡ 3 (mod 4) and p divides (60a+1)(12a+1), then any n ≡ 60a+1 (mod 60p) is solvable.
-/
theorem sierpinski_linear_reduction {p a : ℕ} (hp : p.Prime) (hp3 : p % 4 = 3)
  (h_div : ((60 * a + 1) * (12 * a + 1)) % p = 0) :
  ∀ n, n % (60 * p) = (60 * a + 1) % (60 * p) → SierpinskiSolvable n := by
    -- Let's rewrite the goal using the provided solution.
    intro n hn_mod
    obtain ⟨q, hq⟩ : ∃ q, n = 60 * q + 1 ∧ q % p = a % p := by
      obtain ⟨q, hq⟩ : ∃ q, n = 60 * q + 1 := by
        use (n - 1) / 60;
        have hq : n % 60 = 1 := by
          have := congr_arg ( · % 60 ) hn_mod; norm_num [ Nat.add_mod, Nat.mul_mod ] at this; aesop;
        omega
      generalize_proofs at *; (
      simp_all +decide [ Nat.add_mod, Nat.mul_mod_mul_left ];
      have := Nat.modEq_iff_dvd.mp hn_mod.symm; norm_num at this;
      obtain ⟨ k, hk ⟩ := this; nlinarith [ show k = 0 by nlinarith [ Nat.zero_le ( q % p ), Nat.zero_le ( a % p ), Nat.mod_lt q hp.pos, Nat.mod_lt a hp.pos ] ] ;);
    -- By the reduction lemma, if $4/((60q+1)(12q+1))$ is a sum of two unit fractions, then $n$ is solvable.
    have h_reduction : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z := by
      have h_factor : ∃ d, d ∣ (60 * q + 1) * (12 * q + 1) ∧ d % 4 = 3 := by
        use p;
        simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_mul ];
        exact Or.imp ( fun h => Nat.dvd_of_mod_eq_zero <| by simpa [ Nat.add_mod, Nat.mul_mod, hq.2 ] using Nat.mod_eq_zero_of_dvd h ) ( fun h => Nat.dvd_of_mod_eq_zero <| by simpa [ Nat.add_mod, Nat.mul_mod, hq.2 ] using Nat.mod_eq_zero_of_dvd h ) h_div;
      have := four_div_n_solvable_2_of_factor_mod_4_3 ( show 0 < ( 60 * q + 1 ) * ( 12 * q + 1 ) by positivity ) h_factor; aesop;
    rcases q with ( _ | q ) <;> simp_all +decide;
    · norm_num [ ← hq.2 ] at *;
      rcases h_reduction with ⟨ y, hy, x, hx, h ⟩ ; rw [ inv_add_inv, eq_div_iff ] at h <;> norm_cast at * <;> nlinarith [ Nat.Prime.one_lt hp ] ;
    · convert sierpinski_mod_60_1_reduction ( Nat.succ_pos q ) _ using 1;
      aesop

/-
Definition of hard case: all prime factors of (60q+1)(12q+1) are 1 mod 4. If not hard case, then solvable.
-/
def SierpinskiHardCase (q : ℕ) : Prop :=
  ∀ p, p.Prime → p ∣ ((60 * q + 1) * (12 * q + 1)) → p % 4 = 1

theorem solvable_of_not_hard {q : ℕ} (hq : q > 0) (h : ¬ SierpinskiHardCase q) :
  SierpinskiSolvable (60 * q + 1) := by
    -- If not hard case, then ∃ p, p.Prime, p ∣ (60 * q + 1) * (12 * q + 1), p % 4 ≠ 1
    obtain ⟨p, hp_prime, hp_div, hp_mod⟩ : ∃ p : ℕ, p.Prime ∧ p ∣ (60 * q + 1) * (12 * q + 1) ∧ p % 4 ≠ 1 := by
      contrapose! h; aesop;
    -- Since p is odd and not 1 mod 4, it must be 3 mod 4.
    have hp_mod_3 : p % 4 = 3 := by
      obtain ⟨ k, hk ⟩ := hp_div; replace hk := congr_arg ( · % 4 ) hk; norm_num [ Nat.add_mod, Nat.mul_mod ] at hk; have := Nat.mod_lt p zero_lt_four; interval_cases p % 4 <;> simp_all +decide ;
      omega;
    convert sierpinski_mod_60_1_reduction _ _ using 1;
    · assumption;
    · convert four_div_n_solvable_2_of_factor_mod_4_3 _ _;
      norm_cast;
      · positivity;
      · use p

/-
Strong reduction: It suffices to prove solvability for n = 60q + 1 where all prime factors of n and 12q + 1 are 1 mod 4.
-/
theorem sierpinski_strong_reduction
  (h : ∀ q : ℕ, q > 0 →
    (∀ p, p.Prime → p ∣ (60 * q + 1) → p % 4 = 1) →
    (∀ p, p.Prime → p ∣ (12 * q + 1) → p % 4 = 1) →
    SierpinskiSolvable (60 * q + 1)) :
  ∀ n, n ≥ 4 → n % 60 = 1 → SierpinskiSolvable n := by
    -- Assume n ≥ 4 and n ≡ 1 (mod 60). Then n = 60q + 1 for some q > 0.
    intro n hn hn_mod
    obtain ⟨q, hq_pos, rfl⟩ : ∃ q, q > 0 ∧ n = 60 * q + 1 := by
      exact ⟨ n / 60, by omega, by omega ⟩;
    by_cases hq : SierpinskiHardCase q;
    · exact h q hq_pos ( fun p pp dp => hq p pp ( dvd_mul_of_dvd_left dp _ ) ) ( fun p pp dp => hq p pp ( dvd_mul_of_dvd_right dp _ ) );
    · exact?

/-
If q ≡ 1 (mod 3), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_3_1_reduction {q : ℕ} (hq : q % 3 = 1) : SierpinskiSolvable (60 * q + 1) := by
  -- Let $n = 60q + 1$.
  let n := 60 * q + 1;
  -- Let $x = 12q + 2$.
  let x := 12 * q + 2
  use x, (n * x * (n * x + 1)) / 9, (n * x + 1) / 9
  generalize_proofs at *; (
  -- Now let's verify that these values satisfy the equation.
  have h_eq : 5 / (n : ℚ) = 1 / x + 1 / ((n * x * (n * x + 1)) / 9) + 1 / ((n * x + 1) / 9) := by
    simp +zetaDelta at *; (
    -- Combine and simplify the fractions on the right-hand side.
    field_simp
    ring); -- This completes the proof.
  generalize_proofs at *; (
  rw [ Nat.cast_div, Nat.cast_div ] <;> norm_num at *;
  · grind;
  · grind +ring;
  · grind +ring))

/-
If q ≡ 18 or 21 (mod 23), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_23_18_21 {q : ℕ} (h : q % 23 = 18 ∨ q % 23 = 21) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · -- Let's apply the linear reduction theorem with p=23.
    have h_linear_reduction : ∀ n, n % (60 * 23) = (60 * 18 + 1) % (60 * 23) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · norm_num;
      · norm_num;
    grind;
  · -- Apply the sierpinski_linear_reduction theorem with p=23 and a=21.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 23) (by norm_num : 23 % 4 = 3) (by norm_num : ((60 * 21 + 1) * (12 * 21 + 1)) % 23 = 0);
    grind

/-
If q ≡ 16 or 18 (mod 31), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_31_16_18 {q : ℕ} (h : q % 31 = 16 ∨ q % 31 = 18) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 31, h ] ;
  · -- Apply the sierpinski_linear_reduction theorem with p=31 and a=16.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 31) (by norm_num : 31 % 4 = 3) (by norm_num : ((60 * 16 + 1) * (12 * 16 + 1)) % 31 = 0) (60 * (16 + 31 * (q / 31)) + 1) (by
    grind);
  · -- Apply the sierpinski_linear_reduction theorem with p=31 and a=18.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 31) (by norm_num : 31 % 4 = 3) (by norm_num : ((60 * 18 + 1) * (12 * 18 + 1)) % 31 = 0);
    grind

/-
If q ≡ 5 or 25 (mod 43), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_43_5_25 {q : ℕ} (h : q % 43 = 5 ∨ q % 43 = 25) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the reduction lemma with p=43 and the appropriate a based on the congruence of q mod 43.
  apply sierpinski_linear_reduction (by norm_num : Nat.Prime 43) (by norm_num : 43 % 4 = 3);
  rotate_right;
  exact if h' : q % 43 = 5 then 5 else 25;
  · split_ifs <;> norm_num;
  · grind

/-
If q ≡ 18 or 43 (mod 47), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_47_18_43 {q : ℕ} (h : q % 47 = 18 ∨ q % 47 = 43) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 47 ) ( by norm_num ) _ _ ( show ( 60 * q + 1 ) % ( 60 * 47 ) = ( 60 * 18 + 1 ) % ( 60 * 47 ) by omega ) using 1;
    exact?;
  · have h_linear_reduction : ∀ n, n % (60 * 47) = (60 * 43 + 1) % (60 * 47) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · exact?;
      · norm_num;
    exact h_linear_reduction _ ( by omega )

/-
If q ≡ 54 or 58 (mod 59), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_59_54_58 {q : ℕ} (h : q % 59 = 54 ∨ q % 59 = 58) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · -- Apply the linear reduction with p=59 and a=54.
    have h_linear : ∀ n, n % (60 * 59) = (60 * 54 + 1) % (60 * 59) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction;
      · norm_num;
      · norm_num;
      · norm_num;
    exact h_linear _ ( by omega );
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 59 ) ( by norm_num ) _ _ ( Nat.ModEq.symm <| Nat.modEq_of_dvd <| ?_ ) using 1;
    exacts [ 58, by norm_num, by exact ⟨ q / 59 - 58 / 59, by omega ⟩ ]

/-
If q ≡ 39 or 48 (mod 67), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_67_39_48 {q : ℕ} (h : q % 67 = 39 ∨ q % 67 = 48) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 67, h ];
  · -- Apply the linear reduction with p=67 and a=39.
    have h_linear : ∀ n, n % (60 * 67) = (60 * 39 + 1) % (60 * 67) → SierpinskiSolvable n := by
      apply sierpinski_linear_reduction; norm_num; norm_num; norm_num;
    grind +ring;
  · -- Apply the sierpinski_linear_reduction theorem with p=67 and a=48.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 67) (by norm_num : 67 % 4 = 3) (by norm_num : ((60 * 48 + 1) * (12 * 48 + 1)) % 67 = 0) (60 * (48 + 67 * (q / 67)) + 1) (by
    grind)

/-
If q ≡ 13 or 65 (mod 71), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_71_13_65 {q : ℕ} (h : q % 71 = 13 ∨ q % 71 = 65) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 71, h ];
  · have := sierpinski_linear_reduction ( by norm_num : Nat.Prime 71 ) ( by norm_num ) ( by norm_num : ( ( 60 * 13 + 1 ) * ( 12 * 13 + 1 ) ) % 71 = 0 ) ( 60 * ( 13 + 71 * ( q / 71 ) ) + 1 ) ?_ <;> norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
    · exact this;
    · grind +ring;
  · -- Apply the sierpinski_linear_reduction theorem with p=71.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 71) (by norm_num : 71 % 4 = 3) (by norm_num : ((60 * 65 + 1) * (12 * 65 + 1)) % 71 = 0);
    grind +ring

/-
If q ≡ 4 or 5 (mod 7), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_7_4_5 {q : ℕ} (h : q % 7 = 4 ∨ q % 7 = 5) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h );
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 7 ) ( by norm_num ) _ _ using 1;
    rotate_left;
    exact 4;
    norm_num;
    exact 60 * q + 1;
    grind;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 7 ) ( by norm_num ) _ _ using 1;
    rotate_left;
    exact 5;
    decide +kernel;
    exact 60 * q + 1;
    grind

/-
If q ≡ 6 (mod 19), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_19_6 {q : ℕ} (h : q % 19 = 6) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the sierpinski_linear_reduction theorem with p=19 and a=6.
  apply sierpinski_linear_reduction (by norm_num : Nat.Prime 19) (by norm_num : 19 % 4 = 3) (by norm_num : ((60 * 6 + 1) * (12 * 6 + 1)) % 19 = 0);
  rw [ ← Nat.mod_add_div q 19, h ] ; ring_nf; norm_num;

/-
If q ≡ 2 or 10 (mod 11), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_11_2_10 {q : ℕ} (h : q % 11 = 2 ∨ q % 11 = 10) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the sierpinski_linear_reduction theorem with p=11.
  have h_linear : ∀ n, n % (60 * 11) = (60 * q + 1) % (60 * 11) → SierpinskiSolvable n := by
    apply sierpinski_linear_reduction;
    · norm_num;
    · norm_num;
    · rcases h with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ];
  exact h_linear _ rfl

/-
If q ≡ 25 or 46 (mod 79), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_79_25_46 {q : ℕ} (h : q % 79 = 25 ∨ q % 79 = 46) : SierpinskiSolvable (60 * q + 1) := by
  -- We use sierpinski_linear_reduction with p=79.
  have h_div : 79 ∣ ((60 * q + 1) * (12 * q + 1)) := by
    rcases h with ( h | h ) <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, h ];
  exact solvable_of_not_hard ( by omega ) ( by
    intro H; have := H 79; norm_num at this;
    contradiction )

/-
If q ≡ 65 or 76 (mod 83), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_83_65_76 {q : ℕ} (h : q % 83 = 65 ∨ q % 83 = 76) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 83, h ];
  · -- By sierpinski_linear_reduction, since 83 divides (60*65 + 1)(12*65 + 1), we can conclude that 60*(65 + 83*k) + 1 is solvable.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 83) (by norm_num : 83 % 4 = 3) (by norm_num : ((60 * 65 + 1) * (12 * 65 + 1)) % 83 = 0);
    grind;
  · -- Apply the sierpinski_linear_reduction theorem with p=83 and a=76.
    apply sierpinski_linear_reduction (by norm_num : Nat.Prime 83) (by norm_num : 83 % 4 = 3) (by norm_num : ((60 * 76 + 1) * (12 * 76 + 1)) % 83 = 0) (60 * (76 + 83 * (q / 83)) + 1) (by
    grind)

/-
Bounded verification of Sierpinski conjecture for n < 200000.
-/
theorem sierpinski_bounded_verification_200000 : verifySierpinskiUpTo 200000 = true := by native_decide

/-
If q ≡ 12 or 60 (mod 103), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_103_12_60 {q : ℕ} (h : q % 103 = 12 ∨ q % 103 = 60) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 103 ) ( by norm_num : 103 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 12;
    norm_num;
    exact 60 * q + 1;
    grind;
  · -- Apply the linear reduction with p=103.
    apply sierpinski_linear_reduction;
    case p => exact 103;
    all_goals norm_num;
    rotate_right;
    exacts [ 60, by norm_num, by omega ]

/-
If q ≡ 41 or 98 (mod 107), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_107_41_98 {q : ℕ} (h : q % 107 = 41 ∨ q % 107 = 98) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 107 ) ( by norm_num : 107 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 41;
    decide +revert;
    exact 60 * q + 1;
    grind;
  · -- Apply the linear reduction with p=107.
    apply sierpinski_linear_reduction;
    rotate_left;
    rotate_left;
    rotate_left;
    rotate_left;
    exacts [ 107, 98, by norm_num, by norm_num, by norm_num, by omega ]

/-
If q ≡ 74 or 91 (mod 127), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_127_74_91 {q : ℕ} (h : q % 127 = 74 ∨ q % 127 = 91) : SierpinskiSolvable (60 * q + 1) := by
  rcases h with ( h | h ) <;> rw [ ← Nat.mod_add_div q 127, h ];
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 127 ) ( by norm_num : 127 % 4 = 3 ) _ _ using 1 ; norm_num [ Nat.add_mod, Nat.mul_mod ];
    rotate_left;
    exact 74;
    decide +revert;
    exact 60 * ( 74 + 127 * ( q / 127 ) ) + 1;
    grind;
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 127 ) ( by norm_num : 127 % 4 = 3 ) _ _ using 1 ; norm_num [ Nat.add_mod, Nat.mul_mod ];
    rotate_left;
    exact 91;
    decide +revert;
    exact 60 * ( 91 + 127 * ( q / 127 ) ) + 1;
    grind

/-
If q is in one of the covered residue classes, then 60q+1 is Sierpinski solvable.
-/
def IsCoveredByKnownReductions (q : ℕ) : Prop :=
  q % 3 = 1 ∨
  q % 7 = 4 ∨ q % 7 = 5 ∨
  q % 11 = 2 ∨ q % 11 = 10 ∨
  q % 19 = 6 ∨
  q % 23 = 18 ∨ q % 23 = 21 ∨
  q % 31 = 16 ∨ q % 31 = 18 ∨
  q % 43 = 5 ∨ q % 43 = 25 ∨
  q % 47 = 18 ∨ q % 47 = 43 ∨
  q % 59 = 54 ∨ q % 59 = 58 ∨
  q % 67 = 39 ∨ q % 67 = 48 ∨
  q % 71 = 13 ∨ q % 71 = 65 ∨
  q % 79 = 25 ∨ q % 79 = 46 ∨
  q % 83 = 65 ∨ q % 83 = 76 ∨
  q % 103 = 12 ∨ q % 103 = 60 ∨
  q % 107 = 41 ∨ q % 107 = 98 ∨
  q % 127 = 74 ∨ q % 127 = 91

theorem sierpinski_reduction_covered {q : ℕ} (h : IsCoveredByKnownReductions q) :
  SierpinskiSolvable (60 * q + 1) := by
    cases h;
    · exact?;
    · -- By contradiction, assume that $q$ is not in any of the covered residue classes.
      by_contra h_not_covered;
      -- Apply the appropriate theorem for each case to derive a contradiction.
      have h_cases : ∀ {q : ℕ}, q % 7 = 4 ∨ q % 7 = 5 → SierpinskiSolvable (60 * q + 1) := by
        exact?;
      exact h_not_covered <| by have := @sierpinski_mod_11_2_10 q; have := @sierpinski_mod_19_6 q; have := @sierpinski_mod_23_18_21 q; have := @sierpinski_mod_31_16_18 q; have := @sierpinski_mod_43_5_25 q; have := @sierpinski_mod_47_18_43 q; have := @sierpinski_mod_59_54_58 q; have := @sierpinski_mod_67_39_48 q; have := @sierpinski_mod_71_13_65 q; have := @sierpinski_mod_79_25_46 q; have := @sierpinski_mod_83_65_76 q; have := @sierpinski_mod_103_12_60 q; have := @sierpinski_mod_107_41_98 q; have := @sierpinski_mod_127_74_91 q; aesop;

/-
If q ≡ 24 or 120 (mod 131), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_131_24_120 {q : ℕ} (h : q % 131 = 24 ∨ q % 131 = 120) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general reduction theorem with p = 131 and a = 24 or a = 120.
  have h_reduction : ∀ n, n % (60 * 131) = (60 * 24 + 1) % (60 * 131) ∨ n % (60 * 131) = (60 * 120 + 1) % (60 * 131) → SierpinskiSolvable n := by
    intros n hn_mod
    obtain ⟨a, ha⟩ : ∃ a, n = 60 * a + 1 ∧ (a % 131 = 24 ∨ a % 131 = 120) := by
      exact ⟨ n / 60, by omega, by omega ⟩;
    convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 131 ) ( by norm_num : 131 % 4 = 3 ) _ n _ using 1;
    exacts [ a, by rcases ha.2 with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ], by simp +decide [ ha.1 ] ];
  grind +ring

/-
If q ≡ 44 or 81 (mod 139), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_139_44_81 {q : ℕ} (h : q % 139 = 44 ∨ q % 139 = 81) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · -- For q ≡ 44 (mod 139), we use sierpinski_linear_reduction with p=139.
    apply sierpinski_linear_reduction;
    rotate_left;
    rotate_left;
    rotate_left;
    rotate_left;
    exacts [ 139, 44, by norm_num, by norm_num, by norm_num, by omega ];
  · convert sierpinski_linear_reduction ( by norm_num : Nat.Prime 139 ) ( by norm_num : 139 % 4 = 3 ) _ _ using 1;
    rotate_left;
    exact 81;
    decide +kernel;
    exact 60 * q + 1;
    grind

/-
If q ≡ 6 (mod 7), then SierpinskiSolvable (60q+1) using x=12q+3.
-/
theorem sierpinski_mod_7_6_reduction {q : ℕ} (hq : q % 7 = 6) : SierpinskiSolvable (60 * q + 1) := by
  -- Set $x = 12q + 3$, $y = M * z$, and $z = \frac{M + 1}{14}$ where $M = (60q + 1)(12q + 3)$.
  use 12 * q + 3, (60 * q + 1) * (12 * q + 3) * ((60 * q + 1) * (12 * q + 3) + 1) / 14, ((60 * q + 1) * (12 * q + 3) + 1) / 14;
  rw [ Nat.cast_div, Nat.cast_div ] <;> norm_num <;> ring;
  · field_simp;
    grind;
  · exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 7, hq ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] );
  · norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, Nat.pow_mod, hq ];
    rw [ ← Nat.mod_mod_of_dvd q ( by decide : 7 ∣ 14 ) ] at hq; have := Nat.mod_lt q ( by decide : 0 < 14 ) ; interval_cases q % 14 <;> trivial;

/-
General reduction for any prime p ≡ 3 (mod 4), p > 5.
-/
theorem sierpinski_general_modular_reduction {p : ℕ} (hp : p.Prime) (hp3 : p % 4 = 3) (hp5 : p > 5) :
  ∀ q, ((60 * q + 1) % p = 0 ∨ (12 * q + 1) % p = 0) → SierpinskiSolvable (60 * q + 1) := by
    intros q hq_mod
    have h_factor : p ∣ (60 * q + 1) * (12 * q + 1) := by
      exact hq_mod.elim ( fun h => dvd_mul_of_dvd_left ( Nat.dvd_of_mod_eq_zero h ) _ ) fun h => dvd_mul_of_dvd_right ( Nat.dvd_of_mod_eq_zero h ) _;
    have h_factor_mod : ∃ d, d ∣ (60 * q + 1) * (12 * q + 1) ∧ d % 4 = 3 := by
      exact ⟨ p, h_factor, hp3 ⟩;
    have h_four_div : ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / ((60 * q + 1 : ℚ) * (12 * q + 1)) = 1 / y + 1 / z := by
      convert four_div_n_solvable_2_of_factor_mod_4_3 _ h_factor_mod using 1;
      · norm_cast;
      · positivity;
    convert sierpinski_mod_60_1_reduction _ _ using 1;
    · contrapose! hq_mod; aesop;
    · convert h_four_div using 1

/-
Bounded verification of Sierpinski conjecture for n < 1,000,000.
-/
theorem sierpinski_bounded_verification_1000000 : verifySierpinskiUpTo 1000000 = true := by native_decide

/-
If q ≡ 78 or 88 (mod 151), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_151_78_88 {q : ℕ} (h : q % 151 = 78 ∨ q % 151 = 88) : SierpinskiSolvable (60 * q + 1) := by
  have := sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 151 ) ( by norm_num ) ( by norm_num );
  -- Apply the general modular reduction theorem with p=151.
  apply this q;
  omega

/-
If q ≡ 19 or 95 (mod 163), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_163_19_95 {q : ℕ} (h : q % 163 = 19 ∨ q % 163 = 95) : SierpinskiSolvable (60 * q + 1) := by
  obtain h | h := h;
  · have := sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 163 ) ( by norm_num ) ( by norm_num ) q;
    exact this ( by norm_num [ Nat.add_mod, Nat.mul_mod, h ] );
  · convert sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 163 ) ( by norm_num : 163 % 4 = 3 ) ( by norm_num ) q _ using 1;
    norm_num [ Nat.add_mod, Nat.mul_mod, h ]

/-
If q ≡ 64 or 153 (mod 167), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_167_64_153 {q : ℕ} (h : q % 167 = 64 ∨ q % 167 = 153) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction theorem with p=167.
  have h_mod_167 : ∀ q, ((60 * q + 1) % 167 = 0 ∨ (12 * q + 1) % 167 = 0) → SierpinskiSolvable (60 * q + 1) := by
    intros q hq
    apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 167) (by norm_num : 167 % 4 = 3) (by norm_num) q hq;
  exact h_mod_167 q ( by omega )

/-
If q ≡ 176 or 164 (mod 179), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_179_176_164 {q : ℕ} (h : q % 179 = 176 ∨ q % 179 = 164) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction theorem with p = 179.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 179) (by norm_num : 179 % 4 = 3) (by norm_num : 5 < 179) q;
  omega

/-
If q ≡ 35 or 175 (mod 191), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_191_35_175 {q : ℕ} (h : q % 191 = 35 ∨ q % 191 = 175) : SierpinskiSolvable (60 * q + 1) := by
  apply sierpinski_general_modular_reduction;
  exacts [ show Nat.Prime 191 by norm_num, by norm_num, by norm_num, by omega ]

/-
If q ≡ 63 or 116 (mod 199), then SierpinskiSolvable (60q+1).
-/
theorem sierpinski_mod_199_63_116 {q : ℕ} (h : q % 199 = 63 ∨ q % 199 = 116) : SierpinskiSolvable (60 * q + 1) := by
  -- By sierpinski_general_modular_reduction, if $(60q+1)$ or $(12q+1)$ is divisible by a prime $p \equiv 3 \pmod{4}$, then $n = 60q+1$ is solvable.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 199) (by norm_num : 199 % 4 = 3) (by norm_num : 199 > 5) q;
  rcases h with ( h | h ) <;> norm_num [ Nat.add_mod, Nat.mul_mod, h ]

/-
If q is in one of the extended covered residue classes, then 60q+1 is Sierpinski solvable.
-/
def IsCoveredByKnownReductionsExtended (q : ℕ) : Prop :=
  q % 3 = 1 ∨
  q % 7 = 4 ∨ q % 7 = 5 ∨
  q % 11 = 2 ∨ q % 11 = 10 ∨
  q % 19 = 6 ∨
  q % 23 = 18 ∨ q % 23 = 21 ∨
  q % 31 = 16 ∨ q % 31 = 18 ∨
  q % 43 = 5 ∨ q % 43 = 25 ∨
  q % 47 = 18 ∨ q % 47 = 43 ∨
  q % 59 = 54 ∨ q % 59 = 58 ∨
  q % 67 = 39 ∨ q % 67 = 48 ∨
  q % 71 = 13 ∨ q % 71 = 65 ∨
  q % 79 = 25 ∨ q % 79 = 46 ∨
  q % 83 = 65 ∨ q % 83 = 76 ∨
  q % 103 = 12 ∨ q % 103 = 60 ∨
  q % 107 = 41 ∨ q % 107 = 98 ∨
  q % 127 = 74 ∨ q % 127 = 91 ∨
  q % 131 = 24 ∨ q % 131 = 120 ∨
  q % 139 = 44 ∨ q % 139 = 81 ∨
  q % 151 = 78 ∨ q % 151 = 88 ∨
  q % 163 = 19 ∨ q % 163 = 95 ∨
  q % 167 = 64 ∨ q % 167 = 153 ∨
  q % 179 = 176 ∨ q % 179 = 164 ∨
  q % 191 = 35 ∨ q % 191 = 175 ∨
  q % 199 = 63 ∨ q % 199 = 116

theorem sierpinski_reduction_covered_extended {q : ℕ} (h : IsCoveredByKnownReductionsExtended q) :
  SierpinskiSolvable (60 * q + 1) := by
    obtain h|h := h;
    · exact sierpinski_mod_3_1_reduction h;
    · rcases h with ( h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h | h );
      all_goals try exact sierpinski_mod_7_4_5 ( Or.inl h ) ;
      all_goals try exact sierpinski_mod_7_4_5 ( Or.inr h );
      any_goals apply sierpinski_mod_11_2_10; tauto;
      exact sierpinski_mod_19_6 h
      all_goals try { exact sierpinski_mod_23_18_21 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_23_18_21 ( Or.inr h ) }
      all_goals try { exact sierpinski_mod_31_16_18 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_31_16_18 ( Or.inr h ) }
      all_goals try { exact sierpinski_mod_43_5_25 ( Or.inl h ) }
      all_goals try { exact sierpinski_mod_43_5_25 ( Or.inr h ) };
      any_goals apply sierpinski_mod_47_18_43; tauto;
      any_goals apply sierpinski_mod_59_54_58; tauto;
      any_goals apply sierpinski_mod_67_39_48; tauto;
      any_goals apply sierpinski_mod_71_13_65; tauto;
      any_goals apply sierpinski_mod_79_25_46; tauto;
      any_goals apply sierpinski_mod_83_65_76; tauto;
      any_goals apply sierpinski_mod_103_12_60; tauto;
      any_goals apply sierpinski_mod_107_41_98; tauto;
      any_goals apply sierpinski_mod_127_74_91; tauto;
      any_goals apply sierpinski_mod_131_24_120; tauto;
      any_goals apply sierpinski_mod_139_44_81; tauto;
      any_goals apply sierpinski_mod_151_78_88; tauto;
      any_goals apply sierpinski_mod_163_19_95; tauto;
      · exact sierpinski_mod_167_64_153 ( Or.inl h );
      · exact sierpinski_mod_167_64_153 ( Or.inr h );
      · exact sierpinski_mod_179_176_164 ( Or.inl h );
      · rcases h with ( h | h | h | h | h ) <;> [ exact sierpinski_mod_179_176_164 ( Or.inr h ) ; exact sierpinski_mod_191_35_175 ( Or.inl h ) ; exact sierpinski_mod_191_35_175 ( Or.inr h ) ; exact sierpinski_mod_199_63_116 ( Or.inl h ) ; exact sierpinski_mod_199_63_116 ( Or.inr h ) ]

/-
Find uncovered q up to 1000.
-/
def is_covered_q_bool (q : ℕ) : Bool :=
  q % 3 == 1 ||
  q % 7 == 4 || q % 7 == 5 ||
  q % 11 == 2 || q % 11 == 10 ||
  q % 19 == 6 ||
  q % 23 == 18 || q % 23 == 21 ||
  q % 31 == 16 || q % 31 == 18 ||
  q % 43 == 5 || q % 43 == 25 ||
  q % 47 == 18 || q % 47 == 43 ||
  q % 59 == 54 || q % 59 == 58 ||
  q % 67 == 39 || q % 67 == 48 ||
  q % 71 == 13 || q % 71 == 65 ||
  q % 79 == 25 || q % 79 == 46 ||
  q % 83 == 65 || q % 83 == 76 ||
  q % 103 == 12 || q % 103 == 60 ||
  q % 107 == 41 || q % 107 == 98 ||
  q % 127 == 74 || q % 127 == 91 ||
  q % 131 == 24 || q % 131 == 120 ||
  q % 139 == 44 || q % 139 == 81 ||
  q % 151 == 78 || q % 151 == 88 ||
  q % 163 == 19 || q % 163 == 95 ||
  q % 167 == 64 || q % 167 == 153 ||
  q % 179 == 176 || q % 179 == 164 ||
  q % 191 == 35 || q % 191 == 175 ||
  q % 199 == 63 || q % 199 == 116

def find_uncovered_q (limit : ℕ) : List ℕ :=
  (List.range limit).filter (fun q => !is_covered_q_bool q)

#eval find_uncovered_q 1000

/-
Helper function to check Erdős-Straus decomposition for 4/m.
-/
def check_erdos_straus_4 (m : ℕ) : Bool :=
  let m2 := m * m
  let divisors := (List.range (m2 + 1)).filter (fun d => d > 0 && m2 % d == 0)
  divisors.any fun d =>
    let d' := m2 / d
    (m + d) % 4 == 0 && (m + d') % 4 == 0

/-
Correctness of check_erdos_straus_4.
-/
theorem check_erdos_straus_4_correct {m : ℕ} (hm : m > 0) (h : check_erdos_straus_4 m = true) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (m : ℚ) = 1 / y + 1 / z := by
    -- Unfold the definition of `check_erdos_straus_4`.
    unfold check_erdos_straus_4 at h
    obtain ⟨d, hd_pos, hd_div, hd_mod⟩ : ∃ d, 0 < d ∧ d ∣ m^2 ∧ (m + d) % 4 = 0 ∧ (m + m^2 / d) % 4 = 0 := by
      norm_num +zetaDelta at *;
      exact h.imp fun x hx => ⟨ hx.2.1.1, by simpa only [ sq ] using Nat.dvd_of_mod_eq_zero hx.2.1.2, hx.2.2.1, by simpa only [ sq ] using hx.2.2.2 ⟩;
    obtain ⟨y, hy⟩ : ∃ y, m + d = 4 * y := by
      exact Nat.modEq_zero_iff_dvd.mp hd_mod.1;
    obtain ⟨z, hz⟩ : ∃ z, m + m^2 / d = 4 * z := by
      exact Nat.modEq_zero_iff_dvd.mp hd_mod.2;
    refine' ⟨ y, z, _, _, _ ⟩ <;> norm_num;
    · grind;
    · grind;
    · field_simp;
      rw [ div_add_div, mul_div, eq_div_iff ] <;> norm_cast <;> nlinarith [ Nat.div_mul_cancel hd_div ]

/-
Solvability for q=3.
-/
theorem sierpinski_specific_q_3 : SierpinskiSolvable (60 * 3 + 1) := by
  -- Let's choose $x = 46$.
  use 46;
  by_contra! h_contra;
  obtain ⟨x, y, hx, hy, h_eq⟩ : ∃ x y : ℕ, x > 0 ∧ y > 0 ∧ (5 / (60 * 3 + 1 : ℚ) - 1 / 46) = 1 / x + 1 / y := by
    norm_num +zetaDelta at *;
    exact ⟨ 170, by norm_num, 8326 * 170 / ( 170 * 49 - 8326 ), by norm_num ⟩;
  exact h_contra x y ( by norm_num ) hx hy ( by linear_combination' h_eq )

/-
Correctness of fast Erdős-Straus check.
-/
def check_erdos_straus_4_fast (m : ℕ) : Bool :=
  let m2 := m * m
  (List.range (m + 1)).any fun d =>
    d > 0 && m2 % d == 0 &&
    let d' := m2 / d
    (m + d) % 4 == 0 && (m + d') % 4 == 0

theorem check_erdos_straus_4_fast_correct {m : ℕ} (hm : m > 0) (h : check_erdos_straus_4_fast m = true) :
  ∃ y z : ℕ, y > 0 ∧ z > 0 ∧ 4 / (m : ℚ) = 1 / y + 1 / z := by
    unfold check_erdos_straus_4_fast at h;
    obtain ⟨d, hd⟩ : ∃ d ∈ List.range (m + 1), d > 0 ∧ m * m % d == 0 ∧ (m + d) % 4 == 0 ∧ (m + (m * m / d)) % 4 == 0 := by
      aesop;
    use (m + d) / 4, (m + (m * m / d)) / 4;
    simp_all +decide [ Nat.dvd_iff_mod_eq_zero ];
    refine' ⟨ _, _, _ ⟩;
    · omega;
    · exact Nat.le_of_dvd ( by nlinarith [ Nat.div_mul_cancel ( show d ∣ m * m from Nat.dvd_of_mod_eq_zero hd.2.2.1 ) ] ) ( Nat.dvd_of_mod_eq_zero hd.2.2.2.2 );
    · field_simp;
      ring;
      simpa [ hd.2.1.ne' ] using by ring;

/-
Solvability for q=8.
-/
theorem sierpinski_specific_q_8 : SierpinskiSolvable (60 * 8 + 1) := by
  -- By definition of `SierpinskiSolvable`, we need to show that there exist `x`, `y`, and `z` such that `5 / n = 1 / x + 1 / y + 1 / z`.
  unfold SierpinskiSolvable;
  norm_num +zetaDelta at *;
  by_contra h_contra;
  -- Let's choose any solution $x, y, z$ for $n = 481$.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ (5 / 481 : ℚ) = 1 / x + 1 / y + 1 / z := by
    use 111, 1443, 1443;
    norm_num;
  exact h_contra ⟨ x, hx_pos, y, hy_pos, z, hz_pos, by simpa using h_eq ⟩

/-
Find witness for q=9.
-/
def find_erdos_straus_4_witness (m : ℕ) : Option (ℕ × ℕ) :=
  let m2 := m * m
  (List.range (m + 1)).findSome? fun d =>
    if d > 0 && m2 % d == 0 then
      let d' := m2 / d
      if (m + d) % 4 == 0 && (m + d') % 4 == 0 then
        some ((m + d) / 4, (m + d') / 4)
      else none
    else none

#eval find_erdos_straus_4_witness ((60 * 9 + 1) * (12 * 9 + 1))

/-
Solvability for q=9.
-/
theorem sierpinski_specific_q_9 : SierpinskiSolvable (60 * 9 + 1) := by
  -- By definition of SierpinskiSolvable, we need to show that there exist positive integers x, y, z such that 5 / (60 * 9 + 1) = 1 / x + 1 / y + 1 / z.
  unfold SierpinskiSolvable;
  by_contra! h_contra;
  have h_witness : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / (60 * 9 + 1) = 1 / x + 1 / y + 1 / z := by
    have h_check : (checkSierpinski (60 * 9 + 1) 10000 10000).isSome = true := by
      native_decide +revert
    obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h_check;
    obtain ⟨ hx₁, hx₂ ⟩ := checkSierpinski_correct ( by norm_num ) hx;
    grind;
  exact h_contra _ _ _ h_witness.choose_spec.choose_spec.choose_spec.1 h_witness.choose_spec.choose_spec.choose_spec.2.1 h_witness.choose_spec.choose_spec.choose_spec.2.2.1 ( mod_cast h_witness.choose_spec.choose_spec.choose_spec.2.2.2 )

/-
Solvability for q=9.
-/
theorem sierpinski_q_9 : SierpinskiSolvable (60 * 9 + 1) := by
  convert sierpinski_specific_q_9 using 1

/-
Solvability for q=9 and q=3 with explicit witnesses.
-/
theorem sierpinski_q_9_solved : SierpinskiSolvable (60 * 9 + 1) := by
  use 110, 6615, 15746346
  norm_num

theorem sierpinski_q_3_solved : SierpinskiSolvable (60 * 3 + 1) := by
  use 39, 507, 91767
  norm_num

/-
Solvability for q=8 and q=14.
-/
theorem sierpinski_q_8 : SierpinskiSolvable (60 * 8 + 1) := by
  convert sierpinski_specific_q_8 using 1

theorem sierpinski_q_14 : SierpinskiSolvable (60 * 14 + 1) := by
  by_contra h_not_solvable;
  exact h_not_solvable <| by have := sierpinski_bounded_verification_100000; exact (by
  unfold verifySierpinskiUpTo at this;
  rw [ List.all_eq_true ] at this;
  specialize this 841 ; norm_num [ verifySierpinskiStep ] at this;
  exact checkSierpinski_correct ( by decide ) ( Option.get_mem ( by simpa using this ) ));

/-
Find witnesses for q=8, 14, 15, 17, 20, 23, 27, 29.
-/
#eval checkSierpinski 481 1000 10000
#eval checkSierpinski 841 1000 10000
#eval checkSierpinski 901 1000 10000
#eval checkSierpinski 1021 1000 10000
#eval checkSierpinski 1201 1000 10000
#eval checkSierpinski 1381 1000 10000
#eval checkSierpinski 1621 1000 10000
#eval checkSierpinski 1741 1000 10000

/-
Solvability for q=3, 15, 17.
-/
theorem sierpinski_q_3 : SierpinskiSolvable (60 * 3 + 1) := by
  exact sierpinski_q_3_solved

theorem sierpinski_q_15 : SierpinskiSolvable (60 * 15 + 1) := by
  -- Using the checkSierpinski function, we find that 60*15 + 1 = 901 is solvable.
  have h15 : (checkSierpinski 901 1000 10000).isSome := by
    native_decide +revert;
  obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h15;
  exact checkSierpinski_correct ( by norm_num ) hx

theorem sierpinski_q_17 : SierpinskiSolvable (60 * 17 + 1) := by
  -- Apply the checkSierpinski_correct theorem with the obtained (x, y, z).
  apply checkSierpinski_correct
  native_decide;
  rotate_left;
  exact 1000;
  exact 1000000;
  exact ( checkSierpinski 1021 1000 1000000 ).get!.1;
  exact ( checkSierpinski 1021 1000 1000000 ).get!.2.1
  exact ( checkSierpinski 1021 1000 1000000 ).get!.2.2
  native_decide +revert

/-
Solvability for q=15.
-/
theorem sierpinski_q_15_solved : SierpinskiSolvable (60 * 15 + 1) := by
  exact sierpinski_q_15

/-
Solvability for q=17 and q=20.
-/
theorem sierpinski_q_17_solved : SierpinskiSolvable (60 * 17 + 1) := by
  convert sierpinski_q_17 using 1

theorem sierpinski_q_20_solved : SierpinskiSolvable (60 * 20 + 1) := by
  exact?

/-
Solvability for q=23.
-/
theorem sierpinski_q_23 : SierpinskiSolvable (60 * 23 + 1) := by
  by_contra! h_contra;
  convert checkSierpinski_correct ( show ( 60 * 23 + 1 ) ≠ 0 by decide ) _ using 1;
  exact iff_of_false ( by tauto ) h_contra;
  exact 1000;
  exact 1000000;
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.fst );
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.snd |> Prod.fst );
  exact ( checkSierpinski 1381 1000 1000000 |> Option.get! |> Prod.snd |> Prod.snd );
  native_decide +revert

/-
Solvability for q=20, 27, 29.
-/
theorem sierpinski_q_20 : SierpinskiSolvable (60 * 20 + 1) := by
  exact sierpinski_q_20_solved

theorem sierpinski_q_27 : SierpinskiSolvable (60 * 27 + 1) := by
  by_contra! h_contra;
  convert sierpinski_mod_7_6_reduction _ using 1;
  rotate_left;
  exact ( 60 * 27 + 1 ) / 60;
  · norm_num;
  · norm_num [ h_contra ]

theorem sierpinski_q_29 : SierpinskiSolvable (60 * 29 + 1) := by
  -- Apply the checkSierpinski function to find the decomposition.
  have h_check : (checkSierpinski 1741 10000 100000).isSome := by
    native_decide;
  obtain ⟨ x, hx ⟩ := Option.isSome_iff_exists.mp h_check; exact checkSierpinski_correct ( by decide ) hx;

/-
Solvability for q=30, 36, 38, 42, 45.
-/
theorem sierpinski_q_30 : SierpinskiSolvable (60 * 30 + 1) := by
  by_contra h_not_solvable;
  revert h_not_solvable;
  -- Let's choose any $q$ such that $q \equiv 30 \pmod{31}$.
  set q := 30;
  -- We'll use that $checkSierpinski(60q + 1, 1000, 10000)$ returns `some (x, y, z)` for $q = 30$.
  have h_check : checkSierpinski (60 * q + 1) 1000 10000 ≠ none := by
    native_decide;
  exact fun h => h <| by obtain ⟨ x, hx ⟩ := Option.ne_none_iff_exists'.mp h_check; exact checkSierpinski_correct ( by decide ) hx;

theorem sierpinski_q_36 : SierpinskiSolvable (60 * 36 + 1) := by
  by_contra! h_contra;
  -- Apply the checkSierpinski_correct theorem with the parameters limitX = 1000 and limitK = 10000.
  have h_check : checkSierpinski (60 * 36 + 1) 1000 10000 ≠ none := by
    native_decide +revert;
  obtain ⟨ x, hx ⟩ := Option.ne_none_iff_exists'.mp h_check;
  exact h_contra <| checkSierpinski_correct ( by norm_num ) hx

theorem sierpinski_q_38 : SierpinskiSolvable (60 * 38 + 1) := by
  -- Apply the checkSierpinski_correct theorem to conclude the proof.
  apply checkSierpinski_correct;
  all_goals norm_num;
  rotate_left;
  exact 2000;
  exact 1000000;
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.fst );
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.snd |> Prod.fst );
  exact ( checkSierpinski 2281 2000 1000000 |> Option.get! |> Prod.snd |> Prod.snd );
  native_decide +revert

theorem sierpinski_q_42 : SierpinskiSolvable (60 * 42 + 1) := by
  by_contra! h_contra;
  -- By definition of $SierpinskiSolvable$, we need to show that there exist positive integers $x, y, z$ such that $5 / 2521 = 1 / x + 1 / y + 1 / z$.
  have h_def : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 / 2521 : ℚ) = 1 / x + 1 / y + 1 / z := by
    by_contra! h_contra;
    -- Let's choose any solution $x, y, z$ for $n = 2521$ and derive a contradiction.
    obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 * x * y * z = 2521 * (y * z + x * z + x * y) := by
      simp +zetaDelta at *;
      -- Let's choose any solution $x, y, z$ for $n = 2521$ and derive a contradiction. We will use the method of Vieta jumping.
      have h_vieta : ∃ x y z : ℕ, 0 < x ∧ 0 < y ∧ 0 < z ∧ 5 * x * y * z = 2521 * (y * z + x * z + x * y) := by
        have h_eq : ∃ x y : ℕ, 0 < x ∧ 0 < y ∧ 5 * x * y > 2521 * (x + y) ∧ (5 * x * y - 2521 * (x + y)) ∣ (2521 * x * y) := by
          by_cases h₂ : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, 5 * x * y > 2521 * (x + y) ∧ (5 * x * y - 2521 * (x + y)) ∣ (2521 * x * y);
          · exact ⟨ h₂.choose, h₂.choose_spec.2.choose, Finset.mem_Icc.mp h₂.choose_spec.1 |>.1, Finset.mem_Icc.mp h₂.choose_spec.2.choose_spec.1 |>.1, h₂.choose_spec.2.choose_spec.2.1, h₂.choose_spec.2.choose_spec.2.2 ⟩;
          · exact absurd h₂ ( by native_decide )
        obtain ⟨ x, y, hx, hy, hxy, h ⟩ := h_eq;
        use x, y, (2521 * x * y) / (5 * x * y - 2521 * (x + y));
        exact ⟨ hx, hy, Nat.div_pos ( Nat.le_of_dvd ( by positivity ) h ) ( Nat.sub_pos_of_lt hxy ), by nlinarith [ Nat.div_mul_cancel h, Nat.sub_add_cancel hxy.le ] ⟩;
      exact ⟨ _, h_vieta.choose_spec.choose_spec.choose_spec.1, _, h_vieta.choose_spec.choose_spec.choose_spec.2.1, _, h_vieta.choose_spec.choose_spec.choose_spec.2.2.1, h_vieta.choose_spec.choose_spec.choose_spec.2.2.2 ⟩;
    exact h_contra x y z hx_pos hy_pos hz_pos ( by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> norm_cast <;> first | positivity | linarith );
  exact h_contra h_def

theorem sierpinski_q_45 : SierpinskiSolvable (60 * 45 + 1) := by
  by_contra! h_contra;
  -- By contradiction, assume there exist positive integers $x, y, z$ such that $5 / (60 * 45 + 1) = 1 / x + 1 / y + 1 / z$.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / (60 * 45 + 1) = 1 / x + 1 / y + 1 / z := by
    have h_check : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 * x * y * z : ℚ) = (60 * 45 + 1) * (x * y + y * z + z * x) := by
      norm_cast;
      by_contra! h_contra;
      -- Let's choose any solution $x, y, z$ for $n = 2701$ and derive a contradiction. We will check all combinations of $x, y, z$ in the specified range.
      have h_check : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, ∃ z ∈ Finset.Icc 1 10000, 5 * x * y * z = 2701 * (x * y + y * z + z * x) := by
        by_cases h₂ : ∃ x ∈ Finset.Icc 1 10000, ∃ y ∈ Finset.Icc 1 10000, (5 * x * y - 2701 * (x + y)) ≠ 0 ∧ 2701 * x * y % (5 * x * y - 2701 * (x + y)) = 0 ∧ 2701 * x * y / (5 * x * y - 2701 * (x + y)) ∈ Finset.Icc 1 10000;
        · obtain ⟨ x, hx, y, hy, hxy ⟩ := h₂;
          use x, hx, y, hy, 2701 * x * y / (5 * x * y - 2701 * (x + y));
          simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
          nlinarith [ Nat.div_mul_cancel ( Nat.dvd_of_mod_eq_zero hxy.2.1 ), Nat.sub_add_cancel ( show ( x + y ) * 2701 ≤ x * ( y * 5 ) from le_of_lt ( Nat.lt_of_sub_ne_zero hxy.1 ) ) ];
        · exact absurd h₂ ( by native_decide );
      obtain ⟨ x, hx, y, hy, z, hz, h ⟩ := h_check; exact h_contra x y z ( Finset.mem_Icc.mp hx |>.1 ) ( Finset.mem_Icc.mp hy |>.1 ) ( Finset.mem_Icc.mp hz |>.1 ) h;
    obtain ⟨ x, y, z, hx, hy, hz, h ⟩ := h_check; exact ⟨ x, y, z, hx, hy, hz, by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> first | positivity | linarith ⟩ ;
  exact h_contra ⟨ x, y, z, mod_cast hx_pos, mod_cast hy_pos, mod_cast hz_pos, mod_cast h_eq ⟩

/-
Solvability for q=17 and q=20.
-/
theorem sierpinski_q_17_v2 : SierpinskiSolvable (60 * 17 + 1) := by
  -- Apply the theorem that states if q is in the covered residue classes, then 60q+1 is solvable.
  apply sierpinski_q_17_solved

theorem sierpinski_q_20_v2 : SierpinskiSolvable (60 * 20 + 1) := by
  exact?

/-
Solvability for q=17.
-/
theorem sierpinski_q_17_verified : SierpinskiSolvable (60 * 17 + 1) := by
  exact sierpinski_q_17_v2

/-
Definition of natural density of a set of natural numbers.
-/
open Set Filter Topology Real Nat

def naturalDensity (A : Set ℕ) (d : ℝ) : Prop :=
  Tendsto (fun n => ((A ∩ Iio n).ncard : ℝ) / n) atTop (nhds d)

/-
Definitions for the set of primes congruent to 3 mod 4 (greater than 5) and the set of integers q not covered by any such prime.
-/
def covered_by_prime (p : ℕ) (q : ℕ) : Prop :=
  (60 * q + 1) % p = 0 ∨ (12 * q + 1) % p = 0

def Primes3Mod4 : Set ℕ := {p | p.Prime ∧ p % 4 = 3 ∧ p > 5}

def UncoveredByAllPrimes : Set ℕ := {q | ∀ p ∈ Primes3Mod4, ¬ covered_by_prime p q}

/-
For any prime p ≡ 3 (mod 4) with p > 5, the condition that p divides (60q+1)(12q+1) corresponds to q falling into exactly two distinct residue classes modulo p.
-/
open Set Filter Topology Real Nat

lemma distinct_solutions_mod_p {p : ℕ} (hp : p ∈ Primes3Mod4) :
  ∃ a b : ℕ, a < p ∧ b < p ∧ a ≠ b ∧
  ∀ q, covered_by_prime p q ↔ (q % p = a ∨ q % p = b) := by
    -- By definition of $covered_by_prime$, there exist $a$ and $b$ such that $60a \equiv -1 \pmod{p}$ and $12b \equiv -1 \pmod{p}$.
    obtain ⟨a, ha⟩ : ∃ a : ℕ, a < p ∧ 60 * a ≡ -1 [ZMOD p] := by
      -- By definition of $Primes3Mod4$, $p$ is coprime to $60$, so $60$ has an inverse modulo $p$.
      have h_coprime : Nat.gcd 60 p = 1 := by
        rcases hp with ⟨ hp₁, hp₂, hp₃ ⟩;
        exact Nat.Coprime.symm ( hp₁.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial );
      -- Since $p$ is coprime to $60$, there exists an integer $a$ such that $60a \equiv -1 \pmod{p}$.
      obtain ⟨a, ha⟩ : ∃ a : ℤ, 60 * a ≡ -1 [ZMOD p] := by
        have := Nat.gcd_eq_gcd_ab 60 p;
        exact ⟨ -gcdA 60 p, Int.modEq_iff_dvd.mpr ⟨ -gcdB 60 p, by push_cast at *; linarith ⟩ ⟩;
      exact ⟨ Int.toNat ( a % p ), by linarith [ Int.emod_lt_of_pos a ( show ( p : ℤ ) > 0 from Nat.cast_pos.mpr hp.1.pos ), Int.toNat_of_nonneg ( Int.emod_nonneg a ( show ( p : ℤ ) ≠ 0 from Nat.cast_ne_zero.mpr hp.1.ne_zero ) ) ], by simpa [ Int.ModEq, Int.mul_emod, Int.toNat_of_nonneg ( Int.emod_nonneg a ( show ( p : ℤ ) ≠ 0 from Nat.cast_ne_zero.mpr hp.1.ne_zero ) ) ] using ha ⟩
    obtain ⟨b, hb⟩ : ∃ b : ℕ, b < p ∧ 12 * b ≡ -1 [ZMOD p] := by
      -- By definition of $covered_by_prime$, there exists $b$ such that $12b ≡ -1 \pmod{p}$.
      have hb_exists : ∃ b : ℤ, 12 * b ≡ -1 [ZMOD p] := by
        -- Since $p$ is prime and greater than 5, it is coprime with 12.
        have h_coprime : Int.gcd 12 (p : ℤ) = 1 := by
          refine' Nat.coprime_comm.mp ( hp.1.coprime_iff_not_dvd.mpr _ );
          intro h; have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> norm_num at *;
          all_goals norm_num [ Primes3Mod4 ] at hp;
        have := Int.gcd_eq_gcd_ab 12 p;
        exact ⟨ -Int.gcdA 12 p, Int.modEq_iff_dvd.mpr ⟨ -Int.gcdB 12 p, by linarith ⟩ ⟩;
      exact ⟨ Int.toNat ( hb_exists.choose % p ), by linarith [ Int.emod_lt_of_pos ( hb_exists.choose ) ( Nat.cast_pos.mpr hp.1.pos ), Int.toNat_of_nonneg ( Int.emod_nonneg ( hb_exists.choose ) ( Nat.cast_ne_zero.mpr hp.1.ne_zero ) ) ], by simpa [ Int.ModEq, Int.mul_emod, Int.toNat_of_nonneg ( Int.emod_nonneg _ ( Nat.cast_ne_zero.mpr hp.1.ne_zero ) ) ] using hb_exists.choose_spec ⟩;
    refine' ⟨ a, b, ha.1, hb.1, _, _ ⟩ <;> simp_all +decide [ Int.ModEq ];
    · haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff' ] ;
      grind;
    · intro q
      constructor
      intro hq
      obtain ⟨k, hk⟩ : ∃ k : ℤ, q ≡ k [ZMOD p] ∧ (60 * k ≡ -1 [ZMOD p] ∨ 12 * k ≡ -1 [ZMOD p]) := by
        use q % p; simp_all +decide [ Int.ModEq ] ;
        unfold covered_by_prime at hq; norm_cast at *; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
        exact Or.imp ( fun h => Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using Nat.dvd_of_mod_eq_zero h ) ( fun h => Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using Nat.dvd_of_mod_eq_zero h ) hq;
      · -- Since $60a \equiv -1 \pmod{p}$ and $12b \equiv -1 \pmod{p}$, we have $k \equiv a \pmod{p}$ or $k \equiv b \pmod{p}$.
        have hk_cases : k ≡ a [ZMOD p] ∨ k ≡ b [ZMOD p] := by
          simp_all +decide [ Int.ModEq ];
          haveI := Fact.mk hp.1; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff' ] ;
          grind;
        simp_all +decide [ ← Int.natCast_inj, Int.ModEq ];
        exact Or.imp ( fun h => by rw [ h, Int.emod_eq_of_lt ] <;> linarith ) ( fun h => by rw [ h, Int.emod_eq_of_lt ] <;> linarith ) hk_cases;
      · rintro ( h | h ) <;> simp_all +decide [ ← Int.natCast_inj, Int.ModEq ];
        · have h_div : (60 * q + 1) % p = 0 := by
            rw [ ← Int.natCast_inj ] ; simp +decide [ *, Int.add_emod, Int.mul_emod ];
            simp +decide [ ← Int.mul_emod, ha.2 ];
            exact Int.dvd_of_emod_eq_zero ( by ring_nf; norm_num );
          exact Or.inl h_div;
        · exact Or.inr ( Nat.mod_eq_zero_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using Int.dvd_of_emod_eq_zero <| show ( 12 * q + 1 : ℤ ) % p = 0 from by simpa [ Int.add_emod, Int.mul_emod, h ] using Int.emod_eq_zero_of_dvd <| Int.modEq_iff_dvd.mp hb.2.symm )

/-
If a set A is periodic with period M, its natural density is the fraction of elements in one period.
-/
open Set Filter Topology Real Nat
open scoped BigOperators

lemma density_periodic {A : Set ℕ} {M : ℕ} (hM : M > 0) (h_per : ∀ n, n ∈ A ↔ n + M ∈ A) :
  naturalDensity A ((A ∩ Ico 0 M).ncard / M) := by
    -- We'll use the fact that if the set $A$ is periodic with period $M$, then the number of elements in $A \cap [0, n)$ is approximately $n \cdot \frac{|A \cap [0, M)|}{M}$.
    have h_count : ∀ n : ℕ, (Set.ncard (A ∩ (Iio (n * M)))) = n * (Set.ncard (A ∩ (Ico 0 M))) := by
      intro n
      have h_partition : A ∩ (Iio (n * M)) = ⋃ k ∈ Finset.range n, (fun m => m + k * M) '' (A ∩ (Ico 0 M)) := by
        ext m
        simp [Set.mem_iUnion, Set.mem_image];
        constructor;
        · intro hm;
          use m / M, Nat.div_lt_of_lt_mul <| by linarith, m % M;
          refine' ⟨ ⟨ _, Nat.mod_lt _ hM ⟩, Nat.mod_add_div' _ _ ⟩;
          -- By the periodicity condition, we have that $m \in A$ if and only if $m \mod M \in A$.
          have h_mod : ∀ m, m ∈ A ↔ m % M ∈ A := by
            intro m; rw [ ← Nat.mod_add_div m M ] ; induction' m / M with k hk <;> simp +decide [ Nat.mul_succ, ← add_assoc, ← h_per ] ;
            simpa [ Nat.add_mod, Nat.mod_eq_of_lt hM ] using hk;
          exact h_mod m |>.1 hm.1;
        · rintro ⟨ i, hi, x, hx, rfl ⟩;
          exact ⟨ Nat.recOn i ( by simpa using hx.1 ) fun k hk => by simpa [ Nat.succ_mul, ← add_assoc ] using h_per _ |>.1 hk, by nlinarith ⟩;
      rw [ h_partition ];
      induction' n with n ih;
      · norm_num;
      · induction' n + 1 with n ih <;> simp +decide [ Finset.range_add_one ] at *;
        rw [ @Set.ncard_union_eq ];
        · rw [ Set.ncard_image_of_injective _ fun x y hxy => by nlinarith ] ; linarith;
        · norm_num [ Set.disjoint_left ];
          intros; subst_vars; nlinarith;
        · exact Set.Finite.image _ ( Set.finite_iff_bddAbove.mpr ⟨ M, fun x hx => hx.2.2.le ⟩ );
        · exact Set.Finite.biUnion ( Set.finite_lt_nat n ) fun x hx => Set.Finite.image _ <| Set.finite_iff_bddAbove.mpr ⟨ M, fun y hy => by nlinarith [ hy.2.out ] ⟩;
    -- Let's express the cardinality of $A \cap [0, n)$ in terms of $n$ and the cardinality of $A \cap [0, M)$.
    have h_card : ∀ n : ℕ, (Set.ncard (A ∩ (Iio n))) = (Set.ncard (A ∩ (Ico 0 (n / M * M)))) + (Set.ncard (A ∩ (Ico (n / M * M) n))) := by
      intro n; rw [ ← @Set.ncard_union_eq ] ; congr; ext; simp +decide [ Nat.div_mul_le_self ] ;
      · exact ⟨ fun h => if h' : _ < _ then Or.inl ⟨ h.1, h' ⟩ else Or.inr ⟨ h.1, le_of_not_gt h', h.2 ⟩, fun h => h.elim ( fun h => ⟨ h.1, h.2.trans_le ( Nat.div_mul_le_self _ _ ) ⟩ ) fun h => ⟨ h.1, h.2.2 ⟩ ⟩;
      · exact Set.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ Set.mem_Ico.mp hx₁.2, Set.mem_Ico.mp hx₂.2 ] ;
      · exact Set.finite_iff_bddAbove.mpr ⟨ _, fun x hx => hx.2.2.le ⟩;
      · exact Set.finite_iff_bddAbove.mpr ⟨ n, fun x hx => hx.2.2.le ⟩;
    -- The cardinality of $A \cap [n / M * M, n)$ is at most $M$.
    have h_card_le_M : ∀ n : ℕ, (Set.ncard (A ∩ (Ico (n / M * M) n))) ≤ M := by
      intros n
      have h_card_le_M : (Set.ncard (A ∩ (Ico (n / M * M) n))) ≤ Finset.card (Finset.Ico (n / M * M) n) := by
        rw [ ← Set.ncard_coe_finset ] ; exact Set.ncard_le_ncard fun x hx => by simpa using hx.2;
      exact h_card_le_M.trans ( by simpa using by nlinarith [ Nat.div_add_mod n M, Nat.mod_lt n hM ] );
    -- Using the bounds on the cardinality of $A \cap [n / M * M, n)$, we can show that the limit of the ratio is $|A \cap [0, M)| / M$.
    have h_limit : Filter.Tendsto (fun n : ℕ => ((Set.ncard (A ∩ (Ico 0 (n / M * M)))) : ℝ) / n) Filter.atTop (nhds ((Set.ncard (A ∩ (Ico 0 M))) / M)) := by
      -- Using the fact that $n / M * M$ is approximately $n$, we can simplify the expression.
      have h_simplify : Filter.Tendsto (fun n : ℕ => ((n / M : ℕ) * (Set.ncard (A ∩ (Ico 0 M))) : ℝ) / n) Filter.atTop (nhds ((Set.ncard (A ∩ (Ico 0 M))) / M)) := by
        -- We can factor out $M$ from the numerator and denominator.
        suffices h_factor : Filter.Tendsto (fun n : ℕ => ((n / M : ℕ) : ℝ) / n) Filter.atTop (nhds (1 / M)) by
          convert h_factor.const_mul ( Set.ncard ( A ∩ Ico 0 M ) : ℝ ) using 2 <;> ring;
        -- We can use the fact that $n / M$ is approximately $n / M$ for large $n$.
        have h_approx : Filter.Tendsto (fun n : ℕ => ((n : ℝ) / M - (n / M : ℕ)) / n) Filter.atTop (nhds 0) := by
          -- We can use the fact that $n / M - n / M$ is bounded.
          have h_bound : ∀ n : ℕ, abs ((n / M : ℝ) - (n / M : ℕ)) ≤ 1 := by
            intro n; rw [ abs_le ] ; constructor <;> nlinarith [ show ( n : ℝ ) / M ≥ ↑ ( n / M ) by rw [ ge_iff_le ] ; rw [ le_div_iff₀ ( by positivity ) ] ; norm_cast ; linarith [ Nat.div_mul_le_self n M ], show ( n : ℝ ) / M < ↑ ( n / M ) + 1 by rw [ div_lt_iff₀ ( by positivity ) ] ; norm_cast ; linarith [ Nat.div_add_mod n M, Nat.mod_lt n hM ] ] ;
          exact squeeze_zero_norm ( fun n => by simpa [ abs_div ] using div_le_div_of_nonneg_right ( h_bound n ) ( Nat.cast_nonneg n ) ) ( tendsto_inv_atTop_zero.comp tendsto_natCast_atTop_atTop );
        have := h_approx.const_sub ( 1 / M : ℝ );
        simpa using this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn; rw [ sub_div' ] <;> ring ; positivity );
      convert h_simplify using 2 ; norm_cast ; aesop ( simp_config := { singlePass := true } ) ;
    have h_limit : Filter.Tendsto (fun n : ℕ => ((Set.ncard (A ∩ (Ico (n / M * M) n))) : ℝ) / n) Filter.atTop (nhds 0) := by
      exact squeeze_zero ( fun n => by positivity ) ( fun n => by exact div_le_div_of_nonneg_right ( Nat.cast_le.mpr ( h_card_le_M n ) ) ( Nat.cast_nonneg _ ) ) ( tendsto_const_nhds.div_atTop tendsto_natCast_atTop_atTop );
    rw [ naturalDensity ];
    convert ‹Tendsto ( fun n : ℕ => ( Set.ncard ( A ∩ Ico 0 ( n / M * M ) ) : ℝ ) / n ) Filter.atTop ( 𝓝 ( Set.ncard ( A ∩ Ico 0 M ) / M ) ) ›.add h_limit using 2 <;> push_cast [ h_card ] <;> ring

/-
The number of integers in [0, M) avoiding the "covered" condition for all p in S is the product of (p-2) for p in S, where M is the product of primes in S.
-/
open Set Filter Topology Real Nat
open scoped BigOperators

lemma card_avoiding_in_period {S : Finset ℕ} (hS : ∀ p ∈ S, p ∈ Primes3Mod4) :
  ({q | ∀ p ∈ S, ¬ covered_by_prime p q} ∩ Ico 0 (∏ p ∈ S, p)).ncard = ∏ p ∈ S, (p - 2) := by
    have := @density_periodic;
    replace := @this ∅ ( ∏ p ∈ S, p ) ; norm_num at this;
    unfold naturalDensity at this; norm_num [ Set.ncard_eq_toFinset_card' ] at *;
    induction' S using Finset.induction with p S hpS ih;
    · rfl;
    · -- By the Chinese Remainder Theorem, the map q ↦ (q mod M', q mod p) is a bijection from Ico 0 M to Ico 0 M' × Ico 0 p.
      have h_crt : Finset.card (Finset.filter (fun q => ∀ p' ∈ insert p S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ insert p S, p))) = Finset.card (Finset.filter (fun q => ∀ p' ∈ S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ S, p))) * Finset.card (Finset.filter (fun q => ¬covered_by_prime p q) (Finset.range p)) := by
        have h_crt : Finset.card (Finset.filter (fun q => ∀ p' ∈ insert p S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ insert p S, p))) = Finset.card (Finset.filter (fun q => ∀ p' ∈ S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ S, p))) * Finset.card (Finset.filter (fun q => ¬covered_by_prime p q) (Finset.range p)) := by
          have h_crt_bij : Finset.image (fun q => (q % (∏ p ∈ S, p), q % p)) (Finset.filter (fun q => ∀ p' ∈ insert p S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ insert p S, p))) = Finset.filter (fun q => ∀ p' ∈ S, ¬covered_by_prime p' q) (Finset.range (∏ p ∈ S, p)) ×ˢ Finset.filter (fun q => ¬covered_by_prime p q) (Finset.range p) := by
            ext ⟨x, y⟩; simp [Finset.mem_image];
            constructor;
            · rintro ⟨ a, ⟨ ha₁, ha₂, ha₃ ⟩, rfl, rfl ⟩;
              refine' ⟨ ⟨ Nat.mod_lt _ ( Finset.prod_pos fun q hq => Nat.Prime.pos ( hS q ( Finset.mem_insert_of_mem hq ) |>.1 ) ), _ ⟩, Nat.mod_lt _ ( Nat.Prime.pos ( hS p ( Finset.mem_insert_self p S ) |>.1 ) ), _ ⟩;
              · intro q hq; specialize ha₃ q hq; unfold covered_by_prime at *; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
                simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod, Finset.prod_eq_prod_diff_singleton_mul hq ];
              · unfold covered_by_prime at *; simp_all +decide [ Nat.dvd_iff_mod_eq_zero ] ;
                simpa [ Nat.add_mod, Nat.mul_mod ] using ha₂;
            · intro hxy
              obtain ⟨a, ha⟩ : ∃ a, a ≡ x [MOD ∏ p ∈ S, p] ∧ a ≡ y [MOD p] ∧ a < (∏ p ∈ S, p) * p := by
                have h_crt : Nat.gcd (∏ p ∈ S, p) p = 1 := by
                  exact Nat.Coprime.prod_left fun q hq => by have := Nat.coprime_primes ( hS q ( Finset.mem_insert_of_mem hq ) |>.1 ) ( hS p ( Finset.mem_insert_self p S ) |>.1 ) ; aesop;
                have := Nat.chineseRemainder h_crt x y;
                exact ⟨ this.val % ( ( ∏ p ∈ S, p ) * p ), by simpa [ Nat.ModEq, Nat.mod_mod ] using this.2.1, by simpa [ Nat.ModEq, Nat.mod_mod ] using this.2.2, Nat.mod_lt _ ( Nat.mul_pos ( Finset.prod_pos fun q hq => Nat.Prime.pos ( hS q ( Finset.mem_insert_of_mem hq ) |>.1 ) ) ( Nat.Prime.pos ( hS p ( Finset.mem_insert_self p S ) |>.1 ) ) ) ⟩;
              use a;
              simp_all +decide [ Finset.prod_insert hpS, covered_by_prime ];
              refine' ⟨ ⟨ by linarith, _, _ ⟩, ha.1.symm ▸ Nat.mod_eq_of_lt hxy.1.1, ha.2.1.symm ▸ Nat.mod_eq_of_lt hxy.2.1 ⟩;
              · simp_all +decide [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
              · intro q hq; have := ha.1.of_dvd ( Finset.dvd_prod_of_mem _ hq ) ; simp_all +decide [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] ;
          rw [ ← Finset.card_product, ← h_crt_bij, Finset.card_image_of_injOn ];
          intros q hq q' hq' h_eq;
          have h_crt_eq : q ≡ q' [MOD (∏ p ∈ S, p)] ∧ q ≡ q' [MOD p] := by
            aesop;
          have h_crt_eq : q ≡ q' [MOD (∏ p ∈ insert p S, p)] := by
            rw [ Finset.prod_insert hpS ];
            rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ] ; tauto;
            exact Nat.Coprime.prod_right fun x hx => by have := Nat.coprime_primes ( hS p ( Finset.mem_insert_self p S ) |>.1 ) ( hS x ( Finset.mem_insert_of_mem hx ) |>.1 ) ; aesop;
          exact Nat.mod_eq_of_lt ( Finset.mem_range.mp ( Finset.mem_filter.mp hq |>.1 ) ) ▸ Nat.mod_eq_of_lt ( Finset.mem_range.mp ( Finset.mem_filter.mp hq' |>.1 ) ) ▸ h_crt_eq;
        convert h_crt using 1;
      -- By the properties of the set of primes congruent to 3 mod 4, we know that the number of integers in [0, p) that are not covered by p is p - 2.
      have h_not_covered_p : Finset.card (Finset.filter (fun q => ¬covered_by_prime p q) (Finset.range p)) = p - 2 := by
        have := distinct_solutions_mod_p ( hS p ( Finset.mem_insert_self p S ) );
        obtain ⟨ a, b, ha, hb, hab, h ⟩ := this; simp_all +decide [ Finset.filter_or, Finset.filter_and ] ;
        rw [ show ( Finset.filter ( fun x => ¬x % p = a ) ( Finset.range p ) ∩ Finset.filter ( fun x => ¬x % p = b ) ( Finset.range p ) ) = Finset.range p \ { a, b } from ?_, Finset.card_sdiff ] <;> norm_num [ Finset.subset_iff, Finset.card_sdiff, Finset.card_singleton, Finset.card_range, ha, hb, hab ];
        ext x; simp +decide [ Nat.mod_eq_of_lt ha, Nat.mod_eq_of_lt hb ] ;
        exact ⟨ fun hx => ⟨ hx.1.1, by rintro rfl; exact hx.1.2 ( by rw [ Nat.mod_eq_of_lt ha ] ), by rintro rfl; exact hx.2.2 ( by rw [ Nat.mod_eq_of_lt hb ] ) ⟩, fun hx => ⟨ ⟨ hx.1, by rw [ Nat.mod_eq_of_lt hx.1 ] ; tauto ⟩, hx.1, by rw [ Nat.mod_eq_of_lt hx.1 ] ; tauto ⟩ ⟩;
      rw [ h_crt, ih fun q hq => hS q <| Finset.mem_insert_of_mem hq, h_not_covered_p, Finset.prod_insert hpS ];
      ring

/-
The natural density of the set of integers avoiding the covered condition for a finite set of primes S is the product of (1 - 2/p).
-/
open Set Filter Topology Real Nat
open scoped BigOperators

lemma density_avoiding_finite_primes {S : Finset ℕ} (hS : ∀ p ∈ S, p ∈ Primes3Mod4) :
  naturalDensity {q | ∀ p ∈ S, ¬ covered_by_prime p q} (∏ p ∈ S, (1 - 2 / (p : ℝ))) := by
    convert density_periodic ?_ ?_ using 1;
    case convert_2 => exact ∏ p ∈ S, p;
    · rw [ card_avoiding_in_period hS ];
      rw [ Nat.cast_prod, Nat.cast_prod ];
      rw [ ← Finset.prod_div_distrib, Finset.prod_congr rfl ] ; intros ; rw [ Nat.cast_sub ] <;> norm_num;
      · rw [ sub_div, div_self ( Nat.cast_ne_zero.mpr <| Nat.Prime.ne_zero <| hS _ ‹_› |>.1 ) ];
      · exact Nat.Prime.two_le ( hS _ ‹_› |>.1 );
    · exact Finset.prod_pos fun p hp => Nat.Prime.pos ( hS p hp |>.1 );
    · intro n; simp +decide [ *, covered_by_prime ] ;
      constructor <;> intro h p hp <;> specialize h p hp <;> simp_all +decide [ Nat.add_mod, Nat.mul_mod, Finset.prod_eq_prod_diff_singleton_mul hp ]

/-
Definition of primes congruent to 3 mod 4 below n, and a lemma stating they are indeed in the set Primes3Mod4.
-/
open Set Filter Topology Real Nat
open scoped BigOperators

def Primes3Mod4_below (n : ℕ) : Finset ℕ :=
  (Finset.range n).filter (fun p => p ∈ Primes3Mod4)

lemma Primes3Mod4_below_subset {n : ℕ} : ∀ p ∈ Primes3Mod4_below n, p ∈ Primes3Mod4 := by
  intro p hp
  rw [Primes3Mod4_below, Finset.mem_filter] at hp
  exact hp.2

/-
If the sum of reciprocals of primes 3 mod 4 diverges, then the product of (1 - 2/p) tends to 0.
-/
open Set Filter Topology Real Nat
open scoped BigOperators

lemma product_limit (h_diverge : Tendsto (fun n => ∑ p ∈ Primes3Mod4_below n, (1 / p : ℝ)) atTop atTop) :
  Tendsto (fun n => ∏ p ∈ Primes3Mod4_below n, (1 - 2 / (p : ℝ))) atTop (nhds 0) := by
    -- Applying the inequality $1 - x \leq e^{-x}$ to each term in the product, we get $\prod_{p \in S} (1 - 2/p) \leq \exp(-\sum_{p \in S} 2/p)$.
    have h_prod_le_exp : ∀ S : Finset ℕ, (∀ p ∈ S, p ∈ Primes3Mod4) → (∏ p ∈ S, (1 - 2 / (p : ℝ))) ≤ Real.exp (-∑ p ∈ S, (2 / (p : ℝ))) := by
      intro S hS; rw [ Real.exp_neg, Real.exp_sum ] ;
      rw [ ← Finset.prod_inv_distrib ] ; exact Finset.prod_le_prod ( fun _ _ => sub_nonneg.2 <| div_le_one_of_le₀ ( by norm_cast; linarith [ show ( ‹_› : ℕ ) ≥ 7 by linarith [ show ( ‹_› : ℕ ) ≥ 7 by exact le_of_not_gt fun h => by have := hS _ ‹_›; interval_cases ( ‹_› : ℕ ) <;> simp_all +decide [ Primes3Mod4 ] ] ] ) <| by positivity ) fun _ _ => by rw [ ← Real.exp_neg ] ; exact Real.add_one_le_exp _ |> le_trans ( by ring_nf; norm_num ) ;
    refine' squeeze_zero ( fun n => _ ) ( fun n => h_prod_le_exp _ _ ) _;
    · refine' Finset.prod_nonneg fun p hp => sub_nonneg.2 _;
      exact div_le_one_of_le₀ ( mod_cast by linarith [ show p ≥ 2 by exact Nat.Prime.two_le ( Finset.mem_filter.mp hp |>.2 |>.1 ) ] ) ( Nat.cast_nonneg _ );
    · exact?;
    · norm_num [ div_eq_mul_inv, ← Finset.mul_sum _ _ _ ] at *;
      exact Filter.Tendsto.const_mul_atTop ( by norm_num ) h_diverge

#check Nat.Primes.not_summable_one_div
#check DirichletCharacter.LFunction_ne_zero_of_one_le_re
#check DirichletCharacter.LSeriesSummable_of_one_lt_re
#check DirichletCharacter.LSeriesSummable_iff

/-
CRT coverage theorem.
-/
theorem crt_coverage {S : Finset ℕ} (hS : ∀ p ∈ S, p ∈ Primes3Mod4) :
  ∀ q, q < (∏ p ∈ S, p) / 60 → q ∉ UncoveredByAllPrimes → SierpinskiSolvable (60 * q + 1) := by
    intro q hq hq_not_uncovered
    obtain ⟨p, hp⟩ : ∃ p ∈ Primes3Mod4, covered_by_prime p q := by
      unfold UncoveredByAllPrimes at hq_not_uncovered; aesop;
    have := sierpinski_general_modular_reduction hp.1.1 hp.1.2.1 hp.1.2.2 q hp.2; aesop;

/-
Reduction for p=211.
-/
theorem sierpinski_mod_211_reduction {q : ℕ} (h : (60 * q + 1) % 211 = 0 ∨ (12 * q + 1) % 211 = 0) : SierpinskiSolvable (60 * q + 1) := by
  convert sierpinski_general_modular_reduction _ _ _ _ _ using 1;
  exacts [ 211, by norm_num, by norm_num, by norm_num, h ]

/-
Reduction for p=223.
-/
theorem sierpinski_mod_223_reduction {q : ℕ} (h : (60 * q + 1) % 223 = 0 ∨ (12 * q + 1) % 223 = 0) : SierpinskiSolvable (60 * q + 1) := by
  apply sierpinski_general_modular_reduction;
  exacts [ show Nat.Prime 223 by norm_num, show 223 % 4 = 3 by norm_num, show 223 > 5 by norm_num, h ]

/-
Reduction for p=227.
-/
theorem sierpinski_mod_227_reduction {q : ℕ} (h : (60 * q + 1) % 227 = 0 ∨ (12 * q + 1) % 227 = 0) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general reduction lemma with p=227.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 227) (by norm_num : 227 % 4 = 3) (by norm_num) q h

/-
Reduction for p=239.
-/
theorem sierpinski_mod_239_reduction {q : ℕ} (h : (60 * q + 1) % 239 = 0 ∨ (12 * q + 1) % 239 = 0) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general reduction lemma with p=239.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 239) (by norm_num : 239 % 4 = 3) (by norm_num : 239 > 5) q h

/-
Reduction for p=251.
-/
theorem sierpinski_mod_251_reduction {q : ℕ} (h : (60 * q + 1) % 251 = 0 ∨ (12 * q + 1) % 251 = 0) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction lemma with p=251.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 251) (by norm_num : 251 % 4 = 3) (by norm_num : 251 > 5) q h

/-
Reduction for p=263.
-/
theorem sierpinski_mod_263_reduction {q : ℕ} (h : (60 * q + 1) % 263 = 0 ∨ (12 * q + 1) % 263 = 0) : SierpinskiSolvable (60 * q + 1) := by
  exact sierpinski_general_modular_reduction ( by norm_num : Nat.Prime 263 ) ( by norm_num ) ( by norm_num ) q h

/-
Reduction for p=271.
-/
theorem sierpinski_mod_271_reduction {q : ℕ} (h : (60 * q + 1) % 271 = 0 ∨ (12 * q + 1) % 271 = 0) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general reduction lemma with p=271.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 271) (by norm_num : 271 % 4 = 3) (by norm_num) q h

/-
Reduction for p=283.
-/
theorem sierpinski_mod_283_reduction {q : ℕ} (h : (60 * q + 1) % 283 = 0 ∨ (12 * q + 1) % 283 = 0) : SierpinskiSolvable (60 * q + 1) := by
  -- Apply the general modular reduction theorem with p=283.
  apply sierpinski_general_modular_reduction (by norm_num : Nat.Prime 283) (by norm_num) (by norm_num) q h

/-
If q is covered by any of the known reductions (including the new ones), then 60q+1 is solvable.
-/
def IsCoveredByKnownReductionsExtended2 (q : ℕ) : Prop :=
  IsCoveredByKnownReductionsExtended q ∨
  ((60 * q + 1) % 211 = 0 ∨ (12 * q + 1) % 211 = 0) ∨
  ((60 * q + 1) % 223 = 0 ∨ (12 * q + 1) % 223 = 0) ∨
  ((60 * q + 1) % 227 = 0 ∨ (12 * q + 1) % 227 = 0) ∨
  ((60 * q + 1) % 239 = 0 ∨ (12 * q + 1) % 239 = 0) ∨
  ((60 * q + 1) % 251 = 0 ∨ (12 * q + 1) % 251 = 0) ∨
  ((60 * q + 1) % 263 = 0 ∨ (12 * q + 1) % 263 = 0) ∨
  ((60 * q + 1) % 271 = 0 ∨ (12 * q + 1) % 271 = 0) ∨
  ((60 * q + 1) % 283 = 0 ∨ (12 * q + 1) % 283 = 0)

theorem sierpinski_reduction_covered_extended2 {q : ℕ} (h : IsCoveredByKnownReductionsExtended2 q) :
  SierpinskiSolvable (60 * q + 1) := by
    -- Apply the appropriate reduction for the prime $p$.
    have h_reduction : ∀ p ∈ [211, 223, 227, 239, 251, 263, 271, 283], (60 * q + 1) % p = 0 ∨ (12 * q + 1) % p = 0 → SierpinskiSolvable (60 * q + 1) := by
      intros p hp h_mod
      have h_prime : Nat.Prime p ∧ p % 4 = 3 ∧ p > 5 := by
        fin_cases hp <;> norm_num at h_mod ⊢;
      exact sierpinski_general_modular_reduction h_prime.1 h_prime.2.1 h_prime.2.2 q h_mod;
    rcases h with ( h | h | h | h | h | h | h | h | h ) <;> simp_all +decide [ Nat.mod_eq_of_lt ];
    exact sierpinski_reduction_covered_extended h

#print DirichletCharacter

#check DirichletCharacter.LFunction_ne_zero_of_one_le_re

/-
Definition of the unit homomorphism for the Dirichlet character modulo 4.
-/
def chi4_unit_hom : (ZMod 4)ˣ →* ℂˣ where
  toFun u := if u.val = 1 then 1 else -1
  map_one' := by
    exact?
  map_mul' := by
    -- By checking all possible combinations of x and y in the units of ZMod 4, we can verify that the function preserves multiplication.
    intro x y
    fin_cases x <;> fin_cases y <;> norm_num [ ZMod, Fin.ext_iff ] at *;
    aesop

/-
Definition of the Dirichlet character modulo 4.
-/
def chi4 : DirichletCharacter ℂ 4 := MulChar.ofUnitHom chi4_unit_hom

/-
The Dirichlet character chi4 is not the trivial character.
-/
theorem chi4_nontrivial : chi4 ≠ 1 := by
  unfold chi4;
  unfold MulChar.ofUnitHom; simp +decide [ chi4_unit_hom ] ;
  simp +decide [ MulChar.ext_iff ]

/-
Evaluation of the Dirichlet character chi4 on natural numbers.
-/
lemma chi4_eval (n : ℕ) : chi4 n = if n % 4 = 1 then 1 else if n % 4 = 3 then -1 else 0 := by
  have h_def : ∀ x : ZMod 4, chi4 x = if x = 1 then 1 else if x = 3 then -1 else 0 := by
    unfold chi4;
    intro x; fin_cases x <;> simp +decide [ MulChar.ofUnitHom ] ;
    · grind;
    · grind +ring;
    · norm_cast;
      simp +decide [ chi4_unit_hom ]
  generalize_proofs at *; (
  erw [ h_def ] ; norm_cast; erw [ ← Nat.mod_add_div n 4 ] ; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num;
  · grind;
  · grind;
  · grind;
  · grind)

/-
If a Dirichlet series with non-negative coefficients diverges as s -> 1+, then the sum of coefficients diverges.
-/
theorem dirichlet_series_diverges_at_1_of_pole (f : ℕ → ℝ) (hf : ∀ n, f n ≥ 0)
  (h_div : Tendsto (fun (s : ℝ) => ∑' n, f n / n ^ s) (nhdsWithin 1 (Set.Ioi 1)) atTop) :
  ¬ Summable (fun n => f n / n) := by
    intro H;
    -- If the series is summable, then the sum of the series should be finite.
    have h_sum_finite : ∀ s : ℝ, 1 < s → ∑' n : ℕ, f n / (n : ℝ) ^ s ≤ ∑' n : ℕ, f n / (n : ℝ) := by
      intro s hs; refine' Summable.tsum_le_tsum _ _ _;
      · intro n; rcases n with ( _ | _ | n ) <;> norm_num;
        · norm_num [ show s ≠ 0 by linarith ];
        · field_simp;
          exact mul_le_mul_of_nonneg_left ( by exact le_trans ( by norm_num ) ( Real.rpow_le_rpow_of_exponent_le ( by linarith ) hs.le ) ) ( hf _ );
      · refine' .of_nonneg_of_le ( fun n => div_nonneg ( hf n ) ( Real.rpow_nonneg ( Nat.cast_nonneg n ) _ ) ) ( fun n => _ ) H;
        by_cases hn : n = 0 <;> simp_all +decide [ div_eq_mul_inv ];
        · norm_num [ show s ≠ 0 by linarith ];
        · exact mul_le_mul_of_nonneg_left ( inv_anti₀ ( by positivity ) ( by simpa using Real.rpow_le_rpow_of_exponent_le ( Nat.one_le_cast.mpr ( Nat.pos_of_ne_zero hn ) ) hs.le ) ) ( hf n );
      · exact H;
    exact absurd ( h_div.eventually_gt_atTop ( ∑' n : ℕ, f n / ( n : ℝ ) ) ) fun h => by have := h.and ( self_mem_nhdsWithin ) ; obtain ⟨ s, hs₁, hs₂ ⟩ := this.exists; linarith [ h_sum_finite s hs₂ ] ;

/-
The partial sums of the Dirichlet character chi4 are bounded.
-/
lemma sum_chi4_bounded : ∃ C, ∀ N, ‖∑ n ∈ Finset.range N, chi4 n‖ ≤ C := by
  -- The partial sums of the Dirichlet character chi4 are bounded by 1.
  use 1;
  intro N;
  -- By definition of chi4, we know that chi4(n) is 1 if n ≡ 1 (mod 4), -1 if n ≡ 3 (mod 4), and 0 otherwise.
  have h_chi4 : ∀ n : ℕ, chi4 n = if n % 4 = 1 then 1 else if n % 4 = 3 then -1 else 0 := by
    exact?;
  induction' N using Nat.strong_induction_on with N ih;
  rcases N with ( _ | _ | _ | _ | N ) <;> norm_num [ Finset.sum_range_succ, h_chi4 ];
  norm_num [ Nat.add_mod ] ; have := Nat.mod_lt N zero_lt_four; interval_cases N % 4 <;> norm_num;
  · simpa only [ ← h_chi4 ] using ih N ( by linarith );
  · simpa only [ ← h_chi4 ] using ih N ( by linarith );
  · simpa only [ ← h_chi4 ] using ih N ( by linarith );
  · simpa only [ ← h_chi4 ] using ih N ( by linarith )

/-
The difference between the log-sum and the linear term in the Euler product expansion is bounded for s > 1.
-/
lemma sum_tail_bounded : ∃ C, ∀ s : ℝ, 1 < s → ‖(∑' p : Nat.Primes, (-Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))) - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))))‖ ≤ C := by
  -- The term inside the sum is the tail of the Taylor series for $-\log(1-z) - z = z^2/2 + z^3/3 + \dots$.
  have h_tail : ∀ p : Primes, ∀ s : ℝ, 1 < s → ‖-Complex.log (1 - chi4 p * (p : ℂ) ^ (-s : ℂ)) - chi4 p * (p : ℂ) ^ (-s : ℂ)‖ ≤ (p : ℝ) ^ (-2 * s : ℝ) := by
    intro p s hs
    have h_tail : ∀ z : ℂ, ‖z‖ ≤ 1 / 2 → ‖-Complex.log (1 - z) - z‖ ≤ ‖z‖^2 := by
      intro z hz
      have h_tail : ‖-Complex.log (1 - z) - z‖ ≤ ‖z‖^2 := by
        have h_series : -Complex.log (1 - z) - z = ∑' n : ℕ, z ^ (n + 2) / (n + 2) := by
          have h_series : HasSum (fun n : ℕ => z ^ (n + 2) / (n + 2)) (-Complex.log (1 - z) - z) := by
            have h_series : HasSum (fun n : ℕ => z ^ (n + 1) / (n + 1)) (-Complex.log (1 - z)) := by
              have h_series : HasSum (fun n : ℕ => z ^ n / (n : ℂ)) (-Complex.log (1 - z)) := by
                have h_series : ∀ z : ℂ, ‖z‖ < 1 → HasSum (fun n : ℕ => z ^ n / (n : ℂ)) (-Complex.log (1 - z)) := by
                  exact?;
                exact h_series z <| lt_of_le_of_lt hz <| by norm_num;
              convert hasSum_nat_add_iff' 1 |>.2 h_series using 1;
              · norm_cast;
              · norm_num;
            convert hasSum_nat_add_iff' 1 |>.2 h_series using 1;
            · norm_cast;
            · norm_num;
          exact h_series.tsum_eq.symm
        -- The norm of the sum of a series is bounded by the sum of the norms of the terms.
        have h_norm_sum : ‖∑' n : ℕ, z ^ (n + 2) / (n + 2)‖ ≤ ∑' n : ℕ, ‖z ^ (n + 2) / (n + 2)‖ := by
          convert norm_tsum_le_tsum_norm _ ; norm_num;
          exact Summable.of_nonneg_of_le ( fun n => div_nonneg ( pow_nonneg ( norm_nonneg _ ) _ ) ( norm_nonneg _ ) ) ( fun n => div_le_self ( pow_nonneg ( norm_nonneg _ ) _ ) ( by norm_cast; linarith ) ) ( Summable.comp_injective ( summable_geometric_of_lt_one ( norm_nonneg _ ) ( by linarith ) ) ( by intros a b; aesop ) );
        -- The norm of each term in the series is bounded by ‖z‖^(n+2) / (n+2).
        have h_norm_term : ∀ n : ℕ, ‖z ^ (n + 2) / (n + 2)‖ ≤ ‖z‖ ^ (n + 2) / 2 := by
          norm_num +zetaDelta at *;
          exact fun n => by gcongr ; norm_cast ; linarith;
        have h_sum_bound : ∑' n : ℕ, ‖z‖ ^ (n + 2) / 2 ≤ ‖z‖ ^ 2 := by
          ring_nf;
          rw [ tsum_mul_right, tsum_mul_left, tsum_geometric_of_lt_one ( by positivity ) ( by linarith ) ] ; ring_nf ; norm_num;
          nlinarith [ norm_nonneg z, mul_inv_cancel₀ ( by linarith [ norm_nonneg z ] : ( 1 - ‖z‖ ) ≠ 0 ), pow_two_nonneg ( ‖z‖ - 1 / 2 ) ];
        exact h_series ▸ h_norm_sum.trans ( le_trans ( Summable.tsum_le_tsum h_norm_term ( by exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => h_norm_term n ) ( by exact Summable.mul_right _ <| summable_geometric_of_lt_one ( by positivity ) ( by linarith ) |> Summable.comp_injective <| by intros a b; aesop ) ) ( by exact Summable.mul_right _ <| summable_geometric_of_lt_one ( by positivity ) ( by linarith ) |> Summable.comp_injective <| by intros a b; aesop ) ) h_sum_bound )
      exact h_tail;
    have h_tail : ‖chi4 p * (p : ℂ) ^ (-s : ℂ)‖ ≤ 1 / 2 := by
      have h_tail : ‖(p : ℂ) ^ (-s : ℂ)‖ ≤ (p : ℝ) ^ (-s : ℝ) := by
        norm_num [ Complex.norm_cpow_of_ne_zero, show ( p : ℂ ) ≠ 0 from Nat.cast_ne_zero.mpr p.2.ne_zero ];
      have h_tail : (p : ℝ) ^ (-s : ℝ) ≤ 1 / 2 := by
        rw [ Real.rpow_neg ( Nat.cast_nonneg _ ) ];
        rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_num;
        · exact le_trans ( by norm_cast; linarith [ p.2.two_le ] ) ( Real.rpow_le_rpow_of_exponent_le ( mod_cast p.2.one_lt.le ) hs.le );
        · exact Real.rpow_pos_of_pos ( Nat.cast_pos.mpr p.prop.pos ) _;
      simp +zetaDelta at *;
      exact le_trans ( mul_le_of_le_one_left ( by positivity ) ( by rw [ chi4_eval ] ; split_ifs <;> norm_num ) ) ( le_trans ‹_› h_tail );
    convert le_trans ( ‹∀ z : ℂ, ‖z‖ ≤ 1 / 2 → ‖-Complex.log ( 1 - z ) - z‖ ≤ ‖z‖ ^ 2› _ h_tail ) _ using 1 ; norm_cast ; norm_num ; ring;
    norm_num [ Complex.norm_cpow_of_ne_zero, p.2.ne_zero ];
    rw [ ← Real.rpow_natCast, ← Real.rpow_natCast, ← Real.rpow_mul ] <;> ring_nf <;> norm_num;
    exact mul_le_of_le_one_left ( by positivity ) ( pow_le_one₀ ( by positivity ) ( by erw [ chi4_eval ] ; split_ifs <;> norm_num ) );
  have h_sum_tail : Summable (fun p : Nat.Primes => (p : ℝ) ^ (-2 : ℝ)) := by
    exact Summable.subtype ( Real.summable_nat_rpow.2 <| by norm_num ) _;
  use ∑' p : Nat.Primes, ( p : ℝ ) ^ ( -2 : ℝ ) ; intros s hs; refine' le_trans ( norm_tsum_le_tsum_norm _ ) _;
  · refine' Summable.of_nonneg_of_le ( fun p => norm_nonneg _ ) ( fun p => h_tail p s hs ) _;
    exact Summable.of_nonneg_of_le ( fun p => by positivity ) ( fun p => by simpa [ Real.rpow_mul ] using Real.rpow_le_rpow_of_exponent_le ( mod_cast Nat.Prime.pos p.2 ) ( show ( -2 : ℝ ) * s ≤ -2 by nlinarith ) ) h_sum_tail;
  · refine' Summable.tsum_le_tsum _ _ _;
    · exact fun p => le_trans ( h_tail p s hs ) ( Real.rpow_le_rpow_of_exponent_le ( mod_cast Nat.Prime.pos p.2 ) ( by linarith ) );
    · refine' Summable.of_nonneg_of_le ( fun p => norm_nonneg _ ) ( fun p => h_tail p s hs ) _;
      exact Summable.of_nonneg_of_le ( fun p => Real.rpow_nonneg ( Nat.cast_nonneg _ ) _ ) ( fun p => Real.rpow_le_rpow_of_exponent_le ( mod_cast Nat.one_le_iff_ne_zero.mpr p.2.ne_zero ) ( by linarith ) ) h_sum_tail;
    · convert h_sum_tail using 1

/-
The log of the norm of the L-function for chi4 is bounded for s in (1, 2).
-/
lemma log_norm_LFunction_bounded : ∃ C, ∀ s : ℝ, 1 < s → s < 2 → |Real.log ‖DirichletCharacter.LFunction chi4 s‖| ≤ C := by
  have h_log_bounded : ContinuousOn (fun s : ℝ => Real.log ‖DirichletCharacter.LFunction chi4 s‖) (Set.Icc 1 2) := by
    have h_cont : ContinuousOn (fun s : ℝ => DirichletCharacter.LFunction chi4 s) (Set.Icc 1 2) := by
      have h_cont : DifferentiableOn ℂ (fun s : ℂ => DirichletCharacter.LFunction chi4 s) (Set.univ : Set ℂ) := by
        refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
        apply_rules [ DirichletCharacter.differentiableAt_LFunction ];
        exact Or.inr chi4_nontrivial;
      exact h_cont.continuousOn.comp ( Complex.continuous_ofReal.continuousOn ) fun x hx => Set.mem_univ _;
    exact ContinuousOn.log ( h_cont.norm ) fun x hx => ne_of_gt <| norm_pos_iff.mpr <| by
      apply DirichletCharacter.LFunction_ne_zero_of_one_le_re;
      · exact Or.inl <| chi4_nontrivial;
      · exact_mod_cast hx.1;
  obtain ⟨ C, hC ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_log_bounded; use C; intro s hs₁ hs₂; exact hC s ⟨ by linarith, by linarith ⟩ ;

/-
The sum of the logarithms in the Euler product for chi4 is bounded for s in (1, 2).
-/
lemma sum_log_euler_bounded : ∃ C, ∀ s : ℝ, 1 < s → s < 2 → ‖∑' p : Nat.Primes, -Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ)))‖ ≤ C := by
  convert log_norm_LFunction_bounded using 1;
  congr! 3;
  rename_i s hs;
  constructor <;> intro h <;> contrapose! h;
  · have h_exp : Complex.exp (∑' p : Nat.Primes, -Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ)))) = DirichletCharacter.LFunction chi4 s := by
      rw [ DirichletCharacter.LSeries_eulerProduct_exp_log ];
      · rw [ DirichletCharacter.LFunction_eq_LSeries ];
        exact_mod_cast hs;
      · exact_mod_cast hs;
    have h_log : ‖DirichletCharacter.LFunction chi4 s‖ = Real.exp (Complex.re (∑' p : Nat.Primes, -Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))))) := by
      rw [ ← h_exp, Complex.norm_exp ];
    simp_all +decide [ Complex.log_re, Complex.log_im ];
    exact h.2.trans_le ( Complex.abs_re_le_norm _ );
  · convert h using 2;
    have h_exp : Complex.exp (∑' p : Nat.Primes, -Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ)))) = DirichletCharacter.LFunction chi4 s := by
      convert DirichletCharacter.LSeries_eulerProduct_exp_log chi4 ( show 1 < ( s : ℂ ).re by simpa ) using 1;
      convert DirichletCharacter.LFunction_eq_LSeries _ _ using 1;
      exact_mod_cast hs;
    rw [ ← h_exp, Complex.norm_exp ] ; norm_num;
    convert Complex.im_tsum _;
    · rw [ tsum_eq_single ⟨ 3, by norm_num ⟩ ] <;> norm_num;
      · norm_num [ Complex.log_im, chi4_eval ];
        rw [ show chi4 3 = -1 by exact chi4_eval 3 ▸ by norm_num ] ; norm_num [ Complex.arg_eq_zero_iff ];
        norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
        positivity;
      · intro p hp; rw [ Complex.log_im ] ; norm_num [ chi4_eval ] ;
        split_ifs <;> norm_num [ Complex.arg_eq_zero_iff ];
        · norm_num [ Complex.cpow_def ];
          split_ifs <;> norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
          exact mul_nonneg ( Real.log_nonneg ( mod_cast Nat.one_le_iff_ne_zero.mpr ‹_› ) ) ( by positivity );
        · norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
          split_ifs <;> norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
          positivity;
    · exact?;
    · exact?

/-
The sum of chi4(p)/p^s over primes is bounded for s near 1.
-/
lemma sum_chi4_prime_series_bounded_near_one :
  ∃ C, ∀ s : ℝ, 1 < s → s < 2 → ‖∑' p : Nat.Primes, chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))‖ ≤ C := by
    obtain ⟨ C₁, hC₁ ⟩ := sum_log_euler_bounded;
    obtain ⟨ C₂, hC₂ ⟩ := sum_tail_bounded;
    use C₁ + C₂;
    intro s hs₁ hs₂;
    have h_sum : ∑' p : Nat.Primes, chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ)) = ∑' p : Nat.Primes, -Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))) - ∑' p : Nat.Primes, (-Complex.log (1 - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))) - chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))) := by
      rw [ Summable.tsum_sub ];
      · ring;
      · exact?;
      · have h_summable : Summable (fun p : ℕ => ‖chi4 p * (p : ℂ) ^ (-(s : ℂ))‖) := by
          have h_summable : Summable (fun p : ℕ => ‖(p : ℂ) ^ (-(s : ℂ))‖) := by
            have := Real.summable_nat_rpow_inv.mpr hs₁;
            convert this using 1;
            ext; norm_num [ Complex.norm_cpow_of_ne_zero, Complex.cpow_neg ];
          simp_all +decide [ chi4_eval ];
          exact Summable.of_nonneg_of_le ( fun p => by positivity ) ( fun p => by split_ifs <;> norm_num ) h_summable;
        exact .of_norm <| h_summable.comp_injective Subtype.coe_injective;
    exact h_sum.symm ▸ le_trans ( norm_sub_le _ _ ) ( add_le_add ( hC₁ s hs₁ hs₂ ) ( hC₂ s hs₁ ) )

/-
The sum of 1/p^s over primes tends to infinity as s approaches 1 from above.
-/
lemma sum_prime_inverse_pow_diverges : Tendsto (fun s : ℝ => ∑' p : Nat.Primes, 1 / (p : ℝ) ^ s) (nhdsWithin 1 (Set.Ioi 1)) atTop := by
  convert Nat.Primes.not_summable_one_div using 1;
  constructor <;> intro h;
  · exact?;
  · refine' Filter.tendsto_atTop.mpr fun x => _;
    -- Since the sum of 1/p diverges, for any x, there exists a finite subset of primes whose sum is greater than x.
    obtain ⟨S, hS⟩ : ∃ S : Finset Primes, ∑ p ∈ S, (1 : ℝ) / p > x := by
      contrapose! h;
      refine' summable_of_sum_le _ _;
      exacts [ x, fun _ => by positivity, h ];
    -- Since $S$ is a finite subset of primes, the sum $\sum_{p \in S} \frac{1}{p^s}$ converges to $\sum_{p \in S} \frac{1}{p}$ as $s \to 1^+$.
    have h_sum_S : Filter.Tendsto (fun s : ℝ => ∑ p ∈ S, (1 : ℝ) / p ^ s) (nhdsWithin 1 (Set.Ioi 1)) (nhds (∑ p ∈ S, (1 : ℝ) / p)) := by
      exact tendsto_finset_sum _ fun p hp => tendsto_nhdsWithin_of_tendsto_nhds ( ContinuousAt.tendsto ( show ContinuousAt ( fun s : ℝ => ( 1 : ℝ ) / p ^ s ) 1 by exact ContinuousAt.div continuousAt_const ( ContinuousAt.rpow continuousAt_const continuousAt_id <| Or.inl <| by linarith [ show ( p : ℝ ) > 0 from Nat.cast_pos.mpr p.prop.pos ] ) <| by exact ne_of_gt <| Real.rpow_pos_of_pos ( Nat.cast_pos.mpr p.prop.pos ) _ ) |> fun h => h.trans <| by norm_num );
    filter_upwards [ h_sum_S.eventually ( lt_mem_nhds hS ), self_mem_nhdsWithin ] with s hs₁ hs₂;
    refine' le_trans hs₁.le ( Summable.sum_le_tsum _ _ _ );
    · exact fun _ _ => by positivity;
    · have := Real.summable_one_div_nat_rpow.2 hs₂;
      exact this.comp_injective Subtype.coe_injective

/-
The sum of chi4(p)/p^s over primes is bounded for s near 1.
-/
lemma sum_chi4_prime_series_bounded_near_one_v2 :
  ∃ C, ∀ s : ℝ, 1 < s → s < 2 → ‖∑' p : Nat.Primes, chi4 (p : ℕ) * (p : ℂ) ^ (-(s : ℂ))‖ ≤ C := by
    -- Apply the lemma that states the sum of chi4(p)/p^s over primes is bounded for s near 1.
    apply sum_chi4_prime_series_bounded_near_one