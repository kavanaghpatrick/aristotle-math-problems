/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1c4453f1-831e-4153-a035-7e111eee0d3a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- The inductively defined predicate that `m` is reachable in `n` steps. -/
inductive Reachable : ℕ → ℕ → Prop
  | one : Reachable 1 1
  | add {m n a b} : Reachable m a → Reachable n b → Reachable (m + n) (a + b)
  | mul {m n a b} : Reachable m a → Reachable n b → Reachable (m * n) (a + b)

theorem not_reachable_zero_fst (n : ℕ) : ¬ Reachable 0 n := by
  intro h; generalize hm : 0 = m at h; induction h with
  | one => exact absurd hm (by decide)
  | add h₁ h₂ => rw [eq_comm, add_eq_zero] at hm; aesop
  | mul h₁ h₂ => rw [eq_comm, mul_eq_zero] at hm; aesop

theorem not_reachable_zero_snd (m : ℕ) : ¬ Reachable m 0 := by
  intro h; generalize hn : 0 = n at h; induction h with
  | one => exact absurd hn (by decide)
  | add h₁ h₂ => rw [eq_comm, add_eq_zero] at hn; aesop
  | mul h₁ h₂ => rw [eq_comm, add_eq_zero] at hn; aesop

theorem Reachable.dec {m n : ℕ} (h : Reachable m n) :
    ∃ m' n', m' + 1 = m ∧ n' + 1 = n := by
  obtain _ | m := m
  · exact absurd h (not_reachable_zero_fst _)
  obtain _ | n := n
  · exact absurd h (not_reachable_zero_snd _)
  exact ⟨_, _, rfl, rfl⟩

theorem Reachable.le {m n₁ n₂ : ℕ} (hn : n₁ ≤ n₂) (hm : Reachable m n₁) : Reachable m n₂ := by
  induction hn with
  | refl => exact hm
  | step h ih => convert ih.mul .one; simp

theorem Reachable.self (n : ℕ) (hn : 0 < n) : Reachable n n :=
  Nat.le_induction .one (fun _ _ ih ↦ .add ih .one) n hn

theorem reachable_iff_of_two_le (m n : ℕ) (hm : 2 ≤ m) :
    Reachable m n ↔ ∃ m₁, ∃ _ : m₁ < m, ∃ m₂, ∃ _ : m₂ < m, ∃ n₁, ∃ _ : n₁ < n, ∃ n₂, ∃ _ : n₂ < n,
      n₁ + n₂ = n ∧ Reachable m₁ n₁ ∧ Reachable m₂ n₂ ∧ (m₁ + m₂ = m ∨ m₁ * m₂ = m) := by
  refine ⟨fun hmn ↦ ?_, fun ⟨m₁, hm₁, m₂, hm₂, n₁, hn₁, n₂, hn₂, h₁, h₂, h₃, h₄⟩ ↦
    h₁ ▸ h₄.casesOn (· ▸ .add h₂ h₃) (· ▸ .mul h₂ h₃)⟩
  induction hmn with
  | one => exact absurd hm (by decide)
  | @add m₃ m₄ n₃ n₄ h₁ h₂ ih₁ ih₂ =>
      obtain ⟨m₃, n₃, rfl, rfl⟩ := h₁.dec
      obtain ⟨m₄, n₄, rfl, rfl⟩ := h₂.dec
      refine ⟨m₃ + 1, ?_, m₄ + 1, ?_, n₃ + 1, ?_, n₄ + 1, ?_, rfl, h₁, h₂, .inl rfl⟩ <;> omega
  | @mul m₃ m₄ n₃ n₄ h₁ h₂ ih₁ ih₂ =>
      obtain ⟨m₃, n₃, rfl, rfl⟩ := h₁.dec
      obtain ⟨m₄, n₄, rfl, rfl⟩ := h₂.dec
      obtain _ | m₃ := m₃
      · obtain ⟨m₅, hm₅, m₆, hm₆, n₅, hn₅, n₆, hn₆, h₃, h₄, h₅, h₆⟩ := ih₂ (by omega)
        refine ⟨m₅, ?_, m₆, ?_, n₅+n₃+1, ?_, n₆, ?_, by rw [← h₃]; ring, h₄.le ?_, h₅, ?_⟩
        all_goals omega
      obtain _ | m₄ := m₄
      · obtain ⟨m₅, hm₅, m₆, hm₆, n₅, hn₅, n₆, hn₆, h₃, h₄, h₅, h₆⟩ := ih₁ (by omega)
        refine ⟨m₅, ?_, m₆, ?_, n₅, ?_, n₆+n₄+1, ?_, by rw [← h₃]; ring, h₄, h₅.le ?_, ?_⟩
        all_goals omega
      refine ⟨m₃+2, ?_, m₄+2, ?_, _, ?_, _, ?_, rfl, h₁, h₂, .inr rfl⟩
      · refine (Nat.lt_mul_iff_one_lt_right ?_).2 ?_ <;> omega
      · refine (Nat.lt_mul_iff_one_lt_left ?_).2 ?_ <;> omega
      all_goals omega

open Classical

/-- The complexity of n: minimum number of 1s to express n using + and ×. -/
noncomputable def complexity (n : ℕ) : ℕ :=
  if h : n = 0 then 0 else Nat.find ⟨n, Reachable.self n <| n.pos_of_ne_zero h⟩

theorem Reachable.complexity_le {m n : ℕ} (h : Reachable m n) : complexity m ≤ n := by
  unfold complexity
  split_ifs with h'
  · subst h'; exact absurd h (not_reachable_zero_fst n)
  exact Nat.find_min' _ h

theorem Reachable.complexity_eq {m n : ℕ} (h : Reachable m n)
    (min : ∀ n' < n, ¬ Reachable m n') : complexity m = n := by
  refine le_antisymm h.complexity_le ?_
  unfold complexity
  split_ifs with h'
  · subst h'; exact absurd h (not_reachable_zero_fst n)
  exact (Nat.le_find_iff _ _).2 min

theorem Reachable.complexity {n : ℕ} (hn : 0 < n) : Reachable n (complexity n) := by
  -- By definition of complexity, there exists some $m$ such that $Reachable n m$ and $m$ is the minimum such number.
  obtain ⟨m, hm⟩ : ∃ m, Reachable n m ∧ ∀ k < m, ¬Reachable n k := by
    exact ⟨ Nat.find ⟨ n, Reachable.self n hn ⟩, Nat.find_spec ( ⟨ n, Reachable.self n hn ⟩ : ∃ m, Reachable n m ), fun k hk => Nat.find_min ( ⟨ n, Reachable.self n hn ⟩ : ∃ m, Reachable n m ) hk ⟩;
  convert hm.1;
  exact Reachable.complexity_eq hm.1 hm.2

theorem Reachable.pow (m n : ℕ) (hm : 0 < m) (hn : 0 < n) : Reachable (m ^ n) (m * n) := by
  induction' n with n ih;
  · contradiction;
  · rcases n with ( _ | n ) <;> simp_all +decide [ pow_succ' ];
    · exact Reachable.self m hm;
    · convert Reachable.mul ( Reachable.self m hm ) ih using 1 ; ring

theorem complexity_two_pow_le (n : ℕ) (h : 0 < n) : complexity (2 ^ n) ≤ 2 * n := by
  have : Reachable (2 ^ n) (2 * n) := Reachable.pow 2 n (by decide) h
  exact Reachable.complexity_le this

theorem complexity_add_le (a b : ℕ) (ha : 0 < a) (hb : 0 < b) :
    complexity (a + b) ≤ complexity a + complexity b := by
  have ha' := Reachable.complexity ha
  have hb' := Reachable.complexity hb
  exact Reachable.complexity_le (Reachable.add ha' hb')

theorem complexity_mul_le (a b : ℕ) (ha : 0 < a) (hb : 0 < b) :
    complexity (a * b) ≤ complexity a + complexity b := by
  have ha' := Reachable.complexity ha
  have hb' := Reachable.complexity hb
  exact Reachable.complexity_le (Reachable.mul ha' hb')

lemma factors_of_two_pow (a b n : ℕ) (h : a * b = 2 ^ n) : ∃ i j, a = 2 ^ i ∧ b = 2 ^ j ∧ i + j = n := by
  -- Since $a$ and $b$ are factors of $2^n$, they must themselves be powers of $2$.
  have ha_pow : ∃ i, a = 2 ^ i := by
    -- Since $a$ divides $2^n$, and $2^n$ is a power of 2, $a$ must also be a power of 2.
    have h_div : a ∣ 2 ^ n := by
      exact h ▸ dvd_mul_right _ _;
    rw [ Nat.dvd_prime_pow ] at h_div <;> norm_num at * ; tauto
  have hb_pow : ∃ j, b = 2 ^ j := by
    -- Since $a * b = 2^n$ and $a = 2^i$, we can substitute $a$ into the equation to get $2^i * b = 2^n$.
    obtain ⟨i, hi⟩ := ha_pow
    have hb_eq : b = 2 ^ (n - i) := by
      cases le_total n i <;> simp_all +decide [ ← pow_add ];
      · nlinarith [ pow_pos ( by decide : 0 < 2 ) n, pow_le_pow_right₀ ( by decide : 1 ≤ 2 ) ‹_› ];
      · exact mul_left_cancel₀ ( pow_ne_zero i two_ne_zero ) ( by rw [ ← pow_add, Nat.add_sub_of_le ‹i ≤ n› ] ; linarith );
    use n - i;
  -- Substitute the expressions for a and b from ha_pow and hb_pow into the equation a * b = 2^n.
  obtain ⟨i, hi⟩ := ha_pow
  obtain ⟨j, hj⟩ := hb_pow
  have h_exp : 2 ^ (i + j) = 2 ^ n := by
    rw [ ← h, hi, hj, pow_add ];
  aesop

lemma factors_of_two_pow' (a b n : ℕ) (h : a * b = 2 ^ n) : ∃ i j, a = 2 ^ i ∧ b = 2 ^ j ∧ i + j = n := by
  have ha : a ∣ 2 ^ n := Dvd.intro b h
  have hb : b ∣ 2 ^ n := Dvd.intro_left a h
  obtain ⟨i, hi⟩ := (Nat.dvd_prime_pow (Nat.prime_two)).1 ha
  obtain ⟨j, hj⟩ := (Nat.dvd_prime_pow (Nat.prime_two)).1 hb
  refine ⟨i, j, hi.2, hj.2, ?_⟩
  rw [hi.2, hj.2, ← Nat.pow_add, Nat.pow_right_inj (by decide)] at h
  exact h

#check padicValNat

lemma valuation_eq_of_add_eq_two_pow (a b n : ℕ) (h : a + b = 2 ^ n) (ha : 0 < a) (hb : 0 < b) :
    padicValNat 2 a = padicValNat 2 b := by
      by_contra h_neq;
      -- Without loss of generality, assume that $v_2(a) < v_2(b)$.
      wlog h_wlog : padicValNat 2 a < padicValNat 2 b generalizing a b;
      · exact this b a ( by rw [ add_comm, h ] ) hb ha ( Ne.symm h_neq ) ( lt_of_le_of_ne ( le_of_not_gt h_wlog ) ( Ne.symm h_neq ) );
      · -- If $v_2(a) < v_2(b)$, then $a + b$ is divisible by $2^{v_2(a)}$ but not by $2^{v_2(a) + 1}$.
        have h_div : 2 ^ (padicValNat 2 a) ∣ a + b ∧ ¬(2 ^ (padicValNat 2 a + 1) ∣ a + b) := by
          have h_div : 2 ^ (padicValNat 2 a) ∣ a ∧ ¬(2 ^ (padicValNat 2 a + 1) ∣ a) ∧ 2 ^ (padicValNat 2 a) ∣ b ∧ 2 ^ (padicValNat 2 a + 1) ∣ b := by
            exact ⟨ Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd ha.ne' ( by decide ), Nat.dvd_trans ( pow_dvd_pow _ h_wlog.le ) ( Nat.ordProj_dvd _ _ ), Nat.dvd_trans ( pow_dvd_pow _ ( Nat.succ_le_of_lt h_wlog ) ) ( Nat.ordProj_dvd _ _ ) ⟩;
          exact ⟨ Nat.dvd_add h_div.1 h_div.2.2.1, by rw [ Nat.dvd_add_left h_div.2.2.2 ] ; aesop ⟩;
        simp_all +decide [ Nat.dvd_prime_pow ];
        -- Since $a$ is a positive integer, we have $padicValNat 2 a \leq \log_2(a)$.
        have h_padic_le_log : padicValNat 2 a ≤ Nat.log 2 a := by
          exact Nat.le_log_of_pow_le ( by decide ) ( Nat.le_of_dvd ha ( Nat.ordProj_dvd _ _ ) );
        linarith [ Nat.log_lt_of_lt_pow ( by linarith ) ( show a < 2 ^ n by linarith ) ]

theorem complexity_pos (n : ℕ) (h : 1 < n) : 0 < complexity n := by
  unfold complexity;
  -- Since $n > 1$, the complexity of $n$ cannot be $0$ because that would imply $Reachable n 0$, which contradicts the definition of `Reachable`.
  have h_complexity_pos : ∀ {n : ℕ}, 1 < n → ¬Reachable n 0 := by
    -- By definition of Reachable, if Reachable n 0 were true, then n would have to be 0, which contradicts n > 1.
    intros n hn
    apply not_reachable_zero_snd;
  grind

lemma complexity_mul_ge_two_mul_of_IH (n : ℕ) (IH : ∀ k < n, 0 < k → complexity (2^k) = 2*k)
    (a b : ℕ) (hmul : a * b = 2^n) (ha : 1 < a) (hb : 1 < b) :
    complexity a + complexity b ≥ 2 * n := by
      -- Since $a$ and $b$ are both greater than 1, we have $a = 2^i$ and $b = 2^j$ for some $i, j$ such that $i + j = n$.
      obtain ⟨i, hi⟩ : ∃ i, a = 2 ^ i := by
        have : a ∣ 2 ^ n := hmul ▸ dvd_mul_right _ _; rw [ Nat.dvd_prime_pow ( by decide ) ] at this; aesop;
      obtain ⟨j, hj⟩ : ∃ j, b = 2 ^ j := by
        have : b ∣ 2 ^ n := hmul ▸ dvd_mul_left _ _; rw [ Nat.dvd_prime_pow ( by decide ) ] at this; aesop;
      have h_ij : i + j = n := by
        simp_all +decide [ ← pow_add ];
      grind