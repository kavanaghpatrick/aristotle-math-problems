/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b945fcee-dc5a-46c3-bfb7-c3f0f4b4bf90

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define unitary perfect numbers and prove that all unitary perfect numbers are even.

We first define `properUnitaryDivisors` and `IsUnitaryPerfect`.
We then introduce `unitaryDivisors` and `unitarySigma` (the sum of unitary divisors) and prove key properties:
- `unitarySigma` is multiplicative and equals the product of `(1 + p^a)` for prime power factors `p^a || n`.
- If `n` is odd, `2^k` divides `unitarySigma n`, where `k` is the number of distinct prime factors.
- If `n` is odd and unitary perfect, `n` can have at most 1 distinct prime factor.
- Finally, we prove `even_of_isUnitaryPerfect` by showing that an odd unitary perfect number leads to a contradiction (either `n=1` which is not perfect, or `n=p^a` which implies `n=1`).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The set of proper unitary divisors of n. A divisor d is unitary if gcd(d, n/d) = 1. Proper means 1 <= d < n.
-/
def Erdos1052.properUnitaryDivisors (n : ℕ) : Finset ℕ :=
  {d ∈ Finset.Ico 1 n | d ∣ n ∧ Nat.Coprime d (n / d)}

/-
A number n is unitary perfect if the sum of its proper unitary divisors equals n, and n is positive.
-/
def Erdos1052.IsUnitaryPerfect (n : ℕ) : Prop :=
  ∑ i ∈ Erdos1052.properUnitaryDivisors n, i = n ∧ 0 < n

/-
The set of all unitary divisors of n, and their sum (unitary sigma function).
-/
def Erdos1052.unitaryDivisors (n : ℕ) : Finset ℕ :=
  n.divisors.filter (fun d => Nat.Coprime d (n / d))

def Erdos1052.unitarySigma (n : ℕ) : ℕ :=
  ∑ d ∈ Erdos1052.unitaryDivisors n, d

/-
n is a unitary divisor of itself (if n is non-zero).
-/
lemma Erdos1052.mem_unitaryDivisors_self (n : ℕ) (hn : n ≠ 0) : n ∈ Erdos1052.unitaryDivisors n := by
  -- Since $n$ divides itself and $\gcd(n, n/n) = \gcd(n, 1) = 1$, $n$ is a unitary divisor of itself.
  simp [Erdos1052.unitaryDivisors, hn];
  -- Since $n \neq 0$, we have $n / n = 1$, and thus $\gcd(n, n / n) = \gcd(n, 1) = 1$.
  simp [Nat.div_self (Nat.pos_of_ne_zero hn)]

/-
The unitary sigma function is the sum of proper unitary divisors plus n.
-/
lemma Erdos1052.unitarySigma_eq_sum_proper_add_self (n : ℕ) (hn : 0 < n) : Erdos1052.unitarySigma n = ∑ d ∈ Erdos1052.properUnitaryDivisors n, d + n := by
  rw [ Erdos1052.unitarySigma ];
  rw [ show Erdos1052.unitaryDivisors n = Erdos1052.properUnitaryDivisors n ∪ { n } from ?_, Finset.sum_union ] <;> norm_num [ hn.ne' ];
  · exact fun h => by have := Finset.mem_Ico.mp ( Finset.mem_filter.mp h |>.1 ) ; linarith;
  · ext d; by_cases hd : d = n <;> simp +decide [ *, Erdos1052.unitaryDivisors, Erdos1052.properUnitaryDivisors ] ;
    · linarith;
    · exact ⟨ fun h => ⟨ ⟨ Nat.pos_of_dvd_of_pos h.1.1 hn, lt_of_le_of_ne ( Nat.le_of_dvd hn h.1.1 ) hd ⟩, h.1.1, h.2 ⟩, fun h => ⟨ ⟨ h.2.1, hn.ne' ⟩, h.2.2 ⟩ ⟩

/-
A number is unitary perfect if and only if its unitary sigma sum is 2n.
-/
theorem Erdos1052.isUnitaryPerfect_iff_unitarySigma_eq_two_mul (n : ℕ) (hn : 0 < n) : Erdos1052.IsUnitaryPerfect n ↔ Erdos1052.unitarySigma n = 2 * n := by
  -- By definition of unitary sigma, we have that the sum of the proper unitary divisors plus n equals the unitary sigma.
  have h_unitary_sigma : Erdos1052.unitarySigma n = ∑ i ∈ Erdos1052.properUnitaryDivisors n, i + n := by
    convert Erdos1052.unitarySigma_eq_sum_proper_add_self n hn using 1;
  simp_all +decide [ two_mul, Erdos1052.IsUnitaryPerfect ]

/-
The unitary sigma function equals the product of (1 + p^a) over all prime factors p of n, where p^a is the highest power of p dividing n.
-/
theorem Erdos1052.unitarySigma_eq_prod_prime_factors (n : ℕ) (hn : n ≠ 0) :
    Erdos1052.unitarySigma n = ∏ p ∈ n.primeFactors, (1 + p ^ (n.factorization p)) := by
  -- By definition of unitary divisors, we know that every unitary divisor of $n$ can be written as a product of prime powers where each prime power is either 1 or the highest power of that prime dividing $n$.
  have h_unitary_divisors : ∀ d ∈ Erdos1052.unitaryDivisors n, d = ∏ p ∈ n.primeFactors, p ^ (if p ^ (Nat.factorization n p) ∣ d then Nat.factorization n p else 0) := by
    intro d hd
    have h_div : d ∣ n := by
      exact Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hd |>.1
    have h_prime_factors : ∀ p ∈ n.primeFactors, Nat.factorization d p = if p ^ (Nat.factorization n p) ∣ d then Nat.factorization n p else 0 := by
      intro p hp
      have h_div_prime : Nat.factorization d p ≤ Nat.factorization n p := by
        exact Nat.factorization_le_iff_dvd ( by aesop ) ( by aesop ) |>.2 h_div p;
      split_ifs <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
      · exact le_antisymm h_div_prime ( Nat.le_of_not_lt fun h => absurd ( Nat.dvd_trans ( pow_dvd_pow _ h ) ‹_› ) ( Nat.pow_succ_factorization_not_dvd ( by aesop ) ( by aesop ) ) );
      · contrapose! h_div_prime;
        have h_coprime : Nat.gcd d (n / d) = 1 := by
          unfold Erdos1052.unitaryDivisors at hd; aesop;
        have h_div_prime : p ^ (Nat.factorization n p) ∣ d * (n / d) := by
          rw [ Nat.mul_div_cancel' h_div ] ; exact Nat.ordProj_dvd _ _;
        have h_div_prime : p ^ (Nat.factorization n p) ∣ d := by
          exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( p ^ ( Nat.factorization n p ) ) ( n / d ) from Nat.Coprime.pow_left _ <| hp.left.coprime_iff_not_dvd.mpr fun h => by have := Nat.dvd_gcd ( show p ∣ d from by tauto ) h; aesop ) h_div_prime );
        contradiction
    exact (by
    conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self ( Nat.ne_of_gt ( Nat.pos_of_dvd_of_pos h_div ( Nat.pos_of_ne_zero hn ) ) ) ];
    rw [ Finsupp.prod_of_support_subset ];
    exact?;
    · exact Nat.primeFactors_mono h_div hn;
    · bound);
  -- By definition of unitary divisors, we know that every unitary divisor of $n$ can be written as a product of prime powers where each prime power is either 1 or the highest power of that prime dividing $n$. Therefore, the sum of the unitary divisors of $n$ is equal to the product of $(1 + p^a)$ over all prime factors $p$ of $n$, where $p^a$ is the highest power of $p$ dividing $n$.
  have h_unitary_divisors_sum : ∑ d ∈ Erdos1052.unitaryDivisors n, d = ∑ s ∈ Finset.powerset n.primeFactors, (∏ p ∈ s, p ^ (Nat.factorization n p)) := by
    apply Finset.sum_bij (fun d hd => n.primeFactors.filter (fun p => p ^ (Nat.factorization n p) ∣ d)) _ _ _ <;> norm_num at *;
    · intro d hd; specialize h_unitary_divisors d hd; simp +decide [ Finset.prod_filter ] at h_unitary_divisors ⊢; exact h_unitary_divisors;
    · intro a₁ ha₁ a₂ ha₂ h; rw [ h_unitary_divisors a₁ ha₁, h_unitary_divisors a₂ ha₂ ] ; simp +decide [ Finset.prod_ite, h ] ;
    · intro b hb
      use ∏ p ∈ b, p ^ (Nat.factorization n p);
      refine' ⟨ _, _ ⟩;
      · refine' Finset.mem_filter.mpr ⟨ Nat.mem_divisors.mpr ⟨ _, _ ⟩, _ ⟩ <;> norm_num at *;
        · conv_rhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ];
          apply_rules [ Finset.prod_dvd_prod_of_subset ];
        · exact hn;
        · -- Since $b$ is a subset of the prime factors of $n$, the product $\prod_{p \in b} p^{n.factorization p}$ is coprime to $n / \prod_{p \in b} p^{n.factorization p}$.
          have h_coprime : Nat.Coprime (∏ p ∈ b, p ^ (n.factorization p)) (∏ p ∈ n.primeFactors \ b, p ^ (n.factorization p)) := by
            apply_mod_cast Nat.Coprime.prod_right ; norm_num;
            exact fun p pp _ _ hp => Nat.Coprime.prod_left fun q hq => Nat.Coprime.pow_right _ <| Nat.Coprime.pow_left _ <| by have := Nat.coprime_primes ( Nat.prime_of_mem_primeFactors <| hb hq ) pp; exact this.2 <| by rintro rfl; exact hp hq;
          convert h_coprime using 1;
          rw [ Nat.div_eq_of_eq_mul_left ];
          · exact Finset.prod_pos fun p hp => pow_pos ( Nat.pos_of_mem_primeFactors ( hb hp ) ) _;
          · conv_lhs => rw [ ← Nat.factorization_prod_pow_eq_self hn ];
            rw [ mul_comm, ← Finset.prod_union ];
            · rw [ Finset.union_sdiff_of_subset hb ];
              exact?;
            · exact Finset.disjoint_sdiff;
      · ext p; simp +contextual [ Finset.subset_iff ] at *; (
        constructor <;> intro hp <;> simp +contextual [ Finset.prod_eq_prod_diff_singleton_mul <| show p ∈ b from ?_ ] at *; (
        contrapose! hp; simp +contextual [ Finset.prod_eq_prod_diff_singleton_mul <| show p ∈ n.primeFactors from ?_ ] at *; (
        intro pp dp hn; rw [ Nat.Prime.pow_dvd_iff_le_factorization ] <;> norm_num [ pp, dp, hn ] ;
        · rw [ Nat.factorization_prod ] <;> norm_num [ pp, dp, hn ];
          · rw [ Finset.sum_eq_zero ] <;> norm_num [ pp, dp, hn ];
            · exact pos_iff_ne_zero.mpr ( Finsupp.mem_support_iff.mp ( by { exact Nat.mem_primeFactors.mpr ⟨ pp, dp, hn ⟩ } ) );
            · intro x hx; specialize hb hx; simp +decide [ Nat.factorization_eq_zero_iff, hb.1.ne_one, hb.2.1, hb.2.2 ] ;
              exact Or.inr <| Or.inr <| Or.inl <| fun h => hp <| by have := Nat.prime_dvd_prime_iff_eq pp hb.1; simp_all +singlePass ;
          · exact fun x hx hx' => absurd hx' ( Nat.Prime.ne_zero ( hb hx |>.1 ) );
        · exact Finset.prod_ne_zero_iff.mpr fun x hx => pow_ne_zero _ ( Nat.Prime.ne_zero ( hb hx |>.1 ) )));
        exact ⟨ hb hp, Finset.dvd_prod_of_mem _ hp ⟩);
  convert h_unitary_divisors_sum using 1;
  exact?

/-
If n is odd, then 2^(number of distinct prime factors) divides the unitary sigma of n.
-/
lemma Erdos1052.two_pow_card_primeFactors_dvd_unitarySigma (n : ℕ) (hn : Odd n) (hn0 : n ≠ 0) :
    2 ^ n.primeFactors.card ∣ Erdos1052.unitarySigma n := by
  -- By definition of unitary sigma function, we know that Erdos1052.unitarySigma n = ∏ p ∈ n.primeFactors, (1 + p ^ (n.factorization p)).
  have h_unitarySigma_def : Erdos1052.unitarySigma n = ∏ p ∈ n.primeFactors, (1 + p ^ (n.factorization p)) := by
    exact?;
  convert Finset.prod_dvd_prod_of_dvd _ _ fun p hp => show 2 ∣ ( 1 + p ^ ( n.factorization p ) ) from ?_ using 1;
  · norm_num;
  · simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
    exact fun h => absurd ( hn.of_dvd_nat hp.2 ) ( by simp_all +decide [ Nat.Prime.even_iff ] )

/-
If n is odd and unitary perfect, then n has at most 1 distinct prime factor.
-/
lemma Erdos1052.card_primeFactors_le_one_of_odd_isUnitaryPerfect (n : ℕ) (hn : Odd n) (hup : Erdos1052.IsUnitaryPerfect n) :
    n.primeFactors.card ≤ 1 := by
  -- By definition of unitary perfect, we have that $2n = \sum_{d \mid n, \gcd(d, n/d) = 1} d$.
  have h_unitary_sigma : 2 * n = Erdos1052.unitarySigma n := by
    rw [ Erdos1052.isUnitaryPerfect_iff_unitarySigma_eq_two_mul ] at hup;
    · exact hup.symm;
    · exact Nat.pos_of_ne_zero hn.pos.ne';
  -- By definition of unitary sigma, we have that $\sigma^*(n) = \prod_{p \mid n} (1 + p^{a_p})$.
  have h_unitary_sigma_def : Erdos1052.unitarySigma n = ∏ p ∈ n.primeFactors, (1 + p ^ (n.factorization p)) := by
    convert Erdos1052.unitarySigma_eq_prod_prime_factors n _ using 1;
    aesop_cat;
  -- Since $n$ is odd, each factor $(1 + p^{a_p})$ in the product is even, and thus the product is divisible by $2^{(n.primeFactors).card}$.
  have h_div : 2 ^ (n.primeFactors).card ∣ 2 * n := by
    have h_div : ∀ p ∈ n.primeFactors, 2 ∣ (1 + p ^ (n.factorization p)) := by
      simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
      exact fun p pp dp _ hp => absurd ( pp.even_iff.mp hp ) ( by rintro rfl; exact absurd ( hn.of_dvd_nat dp ) ( by decide ) );
    exact h_unitary_sigma.symm ▸ h_unitary_sigma_def.symm ▸ dvd_trans ( by simpa ) ( Finset.prod_dvd_prod_of_dvd _ _ h_div );
  -- Since $n$ is odd, $2^{(n.primeFactors).card}$ must divide $2$, which implies $(n.primeFactors).card \leq 1$.
  have h_card_le_one : 2 ^ (n.primeFactors).card ∣ 2 := by
    exact Nat.Coprime.dvd_of_dvd_mul_right ( Nat.Coprime.pow_left _ <| by obtain ⟨ k, rfl ⟩ := hn; norm_num ) h_div;
  exact le_of_not_gt fun h => absurd ( dvd_trans ( pow_dvd_pow _ h ) h_card_le_one ) ( by norm_num )

/-
All unitary perfect numbers are even.
-/
theorem Erdos1052.even_of_isUnitaryPerfect (n : ℕ) (hn : Erdos1052.IsUnitaryPerfect n) : Even n := by
  -- Assume that n is odd and derive a contradiction.
  by_contra h_odd_n
  have h_card_prime_factors : n.primeFactors.card ≤ 1 := by
    apply Erdos1052.card_primeFactors_le_one_of_odd_isUnitaryPerfect n (by
    grind) hn
  have h_n_form : ∃ p k, n = p ^ k ∧ p.Prime := by
    interval_cases _ : n.primeFactors.card <;> simp_all +decide [ Finset.card_eq_one ];
    · cases ‹_› <;> simp_all +decide [ Erdos1052.IsUnitaryPerfect ];
    · rcases ‹∃ a, n.primeFactors = { a } › with ⟨ p, hp ⟩ ; rw [ ← Nat.factorization_prod_pow_eq_self ( by aesop_cat : n ≠ 0 ) ] ; exact ⟨ p, ⟨ n.factorization p, by rw [ Finsupp.prod ] ; aesop_cat ⟩, Nat.prime_of_mem_primeFactors <| hp.symm ▸ Finset.mem_singleton_self _ ⟩ ;
  obtain ⟨p, k, hn_eq, hp_prime⟩ := h_n_form
  have h_unitary_sigma : Erdos1052.unitarySigma n = 1 + n := by
    rcases k with ( _ | k ) <;> simp_all +decide [ Nat.primeFactors_pow ];
    · cases hn ; contradiction;
    · convert Erdos1052.unitarySigma_eq_prod_prime_factors ( p ^ ( k + 1 ) ) ( pow_ne_zero _ hp_prime.ne_zero ) using 1 ; simp +decide [ hp_prime.ne_zero, hp_prime.ne_one, Nat.primeFactors_pow ] ; ring;
      simp +decide [ hp_prime.factorization, pow_succ', mul_assoc, mul_comm, mul_left_comm, Finset.prod_singleton ] ; ring;
      simp +decide [ hp_prime.primeFactors, Finsupp.single_apply ] ; ring;
  have h_contradiction : 1 + n = 2 * n := by
    rw [ ← h_unitary_sigma, Erdos1052.isUnitaryPerfect_iff_unitarySigma_eq_two_mul n ( Nat.pos_of_ne_zero ( by aesop ) ) |>.1 hn ]
  have h_n_one : n = 1 := by
    grind
  exact absurd h_n_one (by
  exact ne_of_gt ( lt_of_le_of_ne hn.2 ( Ne.symm <| by rintro rfl; exact absurd hn.1 <| by native_decide ) ))