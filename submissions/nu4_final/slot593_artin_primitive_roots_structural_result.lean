/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1b3171ad-0d02-41fb-90bc-f02ae73a4053

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized and proven structural lemmas regarding Artin's Conjecture on primitive roots.
Key results include:
- `square_not_primitive_root`: Perfect squares are not primitive roots modulo any odd prime.
- `neg_one_order` and `neg_one_not_primitive_root`: -1 is not a primitive root for p ≥ 5.
- `primitive_root_criterion`: Characterization of primitive roots via prime factors of p-1.
- `count_primitive_roots`: The number of primitive roots mod p is φ(p-1).
- `S_a_nonempty`: Witnesses for S(a) being non-empty for a = 2, 3, 5, 6, 7, 10.
- Computational verifications for small cases.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
S(a) = set of primes where a is a primitive root
-/
abbrev S (a : ℤ) : Set ℕ := {p : ℕ | p.Prime ∧ orderOf (a : ZMod p) = (p - 1 : ℕ)}

/-
If a is a perfect square, then a is NOT a primitive root modulo any odd prime p.
-/
theorem square_not_primitive_root (a : ℤ) (ha : IsSquare a) (p : ℕ) (hp : p.Prime) (hp2 : p ≠ 2) :
  orderOf (a : ZMod p) ≠ p - 1 := by
    -- By definition of $IsSquare$, there exists an integer $b$ such that $a = b^2$.
    obtain ⟨b, hb⟩ := ha;
    -- By Fermat's Little Theorem, we know that $b^{p-1} \equiv 1 \pmod{p}$ for any integer $b$ not divisible by $p$.
    have h_fermat : (b ^ (p - 1) : ZMod p) = 1 ∨ (b : ZMod p) = 0 := by
      haveI := Fact.mk hp; exact or_iff_not_imp_right.mpr fun h => ZMod.pow_card_sub_one_eq_one h;
    rcases h_fermat with h | h <;> simp_all +decide [ orderOf_eq_iff, pow_succ' ];
    · intro H; have := orderOf_dvd_iff_pow_eq_one.2 ( show ( ( b : ZMod p ) * ( b : ZMod p ) ) ^ ( ( p - 1 ) / 2 ) = 1 from ?_ ) ; simp_all +decide [ ← pow_two, Nat.mul_div_cancel' ( show 2 ∣ p - 1 from even_iff_two_dvd.mp <| hp.even_sub_one hp2 ) ] ;
      · exact Nat.not_dvd_of_pos_of_lt ( Nat.div_pos ( Nat.le_sub_one_of_lt ( lt_of_le_of_ne hp.two_le ( Ne.symm hp2 ) ) ) zero_lt_two ) ( Nat.div_lt_self ( Nat.sub_pos_of_lt hp.one_lt ) ( by decide ) ) this;
      · rw [ ← sq, ← pow_mul, Nat.mul_div_cancel' ( even_iff_two_dvd.mp ( hp.even_sub_one hp2 ) ) ] ; aesop;
    · rcases p with ( _ | _ | p ) <;> simp_all +decide [ orderOf_eq_iff ];
      exact fun h => absurd h ( by haveI := Fact.mk hp; simp_all +decide )

/-
S(a²) ⊆ {2} for any a
-/
theorem S_of_square_subset (a : ℤ) (ha : IsSquare a) :
  S a ⊆ {p | p = 2} := by
    intro p hp; have := hp.2; have := square_not_primitive_root a ha p hp.1; aesop;

/-
-1 has order 2 modulo any prime p > 2.
-/
theorem neg_one_order (p : ℕ) (hp : p.Prime) (hp2 : 2 < p) :
  orderOf (-1 : ZMod p) = 2 := by
    rw [ orderOf_eq_iff ] <;> norm_num;
    intro m hm₁ hm₂; interval_cases m ; norm_num;
    rw [ neg_eq_iff_add_eq_zero ] ; haveI := Fact.mk hp ; norm_num [ ← ZMod.intCast_eq_intCast_iff ];
    erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by decide ) ( by linarith )

/-
-1 is not a primitive root for p ≥ 5.
-/
theorem neg_one_not_primitive_root (p : ℕ) (hp : p.Prime) (hp5 : 5 ≤ p) :
  orderOf (-1 : ZMod p) ≠ p - 1 := by
    -- For p > 2: (-1) ≠ 1 in ZMod p, so orderOf(-1) = 2.
    have h_order_neg_one : orderOf (-1 : ZMod p) = 2 := by
      exact neg_one_order p hp ( by linarith );
    omega

/-
2 is a primitive root mod 3.
-/
theorem two_primitive_root_3 : orderOf (2 : ZMod 3) = 2 := by
  simp +decide only [orderOf_eq_iff]

/-
2 is a primitive root mod 5.
-/
theorem two_primitive_root_5 : orderOf (2 : ZMod 5) = 4 := by
  simp +decide only [orderOf_eq_iff]

/-
2 is a primitive root mod 11.
-/
theorem two_primitive_root_11 : orderOf (2 : ZMod 11) = 10 := by
  simp +decide only [orderOf_eq_iff]

/-
2 is a primitive root mod 13.
-/
theorem two_primitive_root_13 : orderOf (2 : ZMod 13) = 12 := by
  simp +decide only [orderOf_eq_iff]

/-
Check if ZMod.orderOf_dvd_card_sub_one matches order_dvd_card
-/
#check ZMod.orderOf_dvd_card_sub_one

/-
Standard characterization of primitive roots via prime factors of p-1.
-/
theorem primitive_root_criterion (a : ℤ) (p : ℕ) (hp : p.Prime) (hp2 : 2 < p) (ha : (a : ZMod p) ≠ 0) :
  orderOf (a : ZMod p) = p - 1 ↔
  ∀ q ∈ (p-1 : ℕ).primeFactors, (a : ZMod p) ^ ((p-1) / q) ≠ 1 := by
    refine' ⟨ _, fun h => _ ⟩;
    · intro h q hq; intro H; have := orderOf_dvd_iff_pow_eq_one.mpr H; simp_all +decide [ Nat.dvd_div_iff_mul_dvd ] ;
      exact Nat.not_dvd_of_pos_of_lt ( Nat.sub_pos_of_lt hp.one_lt ) ( lt_mul_of_one_lt_left ( Nat.sub_pos_of_lt hp.one_lt ) hq.1.one_lt ) this;
    · refine' orderOf_eq_of_pow_and_pow_div_prime _ _ _;
      · exact Nat.sub_pos_of_lt hp.one_lt;
      · haveI := Fact.mk hp; exact ZMod.pow_card_sub_one_eq_one ha;
      · exact fun q hq hq' => h q <| Nat.mem_primeFactors.mpr ⟨ hq, hq', Nat.sub_ne_zero_of_lt hp.one_lt ⟩

/-
Order divides p-1 (Lagrange/FLT)
-/
theorem order_dvd_card (a : ℤ) (p : ℕ) (hp : p.Prime) (ha : (a : ZMod p) ≠ 0) :
  orderOf (a : ZMod p) ∣ (p - 1) := by
    rw [ orderOf_dvd_iff_pow_eq_one ];
    haveI := Fact.mk hp; exact ZMod.pow_card_sub_one_eq_one ha;

/-
The number of primitive roots mod p equals φ(p-1).
-/
theorem count_primitive_roots (p : ℕ) [Fact (Nat.Prime p)] (hp2 : 2 < p) :
  Finset.card (Finset.filter (fun a : ZMod p => orderOf a = p - 1) Finset.univ) =
  Nat.totient (p - 1) := by
    have h_card_primitive_roots : (Finset.filter (fun a : ZMod p => orderOf a = p - 1) (Finset.univ : Finset (ZMod p))) = Finset.image (fun g : (ZMod p)ˣ => g : (ZMod p)ˣ → ZMod p) (Finset.filter (fun g : (ZMod p)ˣ => orderOf g = p - 1) (Finset.univ : Finset (ZMod p)ˣ)) := by
      ext a; simp +decide [ orderOf_units ] ;
      by_cases ha : IsUnit a <;> simp_all +decide [ orderOf_units ];
      · constructor <;> intro h;
        · obtain ⟨a_unit, ha_unit⟩ : ∃ a_unit : (ZMod p)ˣ, a_unit = a := by
            exact ⟨ Units.mk0 a ha, rfl ⟩;
          exact ⟨ a_unit, by simpa [ ← ha_unit, orderOf_units ] using h, ha_unit ⟩;
        · rcases h with ⟨ g, hg₁, rfl ⟩ ; rw [ ← hg₁ ] ; norm_num [ orderOf_units ] ;
      · exact ne_of_lt ( Nat.sub_pos_of_lt ( Nat.Prime.one_lt Fact.out ) );
    -- Let $G$ be the multiplicative group of integers modulo $p$.
    set G := (ZMod p)ˣ;
    -- Since $G$ is cyclic of order $p-1$, the number of elements of order $p-1$ in $G$ is $\phi(p-1)$.
    have h_card_G : Finset.card (Finset.filter (fun g : G => orderOf g = p - 1) (Finset.univ : Finset G)) = Nat.totient (p - 1) := by
      have h_card_G : ∀ {n : ℕ}, n ∣ Nat.totient p → Finset.card (Finset.filter (fun g : G => orderOf g = n) (Finset.univ : Finset G)) = Nat.totient n := by
        intro n hn; have := Fact.mk ( Fact.out : Nat.Prime p ) ; have := @IsCyclic.card_orderOf_eq_totient G; aesop;
      convert h_card_G _;
      rw [ Nat.totient_prime Fact.out ];
    rw [ ← h_card_G, h_card_primitive_roots, Finset.card_image_of_injective ] ; aesop_cat;

/-
S(2) is non-empty.
-/
theorem S_2_nonempty : (S 2).Nonempty := by
  -- By definition of $S$, we need to show that there exists a prime $p$ such that $orderOf(2 : ZMod p) = p - 1$.
  use 3;
  exact ⟨ by norm_num, by rw [ orderOf_eq_iff ] <;> decide ⟩

/-
S(3) is non-empty.
-/
theorem S_3_nonempty : (S 3).Nonempty := by
  -- By definition of $S(3)$, we know that $5 \in S(3)$.
  use 5
  simp [S];
  simp +decide only [orderOf_eq_iff]

/-
S(10) is non-empty.
-/
theorem S_10_nonempty : (S 10).Nonempty := by
  -- Show that 7 is in S(10).
  use 7
  constructor
  norm_num
  norm_num;
  simp +decide only [orderOf_eq_iff]

/-
S(5) is non-empty.
-/
theorem S_5_nonempty : (S 5).Nonempty := by
  -- By definition of $S$, we need to show that there exists a prime $p$ such that the order of $5$ modulo $p$ is $p-1$.
  use 3
  simp +decide [S];
  simp +decide only [orderOf_eq_iff]

/-
S(6) is non-empty.
-/
theorem S_6_nonempty : (S 6).Nonempty := by
  -- By definition of $S(6)$, we know that $11 \in S(6)$.
  use 11
  simp +decide [S]
  skip
  exact by
    simp +decide only [orderOf_eq_iff]

/-
S(7) is non-empty.
-/
theorem S_7_nonempty : (S 7).Nonempty := by
  -- By definition of $S$, we need to show that there exists a prime $p$ such that $7$ is a primitive root modulo $p$.
  use 5
  skip;
  exact ⟨ by norm_num, by rw [ orderOf_eq_iff ] <;> native_decide ⟩