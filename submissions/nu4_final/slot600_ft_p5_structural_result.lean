/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9bbf5723-58ca-4135-b629-e21304455067

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully formalized and proven the structural analysis for the p=5 case of the Feit-Thompson conjecture.

Key results proven:
1. `B_cong_1_mod_5q`: B(q) ≡ 1 (mod 5q) for q ≢ 1 (mod 5).
2. `legendre_5_B_eq_1`: The Legendre symbol (5/B(q)) = 1.
3. `ft_p5_q_mod_5`: q ≢ 1 (mod 5) if B(q) | Phi_q(5).
4. `feit_thompson_p_eq_5_bounded_5000`: Bounded verification for q < 5000.
5. `feit_thompson_p5_q7`: Explicit verification for the p=5, q=7 case.

Background lemmas from the general theory (slot560) were also formalized and proven as prerequisites.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of B(q) for p=5.
-/
def B (q : ℕ) : ℕ := q^4 + q^3 + q^2 + q + 1

/-
Background lemma 1: Any prime r dividing both Phi_p(q) and Phi_q(p) satisfies r ≡ 1 (mod pq).
-/
theorem feit_thompson_prime_divisor_congruence (p q : ℕ) (r : ℕ) (hp : p.Prime) (hq : q.Prime) (hr : r.Prime) (h_ne : p ≠ q)
    (h_div_p : (r : ℤ) ∣ (Polynomial.cyclotomic p ℤ).eval (q : ℤ)) (h_div_q : (r : ℤ) ∣ (Polynomial.cyclotomic q ℤ).eval (p : ℤ)) :
    r ≡ 1 [MOD p * q] := by
      -- By definition of cyclotomic polynomials, we know that $r \mid \Phi_p(q)$ implies $r \mid q^p - 1$ and $r \mid \Phi_q(p)$ implies $r \mid p^q - 1$.
      have h_div_q_pow : (r : ℤ) ∣ q^p - 1 := by
        exact h_div_p.trans ( by simpa [ hp.pos ] using Polynomial.eval_dvd <| Polynomial.cyclotomic.dvd_X_pow_sub_one p ℤ )
      have h_div_p_pow : (r : ℤ) ∣ p^q - 1 := by
        exact h_div_q.trans ( by simpa [ hp.pos, hq.pos ] using Polynomial.eval_dvd ( Polynomial.cyclotomic.dvd_X_pow_sub_one q ℤ ) );
      -- From Lemma 2, we know that the order of $q$ modulo $r$ is $p$ and the order of $p$ modulo $r$ is $q$.
      have h_order_q : orderOf (q : ZMod r) = p := by
        have h_order_q : orderOf (q : ZMod r) ∣ p := by
          rw [ orderOf_dvd_iff_pow_eq_one ];
          simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ];
        rw [ Nat.dvd_prime hp ] at h_order_q;
        haveI := Fact.mk hr; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ] ;
        cases p <;> cases q <;> simp_all +decide [ Polynomial.cyclotomic_prime ];
        aesop
      have h_order_p : orderOf (p : ZMod r) = q := by
        haveI := Fact.mk hr; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ] ;
        have := orderOf_dvd_iff_pow_eq_one.mpr h_div_p_pow; simp_all +decide [ Nat.dvd_prime ] ;
        cases this <;> simp_all +decide [ Polynomial.cyclotomic_prime ];
        aesop;
      -- Since the order of $q$ modulo $r$ is $p$, we have $p \mid r - 1$. Similarly, since the order of $p$ modulo $r$ is $q$, we have $q \mid r - 1$.
      have h_div_r_minus_1 : p ∣ r - 1 ∧ q ∣ r - 1 := by
        haveI := Fact.mk hr; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, orderOf_dvd_iff_pow_eq_one ];
        exact ⟨ h_order_q ▸ orderOf_dvd_iff_pow_eq_one.mpr ( by rw [ ZMod.pow_card_sub_one_eq_one ] ; cases p <;> aesop ), h_order_p ▸ orderOf_dvd_iff_pow_eq_one.mpr ( by rw [ ZMod.pow_card_sub_one_eq_one ] ; cases q <;> aesop ) ⟩;
      rw [ Nat.modEq_iff_dvd ];
      simpa [ Nat.cast_sub hr.pos ] using Nat.modEq_iff_dvd.mp ( Nat.modEq_zero_iff_dvd.mpr ( Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by simpa [ * ] using Nat.coprime_primes hp hq ) h_div_r_minus_1.1 h_div_r_minus_1.2 ) )

/-
Background lemma 2: Phi_p(q) | Phi_q(p) → Phi_p(q) ≡ 1 (mod pq).
-/
theorem feit_thompson_congruence_1_mod_pq (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h_ne : p ≠ q)
    (h_div : (Polynomial.cyclotomic p ℤ).eval (q : ℤ) ∣ (Polynomial.cyclotomic q ℤ).eval (p : ℤ)) :
    (Polynomial.cyclotomic p ℤ).eval (q : ℤ) ≡ 1 [ZMOD p * q] := by
      -- Let $r$ be any prime divisor of $\Phi_p(q)$. By the lemma, $r \equiv 1 \mod pq$.
      have h_prime_divisors : ∀ r : ℕ, r.Prime → r ∣ (Polynomial.eval (q : ℤ) (Polynomial.cyclotomic p ℤ)).natAbs → r ≡ 1 [MOD p * q] := by
        intro r hr hr_div
        have hr_div_p : (r : ℤ) ∣ (Polynomial.cyclotomic p ℤ).eval (q : ℤ) := by
          simpa [ ← Int.natCast_dvd_natCast ] using hr_div
        have hr_div_q : (r : ℤ) ∣ (Polynomial.cyclotomic q ℤ).eval (p : ℤ) := by
          exact dvd_trans hr_div_p h_div;
        convert feit_thompson_prime_divisor_congruence p q r hp hq hr h_ne hr_div_p hr_div_q using 1;
      -- Since any prime divisor $r$ of $\Phi_p(q)$ satisfies $r \equiv 1 \mod pq$, the product of these divisors (which is $\Phi_p(q)$ itself) must also be congruent to $1 \mod pq$.
      have h_prod_prime_divisors : (Polynomial.eval (q : ℤ) (Polynomial.cyclotomic p ℤ)).natAbs ≡ 1 [MOD p * q] := by
        rw [ ← Nat.factorization_prod_pow_eq_self ( show ( Polynomial.eval ( q : ℤ ) ( Polynomial.cyclotomic p ℤ ) |> Int.natAbs ) ≠ 0 from ?_ ) ];
        · simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
          exact Finset.prod_eq_one fun x hx => by aesop;
        · haveI := Fact.mk hp; haveI := Fact.mk hq; simp +decide [ Polynomial.cyclotomic_prime ] ;
          exact ne_of_gt <| Finset.sum_pos ( fun _ _ => pow_pos ( Nat.cast_pos.mpr hq.pos ) _ ) ⟨ _, Finset.mem_range.mpr hp.pos ⟩;
      rw [ ← Int.natAbs_of_nonneg ( show 0 ≤ Polynomial.eval ( q : ℤ ) ( Polynomial.cyclotomic p ℤ ) from ?_ ) ];
      · simpa [ ← Int.natCast_modEq_iff ] using h_prod_prime_divisors;
      · haveI := Fact.mk hp; haveI := Fact.mk hq; simp +decide [ Polynomial.cyclotomic_prime ] ;
        exact Finset.sum_nonneg fun _ _ => pow_nonneg ( Nat.cast_nonneg _ ) _

/-
Background lemma 3: Phi_p(q) | Phi_q(p) → q ≢ 1 (mod p).
-/
theorem feit_thompson_mod_p (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h_ne : p ≠ q)
    (h_div : (Polynomial.cyclotomic p ℤ).eval (q : ℤ) ∣ (Polynomial.cyclotomic q ℤ).eval (p : ℤ)) :
    ¬ (q ≡ 1 [MOD p]) := by
      -- Assume for contradiction that $q \equiv 1 \pmod{p}$.
      by_contra h_contra
      have hq_eq_one : q ≡ 1 [MOD p] := by
        assumption;
      -- By Feit-Thompson, we know that $\Phi_p(q) \equiv 1 \pmod{pq}$.
      have h_phi_pq_mod_pq : (Polynomial.cyclotomic p ℤ).eval (q : ℤ) ≡ 1 [ZMOD p * q] := by
        convert feit_thompson_congruence_1_mod_pq p q hp hq h_ne h_div using 1;
      -- However, we have that $\Phi_p(q) \equiv 0 \pmod{p}$, which contradicts $\Phi_p(q) \equiv 1 \pmod{pq}$.
      have h_contradiction : (Polynomial.cyclotomic p ℤ).eval (q : ℤ) ≡ 0 [ZMOD p] := by
        haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        simp_all +decide [ Polynomial.cyclotomic_prime ];
      have := h_phi_pq_mod_pq.of_dvd ( dvd_mul_right ( p : ℤ ) q ) ; simp_all +decide [ Int.ModEq ] ;
      rw [ Int.emod_eq_zero_of_dvd h_contradiction ] at this; rcases p with ( _ | _ | p ) <;> norm_cast at *;

/-
Background lemma 4: q^{p-1} < p^q for p < q (proved for 2 < p).
-/
theorem feit_thompson_size_lemma (p q : ℕ) (hp : p.Prime) (hq : q.Prime) (h_lt : p < q) (hp3 : 2 < p) :
    q ^ (p - 1) < p ^ q := by
      -- We'll use the fact that $q^{p-1} < p^q$ if and only if $(p-1) \ln q < q \ln p$.
      suffices h_ln : (p - 1) * Real.log q < q * Real.log p by
        rw [ ← @Nat.cast_lt ℝ ] ; cases p <;> cases q <;> norm_num at * ; rw [ ← Real.log_lt_log_iff ( by positivity ) ( by positivity ) ] ; simpa [ mul_comm ] using h_ln;
      -- We'll use the fact that $f(x) = \frac{\ln x}{x - 1}$ is decreasing for $x > e$.
      have h_decreasing : ∀ x y : ℝ, Real.exp 1 < x → x < y → Real.log y / (y - 1) < Real.log x / (x - 1) := by
        -- Let's calculate the derivative of $f(x) = \frac{\ln x}{x - 1}$ and show it is negative for $x > e$.
        have h_deriv_neg : ∀ x : ℝ, Real.exp 1 < x → deriv (fun x => Real.log x / (x - 1)) x < 0 := by
          intro x hx;
          norm_num [ show x ≠ 0 by linarith [ Real.exp_pos 1 ], show x - 1 ≠ 0 by linarith [ Real.add_one_le_exp 1 ] ];
          rw [ div_lt_iff₀ ] <;> nlinarith [ Real.add_one_le_exp 1, mul_inv_cancel₀ ( by linarith [ Real.add_one_le_exp 1 ] : x ≠ 0 ), Real.log_exp 1, Real.log_lt_log ( by positivity ) hx ];
        -- Apply the Mean Value Theorem to the interval [x, y].
        intros x y hx hy
        have h_mvt : ∃ c ∈ Set.Ioo x y, deriv (fun x => Real.log x / (x - 1)) c = (Real.log y / (y - 1) - Real.log x / (x - 1)) / (y - x) := by
          apply_rules [ exists_deriv_eq_slope ];
          · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div ( Real.continuousAt_log ( by linarith [ hx.1, Real.exp_pos 1 ] ) ) ( continuousAt_id.sub continuousAt_const ) ( by linarith [ hx.1, Real.add_one_le_exp 1 ] );
          · exact fun u hu => DifferentiableAt.differentiableWithinAt ( by exact DifferentiableAt.div ( Real.differentiableAt_log ( by linarith [ hu.1, Real.exp_pos 1 ] ) ) ( differentiableAt_id.sub_const _ ) ( by linarith [ hu.1, Real.add_one_le_exp 1 ] ) );
        obtain ⟨ c, ⟨ hxc, hcy ⟩, hcd ⟩ := h_mvt; have := h_deriv_neg c ( by linarith ) ; rw [ hcd, div_lt_iff₀ ] at this <;> linarith;
      have := h_decreasing p q ?_ ?_ <;> norm_num at *;
      · rw [ div_lt_div_iff₀ ] at this <;> nlinarith [ show ( p : ℝ ) ≥ 3 by norm_cast, show ( q : ℝ ) ≥ p + 1 by norm_cast, Real.log_pos ( show ( p : ℝ ) > 1 by norm_cast; linarith ), Real.log_lt_log ( by positivity ) ( show ( q : ℝ ) > p by norm_cast ) ];
      · exact lt_of_lt_of_le ( Real.exp_one_lt_d9.trans_le ( by norm_num ) ) ( Nat.cast_le.mpr hp3 );
      · exact?

/-
B(q) ≡ 1 (mod q).
-/
lemma B_cong_1_mod_q (q : ℕ) : B q ≡ 1 [MOD q] := by
  unfold B; norm_num [ ← ZMod.natCast_eq_natCast_iff ] ;

/-
B(q) ≡ 1 (mod 5) when q ≢ 1 (mod 5).
Proof: B(q) = (q^5-1)/(q-1). By Fermat, q^5 ≡ q (mod 5), so B(q) ≡ (q-1)/(q-1) = 1 (mod 5).
-/
lemma B_cong_1_mod_5 (q : ℕ) (hq : q.Prime) (hq5 : 5 < q) (hq_not_1 : ¬ (q ≡ 1 [MOD 5])) :
    B q ≡ 1 [MOD 5] := by
      unfold B; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] ; have := Nat.mod_lt q ( by decide : 5 > 0 ) ; interval_cases _ : q % 5 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hq.dvd_iff_eq ] ;
      exact hq_not_1 ‹_›

/-
Result 1: B(q) ≡ 1 (mod 5q) assuming q ≢ 1 (mod 5).
-/
theorem B_cong_1_mod_5q (q : ℕ) (hq : q.Prime) (hq5 : 5 < q) (h_not_one : ¬ (q ≡ 1 [MOD 5])) :
    B q ≡ 1 [MOD 5*q] := by
      -- By B_cong_1_mod_5, we have B q ≡ 1 [MOD 5].
      have h_mod_5 : B q ≡ 1 [MOD 5] := by
        convert B_cong_1_mod_5 q hq hq5 h_not_one using 1;
      -- By B_cong_1_mod_q, we have B q ≡ 1 [MOD q].
      have h_mod_q : B q ≡ 1 [MOD q] := by
        exact?;
      rw [ ← Nat.modEq_and_modEq_iff_modEq_mul ] ; tauto;
      exact Nat.Coprime.symm ( hq.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases q )

/-
Result 2: The Legendre symbol (5/B(q)) = 1.
Proof: By QR: (5/B) = (B/5)·(-1)^{(5-1)(B-1)/4} = (B/5)·(-1)^{(B-1)}.
B ≡ 1 (mod 5), so (B/5) = (1/5) = 1. And (-1)^{B-1}: need B-1 mod 2.
B-1 = q(q+1)(q²+1). This is even (since q(q+1) is even). So (-1)^{B-1} = 1.
Thus (5/B) = 1·1 = 1.
-/
theorem legendre_5_B_eq_1 (q : ℕ) (hq : q.Prime) (hq5 : 5 < q) (hB : Fact (Nat.Prime (B q))) :
    legendreSym (B q) 5 = 1 := by
      -- By quadratic reciprocity, we have $\left(\frac{B(q)}{5}\right) = \left(\frac{5}{B(q)}\right)$.
      have h_reciprocity : jacobiSym 5 (B q) = jacobiSym (B q) 5 := by
        rw [ jacobiSym.quadratic_reciprocity ] ; norm_num;
        · exact hB.1.odd_of_ne_two <| ne_of_gt <| by { unfold B; nlinarith [ pow_pos hq.pos 2 ] };
        · decide;
      -- Since $B(q) \equiv 1 \pmod{5}$, we have $\left(\frac{B(q)}{5}\right) = \left(\frac{1}{5}\right) = 1$.
      have h_mod_5 : jacobiSym (B q) 5 = 1 := by
        -- By definition of $B$, we know that $B(q) \equiv 1 \pmod{5}$ if $q \not\equiv 1 \pmod{5}$.
        have hB_mod_5 : B q ≡ 1 [MOD 5] ∨ B q ≡ 0 [MOD 5] := by
          unfold B; norm_num [ Nat.ModEq, Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt q ( by decide : 5 > 0 ) ; interval_cases _ : q % 5 <;> simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, hq.dvd_iff_eq ] ;
        rcases hB_mod_5 with h | h <;> rw [ jacobiSym.mod_left ] <;> norm_cast <;> simp_all +decide [ Nat.ModEq ];
        have := Nat.dvd_of_mod_eq_zero h; rw [ hB.1.dvd_iff_eq ] at this <;> simp_all +decide [ B ] ;
        nlinarith only [ this, hq5, pow_pos hq.pos 3 ];
      rw [ jacobiSym ] at h_reciprocity;
      simp_all +decide [ Nat.primeFactorsList_prime hB.1 ]

/-
Result 3: q ≢ 1 (mod 5).
Proof: By feit_thompson_mod_p with p=5.
Phi_5(q) = B(q). Phi_q(5) = (5^q-1)/4.
So B(q) | Phi_q(5) implies q ≢ 1 (mod 5).
-/
theorem ft_p5_q_mod_5 (q : ℕ) (hq : q.Prime) (hq5 : 5 < q)
    (hdiv : B q ∣ (5^q-1)/4) : ¬ (q ≡ 1 [MOD 5]) := by
      intro hq1
      have h_cyclotomic : (Polynomial.cyclotomic 5 ℤ).eval (q : ℤ) ∣ (Polynomial.cyclotomic q ℤ).eval (5 : ℤ) := by
        have h_cyclotomic : (Polynomial.cyclotomic 5 ℤ).eval (q : ℤ) = B q ∧ (Polynomial.cyclotomic q ℤ).eval (5 : ℤ) = (5 ^ q - 1) / (5 - 1) := by
          haveI := Fact.mk hq; simp +decide [ Polynomial.cyclotomic_prime ] ;
          norm_num [ Finset.sum_range_succ, B ];
          exact ⟨ by ring, by rw [ ← geom_sum_mul ] ; norm_num ⟩;
        convert Int.natCast_dvd_natCast.mpr hdiv using 1 ; aesop;
        norm_num [ h_cyclotomic.2, Nat.cast_sub ( Nat.one_le_pow q 5 ( by decide ) ) ];
      have := feit_thompson_mod_p 5 q ( by norm_num ) hq ( by linarith ) h_cyclotomic; simp_all +decide [ Nat.ModEq ] ;

/-
Bounded verification function for p=5 case.
-/
def check_ft_p_eq_5 (q : ℕ) : Bool :=
  if h : q.Prime ∧ 5 < q then
    let b := q^4 + q^3 + q^2 + q + 1
    if b.Prime then
      (5 : ZMod b) ^ q ≠ 1
    else
      true
  else true

/-
Result 5: The p=5, q=7 case explicitly.
For q=7: B(7) = 2801. 2801 is prime.
Need to verify: 5^7 ≢ 1 (mod 2801).
5^7 = 78125. 78125 ≡ 2498 (mod 2801). 2498 ≠ 1.
-/
theorem feit_thompson_p5_q7 : (5 : ZMod 2801) ^ 7 ≠ 1 := by
  decide +revert

/-
Result 4: Bounded verification for q < 1000.
-/
theorem feit_thompson_p_eq_5_bounded_1000 :
    (List.range 1000).all check_ft_p_eq_5 = true := by native_decide

/-
Result 4: Bounded verification for q < 5000.
-/
theorem feit_thompson_p_eq_5_bounded_5000 :
    (List.range 5000).all check_ft_p_eq_5 = true := by native_decide