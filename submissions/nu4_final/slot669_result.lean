/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f70f28c9-0114-409b-9592-b92eeed54a36

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
S'(h, k) := ∑_{j=1}^{k-1} (-1)^{j + 1 + ⌊hj/k⌋}
-/
def S' (h k : ℕ) : ℤ := ∑ j ∈ Finset.Ico 1 k, (-1 : ℤ) ^ (j + 1 + ⌊(h * j : ℚ) / k⌋₊)

/-
S(k) := ∑_{h=1}^{k-1} S'(h, k)
-/
def S (k : ℕ) : ℤ := ∑ h ∈ Finset.Ico 1 k, S' h k

/-
verify_conj_1_1(N) checks if S(k) > 0 for all odd primes k < N.
-/
def verify_conj_1_1 (N : ℕ) : Bool :=
  (List.range N).all fun k => if k.Prime ∧ Odd k then decide (0 < S k) else true

/-
If verify_conj_1_1(N) is true, then S(k) > 0 for all odd primes k < N.
-/
lemma verify_conj_1_1_correct (N : ℕ) : verify_conj_1_1 N = true → ∀ k < N, k.Prime → Odd k → 0 < S k := by
  unfold verify_conj_1_1;
  grind

/-
Conjecture 1.1 verified for k < 100.
-/
theorem conj_1_1_verified_100 : ∀ k < 100, k.Prime → Odd k → 0 < S k := by
  apply verify_conj_1_1_correct 100
  native_decide

/-
verify_conj_4_1(N) checks if S(k) > k for all odd primes 5 < k < N.
-/
def verify_conj_4_1 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 5 < k ∧ k.Prime ∧ Odd k then decide (k < S k) else true

/-
If verify_conj_4_1(N) is true, then S(k) > k for all odd primes 5 < k < N.
-/
lemma verify_conj_4_1_correct (N : ℕ) : verify_conj_4_1 N = true → ∀ k < N, 5 < k → k.Prime → Odd k → k < S k := by
  unfold verify_conj_4_1;
  grind

/-
Conjecture 1.1 verified for k < 1000.
-/
theorem conj_1_1_verified_1000 : ∀ k < 1000, k.Prime → Odd k → 0 < S k := by
  apply verify_conj_1_1_correct 1000
  native_decide

/-
verify_conj_4_1_range(start, stop) checks if S(k) > k for all odd primes k in [start, stop).
-/
def verify_conj_4_1_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 5 < k ∧ k.Prime ∧ Odd k then decide (k < S k) else true

/-
If verify_conj_4_1_range(start, stop) is true, then S(k) > k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_1_range_correct (start stop : ℕ) :
  verify_conj_4_1_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 5 < k → k.Prime → Odd k → k < S k := by
    unfold verify_conj_4_1_range;
    grind

/-
Conjecture 4.1 verified for 5 < k < 500.
-/
theorem conj_4_1_verified_500 : ∀ k ∈ List.range' 0 500, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 0 500
  native_decide

/-
Conjecture 4.1 verified for 500 <= k < 600.
-/
theorem conj_4_1_verified_500_600 : ∀ k ∈ List.range' 500 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 500 600
  native_decide

/-
Conjecture 4.1 verified for 600 <= k < 700.
-/
theorem conj_4_1_verified_600_700 : ∀ k ∈ List.range' 600 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 600 700
  native_decide

/-
Conjecture 4.1 verified for 700 <= k < 800.
-/
theorem conj_4_1_verified_700_800 : ∀ k ∈ List.range' 700 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 700 800
  native_decide

/-
Conjecture 4.1 verified for 800 <= k < 900.
-/
theorem conj_4_1_verified_800_900 : ∀ k ∈ List.range' 800 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 800 900
  native_decide

/-
Conjecture 4.1 verified for 900 <= k < 1000.
-/
theorem conj_4_1_verified_900_1000 : ∀ k ∈ List.range' 900 100, 5 < k → k.Prime → Odd k → k < S k := by
  apply verify_conj_4_1_range_correct 900 1000
  native_decide

/-
Conjecture 4.1 verified for 500 <= k < 1000 by combining sub-ranges.
-/
theorem conj_4_1_verified_500_1000 : ∀ k ∈ List.range' 500 500, 5 < k → k.Prime → Odd k → k < S k := by
  intros k hk hk_gt hk_prime hk_odd;
  have h_split : k ∈ List.range' 500 100 ∨ k ∈ List.range' 600 100 ∨ k ∈ List.range' 700 100 ∨ k ∈ List.range' 800 100 ∨ k ∈ List.range' 900 100 := by
    simp +zetaDelta at *;
    omega;
  rcases h_split with ( h | h | h | h | h ) <;> [ exact conj_4_1_verified_500_600 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_600_700 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_700_800 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_800_900 k h hk_gt hk_prime hk_odd; exact conj_4_1_verified_900_1000 k h hk_gt hk_prime hk_odd ]

/-
Conjecture 4.1 verified for 5 < k < 1000 by combining 0-500 and 500-1000.
-/
theorem conj_4_1_verified_1000 : ∀ k < 1000, 5 < k → k.Prime → Odd k → k < S k := by
  -- By combining the results from the sub-ranges, we can conclude that the conjecture holds for all k from 6 to 999.
  intros k hk_lt hk_gt hk_prime hk_odd
  by_cases hk_range : k < 500;
  · convert conj_4_1_verified_500 k _ _ _ _ using 1;
    · grind;
    · linarith;
    · assumption;
    · assumption;
  · convert conj_4_1_verified_500_1000 k _ _ _ _ ; aesop;
    · linarith;
    · assumption;
    · assumption

/-
S(2) = 1.
-/
theorem S_2_eq_1 : S 2 = 1 := by
  native_decide

/-
verify_conj_4_2(N) checks if S(k) > 2k for all odd primes 233 < k < N.
-/
def verify_conj_4_2 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 233 < k ∧ k.Prime ∧ Odd k then decide (2 * k < S k) else true

/-
If verify_conj_4_2(N) is true, then S(k) > 2k for all odd primes 233 < k < N.
-/
lemma verify_conj_4_2_correct (N : ℕ) : verify_conj_4_2 N = true → ∀ k < N, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  intro h k hk₁ hk₂ hk₃ hk₄; revert k; contrapose! h; simp_all +decide [ List.all ] ;
  unfold verify_conj_4_2; aesop;

/-
verify_conj_4_2_range(start, stop) checks if S(k) > 2k for all odd primes k in [start, stop).
-/
def verify_conj_4_2_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 233 < k ∧ k.Prime ∧ Odd k then decide (2 * k < S k) else true

/-
Conjecture 4.2 verified for 234 <= k < 600.
-/
theorem conj_4_2_verified_234_600 : ∀ k ∈ List.range' 234 (600 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
  -- We'll use that $S(k)$ is computed for each $k$ in the range $234$ to $599$.
  have h_computed : ∀ k ∈ Finset.Ico 234 600, Nat.Prime k → Odd k → 2 * k < S k := by
    simp +zetaDelta at *;
    intros k hk1 hk2 hk3 hk4
    interval_cases k <;> norm_num [ S ];
    all_goals norm_num [ Finset.sum_Ico_eq_sum_range ] at *;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
  aesop

/-
If verify_conj_4_2_range(start, stop) is true, then S(k) > 2k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_2_range_correct (start stop : ℕ) :
  verify_conj_4_2_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 233 < k → k.Prime → Odd k → 2 * k < S k := by
    unfold verify_conj_4_2_range;
    grind

/-
Conjecture 4.2 verified for 600 <= k < 800.
-/
theorem conj_4_2_verified_600_800 : ∀ k ∈ List.range' 600 200, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  apply verify_conj_4_2_range_correct 600 800
  native_decide

/-
Conjecture 4.2 verified for 800 <= k < 1000.
-/
theorem conj_4_2_verified_800_1000 : ∀ k ∈ List.range' 800 200, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  intro k hk₁ hk₂ hk₃ hk₄;
  norm_num [ List.mem_range' ] at hk₁;
  obtain ⟨ i, hi, rfl ⟩ := hk₁; interval_cases i <;> norm_num at *;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert

/-
Conjecture 4.2 verified for 233 < k < 1000 by combining sub-ranges.
-/
theorem conj_4_2_verified_1000 : ∀ k < 1000, 233 < k → k.Prime → Odd k → 2 * k < S k := by
  -- By combining the results from the subranges, we can conclude that the conjecture holds for all odd primes between 234 and 999. We'll use the fact that if the conjecture holds for each subrange, then it holds for the entire range.
  have h_combined : ∀ k ∈ List.range' 234 (1000 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
    intro k hk h233 h_prime h_odd
    have h600 : ∀ k ∈ List.range' 234 (600 - 234), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    have h800 : ∀ k ∈ List.range' 600 (800 - 600), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    have h1000 : ∀ k ∈ List.range' 800 (1000 - 800), 233 < k → k.Prime → Odd k → 2 * k < S k := by
      exact?
    grind;
  grind

/-
Check if S'(h, k) = -S'(k-h, k) for k < N.
-/
def check_symmetry (N : ℕ) : Bool :=
  (List.range N).all fun k =>
    if k > 2 then
      (List.range k).all fun h =>
        if h > 0 then S' h k == - S' (k - h) k else true
    else true

/-
Disproof of symmetry: there exist k, h such that S'(h, k) != -S'(k-h, k).
-/
theorem symmetry_disproof : ∃ k h, h < k ∧ S' h k ≠ - S' (k - h) k := by
  use 3, 1
  native_decide

/-
verify_conj_4_3(N) checks if S(k) > 3k for all odd primes 3119 < k < N.
-/
def verify_conj_4_3 (N : ℕ) : Bool :=
  (List.range N).all fun k => if 3119 < k ∧ k.Prime ∧ Odd k then decide (3 * k < S k) else true

/-
If verify_conj_4_3(N) is true, then S(k) > 3k for all odd primes 3119 < k < N.
-/
lemma verify_conj_4_3_correct (N : ℕ) : verify_conj_4_3 N = true → ∀ k < N, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  intro h k hk₁ hk₂ hk₃ hk₄; revert h; unfold verify_conj_4_3; (
  grind);

/-
verify_conj_4_3_range(start, stop) checks if S(k) > 3k for all odd primes k in [start, stop).
-/
def verify_conj_4_3_range (start stop : ℕ) : Bool :=
  (List.range' start (stop - start)).all fun k =>
    if 3119 < k ∧ k.Prime ∧ Odd k then decide (3 * k < S k) else true

/-
If verify_conj_4_3_range(start, stop) is true, then S(k) > 3k for all odd primes k in [start, stop).
-/
lemma verify_conj_4_3_range_correct (start stop : ℕ) :
  verify_conj_4_3_range start stop = true →
  ∀ k ∈ List.range' start (stop - start), 3119 < k → k.Prime → Odd k → 3 * k < S k := by
    -- By definition of `verify_conj_4_3_range`, if it returns true, then for all `k` in the range [start, stop), the condition `3 * k < S k` holds.
    intro h_true
    intro k hk_range hk_gt hk_prime hk_odd
    have h_cond : 3 * (k : ℤ) < S k := by
      contrapose! h_true; simp_all +decide [ verify_conj_4_3_range ] ;
      exact ⟨ k, hk_range.1, hk_range.2, ⟨ hk_gt, hk_prime, hk_odd ⟩, h_true ⟩
    exact h_cond

/-
Conjecture 4.3 verified for 3120 <= k < 3130.
-/
theorem conj_4_3_verified_3120_3130 : ∀ k ∈ List.range' 3120 10, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  apply verify_conj_4_3_range_correct 3120 3130
  native_decide

/-
Conjecture 4.3 verified for 3130 <= k < 3135.
-/
theorem conj_4_3_verified_3130_3135 : ∀ k ∈ List.range' 3130 5, 3119 < k → k.Prime → Odd k → 3 * k < S k := by
  apply verify_conj_4_3_range_correct 3130 3135
  native_decide