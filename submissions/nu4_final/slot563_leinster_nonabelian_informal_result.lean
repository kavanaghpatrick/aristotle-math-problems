/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ffe4e876-5980-4b2e-858b-1bf1a6d1855a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define a Leinster group as a finite group where the sum of the orders of its normal subgroups equals twice the order of the group. We prove that there exists a non-abelian Leinster group, specifically the direct product of the symmetric group on 3 elements and the cyclic group of order 5 ($S_3 \times C_5$). We establish helper lemmas to compute the sum of normal subgroup orders for direct products of groups with coprime orders, and for $S_3$ and $C_5$ individually.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A finite group G is a Leinster group if the sum of the orders of its normal subgroups equals twice the order of G.
-/
def IsLeinster (G : Type*) [Group G] [Fintype G] : Prop :=
  ∑ H : {H : Subgroup G // H.Normal}, Nat.card H = 2 * Fintype.card G

/-
Checking availability of definitions and instances.
-/
#check Equiv.Perm
#check ZMod
#check Multiplicative
#synth Group (Equiv.Perm (Fin 3))
#synth AddGroup (ZMod 5)
#synth Group (Multiplicative (ZMod 5))
#synth Group (Equiv.Perm (Fin 3) × Multiplicative (ZMod 5))

/-
The group G = S3 x C5 is non-abelian.
-/
abbrev G_leinster : Type := Equiv.Perm (Fin 3) × Multiplicative (ZMod 5)

theorem G_leinster_nonabelian : ¬ ∀ (a b : G_leinster), a * b = b * a := by
  simp +decide [ G_leinster ] at *

/-
If G and H have coprime orders, the sum of orders of normal subgroups of G x H is the product of the sums for G and H.
-/
theorem sum_card_normal_prod_eq_mul {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]
    (h_coprime : Nat.Coprime (Fintype.card G) (Fintype.card H)) :
    ∑ N : {N : Subgroup (G × H) // N.Normal}, Nat.card N =
    (∑ N : {N : Subgroup G // N.Normal}, Nat.card N) * (∑ N : {N : Subgroup H // N.Normal}, Nat.card N) := by
  -- By definition of coprimality, every normal subgroup of $G \times H$ is of the form $N \times M$ where $N$ is normal in $G$ and $M$ is normal in $H$.
  have h_normal_subgroups : ∀ N : Subgroup (G × H), N.Normal → ∃ N_G : Subgroup G, ∃ N_H : Subgroup H, N_G.Normal ∧ N_H.Normal ∧ N = Subgroup.prod N_G N_H := by
    intro N hN
    obtain ⟨N_G, N_H, hN_prod⟩ : ∃ N_G : Subgroup G, ∃ N_H : Subgroup H, N = Subgroup.prod N_G N_H := by
      -- By definition of coprimality, every normal subgroup of $G \times H$ is of the form $N \times M$ where $N$ is normal in $G$ and $M$ is normal in $H$. We use the fact that the projection maps are surjective.
      have h_proj : ∀ g : G, ∀ h : H, (g, h) ∈ N → (g, 1) ∈ N ∧ (1, h) ∈ N := by
        intro g h hgh
        have h_order : (g, h) ^ (Fintype.card G) ∈ N ∧ (g, h) ^ (Fintype.card H) ∈ N := by
          exact ⟨ N.pow_mem hgh _, N.pow_mem hgh _ ⟩;
        have h_order : (1, h ^ Fintype.card G) ∈ N ∧ (g ^ Fintype.card H, 1) ∈ N := by
          simp_all +decide [ Prod.pow_def ];
        -- Since $g$ and $h$ have orders coprime to each other, we can use the fact that if $(g^k, 1) \in N$ for some $k$, then $(g, 1) \in N$.
        have h_g : (g, 1) ∈ N := by
          have h_g : ∃ k : ℕ, k * Fintype.card H ≡ 1 [MOD Fintype.card G] := by
            have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime.symm;
            rcases n : Fintype.card G with ( _ | _ | n ) <;> simp_all +decide [ mul_comm, Nat.ModEq ];
            exact ⟨ 0, by simp +decide ⟩;
          obtain ⟨ k, hk ⟩ := h_g;
          have h_g : (g ^ (k * Fintype.card H), 1) ∈ N := by
            have h_g : (g ^ Fintype.card H, 1) ^ k ∈ N := by
              exact N.pow_mem h_order.2 k;
            convert h_g using 1 ; simp +decide [ pow_mul' ];
          rw [ ← Nat.mod_add_div ( k * Fintype.card H ) ( Fintype.card G ), hk ] at h_g; simp_all +decide [ pow_add, pow_mul ] ;
        have h_h : (1, h) ∈ N := by
          have h_h : (1, h ^ Fintype.card G) ∈ N := by
            exact h_order.1;
          -- Since $h$ has order coprime to $Fintype.card G$, we can use the fact that if $(1, h^k) \in N$ for some $k$, then $(1, h) \in N$.
          have h_h_order : ∃ k : ℕ, k * Fintype.card G ≡ 1 [MOD Fintype.card H] := by
            have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime;
            rcases n : Fintype.card H with ( _ | _ | n ) <;> simp_all +decide [ mul_comm, Nat.ModEq ];
            exact ⟨ 0, by simp +decide ⟩;
          obtain ⟨ k, hk ⟩ := h_h_order;
          have h_h_order : (1, h ^ (k * Fintype.card G)) ∈ N := by
            convert N.pow_mem h_h k using 1 ; simp +decide [ pow_mul' ];
          rw [ ← Nat.mod_add_div ( k * Fintype.card G ) ( Fintype.card H ), hk ] at h_h_order; simp_all +decide [ pow_add, pow_mul ] ;
        exact ⟨h_g, h_h⟩;
      refine' ⟨ Subgroup.map ( MonoidHom.fst G H ) N, Subgroup.map ( MonoidHom.snd G H ) N, le_antisymm _ _ ⟩ <;> simp_all +decide [ Subgroup.map, Subgroup.prod ];
      · exact fun x hx => ⟨ ⟨ x, hx, rfl ⟩, ⟨ x, hx, rfl ⟩ ⟩;
      · rintro ⟨ g, h ⟩ ⟨ ⟨ x, hx, rfl ⟩, ⟨ y, hy, rfl ⟩ ⟩;
        convert N.mul_mem ( h_proj _ _ hx |>.1 ) ( h_proj _ _ hy |>.2 ) using 1 ; aesop;
    refine' ⟨ N_G, N_H, _, _, hN_prod ⟩ <;> simp_all +decide [ Subgroup.Normal ];
    · refine' ⟨ fun g hg => _ ⟩;
      intro h; have := hN.conj_mem _ ( show ( g, 1 ) ∈ N_G.prod N_H from ⟨ hg, N_H.one_mem ⟩ ) ( h, 1 ) ; simp_all +decide [ Subgroup.mem_prod ] ;
    · refine' ⟨ fun h hh => _ ⟩;
      intro g
      have := hN.conj_mem (1, h) (by
      exact ⟨ N_G.one_mem, hh ⟩) (1, g)
      simp_all +decide [ Subgroup.mem_prod ];
  -- By definition of coprimality, every normal subgroup of $G \times H$ is of the form $N \times M$ where $N$ is normal in $G$ and $M$ is normal in $H$. Therefore, we can rewrite the sum over normal subgroups of $G \times H$ as a double sum over normal subgroups of $G$ and $H$.
  have h_double_sum : ∑ N : { N : Subgroup (G × H) // N.Normal }, Nat.card ↥(↑N : Subgroup (G × H)) = ∑ N_G : { N : Subgroup G // N.Normal }, ∑ N_H : { N : Subgroup H // N.Normal }, Nat.card ↥(Subgroup.prod (↑N_G : Subgroup G) (↑N_H : Subgroup H)) := by
    have h_double_sum : Finset.image (fun (p : { N : Subgroup G // N.Normal } × { N : Subgroup H // N.Normal }) => Subgroup.prod (↑p.1 : Subgroup G) (↑p.2 : Subgroup H)) (Finset.univ : Finset ({ N : Subgroup G // N.Normal } × { N : Subgroup H // N.Normal })) = Finset.image (fun N : { N : Subgroup (G × H) // N.Normal } => (↑N : Subgroup (G × H))) (Finset.univ : Finset { N : Subgroup (G × H) // N.Normal }) := by
      ext N; simp [h_normal_subgroups];
      exact ⟨ fun ⟨ N_G, hN_G, N_H, hN_H, h ⟩ => h ▸ Subgroup.prod_normal N_G N_H, fun hN => by obtain ⟨ N_G, N_H, hN_G, hN_H, rfl ⟩ := h_normal_subgroups N hN; exact ⟨ N_G, hN_G, N_H, hN_H, rfl ⟩ ⟩;
    have h_double_sum : ∑ N ∈ Finset.image (fun (p : { N : Subgroup G // N.Normal } × { N : Subgroup H // N.Normal }) => Subgroup.prod (↑p.1 : Subgroup G) (↑p.2 : Subgroup H)) (Finset.univ : Finset ({ N : Subgroup G // N.Normal } × { N : Subgroup H // N.Normal })), Nat.card ↥N = ∑ N_G : { N : Subgroup G // N.Normal }, ∑ N_H : { N : Subgroup H // N.Normal }, Nat.card ↥(Subgroup.prod (↑N_G : Subgroup G) (↑N_H : Subgroup H)) := by
      rw [ Finset.sum_image ];
      · exact?;
      · intro p hp q hq h_eq; simp_all +decide [ Subgroup.ext_iff ] ;
        ext <;> simp_all +decide [ Subgroup.mem_prod ];
        · simpa using h_eq _ 1;
        · specialize h_eq 1; aesop;
    rw [ ← h_double_sum, ‹Finset.image ( fun p : { N : Subgroup G // N.Normal } × { N : Subgroup H // N.Normal } => ( p.1 : Subgroup G ).prod ( p.2 : Subgroup H ) ) Finset.univ = Finset.image ( fun N : { N : Subgroup ( G × H ) // N.Normal } => ( N : Subgroup ( G × H ) ) ) Finset.univ›, Finset.sum_image ] ; aesop;
  -- Since the orders of $G$ and $H$ are coprime, the order of the product of two subgroups is the product of their orders.
  have h_order_prod : ∀ (N_G : Subgroup G) (N_H : Subgroup H), Nat.card (↥(Subgroup.prod N_G N_H)) = Nat.card (↥N_G) * Nat.card (↥N_H) := by
    simp +decide [ Nat.card_eq_fintype_card, Fintype.card_subtype ];
    intro N_G N_H; rw [ ← Finset.card_product ] ; congr; ext ⟨ x, y ⟩ ; simp +decide [ Subgroup.mem_prod ] ;
  simp_all +decide only [Finset.sum_mul _ _ _];
  simp +decide only [Finset.mul_sum _ _ _]

/-
The sum of the orders of the normal subgroups of S3 is 10.
-/
theorem sum_card_normal_S3 :
    ∑ N : {N : Subgroup (Equiv.Perm (Fin 3)) // N.Normal}, Nat.card N = 10 := by
  -- List all normal subgroups of $S_3$ and their orders.
  have h_normal_subgroups : {N : Subgroup (Equiv.Perm (Fin 3)) | N.Normal} = {⊥, (Subgroup.closure {Equiv.swap 0 1 * Equiv.swap 1 2}), ⊤} := by
    ext N
    constructor;
    · intro hN
      have h_order : Fintype.card N = 1 ∨ Fintype.card N = 3 ∨ Fintype.card N = 6 := by
        have := Subgroup.card_subgroup_dvd_card N; simp_all +decide [ Nat.dvd_prime ] ;
        have : Fintype.card N ≤ 6 := Nat.le_of_dvd ( by decide ) this; interval_cases _ : Fintype.card N <;> simp_all +decide ;
        -- If $N$ has order 2, then it must be generated by an element of order 2.
        obtain ⟨g, hg⟩ : ∃ g : Equiv.Perm (Fin 3), g ∈ N ∧ orderOf g = 2 := by
          have := exists_prime_orderOf_dvd_card 2 ( by rw [ ‹Fintype.card N = 2› ] ) ; aesop;
        -- Since $N$ is normal, it must contain all conjugates of $g$.
        have h_conjugates : ∀ h : Equiv.Perm (Fin 3), h * g * h⁻¹ ∈ N := by
          exact fun h => hN.conj_mem _ hg.1 h;
        have h_conjugates_card : Finset.card (Finset.image (fun h : Equiv.Perm (Fin 3) => h * g * h⁻¹) Finset.univ) = 3 := by
          fin_cases g <;> simp +decide at hg ⊢;
          · simp_all +decide [ orderOf_eq_iff ];
          · simp_all +decide [ orderOf_eq_iff ];
        have h_conjugates_subset : Finset.image (fun h : Equiv.Perm (Fin 3) => h * g * h⁻¹) Finset.univ ⊆ Finset.image (fun x : ↥N => x.val) Finset.univ := by
          exact Finset.image_subset_iff.mpr fun h _ => Finset.mem_image.mpr ⟨ ⟨ h * g * h⁻¹, h_conjugates h ⟩, Finset.mem_univ _, rfl ⟩;
        exact h_conjugates_card.not_lt ( lt_of_le_of_lt ( Finset.card_le_card h_conjugates_subset ) ( by rw [ Finset.card_image_of_injective _ fun x y hxy => by aesop ] ; simp +decide [ * ] ) );
      rcases h_order with h | h | h <;> simp_all +decide [ Fintype.card_eq_one_iff, Subgroup.eq_bot_iff_forall, Subgroup.eq_top_iff' ];
      · exact Or.inl fun x hx => h.choose_spec.2 x hx ▸ h.choose_spec.2 1 ( N.one_mem ) ▸ rfl;
      · -- Since $N$ is a subgroup of $S_3$ with order 3, it must be cyclic and generated by a 3-cycle.
        have h_gen : ∃ g : Equiv.Perm (Fin 3), N = Subgroup.zpowers g ∧ orderOf g = 3 := by
          have h_cyclic : IsCyclic N := by
            exact isCyclic_of_prime_card ( by aesop );
          obtain ⟨ g, hg ⟩ := h_cyclic.exists_generator;
          refine' ⟨ g, _, _ ⟩;
          · ext x;
            exact ⟨ fun hx => by obtain ⟨ k, hk ⟩ := hg ⟨ x, hx ⟩ ; exact ⟨ k, by simpa [ Subtype.ext_iff ] using hk ⟩, fun hx => by obtain ⟨ k, hk ⟩ := hx; exact hk.symm ▸ Subgroup.zpow_mem _ g.2 _ ⟩;
          · have := orderOf_eq_card_of_forall_mem_zpowers hg; aesop;
        obtain ⟨ g, rfl, hg ⟩ := h_gen;
        fin_cases g <;> simp_all +decide [ orderOf_eq_iff ];
        · exact Or.inr <| Or.inl <| by rw [ Subgroup.zpowers_eq_closure ] ;
        · simp_all +decide [ Subgroup.zpowers_eq_closure ];
          refine Or.inr <| Or.inl <| le_antisymm ?_ ?_ <;> simp +decide [ Subgroup.closure_le, Set.singleton_subset_iff ];
          · simp +decide [ Subgroup.mem_closure_singleton ];
            exists 2;
          · rw [ Subgroup.mem_closure_singleton ];
            exists 2;
      · have := Subgroup.card_mul_index N; simp_all +decide ;
        simp_all +decide [ Fintype.card_perm ];
        simp_all +decide [ Nat.factorial ];
    · rintro ( rfl | rfl | rfl ) <;> constructor <;> simp +decide [ Subgroup.mem_closure_singleton ];
      intro a g;
      -- Since $(Equiv.swap 0 1 * Equiv.swap 1 2)$ is a 3-cycle, its powers cycle through the elements of $A_3$.
      have h_cycle : ∀ g : Equiv.Perm (Fin 3), ∃ n : ℤ, g * (Equiv.swap 0 1 * Equiv.swap 1 2) * g⁻¹ = (Equiv.swap 0 1 * Equiv.swap 1 2) ^ n := by
        intro g
        use if g * (Equiv.swap 0 1 * Equiv.swap 1 2) * g⁻¹ = Equiv.swap 0 1 * Equiv.swap 1 2 then 1 else if g * (Equiv.swap 0 1 * Equiv.swap 1 2) * g⁻¹ = (Equiv.swap 0 1 * Equiv.swap 1 2)⁻¹ then -1 else 0;
        fin_cases g <;> simp +decide;
      obtain ⟨ n, hn ⟩ := h_cycle g;
      use n * a;
      simp +decide [ zpow_mul, ← hn ];
  -- Substitute the list of normal subgroups into the sum.
  have h_sum : ∑ N : {N : Subgroup (Equiv.Perm (Fin 3)) // N.Normal}, Nat.card N = ∑ N ∈ ({⊥, (Subgroup.closure {Equiv.swap 0 1 * Equiv.swap 1 2}), ⊤} : Finset (Subgroup (Equiv.Perm (Fin 3)))), Nat.card N := by
    refine' Finset.sum_bij ( fun N _ => N.val ) _ _ _ _ <;> simp_all +decide [ Set.ext_iff ];
  rw [ h_sum, Finset.sum_insert, Finset.sum_insert ] <;> simp +decide;
  · rw [ show ( Subgroup.closure { Equiv.swap 0 1 * Equiv.swap 1 2 } : Subgroup ( Equiv.Perm ( Fin 3 ) ) ) = Subgroup.zpowers ( Equiv.swap 0 1 * Equiv.swap 1 2 ) by simp +decide [ Subgroup.zpowers_eq_closure ] ];
    simp +decide only [Fintype.card_zpowers];
    rw [ show orderOf ( Equiv.swap 0 1 * Equiv.swap 1 2 : Equiv.Perm ( Fin 3 ) ) = 3 by rw [ orderOf_eq_iff ] <;> decide ] ; rfl;
  · simp +decide [ Subgroup.eq_top_iff', Subgroup.mem_closure_singleton ];
    use Equiv.swap 0 1;
    intro x hx; replace hx := congr_arg Equiv.Perm.sign hx; simp_all +decide ;
  · simp +decide [ eq_comm, Subgroup.eq_top_iff' ];
    rw [ eq_comm, Subgroup.closure_eq_bot_iff ] ; simp +decide

/-
The sum of the orders of the normal subgroups of C5 is 6.
-/
theorem sum_card_normal_C5 :
    ∑ N : {N : Subgroup (Multiplicative (ZMod 5)) // N.Normal}, Nat.card N = 6 := by
  rw [ Finset.sum_eq_add_sum_diff_singleton <| Finset.mem_univ ⟨ ⊥, by infer_instance ⟩ ];
  rw [ Finset.sum_eq_single ⟨ ⊤, by infer_instance ⟩ ] <;> simp +decide;
  · intro a ha h; have := Subgroup.card_subgroup_dvd_card a; simp_all +decide [ Nat.dvd_prime ] ;
    cases this <;> simp_all +decide [ Fintype.card_eq_one_iff, Subgroup.eq_bot_iff_forall ];
    · rename_i h; rcases h with ⟨ x, hx₁, hx₂ ⟩ ; have := hx₂ 0 ( a.one_mem ) ; aesop;
    · exact Subgroup.eq_top_of_card_eq _ ( by aesop );
  · simp +decide [ Subgroup.eq_bot_iff_forall ]

/-
There exists a finite non-abelian Leinster group.
-/
theorem exists_nonabelian_leinster_group :
    ∃ G : Type, ∃ (_ : Group G) (_ : Fintype G),
      IsLeinster G ∧ ¬ ∀ (a b : G), a * b = b * a := by
        -- Let's choose the group G = S3 x C5.
        use G_leinster;
        refine ⟨ inferInstance, inferInstance, ?_, ?_ ⟩;
        · -- By definition of IsLeinster, we need to show that the sum of the orders of the normal subgroups of G_leinster is equal to twice the order of G_leinster.
          unfold IsLeinster;
          convert sum_card_normal_prod_eq_mul _ using 1;
          · rw [ sum_card_normal_S3, sum_card_normal_C5 ] ; norm_cast;
          · native_decide;
        · native_decide +revert