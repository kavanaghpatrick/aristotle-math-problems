/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7c5032b7-bca1-47b7-aa21-f0e1d03e4018

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For a positive integer n, a unitary divisor d of n satisfies d | n and gcd(d, n/d) = 1.
-/
def unitaryDivisors (n : ℕ) : Finset ℕ :=
  n.divisors.filter (fun d => n.gcd (n / d) == 1)

/-
The unitary divisor function σ*(n) = ∑ d where d ranges over unitary divisors of n.
n is unitary perfect if σ*(n) = 2n.
-/
def sigmaStar (n : ℕ) : ℕ :=
  (unitaryDivisors n).sum id

def isUnitaryPerfect (n : ℕ) : Prop :=
  sigmaStar n = 2 * n

/-
If a and b are coprime, then the unitary divisors of a * b are exactly the products of unitary divisors of a and unitary divisors of b.
-/
lemma unitaryDivisors_mul_of_coprime {a b : ℕ} (hab : a.Coprime b) :
  unitaryDivisors (a * b) = Finset.image (fun x : ℕ × ℕ => x.1 * x.2) (unitaryDivisors a ×ˢ unitaryDivisors b) := by
    -- To prove equality of finite sets, we show each set is a subset of the other.
    apply Finset.ext
    intro d
    simp [unitaryDivisors];
    constructor;
    · intro hd
      obtain ⟨hd_div, hd_coprime⟩ := hd;
      -- Since $d$ divides $a * b$ and $a$ and $b$ are coprime, $d$ can be written as $d = d_1 * d_2$ where $d_1$ divides $a$ and $d_2$ divides $b$.
      obtain ⟨d1, d2, hd1, hd2, hd_eq⟩ : ∃ d1 d2, d1 ∣ a ∧ d2 ∣ b ∧ d = d1 * d2 := by
        exact Exists.imp ( by aesop ) ( Nat.dvd_mul.mp hd_div.1 );
      -- Since $d$ is a unitary divisor of $a * b$, we have $\gcd(a * b, (a * b) / d) = 1$. Substituting $d = d1 * d2$, we get $\gcd(a * b, (a / d1) * (b / d2)) = 1$.
      have h_coprime : Nat.gcd (a * b) ((a / d1) * (b / d2)) = 1 := by
        convert hd_coprime using 2 ; rw [ hd_eq ] ; rw [ Nat.div_mul_div_comm ] <;> aesop;
      refine' ⟨ d1, d2, _, _ ⟩ <;> simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
    · intro h;
      rcases h with ⟨ x, y, h, rfl ⟩;
      rw [ Nat.mul_div_mul_comm h.1.1.1 h.2.1.1 ];
      simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, Nat.Coprime, Nat.Coprime.symm ];
      exact ⟨ mul_dvd_mul h.1.1.1 h.2.1.1, Nat.Coprime.coprime_dvd_right ( Nat.div_dvd_of_dvd h.1.1.1 ) ( Nat.Coprime.symm hab ), Nat.Coprime.coprime_dvd_right ( Nat.div_dvd_of_dvd h.2.1.1 ) hab ⟩

/-
If a and b are coprime, then σ*(a * b) = σ*(a) * σ*(b).
-/
lemma sigmaStar_mul_of_coprime {a b : ℕ} (hab : a.Coprime b) :
  sigmaStar (a * b) = sigmaStar a * sigmaStar b := by
    unfold sigmaStar;
    -- Apply the lemma that states the unitary divisors of a product of coprime numbers are the products of the unitary divisors of each number.
    have h_unitary_divisors : unitaryDivisors (a * b) = Finset.image (fun (x : ℕ × ℕ) => x.1 * x.2) (unitaryDivisors a ×ˢ unitaryDivisors b) := by
      exact?;
    rw [ h_unitary_divisors, Finset.sum_image, Finset.sum_product ];
    · simp +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul ];
    · intros x hx y hy hxy;
      -- Since $a$ and $b$ are coprime, if $x.1 \mid a$ and $y.1 \mid a$, then $x.1 = y.1$.
      have h1 : x.1 ∣ a ∧ y.1 ∣ a → x.1 = y.1 := by
        simp +zetaDelta at *;
        intro hx1 hy1; have := Nat.dvd_antisymm ( show x.1 ∣ y.1 from ?_ ) ( show y.1 ∣ x.1 from ?_ ) ; aesop;
        · exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( x.1 ) ( y.2 ) from Nat.Coprime.coprime_dvd_left hx1 <| Nat.Coprime.coprime_dvd_right ( show y.2 ∣ b from Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hy.2 |>.1 ) <| by simpa ) ) <| hxy.symm ▸ dvd_mul_right _ _;
        · exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( y.1 ) ( x.2 ) from Nat.Coprime.coprime_dvd_left hy1 <| Nat.Coprime.coprime_dvd_right ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hx.2 |>.1 ) hab ) ) <| hxy.symm ▸ dvd_mul_right _ _;
      simp_all +decide [ unitaryDivisors ];
      aesop

/-
Checking values of unitaryDivisors and sigmaStar for 4 and 2.
-/
#eval unitaryDivisors 4
#eval sigmaStar 4
#eval unitaryDivisors 2
#eval sigmaStar 2

/-
Corrected definitions:
For a positive integer n, a unitary divisor d of n satisfies d | n and gcd(d, n/d) = 1.
The unitary divisor function σ*(n) = ∑ d where d ranges over unitary divisors of n.
n is unitary perfect if σ*(n) = 2n.
-/
def unitary_divisors (n : ℕ) : Finset ℕ :=
  n.divisors.filter (fun d => Nat.gcd d (n / d) == 1)

def sigma_star (n : ℕ) : ℕ :=
  (unitary_divisors n).sum id

def is_unitary_perfect (n : ℕ) : Prop :=
  sigma_star n = 2 * n

/-
If a and b are coprime, then the unitary divisors of a * b are exactly the products of unitary divisors of a and unitary divisors of b.
-/
lemma unitary_divisors_mul_of_coprime {a b : ℕ} (hab : a.Coprime b) :
  unitary_divisors (a * b) = Finset.image (fun x : ℕ × ℕ => x.1 * x.2) (unitary_divisors a ×ˢ unitary_divisors b) := by
    unfold unitary_divisors;
    ext d;
    constructor;
    · intro hd;
      -- Since $d$ divides $a \cdot b$ and $\gcd(d, a \cdot b / d) = 1$, we can write $d = x \cdot y$ where $x$ divides $a$ and $y$ divides $b$.
      obtain ⟨x, y, hx, hy, hd_eq⟩ : ∃ x y, x ∣ a ∧ y ∣ b ∧ d = x * y := by
        exact Exists.imp ( by aesop ) ( Nat.dvd_mul.mp ( Nat.dvd_of_mem_divisors ( Finset.filter_subset _ _ hd ) ) );
      simp_all +decide [ Nat.mul_div_mul_comm hx hy ];
      refine' ⟨ x, y, ⟨ ⟨ hx, _ ⟩, hy, _ ⟩, rfl ⟩ <;> simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
    · simp +zetaDelta at *;
      rintro x y hx ha hx' hy hb hy' rfl; refine' ⟨ ⟨ mul_dvd_mul hx hy, ha, hb ⟩, _ ⟩ ; simp_all +decide [ Nat.mul_div_mul_comm hx hy ] ;
      apply_rules [ Nat.Coprime.mul_left, Nat.Coprime.symm ];
      · exact Nat.Coprime.coprime_dvd_left hx <| Nat.Coprime.coprime_dvd_right ( Nat.div_dvd_of_dvd hy ) hab;
      · rw [ Nat.coprime_mul_iff_right ];
        exact ⟨ Nat.Coprime.coprime_dvd_left hy <| Nat.Coprime.coprime_dvd_right ( Nat.div_dvd_of_dvd hx ) <| by simpa [ Nat.coprime_comm ] using hab, hy' ⟩

/-
If a and b are coprime, then σ*(a * b) = σ*(a) * σ*(b).
-/
lemma sigma_star_mul_of_coprime {a b : ℕ} (hab : a.Coprime b) :
  sigma_star (a * b) = sigma_star a * sigma_star b := by
    -- Apply the multiplicativity of the unitary divisor function.
    have h_unitary_multiplicative : ∀ {a b : ℕ}, a.Coprime b → (unitary_divisors (a * b)).sum id = (unitary_divisors a).sum id * (unitary_divisors b).sum id := by
      intros a b hab
      have h_unitary_divisors_mul : unitary_divisors (a * b) = Finset.image (fun (x : ℕ × ℕ) => x.1 * x.2) (unitary_divisors a ×ˢ unitary_divisors b) := by
        exact?;
      rw [ h_unitary_divisors_mul, Finset.sum_image, Finset.sum_product ];
      · simp +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul ];
      · intros x hx y hy hxy;
        -- Since $a$ and $b$ are coprime, if $x.1 \mid a$ and $y.1 \mid a$, then $x.1 = y.1$.
        have h1 : x.1 ∣ a ∧ y.1 ∣ a → x.1 = y.1 := by
          simp +zetaDelta at *;
          intro hx1 hy1; have := Nat.dvd_antisymm ( show x.1 ∣ y.1 from ?_ ) ( show y.1 ∣ x.1 from ?_ ) ; aesop;
          · exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( x.1 ) ( y.2 ) from Nat.Coprime.coprime_dvd_left hx1 <| Nat.Coprime.coprime_dvd_right ( show y.2 ∣ b from Nat.dvd_of_mem_divisors <| Finset.filter_subset _ _ hy.2 ) hab ) ) <| hxy.symm ▸ dvd_mul_right _ _;
          · exact ( Nat.Coprime.dvd_of_dvd_mul_right ( show Nat.Coprime ( y.1 ) ( x.2 ) from Nat.Coprime.coprime_dvd_left hy1 <| Nat.Coprime.coprime_dvd_right ( Nat.dvd_of_mem_divisors <| Finset.mem_filter.mp hx.2 |>.1 ) hab ) ) <| hxy.symm ▸ dvd_mul_right _ _;
        unfold unitary_divisors at hx hy; aesop;
    exact h_unitary_multiplicative hab

/-
For a prime power p^k with k ≥ 1, the unitary divisors are {1, p^k}.
-/
lemma unitary_divisors_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≠ 0) :
  unitary_divisors (p ^ k) = {1, p ^ k} := by
    simp +decide [ unitary_divisors, hp ];
    ext d;
    constructor <;> intro H <;> simp_all +decide [ Nat.divisors_prime_pow ];
    · rcases H with ⟨ ⟨ a, ha, rfl ⟩, hgcd ⟩ ; rcases a with ( _ | a ) <;> simp_all +decide [ Nat.pow_succ' ] ;
      rw [ show p ^ k / ( p * p ^ a ) = p ^ ( k - a - 1 ) from ?_ ] at hgcd;
      · rcases x : k - a - 1 with ( _ | _ | k ) <;> simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
        exact Or.inr ( by rw [ show k = a + 1 by omega ] ; ring );
      · rw [ Nat.div_eq_of_eq_mul_left ];
        · exact mul_pos hp.pos ( pow_pos hp.pos _ );
        · rw [ show k = k - a - 1 + a + 1 by omega, pow_add, pow_add ] ; ring;
          grind;
    · rcases H with ( rfl | rfl ) <;> [ exact ⟨ ⟨ 0, Nat.zero_lt_succ _, rfl ⟩, by norm_num ⟩ ; exact ⟨ ⟨ k, Nat.lt_succ_self _, rfl ⟩, by norm_num [ Nat.div_self ( pow_pos hp.pos _ ) ] ⟩ ] ;

/-
For a prime power p^k with k ≥ 1, σ*(p^k) = 1 + p^k.
-/
lemma sigma_star_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≠ 0) :
  sigma_star (p ^ k) = 1 + p ^ k := by
    convert Finset.sum_pair ?_ using 1;
    convert congr_arg ( fun s => s.sum id ) ( unitary_divisors_prime_pow hp hk ) using 1;
    · rfl;
    · exact ne_of_lt ( one_lt_pow₀ hp.one_lt hk )

/-
If n is a unitary perfect number with n = 2^k * m where m is odd, then (1 + 2^k) | m.
-/
theorem power_of_two_divisor_lemma (n k m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^k * m) (h_perf : is_unitary_perfect n) :
  1 + 2^k ∣ m := by
    -- Since $n$ is unitary perfect, we have $\sigma^*(n) = 2n$. Using the multiplicative property of $\sigma^*$, we get $\sigma^*(n) = \sigma^*(2^k) \cdot \sigma^*(m)$.
    have h_sigma_mul : sigma_star n = (1 + 2^k) * sigma_star m := by
      rw [ h_eq, sigma_star_mul_of_coprime ];
      · cases k <;> simp_all +decide [ sigma_star_prime_pow ];
        -- Since $m$ is odd, we can write $m = \prod_{i=1}^k p_i^{e_i}$ where $p_i$ are distinct odd primes and $e_i \geq 1$.
        obtain ⟨f, hf⟩ : ∃ f : Finset ℕ, (∀ p ∈ f, Nat.Prime p ∧ p ∣ m) ∧ m = ∏ p ∈ f, p ^ (Nat.factorization m p) := by
          exact ⟨ m.primeFactors, fun p hp => ⟨ Nat.prime_of_mem_primeFactors hp, Nat.dvd_of_mem_primeFactors hp ⟩, Eq.symm <| Nat.factorization_prod_pow_eq_self hn ⟩;
        -- Using the multiplicative property of $\sigma^*$, we get $\sigma^*(m) = \prod_{p \in f} \sigma^*(p^{e_p})$.
        have h_sigma_mul : sigma_star m = ∏ p ∈ f, sigma_star (p ^ (Nat.factorization m p)) := by
          have h_sigma_mul : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → sigma_star (∏ p ∈ S, p ^ (Nat.factorization m p)) = ∏ p ∈ S, sigma_star (p ^ (Nat.factorization m p)) := by
            intro S hS; induction S using Finset.induction <;> norm_num at *;
            · native_decide +revert;
            · rw [ Finset.prod_insert ‹_›, sigma_star_mul_of_coprime ];
              · rw [ Finset.prod_insert ‹_›, ‹ ( ∀ p ∈ _, Nat.Prime p ) → sigma_star ( ∏ p ∈ _, p ^ ( m.factorization p ) ) = ∏ p ∈ _, sigma_star ( p ^ ( m.factorization p ) ) › hS.2 ];
              · refine' Nat.Coprime.prod_right fun p hp => _;
                exact Nat.coprime_pow_primes _ _ hS.1 ( hS.2 p hp ) ( by rintro rfl; exact ‹¬_› hp );
          rw [ ← h_sigma_mul fun p hp => hf.1 p hp |>.1, ← hf.2 ];
        -- Since $p$ is odd, we have $\sigma^*(p^{e_p}) = 1 + p^{e_p}$.
        have h_sigma_odd : ∀ p ∈ f, sigma_star (p ^ (Nat.factorization m p)) = 1 + p ^ (Nat.factorization m p) := by
          intro p hp; specialize hf; rcases eq_or_ne ( Nat.factorization m p ) 0 with h | h <;> simp +decide [ h, sigma_star_prime_pow, hf.1 p hp ] ;
          simp +decide [ Nat.factorization_eq_zero_iff, hf.1 p hp ] at h;
          contradiction;
        -- Since $m$ is odd, each term $1 + p^{e_p}$ is even, and thus the product $\prod_{p \in f} (1 + p^{e_p})$ is divisible by $2^{|f|}$.
        have h_div : 2 ^ f.card ∣ ∏ p ∈ f, (1 + p ^ (Nat.factorization m p)) := by
          have h_div : ∀ p ∈ f, 2 ∣ (1 + p ^ (Nat.factorization m p)) := by
            intro p hp; rw [ ← even_iff_two_dvd ] ; simp +decide [ hm, parity_simps ] ;
            exact fun h => absurd ( hm.of_dvd_nat ( hf.1 p hp |>.2 ) ) ( by simp +decide [ h, parity_simps ] );
          exact dvd_trans ( by norm_num ) ( Finset.prod_dvd_prod_of_dvd _ _ h_div );
        -- Since $m$ is odd, we have $2^{|f|} \mid 2m$, which implies $|f| \leq 1$.
        have h_card : f.card ≤ 1 := by
          have h_card : 2 ^ f.card ∣ 2 * m := by
            convert h_div using 1;
            rw [ ← h_perf, h_sigma_mul, Finset.prod_congr rfl h_sigma_odd ];
          contrapose! h_card;
          rw [ Nat.Prime.pow_dvd_iff_le_factorization ] <;> norm_num;
          · rw [ Nat.factorization_mul ] <;> norm_num [ hn ];
            rw [ Nat.factorization_eq_zero_of_not_dvd ] <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.odd_iff.mp hm ] ; linarith;
          · exact hn;
        rcases f with ⟨ ⟨ p, hp ⟩ ⟩ <;> norm_num at *;
        · unfold is_unitary_perfect at h_perf; aesop;
        · norm_num [ h_card ] at *;
          unfold is_unitary_perfect at h_perf; norm_num [ h_sigma_odd ] at h_perf;
          norm_num [ show ( ‹_› : ℕ ) ^ ( m.factorization ‹_› ) = 1 by linarith ] at *;
          aesop ( simp_config := { singlePass := true } );
      · cases k <;> cases hm <;> aesop;
    -- Since $2^{k+1} \cdot m$ is equal to $(1 + 2^k) \cdot \sigma^*(m)$, and $1 + 2^k$ is coprime with $2^{k+1}$, it must divide $m$.
    have h_div : (1 + 2^k) ∣ (2^(k+1) * m) := by
      exact ⟨ sigma_star m, by ring_nf at *; linarith [ h_perf.symm ] ⟩;
    refine' Nat.Coprime.dvd_of_dvd_mul_left _ h_div;
    rcases k with ( _ | k ) <;> simp_all +decide [ parity_simps ];
    linarith [ show 0 < sigma_star m from Finset.sum_pos ( fun x hx => Nat.pos_of_mem_divisors ( Finset.mem_filter.mp hx |>.1 ) ) ⟨ 1, Finset.mem_filter.mpr ⟨ Nat.one_mem_divisors.mpr hn, by norm_num ⟩ ⟩ ]

/-
If n = 2^k * m is unitary perfect, then σ*(m)/m = 2^{k+1}/(1 + 2^k).
-/
theorem ratio_constraint (n k m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^k * m) (h_perf : is_unitary_perfect n) :
  (sigma_star m : ℚ) / m = (2^(k+1) : ℚ) / (1 + 2^k) := by
    have h_sigma_star_eq : (sigma_star (2^k * m) : ℚ) = (1 + 2^k) * sigma_star m := by
      convert congr_arg ( ( ↑ ) : ℕ → ℚ ) ( sigma_star_mul_of_coprime ( show Nat.Coprime ( 2 ^ k ) m from ?_ ) ) using 1;
      · rcases k with ( _ | k ) <;> simp_all +decide [ sigma_star_prime_pow ];
        unfold sigma_star; norm_num;
        norm_num [ unitary_divisors ];
        norm_num [ Finset.sum_filter ];
        intro i hi hm₁ hm₂; have := Nat.gcd_dvd_left i ( m / i ) ; have := Nat.gcd_dvd_right i ( m / i ) ; simp_all +decide [ Nat.dvd_prime ] ;
        obtain ⟨ k, hk ⟩ := hi; simp_all +decide [ Nat.gcd_mul_left, Nat.gcd_mul_right ] ;
        have := power_of_two_divisor_lemma ( i * k ) 0 ( i * k ) ; simp_all +decide [ is_unitary_perfect ];
        grind;
      · cases k <;> cases hm <;> aesop;
    rw [ div_eq_div_iff ] <;> norm_cast at * <;> simp_all +decide [ is_unitary_perfect ] ; ring_nf at * ; aesop;

/-
If n = 2^k * m is unitary perfect with m odd, then (4/3)^ω(m) ≥ 2^{k+1}/(1+2^k).
-/
theorem prime_factors_bound (n k m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^k * m) (h_perf : is_unitary_perfect n) :
  (2^(k+1) : ℚ) / (1 + 2^k) ≤ (4/3) ^ m.primeFactors.card := by
    -- We know σ*(m)/m = ∏ (1 + 1/p^a) where the product is over prime power unitary divisors of m.
    have h_sigma_star_div_m : (sigma_star m : ℚ) / m = ∏ p ∈ m.primeFactors, (1 + 1 / (p ^ (Nat.factorization m p) : ℚ)) := by
      -- By definition of sigma_star, we know that σ*(m) = ∏ (1 + p^a) where the product is over prime power unitary divisors of m.
      have h_sigma_star_def : (sigma_star m : ℚ) = ∏ p ∈ m.primeFactors, (1 + p ^ (Nat.factorization m p)) := by
        -- Applying the multiplicative property of $\sigma^*$ to $m$, we get $\sigma^*(m) = \prod_{p | m} \sigma^*(p^{v_p(m)})$.
        have h_sigma_star_prod : sigma_star m = ∏ p ∈ m.primeFactors, sigma_star (p ^ (Nat.factorization m p)) := by
          -- Applying the multiplicative property of $\sigma^*$ to $m$, we get $\sigma^*(m) = \prod_{p | m} \sigma^*(p^{v_p(m)})$ by definition of $sigma_star$.
          have h_sigma_star_prod : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → sigma_star (∏ p ∈ S, p ^ (Nat.factorization m p)) = ∏ p ∈ S, sigma_star (p ^ (Nat.factorization m p)) := by
            intros S hS_prime
            induction' S using Finset.induction with p S hS ih;
            · unfold sigma_star; aesop;
            · rw [ Finset.prod_insert hS, sigma_star_mul_of_coprime ];
              · rw [ Finset.prod_insert hS, ih fun q hq => hS_prime q <| Finset.mem_insert_of_mem hq ];
              · exact Nat.Coprime.prod_right fun q hq => Nat.Coprime.pow _ _ <| Nat.Coprime.symm <| Nat.Prime.coprime_iff_not_dvd ( hS_prime q <| Finset.mem_insert_of_mem hq ) |>.2 fun hq' => hS <| by have := Nat.prime_dvd_prime_iff_eq ( hS_prime q <| Finset.mem_insert_of_mem hq ) ( hS_prime p <| Finset.mem_insert_self p S ) ; aesop;
          convert h_sigma_star_prod fun p hp => Nat.prime_of_mem_primeFactors hp;
          exact Eq.symm ( Nat.factorization_prod_pow_eq_self hm.pos.ne' );
        rw [ h_sigma_star_prod ];
        exact congr_arg _ ( Finset.prod_congr rfl fun p hp => by rw [ sigma_star_prime_pow ( Nat.prime_of_mem_primeFactors hp ) ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) ) ] );
      -- By definition of $m$, we know that $m = \prod_{p \in m.primeFactors} p^{Nat.factorization m p}$.
      have h_m_def : (m : ℚ) = ∏ p ∈ m.primeFactors, (p : ℚ) ^ (Nat.factorization m p) := by
        exact mod_cast Eq.symm ( Nat.factorization_prod_pow_eq_self hm.pos.ne' );
      field_simp;
      rw [ h_sigma_star_def, h_m_def, Nat.cast_prod, Finset.prod_div_distrib ] ; norm_num [ add_comm ];
    -- For each odd prime factor p of m, let p^a || m. Then 1 + 1/p^a ≤ 1 + 1/3 = 4/3 because p ≥ 3 and a ≥ 1.
    have h_bound : ∏ p ∈ m.primeFactors, (1 + 1 / (p ^ (Nat.factorization m p) : ℚ)) ≤ (4 / 3 : ℚ) ^ m.primeFactors.card := by
      refine' le_trans ( Finset.prod_le_prod _ fun p hp => show ( 1 + 1 / ( p : ℚ ) ^ ( m.factorization p ) ) ≤ 4 / 3 from _ ) _ <;> norm_num;
      · exact fun _ _ _ _ => by positivity;
      · -- Since $p$ is an odd prime factor of $m$, we have $p \geq 3$.
        have hp_ge_3 : 3 ≤ p := by
          exact lt_of_le_of_ne ( Nat.Prime.two_le ( Nat.prime_of_mem_primeFactors hp ) ) ( Ne.symm <| by rintro rfl; exact absurd ( hm.of_dvd_nat <| Nat.dvd_of_mem_primeFactors hp ) ( by norm_num ) );
        nlinarith only [ show ( p : ℚ ) ≥ 3 by norm_cast, inv_mul_cancel₀ ( show ( p : ℚ ) ^ ( m.factorization p ) ≠ 0 by positivity ), pow_le_pow_right₀ ( show ( p : ℚ ) ≥ 1 by norm_cast; linarith ) ( show m.factorization p ≥ 1 by exact Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) ];
      · rw [ div_pow ];
    have := ratio_constraint n k m hn hm h_eq h_perf; norm_cast at *; aesop;

/-
If n = 2^k * m is unitary perfect with m odd, then k ≥ 1.
-/
theorem lower_bound_on_k (n k m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^k * m) (h_perf : is_unitary_perfect n) :
  1 ≤ k := by
    -- If $k = 0$, then $n = m$ is odd. Since $n$ is unitary perfect, $\sigma^*(n) = 2n$.
    by_cases hk_zero : k = 0;
    · -- Since $m$ is odd and unitary perfect, we have $2^{\omega(m)} \mid \sigma^*(m)$.
      have h_div : 2 ^ m.primeFactors.card ∣ sigma_star m := by
        -- Since $m$ is odd and unitary perfect, we have $\sigma^*(m) = \prod_{p \mid m} (1 + p^{v_p(m)})$.
        have h_sigma_star_prod : sigma_star m = ∏ p ∈ m.primeFactors, (1 + p ^ (Nat.factorization m p)) := by
          have h_sigma_star_prod : sigma_star m = (∏ p ∈ m.primeFactors, sigma_star (p ^ (Nat.factorization m p))) := by
            -- Applying the multiplicative property of $\sigma^*$ to the prime factorization of $m$.
            have h_sigma_star_factorization : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → sigma_star (∏ p ∈ S, p ^ (Nat.factorization m p)) = ∏ p ∈ S, sigma_star (p ^ (Nat.factorization m p)) := by
              intros S hS_prime
              induction' S using Finset.induction with p S hS ih;
              · unfold sigma_star; aesop;
              · rw [ Finset.prod_insert hS, sigma_star_mul_of_coprime ];
                · rw [ Finset.prod_insert hS, ih fun q hq => hS_prime q ( Finset.mem_insert_of_mem hq ) ];
                · exact Nat.Coprime.prod_right fun q hq => Nat.Coprime.pow _ _ <| by have := Nat.coprime_primes ( hS_prime p <| Finset.mem_insert_self p S ) ( hS_prime q <| Finset.mem_insert_of_mem hq ) ; aesop;
            convert h_sigma_star_factorization fun p hp => Nat.prime_of_mem_primeFactors hp;
            exact Eq.symm ( Nat.factorization_prod_pow_eq_self hm.pos.ne' );
          convert h_sigma_star_prod using 2;
          rename_i p hp;
          rw [ sigma_star_prime_pow ( Nat.prime_of_mem_primeFactors hp ) ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) ) ];
        -- Since each term $(1 + p^{v_p(m)})$ is even, their product is divisible by $2^{\omega(m)}$.
        have h_even_terms : ∀ p ∈ m.primeFactors, Even (1 + p ^ (Nat.factorization m p)) := by
          intro p hp; simp_all +decide [ parity_simps ] ;
          exact fun h => absurd ( hm.of_dvd_nat hp.2 ) ( by simp +decide [ h, hp.1.even_iff ] );
        exact h_sigma_star_prod.symm ▸ dvd_trans ( by norm_num ) ( Finset.prod_dvd_prod_of_dvd _ _ fun p hp => even_iff_two_dvd.mp ( h_even_terms p hp ) );
      -- Since $m$ is odd and unitary perfect, we have $2^{\omega(m)} \mid 2m$.
      have h_div_2m : 2 ^ m.primeFactors.card ∣ 2 * m := by
        unfold is_unitary_perfect at h_perf; aesop;
      -- Since $m$ is odd, we have $\gcd(2^{\omega(m)}, m) = 1$, so $2^{\omega(m)} \mid 2$.
      have h_div_2 : 2 ^ m.primeFactors.card ∣ 2 := by
        refine' Nat.Coprime.dvd_of_dvd_mul_right _ h_div_2m;
        exact Nat.Coprime.pow_left _ ( Nat.prime_two.coprime_iff_not_dvd.mpr <| by simpa [ ← even_iff_two_dvd ] using hm );
      -- Since $2^{\omega(m)} \mid 2$, we have $\omega(m) \leq 1$.
      have h_omega_le_1 : m.primeFactors.card ≤ 1 := by
        exact le_of_not_gt fun h => absurd ( dvd_trans ( pow_dvd_pow _ h ) h_div_2 ) ( by norm_num );
      cases h_omega_le_1.eq_or_lt <;> simp_all +decide [ is_unitary_perfect ];
      -- If $m$ has exactly one prime factor $p$, then $m = p^a$ for some $a$.
      obtain ⟨p, a, hp, ha⟩ : ∃ p a : ℕ, Nat.Prime p ∧ m = p^a := by
        rw [ Finset.card_eq_one ] at *;
        rw [ ← Nat.factorization_prod_pow_eq_self hn ];
        rcases ‹_› with ⟨ p, hp ⟩ ; exact ⟨ p, m.factorization p, Nat.prime_of_mem_primeFactors <| hp.symm ▸ Finset.mem_singleton_self _, by rw [ Finsupp.prod ] ; aesop ⟩ ;
      rcases a with ( _ | _ | a ) <;> simp_all +decide [ Nat.primeFactors_pow ];
      · unfold sigma_star at h_perf; simp_all +decide [ Finset.sum_filter, Finset.sum_range_succ' ] ;
        unfold unitary_divisors at h_perf; simp_all +decide [ Finset.sum_filter, Finset.sum_range_succ' ] ;
        rcases p with ( _ | _ | p ) <;> simp_all +arith +decide [ Nat.div_self hp.pos ];
      · have := sigma_star_prime_pow hp ( Nat.succ_ne_zero ( Nat.succ a ) ) ; simp_all +decide [ pow_succ' ];
        nlinarith [ Nat.Prime.one_lt hp, pow_pos hp.pos a, pow_pos hp.pos 2 ];
    · exact Nat.pos_of_ne_zero hk_zero

/-
The numbers 6, 60, 90, and 87360 are unitary perfect.
-/
theorem unitary_perfect_examples :
  is_unitary_perfect 6 ∧ is_unitary_perfect 60 ∧ is_unitary_perfect 90 ∧ is_unitary_perfect 87360 := by
    unfold is_unitary_perfect; native_decide;

/-
If z is odd, A is odd, B is even, and σ*(z)/z = A/B, then we have a contradiction.
-/
lemma sigma_star_ratio_parity_contradiction (z A B : ℕ) (hz_odd : Odd z) (hA_odd : Odd A) (hB_even : Even B) (h_ratio : sigma_star z * B = z * A) : False := by
  apply_fun Even at h_ratio; simp_all +decide [ parity_simps ] ;
  grind

/-
For any positive integer n, σ*(n)/n ≥ 1.
-/
lemma sigma_star_div_self_ge_one (n : ℕ) (hn : n ≠ 0) :
  (sigma_star n : ℚ) / n ≥ 1 := by
    -- The sum of all divisors of n is at least n, and since unitary divisors are a subset of divisors, their sum is also at least n.
    have h_sum_divisors : (sigma_star n : ℚ) ≥ n := by
      norm_num [ sigma_star ];
      rw [ ← Nat.cast_sum, Finset.sum_eq_add_sum_diff_singleton ( show n ∈ unitary_divisors n from ?_ ) ] ; norm_num [ hn ];
      · exact Finset.sum_nonneg fun _ _ => Nat.cast_nonneg _;
      · -- Since $n$ divides itself and $\gcd(n, n/n) = \gcd(n, 1) = 1$, $n$ is a unitary divisor of itself.
        simp [unitary_divisors, hn];
        rw [ Nat.div_self ( Nat.pos_of_ne_zero hn ), Nat.gcd_one_right ];
    rwa [ ge_iff_le, one_le_div ( by positivity ) ]

/-
For any positive integer n, σ*(n)/n = 1 if and only if n = 1.
-/
lemma sigma_star_div_self_eq_one (n : ℕ) (hn : n ≠ 0) :
  (sigma_star n : ℚ) / n = 1 ↔ n = 1 := by
    rw [ div_eq_iff ] <;> norm_cast;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Finset.sum_range_succ' ];
    refine' ne_of_gt _;
    refine' lt_of_lt_of_le _ ( Finset.sum_le_sum_of_subset _ );
    rotate_left;
    exact { 1, n + 1 + 1 };
    · simp +decide [ Finset.insert_subset_iff, unitary_divisors ];
    · simp +arith +decide

/-
If 3 * σ*(m) = 4 * m, then 3 divides m.
-/
lemma m_div_3_of_ratio_4_3 (m : ℕ) (h : 3 * sigma_star m = 4 * m) : 3 ∣ m := by
  omega

/-
If m = 3^k * x with k ≥ 1 and gcd(x, 3) = 1, and σ*(m)/m = 4/3, then (1+3^k)σ*(x) = 4 * 3^(k-1) * x.
-/
lemma sigma_star_x_eq (k x : ℕ) (hk : k ≥ 1) (hx : Nat.Coprime x 3) (h_ratio : 3 * sigma_star (3^k * x) = 4 * (3^k * x)) :
  (1 + 3^k) * sigma_star x = 4 * 3^(k-1) * x := by
    -- By definition of $sigma_star$, we have $\sigma^*(3^k * x) = (1 + 3^k) * \sigma^*(x)$ since $x$ is coprime to $3$.
    have h_sigma_def : sigma_star (3^k * x) = (1 + 3^k) * sigma_star x := by
      convert sigma_star_mul_of_coprime _ using 1;
      · rw [ sigma_star_prime_pow ] <;> norm_num;
        linarith;
      · exact Nat.Coprime.pow_left _ hx.symm;
    cases k <;> norm_num [ pow_succ' ] at * ; linarith

/-
If x is odd and σ*(x)/x = 6/5, then x = 5.
-/
lemma sigma_star_ratio_six_fifths (x : ℕ) (hx_odd : Odd x) (h_ratio : sigma_star x * 5 = x * 6) :
  x = 5 := by
    -- Since $x$ is odd and $x \mid 5 \cdot \sigma^*(x)$, it must be that $x = 5^k \cdot y$ where $y$ is coprime to 5.
    obtain ⟨k, y, hk, hy, hxy⟩ : ∃ k y, x = 5 ^ k * y ∧ Nat.Coprime y 5 ∧ k ≥ 1 := by
      by_cases h5 : 5 ∣ x;
      · use Nat.factorization x 5, x / 5 ^ Nat.factorization x 5;
        exact ⟨ Eq.symm ( Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ), Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 <| Nat.not_dvd_ordCompl ( by decide ) <| by aesop ), Nat.pos_of_ne_zero <| fun h => by simp_all +decide [ Nat.factorization_eq_zero_iff ] ⟩;
      · grind;
    -- From the equation $(1 + 5^k) * \sigma^*(y) = 6 * 5^{k-1} * y$, we know that $\sigma^*(y)$ is odd.
    have h_sigma_y_odd : Odd (sigma_star y) := by
      -- Applying the lemma sigma_star_x_eq, we get $(1 + 5^k) * \sigma^*(y) = 6 * 5^{k-1} * y$.
      have h_sigma_y : (1 + 5 ^ k) * sigma_star y = 6 * 5 ^ (k - 1) * y := by
        -- Using the multiplicative property of $\sigma^*$, we have $\sigma^*(x) = \sigma^*(5^k) \cdot \sigma^*(y)$.
        have h_sigma_star_mul : sigma_star x = sigma_star (5^k) * sigma_star y := by
          convert sigma_star_mul_of_coprime _ using 1 ; aesop
          generalize_proofs at *; (
          exact Nat.Coprime.pow_left _ hy.symm);
        -- Using the formula for $\sigma^*(5^k)$, we have $\sigma^*(5^k) = 1 + 5^k$.
        have h_sigma_star_5k : sigma_star (5^k) = 1 + 5^k := by
          convert sigma_star_prime_pow ( by norm_num : Nat.Prime 5 ) ( by linarith : k ≠ 0 ) using 1;
        cases k <;> simp_all +decide [ pow_succ' ] ; linarith;
      replace h_sigma_y := congr_arg ( · % 4 ) h_sigma_y ; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at h_sigma_y;
      grind;
    -- If $y > 1$, let $p$ be a prime factor of $y$. Then $p$ is odd.
    by_cases hy_gt_one : y > 1;
    · -- Let $p$ be a prime factor of $y$. Then $p$ is odd.
      obtain ⟨p, hp⟩ : ∃ p, Nat.Prime p ∧ p ∣ y ∧ p ≠ 2 := by
        obtain ⟨ p, hp₁, hp₂ ⟩ := Nat.exists_prime_and_dvd hy_gt_one.ne';
        exact ⟨ p, hp₁, hp₂, by rintro rfl; exact absurd ( hx_odd.of_dvd_nat ( hk.symm ▸ dvd_mul_of_dvd_right hp₂ _ ) ) ( by norm_num ) ⟩;
      -- Since $p$ is a prime factor of $y$, we have $(1 + p^k) \mid \sigma^*(y)$.
      have h_div : (1 + p ^ (Nat.factorization y p)) ∣ sigma_star y := by
        have h_div : sigma_star y = sigma_star (p ^ (Nat.factorization y p)) * sigma_star (y / p ^ (Nat.factorization y p)) := by
          rw [ ← sigma_star_mul_of_coprime ];
          · rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ];
          · exact Nat.Coprime.pow_left _ ( hp.1.coprime_iff_not_dvd.mpr <| Nat.not_dvd_ordCompl ( by aesop ) <| by aesop );
        simp_all +decide [ sigma_star_prime_pow ];
        exact dvd_mul_of_dvd_left ( by rw [ sigma_star_prime_pow hp.1 ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by aesop ) ) ) ) ] ) _;
      replace h_div := h_div.even; simp_all +decide [ parity_simps ] ;
      exact absurd ( h_div fun h => absurd ( hp.1.even_iff.mp h ) hp.2.2 ) ( by simpa using h_sigma_y_odd );
    · interval_cases y <;> simp_all +decide;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ' ];
      rw [ show 5 * ( 5 * 5 ^ k ) = 5 ^ ( k + 2 ) by ring, sigma_star_prime_pow ] at h_ratio <;> norm_num at *;
      grind

/-
If x is odd and σ*(x)/x = 6/5, then x = 5.
-/
lemma sigma_star_ratio_six_fifths_v2 (x : ℕ) (hx_odd : Odd x) (h_ratio : sigma_star x * 5 = x * 6) :
  x = 5 := by
    exact?

/-
If x is odd and σ*(x)/x = 6/5, then x = 5.
-/
lemma sigma_star_ratio_six_fifths_v3 (x : ℕ) (hx_odd : Odd x) (h_ratio : sigma_star x * 5 = x * 6) :
  x = 5 := by
    exact?

/-
For an odd integer n, σ*(n) is odd if and only if n = 1.
-/
lemma sigma_star_odd_iff_eq_one (n : ℕ) (hn : Odd n) :
  Odd (sigma_star n) ↔ n = 1 := by
    by_cases h : n = 1 <;> simp_all +decide [ Nat.even_iff ];
    -- Since n is odd and greater than 1, there exists a prime factor p of n such that p^k || n for some k ≥ 1.
    obtain ⟨p, k, hp, hk⟩ : ∃ p k, Nat.Prime p ∧ k ≥ 1 ∧ p^k ∣ n ∧ ¬p^(k+1) ∣ n := by
      exact ⟨ Nat.minFac n, Nat.factorization n ( Nat.minFac n ), Nat.minFac_prime h, Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( Nat.mem_primeFactors.mpr ⟨ Nat.minFac_prime h, Nat.minFac_dvd n, by aesop ⟩ ) ), Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd hn.pos.ne' ( Nat.minFac_prime h ) ⟩;
    -- Since $p^k$ divides $n$ and $p$ is odd, we have $\sigma^*(n) = \sigma^*(p^k) \cdot \sigma^*(n/p^k)$.
    have h_sigma_star_factor : sigma_star n = sigma_star (p^k) * sigma_star (n / p^k) := by
      rw [ ← sigma_star_mul_of_coprime ];
      · rw [ Nat.mul_div_cancel' hk.2.1 ];
      · exact Nat.Coprime.pow_left _ ( hp.coprime_iff_not_dvd.mpr fun h => hk.2.2 <| by convert Nat.mul_dvd_mul_left ( p ^ k ) h using 1; rw [ Nat.mul_div_cancel' hk.2.1 ] );
    -- Since $p$ is odd, we have $\sigma^*(p^k) = 1 + p^k$, which is even.
    have h_sigma_star_pk_even : sigma_star (p^k) % 2 = 0 := by
      rw [ sigma_star_prime_pow hp ( by linarith ) ] ; norm_num [ Nat.add_mod, Nat.pow_mod, hp.eq_two_or_odd.resolve_left ];
      cases Nat.Prime.eq_two_or_odd hp <;> simp_all +decide [ Nat.even_iff ];
      exact absurd ( even_iff_two_dvd.mpr ( dvd_trans ( dvd_pow_self _ ( by linarith ) ) hk.2.1 ) ) ( by simpa using hn );
    norm_num [ h_sigma_star_factor, Nat.mul_mod, h_sigma_star_pk_even ]

/-
For k ≥ 3, the equation (1 + 3^k) * σ*(x) = 4 * 3^(k-1) * x has no solution for odd x.
-/
lemma no_solution_for_k_ge_3 (k x : ℕ) (hk : k ≥ 3) (hx_odd : Odd x) (h_eq : (1 + 3^k) * sigma_star x = 4 * 3^(k-1) * x) : False := by
  -- Since $x$ is odd, if $x$ has at least two distinct prime factors, $\sigma^*(x)$ would be divisible by 4 (product of two even numbers).
  by_cases h_prime_factors : (Nat.factorization x).support.card ≥ 2;
  · -- Since $x$ is odd and has at least two distinct prime factors, $\sigma^*(x)$ is divisible by 4.
    have h_sigma_star_div_4 : 4 ∣ sigma_star x := by
      -- Since $x$ is odd and has at least two distinct prime factors, $\sigma^*(x)$ is the product of terms of the form $(1 + p^{a_i})$ where $p$ is an odd prime and $a_i$ is the exponent of $p$ in the prime factorization of $x$.
      have h_sigma_star_factorization : sigma_star x = ∏ p ∈ (Nat.factorization x).support, (1 + p ^ (Nat.factorization x p)) := by
        have h_sigma_star_factorization : ∀ {m : ℕ}, m ≠ 0 → sigma_star m = ∏ p ∈ (Nat.factorization m).support, (1 + p ^ (Nat.factorization m p)) := by
          intros m hm_nonzero
          have h_sigma_star_factorization : sigma_star m = ∏ p ∈ (Nat.factorization m).support, sigma_star (p ^ (Nat.factorization m p)) := by
            -- Applying the multiplicativity of $\sigma^*$ to the prime factorization of $m$.
            have h_sigma_star_factorization : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → sigma_star (∏ p ∈ S, p ^ (Nat.factorization m p)) = ∏ p ∈ S, sigma_star (p ^ (Nat.factorization m p)) := by
              intros S hS_prime
              induction' S using Finset.induction with p S hS ih;
              · unfold sigma_star; simp +decide ;
              · rw [ Finset.prod_insert hS, sigma_star_mul_of_coprime ];
                · rw [ Finset.prod_insert hS, ih fun q hq => hS_prime q <| Finset.mem_insert_of_mem hq ];
                · exact Nat.Coprime.prod_right fun q hq => Nat.Coprime.pow _ _ <| by have := Nat.coprime_primes ( hS_prime p <| Finset.mem_insert_self _ _ ) ( hS_prime q <| Finset.mem_insert_of_mem hq ) ; aesop;
            convert h_sigma_star_factorization fun p hp => Nat.prime_of_mem_primeFactors hp;
            exact Eq.symm ( Nat.factorization_prod_pow_eq_self hm_nonzero );
          rw [ h_sigma_star_factorization ];
          exact Finset.prod_congr rfl fun p hp => sigma_star_prime_pow ( Nat.prime_of_mem_primeFactors hp ) ( Nat.ne_of_gt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp hp ) ) );
        exact h_sigma_star_factorization hx_odd.pos.ne';
      -- Since $x$ is odd and has at least two distinct prime factors, each term $(1 + p^{a_i})$ in the product is even.
      have h_even_terms : ∀ p ∈ (Nat.factorization x).support, Even (1 + p ^ (Nat.factorization x p)) := by
        intro p hp; simp_all +decide [ parity_simps ] ;
        exact fun h => absurd ( hx_odd.of_dvd_nat hp.2.1 ) ( by simp +decide [ h, hp.1.even_iff ] );
      have h_even_terms : 2 ^ (Nat.factorization x).support.card ∣ sigma_star x := by
        exact h_sigma_star_factorization.symm ▸ dvd_trans ( by norm_num ) ( Finset.prod_dvd_prod_of_dvd _ _ fun p hp => even_iff_two_dvd.mp ( h_even_terms p hp ) );
      exact dvd_trans ( pow_dvd_pow _ h_prime_factors ) h_even_terms;
    -- Since $4 \mid \sigma^*(x)$, we have $v_2(\sigma^*(x)) \geq 2$.
    have h_v2_sigma_star : Nat.factorization (sigma_star x) 2 ≥ 2 := by
      obtain ⟨ c, hc ⟩ := h_sigma_star_div_4; simp_all +decide [ Nat.factorization_eq_zero_iff ] ;
      rw [ Nat.factorization_mul ] <;> norm_num;
      · exact le_add_of_le_of_nonneg ( by native_decide ) ( Nat.zero_le _ );
      · aesop;
    -- Since $4 \mid \sigma^*(x)$, we have $v_2(1 + 3^k) + v_2(\sigma^*(x)) = 2$.
    have h_v2_sum : Nat.factorization (1 + 3 ^ k) 2 + Nat.factorization (sigma_star x) 2 = 2 := by
      have h_v2_sum : Nat.factorization ((1 + 3 ^ k) * sigma_star x) 2 = Nat.factorization (4 * 3 ^ (k - 1) * x) 2 := by
        rw [h_eq];
      rw [ Nat.factorization_mul, Nat.factorization_mul ] at h_v2_sum <;> simp_all +decide [ Nat.factorization_eq_zero_of_not_dvd, ← even_iff_two_dvd, parity_simps ] ;
      · native_decide;
      · aesop_cat;
      · aesop_cat;
    linarith [ show Nat.factorization ( 1 + 3 ^ k ) 2 > 0 from Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by { exact Nat.mem_primeFactors.mpr ⟨ Nat.prime_two, Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact even_iff_two_dvd.mp ( by simp +decide [ parity_simps ] ) ), by positivity ⟩ } ) ) ];
  · interval_cases _ : Finset.card _ <;> simp_all +decide;
    · rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', mul_assoc ];
      rcases ‹x = 0 ∨ x = 1› with ( rfl | rfl ) <;> norm_num at *;
      erw [ show sigma_star 1 = 1 by rfl ] at h_eq ; linarith [ pow_pos ( by decide : 0 < 3 ) k ];
    · -- Let $x = p^a$ for some odd prime $p$ and integer $a \geq 1$.
      obtain ⟨p, a, hp, ha⟩ : ∃ p a : ℕ, Nat.Prime p ∧ a ≥ 1 ∧ x = p^a := by
        norm_num +zetaDelta at *;
        rw [ Finset.card_eq_one ] at *;
        rw [ ← Nat.factorization_prod_pow_eq_self hx_odd.pos.ne' ];
        rcases ‹_› with ⟨ p, hp ⟩ ; exact ⟨ p, Nat.prime_of_mem_primeFactors <| hp.symm ▸ Finset.mem_singleton_self _, x.factorization p, Nat.pos_of_ne_zero <| Finsupp.mem_support_iff.mp <| by aesop, by rw [ Finsupp.prod ] ; aesop ⟩ ;
      -- Substitute $x = p^a$ into the equation $(1 + 3^k) * \sigma^*(x) = 4 * 3^{k-1} * x$.
      have h_sub : (1 + 3^k) * (1 + p^a) = 4 * 3^(k-1) * p^a := by
        have h_sub : sigma_star (p^a) = 1 + p^a := by
          convert sigma_star_prime_pow hp ( by linarith ) using 1;
        aesop;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ' ];
      -- Let's simplify the equation $(1 + 3 * (3 * 3^k)) * (1 + p^a) = 4 * (3 * 3^k) * p^a$.
      have h_simplified : 3^k * (3 * p^a - 9) = p^a + 1 := by
        rw [ Nat.mul_sub_left_distrib, Nat.sub_eq_of_eq_add ] ; linarith;
      rcases n : 3 * p ^ a - 9 with ( _ | _ | n ) <;> simp_all +decide [ Nat.pow_succ', mul_assoc ];
      · omega;
      · rw [ Nat.sub_eq_iff_eq_add ] at n;
        · nlinarith only [ n, h_simplified, pow_le_pow_right₀ ( show 1 ≤ 3 by decide ) hk, pow_pos hp.pos a ];
        · exact le_of_lt ( Nat.lt_of_sub_eq_succ n )

/-
If n = 2 * m is unitary perfect with m odd, then n = 6 or n = 90.
-/
theorem unitary_perfect_k_1 (n m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^1 * m) (h_perf : is_unitary_perfect n) :
  n = 6 ∨ n = 90 := by
    -- We have σ*(m)/m = 4/3.
    have h_ratio : (sigma_star m : ℚ) / m = 4 / 3 := by
      convert ratio_constraint n 1 m hn hm h_eq h_perf using 1 ; norm_num [ h_eq ];
    -- By m_div_3_of_ratio_4_3, 3 divides m.
    obtain ⟨k, x, hk, hx, h_eq'⟩ : ∃ k x : ℕ, k ≥ 1 ∧ Nat.Coprime x 3 ∧ m = 3^k * x := by
      have h_div3 : 3 ∣ m := by
        exact m_div_3_of_ratio_4_3 m ( by rw [ div_eq_div_iff ] at h_ratio <;> norm_cast at * <;> linarith [ hm.pos ] );
      exact ⟨ Nat.factorization m 3, m / 3 ^ Nat.factorization m 3, Nat.succ_le_of_lt ( Nat.pos_of_ne_zero ( Finsupp.mem_support_iff.mp ( by { exact Nat.mem_primeFactors.mpr ⟨ by norm_num, h_div3, by aesop_cat ⟩ } ) ) ), Nat.Coprime.symm ( Nat.prime_three.coprime_iff_not_dvd.mpr <| Nat.not_dvd_ordCompl ( by norm_num ) <| by aesop_cat ), by rw [ Nat.mul_div_cancel' <| Nat.ordProj_dvd _ _ ] ⟩;
    -- By sigma_star_x_eq, (1+3^k) * σ*(x) = 4 * 3^(k-1) * x.
    have h_eq'' : (1 + 3^k) * sigma_star x = 4 * 3^(k-1) * x := by
      have h_eq'' : sigma_star (3^k * x) = sigma_star (3^k) * sigma_star x := by
        apply sigma_star_mul_of_coprime;
        exact Nat.Coprime.pow_left _ hx.symm;
      have h_eq''' : sigma_star (3^k) = 1 + 3^k := by
        convert sigma_star_prime_pow ( by norm_num : Nat.Prime 3 ) ( by linarith : k ≠ 0 ) using 1;
      rcases k with ( _ | k ) <;> simp_all +decide [ pow_succ' ];
      rw [ div_eq_div_iff ] at h_ratio <;> norm_cast at * <;> first |linarith|aesop;
    -- If k=1: (1+3)σ*(x) = 4x => σ*(x)=x => x=1 => m=3 => n=6.
    by_cases hk1 : k = 1;
    · have := sigma_star_div_self_eq_one x ( by aesop ) ; aesop;
    · -- If k=2: (1+9)σ*(x) = 12x => 10σ*(x) = 12x => 5σ*(x) = 6x => σ*(x)/x = 6/5.
      by_cases hk2 : k = 2;
      · -- By sigma_star_ratio_six_fifths_v2, x=5 => m=45 => n=90.
        have hx5 : x = 5 := by
          apply sigma_star_ratio_six_fifths_v2 x (by
          exact hm.of_dvd_nat ( h_eq'.symm ▸ dvd_mul_left _ _ )) (by
          subst_vars; norm_num at *; linarith;)
        aesop;
      · -- If k>=3: By no_solution_for_k_ge_3, this case is impossible.
        have := no_solution_for_k_ge_3 k x (by
        exact le_of_not_gt fun h => by interval_cases k <;> contradiction;) (by
        exact hm.of_dvd_nat ( h_eq'.symm ▸ dvd_mul_left _ _ )) h_eq''; contradiction

/-
If (1+3)σ*(x) = 4x, then x=1.
-/
lemma solution_k_1 (x : ℕ) (hx : Nat.Coprime x 3) (h_eq : (1 + 3^1) * sigma_star x = 4 * 3^0 * x) : x = 1 := by
  -- By definition of $sigma_star$, we know that $sigma_star x = x$ implies $x$ has no other unitary divisors besides itself.
  have h_sigma_star_eq_self : sigma_star x = x → x = 1 := by
    intro h; have := sigma_star_div_self_eq_one x; aesop;
  exact h_sigma_star_eq_self ( by linarith )

/-
If n = 2 * m is unitary perfect with m odd, then n = 6 or n = 90.
-/
theorem unitary_perfect_k_1_v2 (n m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^1 * m) (h_perf : is_unitary_perfect n) :
  n = 6 ∨ n = 90 := by
    exact?

/-
If n = 2 * m is unitary perfect with m odd, then n = 6 or n = 90.
-/
theorem unitary_perfect_k_1_v3 (n m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^1 * m) (h_perf : is_unitary_perfect n) :
  n = 6 ∨ n = 90 := by
    exact?

/-
If n = 2 * m is unitary perfect with m odd, then n = 6 or n = 90.
-/
theorem unitary_perfect_k_1_v4 (n m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^1 * m) (h_perf : is_unitary_perfect n) :
  n = 6 ∨ n = 90 := by
    exact?

/-
If n = 2 * m is unitary perfect with m odd, then n = 6 or n = 90.
-/
theorem unitary_perfect_k_1_v5 (n m : ℕ) (hn : n ≠ 0) (hm : Odd m) (h_eq : n = 2^1 * m) (h_perf : is_unitary_perfect n) :
  n = 6 ∨ n = 90 := by
    convert unitary_perfect_k_1_v4 n m hn hm h_eq h_perf using 1