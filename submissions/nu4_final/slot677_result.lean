/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a67cc5ff-0c92-497c-aea9-e3146fcd1e52

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of Pell numbers and properties related to the open conjecture on infinite Pell primes. Defined Pell numbers and Pell-Lucas numbers. Proved recurrence relations, divisibility properties (strong divisibility sequence), GCD properties, rank of appearance theorem, connection to Legendre symbol, and properties of prime divisors. The main conjecture remains open.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Pell numbers P_n are defined by P_0=0, P_1=1, P_{n+2}=2P_{n+1}+P_n.
-/
def pellNumber : ℕ → ℕ
  | 0 => 0
  | 1 => 1
  | (n + 2) => 2 * pellNumber (n + 1) + pellNumber n

/-
If n divides m, then the n-th Pell number divides the m-th Pell number.
-/
theorem pellNumber_dvd_pellNumber {n m : ℕ} (h : n ∣ m) : pellNumber n ∣ pellNumber m := by
  -- We'll use the fact that Pell numbers follow a recurrence relation similar to Fibonacci numbers.
  have pell_recurrence : ∀ n, pellNumber (n + 2) = 2 * pellNumber (n + 1) + pellNumber n := by
    exact?;
  -- We'll use the fact that Pell numbers satisfy the same recurrence relation as Fibonacci numbers.
  have pell_recurrence : ∀ n m, pellNumber (n + m + 1) = pellNumber (n + 1) * pellNumber (m + 1) + pellNumber n * pellNumber m := by
    intro n m; induction' m with m ih generalizing n <;> simp_all +decide [ Nat.succ_eq_add_one, mul_add ] ; ring;
    · norm_num [ show pellNumber 0 = 0 by rfl, show pellNumber 1 = 1 by rfl ];
    · convert ih ( n + 1 ) using 1 ; ring;
      rw [ pell_recurrence ] ; ring;
  obtain ⟨ k, rfl ⟩ := h;
  induction' k with k ih;
  · norm_num [ show pellNumber 0 = 0 from rfl ];
  · specialize pell_recurrence ( n - 1 ) ( n * k ) ; rcases n with ( _ | n ) <;> simp_all +decide [ Nat.dvd_add_right, dvd_mul_of_dvd_right ] ;
    convert dvd_add ( dvd_mul_right ( pellNumber ( n + 1 ) ) ( pellNumber ( ( n + 1 ) * k + 1 ) ) ) ( dvd_mul_of_dvd_right ih ( pellNumber n ) ) using 1 ; ring_nf at * ; aesop

/-
If the n-th Pell number is prime, then n is prime.
-/
theorem prime_of_prime_pellNumber {n : ℕ} (h : Prime (pellNumber n)) : Prime n := by
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ ← Nat.prime_iff ];
  -- By definition of Pell numbers, we know that if $n$ is composite, then $P_n$ is also composite.
  have h_composite : ∀ n, 1 < n → ¬Nat.Prime n → ¬Nat.Prime (pellNumber n) := by
    intros n hn hnp
    obtain ⟨k, m, hk, hm⟩ : ∃ k m, 1 < k ∧ k < n ∧ m = n / k ∧ n = k * m := by
      exact ⟨ Nat.minFac n, n / Nat.minFac n, Nat.Prime.one_lt ( Nat.minFac_prime hn.ne' ), Nat.lt_of_le_of_ne ( Nat.minFac_le hn.le ) fun con => hnp <| con ▸ Nat.minFac_prime hn.ne', rfl, by rw [ Nat.mul_div_cancel' <| Nat.minFac_dvd n ] ⟩;
    -- By the properties of Pell numbers, we know that $P_{km}$ is divisible by $P_k$.
    have h_div : pellNumber k ∣ pellNumber (k * m) := by
      exact pellNumber_dvd_pellNumber ( dvd_mul_right _ _ );
    rw [ hm.2.2 ];
    intro H; rw [ H.dvd_iff_eq ] at h_div <;> norm_num at *;
    · -- By the properties of Pell numbers, we know that $P_{km}$ is strictly increasing for $k \geq 1$.
      have h_inc : StrictMono pellNumber := by
        refine' strictMono_nat_of_lt_succ _;
        intro n; induction n <;> norm_num [ pellNumber ] at * ; linarith;
      exact absurd h_div ( ne_of_gt ( h_inc ( by nlinarith [ show m > 1 from by nlinarith ] ) ) );
    · rcases k with ( _ | _ | _ | k ) <;> simp +arith +decide [ pellNumber ] at *;
      omega;
  exact Classical.not_not.1 fun hn => h_composite _ ( Nat.le_add_left _ _ ) hn h

/-
The GCD of the n-th and m-th Pell numbers is the Pell number of the GCD of n and m.
-/
theorem pellNumber_gcd (n m : ℕ) : Nat.gcd (pellNumber n) (pellNumber m) = pellNumber (Nat.gcd n m) := by
  -- We first prove the identity $P_m = P_n P_{m-n+1} + P_{n-1} P_{m-n}$.
  have hPell_identity : ∀ n m : ℕ, n > 0 → m ≥ n → pellNumber m = pellNumber n * pellNumber (m - n + 1) + pellNumber (n - 1) * pellNumber (m - n) := by
    intros n m hn hm
    induction' n with n ih generalizing m;
    · contradiction;
    · rcases m with ( _ | _ | m ) <;> simp +arith +decide [ Nat.succ_sub ] at hm ⊢;
      · aesop;
      · rcases n with ( _ | n ) <;> simp +arith +decide [ Nat.succ_sub ] at hm ⊢;
        · exact Eq.symm ( by rw [ show pellNumber 0 = 0 by rfl, show pellNumber 1 = 1 by rfl ] ; ring );
        · convert ih ( m + 2 ) ( Nat.succ_pos _ ) ( by linarith ) using 1;
          rw [ show m + 2 - ( n + 1 ) = m - n + 1 by omega ] ; simp +arith +decide [ pellNumber ] ; ring!;
  -- We'll use the identity $P_m = P_n P_{m-n+1} + P_{n-1} P_{m-n}$ to show that $\gcd(P_m, P_n) = P_{\gcd(m, n)}$.
  have h_gcd_identity : ∀ n m : ℕ, n > 0 → m > n → Nat.gcd (pellNumber n) (pellNumber m) = Nat.gcd (pellNumber n) (pellNumber (m - n)) := by
    intros n m hn hm
    have h_gcd_identity_step : Nat.gcd (pellNumber n) (pellNumber m) = Nat.gcd (pellNumber n) (pellNumber (m - n)) := by
      have h_step : pellNumber m = pellNumber n * pellNumber (m - n + 1) + pellNumber (n - 1) * pellNumber (m - n) := hPell_identity n m hn (le_of_lt hm)
      -- Since $P_{n-1}$ and $P_n$ are coprime, we have $\gcd(P_n, P_{n-1} P_{m-n}) = \gcd(P_n, P_{m-n})$.
      have h_coprime : Nat.gcd (pellNumber n) (pellNumber (n - 1)) = 1 := by
        rcases n with ( _ | _ | n ) <;> simp +arith +decide [ *, Nat.gcd_comm ] at *;
        exact Nat.recOn n ( by decide ) fun n ih => by { rw [ show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) by rfl ] ; simp +decide [ *, Nat.gcd_comm ] };
      simp +decide [ h_step, Nat.gcd_comm ];
      exact?;
    exact h_gcd_identity_step;
  -- By repeatedly applying the identity, we can reduce the problem to the case where $n = \gcd(m, n)$.
  have h_gcd_reduction : ∀ n m : ℕ, n > 0 → m > 0 → Nat.gcd (pellNumber n) (pellNumber m) = Nat.gcd (pellNumber (Nat.gcd n m)) (pellNumber (Nat.gcd n m)) := by
    intros n m hn hm
    induction' n using Nat.strong_induction_on with n ih generalizing m
    induction' m using Nat.strong_induction_on with m ih';
    rcases lt_trichotomy n m with ( h | rfl | h ) <;> simp_all +decide [ Nat.gcd_comm ];
    · simp +decide [ Nat.gcd_comm, h.le ];
    · grind;
  by_cases hn : n = 0 <;> by_cases hm : m = 0 <;> simp_all +decide [ Nat.gcd_comm ];
  · exact Nat.gcd_zero_right _;
  · exact Nat.gcd_eq_left ( by exact Nat.recOn n ( by norm_num [ pellNumber ] ) fun n ihn => by cases n <;> simp_all +decide [ pellNumber ] );
  · exact h_gcd_reduction n m ( Nat.pos_of_ne_zero hn ) ( Nat.pos_of_ne_zero hm )

/-
The Pell numbers are strictly increasing for n >= 1.
-/
theorem pellNumber_strictMono : StrictMonoOn pellNumber (Set.Ici 1) := by
  -- We'll use induction to prove that the Pell numbers are strictly increasing for $n \geq 1$.
  have h_ind : ∀ n ≥ 1, pellNumber n < pellNumber (n + 1) := by
    intro n hn;
    -- We will prove this by induction on $n$.
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | n ) <;> simp +arith +decide [ * ] at *;
    exact by erw [ show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) by rfl ] ; linarith [ ih _ le_rfl ( Nat.succ_pos _ ) ] ;
  intros m hm n hn hmn;
  -- By induction on $n - m$, we can show that $P_m < P_n$ for any $m < n$.
  induction' hmn with k hk ih;
  · exact h_ind m hm;
  · grind

/-
There are infinitely many prime numbers that divide at least one Pell number.
-/
theorem infinite_prime_factors_pell : Infinite {p | Nat.Prime p ∧ ∃ n, p ∣ pellNumber n} := by
  refine Set.infinite_coe_iff.mpr ?_;
  refine Set.Infinite.mono ?_ ( Nat.infinite_setOf_prime_modEq_one ( show 32 ≠ 0 by decide ) );
  -- For any prime $p \equiv 1 \pmod{32}$, we know that $\left(\frac{2}{p}\right) = 1$, which implies that $p$ divides some Pell number.
  intro p hp
  obtain ⟨n, hn⟩ : ∃ n, pellNumber n ≡ 0 [MOD p] := by
    exact ⟨ 0, rfl ⟩;
  exact ⟨ hp.1, n, Nat.dvd_of_mod_eq_zero hn ⟩

/-
Consecutive Pell numbers are coprime.
-/
theorem pellNumber_coprime_succ (n : ℕ) : Nat.Coprime (pellNumber n) (pellNumber (n + 1)) := by
  induction' n with n ih;
  · decide +revert;
  · exact Nat.Coprime.symm ( by rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; simpa using ih )

/-
Cassini's Identity for Pell numbers for n >= 1: P_{n+1} * P_{n-1} - P_n^2 = (-1)^n.
-/
theorem pellNumber_cassini (n : ℕ) (h : n ≥ 1) : (pellNumber (n + 1) : ℤ) * pellNumber (n - 1) - (pellNumber n : ℤ) ^ 2 = (-1) ^ n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | n ) <;> simp_all +decide;
  rcases n with ( _ | n ) <;> simp_all +decide [ pow_succ' ];
  have := ih ( n + 1 ) ( by linarith ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ( by linarith ) ; norm_num [ pow_succ', pellNumber ] at * ; nlinarith

/-
Addition formula for Pell numbers: P_{n+m} = P_n * P_{m+1} + P_{n-1} * P_m for n >= 1.
-/
theorem pellNumber_add (n m : ℕ) (h : n ≥ 1) : pellNumber (n + m) = pellNumber n * pellNumber (m + 1) + pellNumber (n - 1) * pellNumber m := by
  induction' m with m ih generalizing n;
  · exact?;
  · convert ih ( n + 1 ) ( by linarith ) using 1;
    · ac_rfl;
    · rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ];
      ring

/-
Rank of appearance theorem: if k is the smallest positive index such that prime p divides P_k, then p divides P_n iff k divides n.
-/
theorem pellNumber_rank_of_appearance (p : ℕ) (hp : Prime p) (h_exists : ∃ k > 0, p ∣ pellNumber k) :
    let k := Nat.find h_exists
    ∀ n, p ∣ pellNumber n ↔ k ∣ n := by
      intros k n
      constructor
      intro h_div
      have h_div_k : p ∣ pellNumber (Nat.gcd k n) := by
        exact pellNumber_gcd k n ▸ Nat.dvd_gcd ( Nat.find_spec h_exists |>.2 ) h_div
      have h_div_k_eq : Nat.gcd k n = k := by
        exact le_antisymm ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.gcd_dvd_left _ _ ) ) ( Nat.find_min' h_exists ⟨ Nat.gcd_pos_of_pos_left _ ( Nat.pos_of_ne_zero ( by aesop ) ), h_div_k ⟩ ) ▸ rfl
      apply Nat.dvd_of_mod_eq_zero
      exact (by
      exact Nat.mod_eq_zero_of_dvd <| h_div_k_eq ▸ Nat.gcd_dvd_right _ _);
      exact fun h => dvd_trans ( Nat.find_spec h_exists |>.2 ) ( pellNumber_dvd_pellNumber h )

/-
For any prime p != 2, there exists k > 0 such that p divides P_k.
-/
theorem exists_rank_of_appearance (p : ℕ) (hp : Prime p) (hp2 : p ≠ 2) : ∃ k > 0, p ∣ pellNumber k := by
  -- By the pigeonhole principle, since there are only $p^2$ possible pairs $(P_n \mod p, P_{n+1} \mod p)$, there must exist indices $i$ and $j$ with $i < j$ such that $(P_i \mod p, P_{i+1} \mod p) = (P_j \mod p, P_{j+1} \mod p)$.
  obtain ⟨i, j, hij, h_eq⟩ : ∃ i j, i < j ∧ (pellNumber i % p = pellNumber j % p) ∧ (pellNumber (i + 1) % p = pellNumber (j + 1) % p) := by
    have h_finite : Set.Finite (Set.range (fun n => (pellNumber n % p, pellNumber (n + 1) % p))) := by
      exact Set.finite_iff_bddAbove.mpr ⟨ ⟨ p - 1, p - 1 ⟩, by rintro a ⟨ n, rfl ⟩ ; exact ⟨ Nat.le_sub_one_of_lt ( Nat.mod_lt _ hp.nat_prime.pos ), Nat.le_sub_one_of_lt ( Nat.mod_lt _ hp.nat_prime.pos ) ⟩ ⟩;
    contrapose! h_finite;
    exact Set.infinite_range_of_injective fun m n hmn => le_antisymm ( le_of_not_gt fun hmn' => h_finite _ _ hmn' ( by aesop ) ( by aesop ) ) ( le_of_not_gt fun hmn' => h_finite _ _ hmn' ( by aesop ) ( by aesop ) );
  induction' i with i ih generalizing j;
  · exact ⟨ j, hij, Nat.dvd_of_mod_eq_zero ( h_eq.1.symm ▸ by norm_num [ pellNumber ] ) ⟩;
  · specialize ih ( j - 1 ) ( by omega ) ; rcases j <;> simp_all +decide [ Nat.succ_eq_add_one ];
    simp_all +decide [ Nat.dvd_iff_mod_eq_zero, pellNumber ];
    simp_all +decide [ ← ZMod.natCast_eq_natCast_iff' ];
    aesop

/-
If 2 is a quadratic residue modulo an odd prime p, then p divides P_{p-1}.
-/
theorem pell_divides_sub_one_of_legendre_one (p : ℕ) [Fact (Nat.Prime p)] (hp : p ≠ 2) (h : legendreSym p 2 = 1) : p ∣ pellNumber (p - 1) := by
  -- Let's consider the roots of the characteristic polynomial $x^2 - 2x - 1$ modulo $p$.
  obtain ⟨α, β, h_roots⟩ : ∃ α β : ZMod p, α^2 = 2 * α + 1 ∧ β^2 = 2 * β + 1 ∧ α ≠ β := by
    -- Since $2$ is a quadratic residue modulo $p$, there exists an integer $x$ such that $x^2 \equiv 2 \pmod{p}$.
    obtain ⟨x, hx⟩ : ∃ x : ZMod p, x^2 = 2 := by
      rw [ legendreSym.eq_one_iff ] at h;
      · exact Exists.elim h fun x hx => ⟨ x, by rw [ sq, ← hx ] ; norm_num ⟩;
      · simp +zetaDelta at *;
        erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne ( Nat.Prime.two_le Fact.out ) ( Ne.symm hp ) );
    refine' ⟨ 1 + x, 1 - x, _, _, _ ⟩ <;> ring_nf at * <;> simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
    · ring;
    · ring;
    · by_cases h : x = 0 <;> simp_all +decide [ sub_eq_add_neg ];
      · rcases p with ( _ | _ | _ | p ) <;> cases hx <;> contradiction;
      · rw [ eq_neg_iff_add_eq_zero ] ; ring_nf at * ; aesop;
  -- Using the roots α and β, we can express P_n as (α^n - β^n) / (α - β).
  have h_expansion : ∀ n : ℕ, pellNumber n = (α^n - β^n) / (α - β) := by
    intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pow_succ' ] ; ring;
    · norm_num [ pellNumber ];
    · rw [ div_self ( sub_ne_zero_of_ne h_roots.2.2 ) ] ; norm_num [ pellNumber ];
    · rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; simp_all +decide [ pow_succ', ← mul_assoc ] ; ring;
      rw [ ih n ( by linarith ) ] ; ring;
  simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
  rw [ ZMod.pow_card_sub_one_eq_one, ZMod.pow_card_sub_one_eq_one ] <;> aesop

/-
If 2 is a quadratic non-residue modulo an odd prime p, then p divides P_{p+1}.
-/
theorem pell_divides_add_one_of_legendre_neg_one (p : ℕ) [Fact (Nat.Prime p)] (hp : p ≠ 2) (h : legendreSym p 2 = -1) : p ∣ pellNumber (p + 1) := by
  -- By definition of $P_k$, we know that $P_k = \frac{(1+\sqrt{2})^k - (1-\sqrt{2})^k}{2\sqrt{2}}$.
  have h_pell_def : ∀ k : ℕ, pellNumber k = ((1 + Real.sqrt 2) ^ k - (1 - Real.sqrt 2) ^ k) / (2 * Real.sqrt 2) := by
    intro k; induction' k using Nat.strong_induction_on with k ih; rcases k with ( _ | _ | k ) <;> norm_num [ *, pow_succ' ] at *; ring_nf at *; aesop;
    rw [ show pellNumber ( k + 2 ) = 2 * pellNumber ( k + 1 ) + pellNumber k from rfl ] ; push_cast [ ih k ( by linarith ), ih ( k + 1 ) ( by linarith ) ] ; ring_nf ; norm_num ; ring;
  -- Let's simplify the expression for $P_{p+1}$.
  have h_pell_simplified : pellNumber (p + 1) = ∑ i ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * i + 1) * 2 ^ i := by
    have h_pell_simplified : pellNumber (p + 1) = ∑ i ∈ Finset.range (p + 2), Nat.choose (p + 1) i * Real.sqrt 2 ^ (i - 1) * (if i % 2 = 1 then 1 else 0) := by
      have h_pell_simplified : pellNumber (p + 1) = (∑ i ∈ Finset.range (p + 2), Nat.choose (p + 1) i * Real.sqrt 2 ^ i - ∑ i ∈ Finset.range (p + 2), Nat.choose (p + 1) i * (-Real.sqrt 2) ^ i) / (2 * Real.sqrt 2) := by
        rw [ h_pell_def ];
        simp +decide [ add_comm ( 1 : ℝ ), add_pow, sub_eq_add_neg, mul_comm ];
      rw [ h_pell_simplified, ← Finset.sum_sub_distrib ];
      rw [ Finset.sum_div _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rcases Nat.even_or_odd' i with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
      norm_num;
    -- Let's simplify the expression for $P_{p+1}$ further.
    have h_pell_simplified' : pellNumber (p + 1) = ∑ i ∈ Finset.filter (fun i => i % 2 = 1) (Finset.range (p + 2)), Nat.choose (p + 1) i * Real.sqrt 2 ^ (i - 1) := by
      simp_all +decide [ Finset.sum_filter ];
    -- Let's simplify the expression for $P_{p+1}$ further by separating the sum into two parts: one for odd $i$ and one for even $i$.
    have h_pell_simplified'' : pellNumber (p + 1) = ∑ i ∈ Finset.range ((p + 1) / 2), Nat.choose (p + 1) (2 * i + 1) * Real.sqrt 2 ^ (2 * i) := by
      rw [ h_pell_simplified' ];
      refine' Finset.sum_bij ( fun i hi => i / 2 ) _ _ _ _ <;> norm_num;
      · intro a ha₁ ha₂; cases Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) <;> omega;
      · intros; omega;
      · exact fun b hb => ⟨ 2 * b + 1, ⟨ by linarith [ Nat.div_mul_le_self ( p + 1 ) 2 ], by norm_num [ Nat.add_mod ] ⟩, by norm_num [ Nat.add_div ] ⟩;
      · intro a ha₁ ha₂; rw [ ← Nat.div_add_mod a 2 ] ; norm_num [ ha₂ ] ;
        norm_num [ Nat.add_div ];
    norm_num [ pow_mul ] at *;
    norm_cast at * ; cases Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) <;> simp_all +arith +decide [ Nat.add_div ];
  -- Let's simplify the expression for $P_{p+1}$ modulo $p$.
  have h_pell_mod : ∑ i ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * i + 1) * 2 ^ i ≡ ∑ i ∈ Finset.range (p / 2 + 1), (if i = 0 then 1 else if i = p / 2 then 2 ^ (p / 2) else 0) [MOD p] := by
    have h_binom_mod : ∀ i ∈ Finset.range (p / 2 + 1), i ≠ 0 ∧ i ≠ p / 2 → Nat.choose (p + 1) (2 * i + 1) ≡ 0 [MOD p] := by
      intros i hi_range hi_ne_zero
      have h_choose : Nat.choose (p + 1) (2 * i + 1) = (p + 1) * Nat.choose p (2 * i) / (2 * i + 1) := by
        rw [ Nat.div_eq_of_eq_mul_left ] <;> linarith [ Nat.succ_mul_choose_eq p ( 2 * i ), Nat.choose_succ_succ p ( 2 * i ) ];
      rw [ Nat.modEq_zero_iff_dvd, h_choose ];
      refine' Nat.dvd_div_of_mul_dvd _;
      refine' Nat.Coprime.mul_dvd_of_dvd_of_dvd _ _ _;
      · exact Nat.Coprime.symm ( ( Fact.out : Nat.Prime p ) |> fun pp => pp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Nat.succ_pos _ ) <| by linarith [ Finset.mem_range.mp hi_range, Nat.div_mul_le_self p 2, show i < p / 2 from lt_of_le_of_ne ( Nat.le_of_lt_succ <| Finset.mem_range.mp hi_range ) hi_ne_zero.2 ] );
      · have h_choose : (2 * i + 1) * Nat.choose (p + 1) (2 * i + 1) = (p + 1) * Nat.choose p (2 * i) := by
          rw [ Nat.mul_comm, Nat.succ_mul_choose_eq ];
        exact Dvd.intro _ h_choose;
      · exact dvd_mul_of_dvd_right ( Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime p ) ( by linarith [ Nat.pos_of_ne_zero hi_ne_zero.1 ] ) ( by linarith [ Nat.div_mul_le_self p 2, Finset.mem_range.mp hi_range, show i < p / 2 from lt_of_le_of_ne ( Finset.mem_range_succ_iff.mp hi_range ) hi_ne_zero.2 ] ) ) _;
    have h_sum_mod : ∀ i ∈ Finset.range (p / 2 + 1), Nat.choose (p + 1) (2 * i + 1) * 2 ^ i ≡ if i = 0 then 1 else if i = p / 2 then 2 ^ (p / 2) else 0 [MOD p] := by
      intro i hi; split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
      rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> simp_all +arith +decide [ Nat.choose_succ_succ ];
      norm_num [ Nat.add_div ];
    simp_all +decide only [← ZMod.natCast_eq_natCast_iff, Nat.cast_sum];
  -- Let's simplify the expression for $P_{p+1}$ modulo $p$ further.
  have h_pell_mod_simplified : ∑ i ∈ Finset.range (p / 2 + 1), (if i = 0 then 1 else if i = p / 2 then 2 ^ (p / 2) else 0) ≡ 1 + 2 ^ (p / 2) [MOD p] := by
    norm_num [ Finset.sum_range_succ' ];
    rcases k : p / 2 with ( _ | _ | k ) <;> simp_all +arith +decide [ Finset.sum_range_succ ];
    · interval_cases p <;> trivial;
    · rfl;
    · rfl;
  -- Since $2^{p/2} \equiv -1 \pmod{p}$, we have $1 + 2^{p/2} \equiv 0 \pmod{p}$.
  have h_final : 1 + 2 ^ (p / 2) ≡ 0 [ZMOD p] := by
    have h_final : 2 ^ (p / 2) ≡ -1 [ZMOD p] := by
      have h_final : 2 ^ (p / 2) ≡ legendreSym p 2 [ZMOD p] := by
        simp +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym.eq_pow ];
      aesop;
    exact h_final.add_left 1;
  simp_all +decide [ ← Int.natCast_modEq_iff ];
  exact_mod_cast Int.dvd_of_emod_eq_zero ( h_pell_mod.trans <| h_pell_mod_simplified.trans h_final )

/-
For any prime p != 2, the rank of appearance of p divides p - (2/p).
-/
theorem rank_of_appearance_dvd_legendre (p : ℕ) (hp : Nat.Prime p) (hp2 : p ≠ 2) :
    letI : Fact (Nat.Prime p) := ⟨hp⟩
    let k := Nat.find (exists_rank_of_appearance p (Nat.prime_iff.mp hp) hp2)
    (k : ℤ) ∣ (p : ℤ) - legendreSym p 2 := by
      have := @pell_divides_sub_one_of_legendre_one p ; have := @pell_divides_add_one_of_legendre_neg_one p ; ( cases eq_or_ne p 2 <;> simp_all +decide [ legendreSym ] ; );
      -- Let's consider the two cases: when the Legendre symbol is 1 and when it is -1.
      by_cases h_legendre : quadraticCharFun (ZMod p) 2 = 1 ∨ quadraticCharFun (ZMod p) 2 = -1;
      · haveI := Fact.mk hp; simp_all +decide [ quadraticCharFun ] ;
        split_ifs at * <;> simp_all +decide [ Nat.find_eq_iff ];
        · have := pellNumber_rank_of_appearance p ( by exact Nat.prime_iff.mp hp ) ?_;
          convert Int.natCast_dvd_natCast.mpr ( this _ |>.1 ‹_› ) using 1 ; rw [ Nat.cast_sub ] <;> norm_num ; linarith [ hp.two_le ];
          exact ⟨ p - 1, Nat.sub_pos_of_lt hp.one_lt, this ⟩;
        · have := pellNumber_rank_of_appearance p ( by exact Nat.prime_iff.mp hp ) ?_;
          exact_mod_cast this _ |>.1 ‹_›;
          exact ⟨ p + 1, Nat.succ_pos _, this ⟩;
      · haveI := Fact.mk hp; simp_all +decide [ quadraticCharFun ] ;
        split_ifs at h_legendre <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
        rcases p with ( _ | _ | _ | p ) <;> cases ‹_› <;> trivial

/-
For any prime p, P_p is congruent to (2/p) modulo p.
-/
theorem pellNumber_prime_mod_p (p : ℕ) [Fact (Nat.Prime p)] : (pellNumber p : ZMod p) = legendreSym p 2 := by
  -- Use the closed form of the Pell numbers to express $P_p$ in terms of $(1 + \sqrt{2})$ and $(1 - \sqrt{2})$.
  have h_closed_form : ∀ n : ℕ, (pellNumber n : ℤ) = ((1 + Real.sqrt 2) ^ n - (1 - Real.sqrt 2) ^ n) / (2 * Real.sqrt 2) := by
    intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> norm_num [ pow_succ' ] at *;
    · ring_nf; norm_num [ pellNumber ] ;
    · rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n by rfl ] ; push_cast [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; ring ; norm_num ; ring;
  -- Consider the expression $(1 + \sqrt{2})^p - (1 - \sqrt{2})^p$ modulo $p$.
  have h_mod : ((1 + Real.sqrt 2) ^ p - (1 - Real.sqrt 2) ^ p) / (2 * Real.sqrt 2) = (∑ k ∈ Finset.range (p / 2 + 1), Nat.choose p (2 * k + 1) * 2 ^ k) := by
    field_simp;
    -- Expand $(1 + \sqrt{2})^p$ and $(1 - \sqrt{2})^p$ using the binomial theorem.
    have h_binom : (1 + Real.sqrt 2) ^ p = ∑ k ∈ Finset.range (p + 1), Nat.choose p k * Real.sqrt 2 ^ k ∧ (1 - Real.sqrt 2) ^ p = ∑ k ∈ Finset.range (p + 1), Nat.choose p k * (-Real.sqrt 2) ^ k := by
      exact ⟨ by rw [ add_comm, add_pow ] ; simp +decide [ mul_comm ], by rw [ sub_eq_add_neg, add_comm, add_pow ] ; simp +decide [ mul_comm ] ⟩;
    -- Separate the sums into even and odd powers of $\sqrt{2}$.
    have h_split : ∑ k ∈ Finset.range (p + 1), (Nat.choose p k : ℝ) * (Real.sqrt 2 ^ k - (-Real.sqrt 2) ^ k) = ∑ k ∈ Finset.filter (fun k => k % 2 = 1) (Finset.range (p + 1)), (Nat.choose p k : ℝ) * (Real.sqrt 2 ^ k - (-Real.sqrt 2) ^ k) := by
      rw [ Finset.sum_filter ] ; congr ; ext x ; rcases Nat.even_or_odd' x with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ;
    -- Simplify the expression for the sum of the odd terms.
    have h_odd_terms_simplified : ∑ k ∈ Finset.filter (fun k => k % 2 = 1) (Finset.range (p + 1)), (Nat.choose p k : ℝ) * (Real.sqrt 2 ^ k - (-Real.sqrt 2) ^ k) = ∑ k ∈ Finset.range ((p + 1) / 2), (Nat.choose p (2 * k + 1) : ℝ) * (Real.sqrt 2 ^ (2 * k + 1) - (-Real.sqrt 2) ^ (2 * k + 1)) := by
      refine' Finset.sum_bij ( fun x hx => x / 2 ) _ _ _ _ <;> norm_num;
      · intro a ha₁ ha₂; omega;
      · intros; omega;
      · exact fun b hb => ⟨ 2 * b + 1, ⟨ by linarith [ Nat.div_mul_le_self ( p + 1 ) 2 ], by norm_num [ Nat.add_mod ] ⟩, by norm_num [ Nat.add_div ] ⟩;
      · intro a ha₁ ha₂; rw [ ← Nat.div_add_mod a 2 ] ; norm_num [ ha₂ ] ;
        norm_num [ Nat.add_div ];
    simp_all +decide [ mul_sub, ← mul_assoc, ← Finset.sum_mul _ _ _ ];
    norm_num [ pow_add, pow_mul, ← mul_assoc, ← Finset.mul_sum _ _ _, ← Finset.sum_mul ] ; ring;
    rw [ Nat.add_div ] <;> norm_num ; ring;
    cases Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) <;> simp_all +decide [ add_comm, mul_comm ];
    norm_num [ Finset.sum_range_succ ] ; ring;
  -- Since $p$ is an odd prime, we have $2^{(p-1)/2} \equiv \left(\frac{2}{p}\right) \pmod{p}$.
  have h_legendre : 2 ^ (p / 2) ≡ legendreSym p 2 [ZMOD p] := by
    simp +decide [ ← ZMod.intCast_eq_intCast_iff, legendreSym.eq_pow ];
  simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, ← ZMod.natCast_eq_natCast_iff ];
  rw [ show pellNumber p = ∑ x ∈ Finset.range ( p / 2 + 1 ), Nat.choose p ( 2 * x + 1 ) * 2 ^ x from ?_ ];
  · norm_num [ ← ZMod.natCast_eq_natCast_iff, h_mod ];
    rw [ Finset.sum_eq_single ( p / 2 ) ] <;> norm_num;
    · cases Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) <;> simp_all +decide [ Nat.choose_eq_zero_of_lt ];
      · subst_vars; norm_num [ legendreSym ] ;
      · rw [ show 2 * ( p / 2 ) + 1 = p by linarith [ Nat.mod_add_div p 2 ] ] ; norm_num;
    · intro b hb₁ hb₂; left; norm_cast;
      rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime p ) ( by omega ) ( by omega );
  · exact_mod_cast h_closed_form p |>.trans h_mod

/-
The n-th Pell number is even if and only if n is even.
-/
theorem pellNumber_even_iff (n : ℕ) : Even (pellNumber n) ↔ Even n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> simp +arith +decide [ *, Nat.even_add, Nat.even_mul ] at *;
  rw [ show pellNumber ( n + 3 ) = 2 * pellNumber ( n + 2 ) + pellNumber ( n + 1 ) by rfl ] ; simp +arith +decide [ *, parity_simps ]

/-
Pell numbers are greater than or equal to their index.
-/
theorem pellNumber_ge_n (n : ℕ) : pellNumber n ≥ n := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> simp +arith +decide [ *, pellNumber ];
  grind

/-
For any odd prime p, any prime divisor q of P_p satisfies q = 1 mod 2p or q = -1 mod 2p.
-/
theorem prime_divisors_of_pell_prime_index {p q : ℕ} (hp : Nat.Prime p) (hp_odd : p ≠ 2) (hq : Nat.Prime q) (h_div : q ∣ pellNumber p) :
    q ≡ 1 [MOD 2 * p] ∨ q ≡ 2 * p - 1 [MOD 2 * p] := by
      -- By definition of $k$, we know that $q \mid P_{p}$ implies $k \mid p$.
      obtain ⟨k, hk⟩ : ∃ k > 0, q ∣ pellNumber k ∧ ∀ j > 0, q ∣ pellNumber j → k ∣ j := by
        obtain ⟨k, hk⟩ : ∃ k > 0, q ∣ pellNumber k := by
          exact ⟨ p, hp.pos, h_div ⟩;
        have h_rank_of_appearance : ∀ n, q ∣ pellNumber n ↔ (Nat.find (⟨k, hk.left, hk.right⟩ : ∃ k > 0, q ∣ pellNumber k)) ∣ n := by
          convert pellNumber_rank_of_appearance q ( Nat.prime_iff.mp hq ) _;
        exact ⟨ Nat.find ( ⟨ k, hk.1, hk.2 ⟩ : ∃ k > 0, q ∣ pellNumber k ), Nat.find_spec ( ⟨ k, hk.1, hk.2 ⟩ : ∃ k > 0, q ∣ pellNumber k ) |>.1, Nat.find_spec ( ⟨ k, hk.1, hk.2 ⟩ : ∃ k > 0, q ∣ pellNumber k ) |>.2, fun j hj hj' => h_rank_of_appearance j |>.1 hj' ⟩;
      -- Since we are assuming $q \mid P_p$, the rank of appearance $k$ must divide $p$. Recall that $p$ is a prime number.
      have hk_div_p : k ∣ p := by
        exact hk.2.2 p hp.pos h_div
      have hk_cases : k = 1 ∨ k = p := by
        rwa [ Nat.dvd_prime hp ] at hk_div_p
      cases hk_cases <;> simp_all +decide [ Nat.dvd_prime ];
      · exact absurd hk ( Nat.Prime.not_dvd_one hq );
      · -- By definition of $k$, we know that $q \mid P_{q-1}$ or $q \mid P_{q+1}$.
        have h_div_q_minus_one_or_q_plus_one : q ∣ pellNumber (q - 1) ∨ q ∣ pellNumber (q + 1) := by
          haveI := Fact.mk hq; have := @pell_divides_sub_one_of_legendre_one q; have := @pell_divides_add_one_of_legendre_neg_one q; simp_all +decide [ legendreSym ] ;
          by_cases hq2 : q = 2 <;> simp_all +decide [ quadraticCharFun ];
          · contrapose! hk;
            exact fun _ => ⟨ 2, by decide, by decide, Nat.not_dvd_of_pos_of_lt ( by decide ) ( lt_of_le_of_ne hp.two_le ( Ne.symm hp_odd ) ) ⟩;
          · split_ifs at * <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
            rcases q with ( _ | _ | _ | q ) <;> cases ‹_› <;> trivial;
        -- Since $p \mid k$, we have $p \mid q - 1$ or $p \mid q + 1$.
        have h_div_p_q_minus_one_or_q_plus_one : p ∣ q - 1 ∨ p ∣ q + 1 := by
          exact Or.imp ( fun h => hk.2 _ ( Nat.sub_pos_of_lt hq.one_lt ) h ) ( fun h => hk.2 _ ( Nat.succ_pos _ ) h ) h_div_q_minus_one_or_q_plus_one;
        -- Since $q$ is an odd prime, we have $q \equiv 1 \pmod{2}$.
        have h_q_mod_two : q ≡ 1 [MOD 2] := by
          cases hq.eq_two_or_odd <;> simp_all +decide [ Nat.ModEq ];
        -- Since $p$ is an odd prime, we have $p \mid q - 1$ or $p \mid q + 1$ implies $2p \mid q - 1$ or $2p \mid q + 1$.
        have h_div_2p_q_minus_one_or_q_plus_one : 2 * p ∣ q - 1 ∨ 2 * p ∣ q + 1 := by
          cases h_div_p_q_minus_one_or_q_plus_one <;> simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
          · exact Or.inl ( Nat.mod_eq_zero_of_dvd <| by exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( Nat.coprime_comm.mp <| hp.coprime_iff_not_dvd.mpr fun h => hp_odd <| by have := Nat.le_of_dvd ( by linarith ) h; interval_cases p <;> trivial ) ( Nat.dvd_of_mod_eq_zero <| by omega ) ( Nat.dvd_of_mod_eq_zero <| by omega ) );
          · exact Or.inr ( Nat.mod_eq_zero_of_dvd <| by exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( show Nat.Coprime 2 p from Nat.prime_two.coprime_iff_not_dvd.mpr fun h => hp_odd <| by have := Nat.prime_dvd_prime_iff_eq Nat.prime_two hp; tauto ) ( Nat.dvd_of_mod_eq_zero <| by omega ) <| Nat.dvd_of_mod_eq_zero <| by omega );
        rcases h_div_2p_q_minus_one_or_q_plus_one with h | h <;> obtain ⟨ k, hk ⟩ := h <;> simp_all +decide [ Nat.modEq_iff_dvd ];
        · exact Or.inl ⟨ -k, by linarith [ Nat.sub_add_cancel hq.pos ] ⟩;
        · exact Or.inr ⟨ -k + 1, by linarith ⟩

/-
The exponent of 2 in the prime factorization of P_n is equal to the exponent of 2 in the prime factorization of n.
-/
theorem pellNumber_valuation_two (n : ℕ) : Nat.factorization (pellNumber n) 2 = Nat.factorization n 2 := by
  revert n;
  -- We'll use induction on the exponent of 2 in n.
  have h_ind : ∀ k m : ℕ, m % 2 = 1 → (pellNumber (2^k * m)).factorization 2 = k := by
    intro k m hm_odd;
    induction' k with k ih generalizing m <;> simp_all +decide [ pow_succ', mul_assoc ];
    · rw [ Nat.factorization_eq_zero_of_not_dvd ];
      rw [ ← Nat.mod_add_div m 2, hm_odd ];
      induction m / 2 <;> simp_all +arith +decide [ Nat.mul_succ, Nat.add_mod, Nat.mul_mod, pellNumber ];
    · -- Using the recurrence relation $P_{2n} = 2P_n(P_n + P_{n-1})$, we can express $P_{2^{k+1}m}$ in terms of $P_{2^km}$.
      have h_recurrence : pellNumber (2 * (2 ^ k * m)) = 2 * pellNumber (2 ^ k * m) * (pellNumber (2 ^ k * m) + pellNumber (2 ^ k * m - 1)) := by
        have h_recurrence : ∀ n ≥ 1, pellNumber (2 * n) = 2 * pellNumber n * (pellNumber n + pellNumber (n - 1)) := by
          intro n hn
          have h_recurrence : pellNumber (n + n) = pellNumber n * pellNumber (n + 1) + pellNumber (n - 1) * pellNumber n := by
            exact pellNumber_add n n hn;
          convert h_recurrence using 1 <;> ring;
          rw [ add_comm 1 n ] ; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ] ; ring;
        exact h_recurrence _ ( Nat.mul_pos ( pow_pos ( by decide ) _ ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) );
      rw [ h_recurrence, Nat.factorization_mul, Nat.factorization_mul ] <;> simp_all +decide [ Nat.factorization_eq_zero_iff ];
      · rw [ Nat.factorization_eq_zero_of_not_dvd ] ; simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ];
        · ring;
        · -- By definition of Pell numbers, we know that $P_n$ is even if and only if $n$ is even.
          have h_pell_even : ∀ n, Even (pellNumber n) ↔ Even n := by
            exact?;
          cases h : 2 ^ k * m <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ];
          grind;
      · -- By definition of Pell numbers, $P_n$ is positive for all $n \geq 1$.
        have h_pos : ∀ n ≥ 1, 0 < pellNumber n := by
          intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ] ;
        exact ne_of_gt ( h_pos _ ( Nat.mul_pos ( pow_pos ( by decide ) _ ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) );
      · -- By definition of Pell numbers, $P_n$ is positive for all $n \geq 1$.
        have h_pell_pos : ∀ n ≥ 1, 0 < pellNumber n := by
          intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ] ;
        exact ne_of_gt ( h_pell_pos _ ( Nat.mul_pos ( pow_pos ( by decide ) _ ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) );
      · -- Since Pell numbers are positive for all n ≥ 1, pellNumber (2^k * m) cannot be zero.
        have h_pos : ∀ n ≥ 1, 0 < pellNumber n := by
          intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pellNumber ] ;
        exact fun h => absurd h ( ne_of_gt ( h_pos _ ( Nat.mul_pos ( pow_pos ( by decide ) _ ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ) );
  intro n; specialize h_ind ( Nat.factorization n 2 ) ( n / 2 ^ Nat.factorization n 2 ) ; by_cases hn : n = 0 <;> simp_all +decide [ Nat.mul_div_cancel' ( Nat.ordProj_dvd n 2 ) ] ;
  exact h_ind ( Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) ( Nat.not_dvd_ordCompl ( by norm_num ) ( by aesop ) ) )

/-
Definition of Pell-Lucas numbers and the identity Q_n^2 - 8P_n^2 = 4(-1)^n.
-/
def pellLucasNumber : ℕ → ℕ
  | 0 => 2
  | 1 => 2
  | (n + 2) => 2 * pellLucasNumber (n + 1) + pellLucasNumber n

theorem pellLucasNumber_sq_sub_eight_mul_pellNumber_sq (n : ℕ) :
    (pellLucasNumber n : ℤ) ^ 2 - 8 * (pellNumber n : ℤ) ^ 2 = 4 * (-1) ^ n := by
      induction' n using Nat.strong_induction_on with n ih;
      rcases n with ( _ | _ | _ | n ) <;> norm_num [ pellNumber, pellLucasNumber ] at *;
      have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ; norm_num [ pow_succ, pellNumber, pellLucasNumber ] at * ; linarith;

/-
Doubling formula for Pell numbers: P_{2n} = P_n * Q_n.
-/
theorem pellNumber_two_mul (n : ℕ) : pellNumber (2 * n) = pellNumber n * pellLucasNumber n := by
  -- We'll use induction to prove that the Pell-Lucas numbers satisfy the same recurrence relation as the Pell numbers.
  have h_recurrence : ∀ n, pellLucasNumber (n + 2) = 2 * pellLucasNumber (n + 1) + pellLucasNumber n := by
    exact?;
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | _ | n ) <;> simp +arith +decide [ *, Nat.mul_succ ];
  have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; have := ih ( n + 2 ) ( by linarith ) ; simp_all +decide [ Nat.mul_succ, pellNumber ] ;
  linarith

/-
GCD of P_n and Q_n is 2 if n is even, and 1 if n is odd.
-/
theorem gcd_pell_pellLucas (n : ℕ) : Nat.gcd (pellNumber n) (pellLucasNumber n) = if Even n then 2 else 1 := by
  -- By definition of $P_n$ and $Q_n$, we know that $Q_n^2 - 8P_n^2 = 4(-1)^n$.
  have h_pell_lucas : (pellLucasNumber n : ℤ) ^ 2 - 8 * (pellNumber n : ℤ) ^ 2 = 4 * (-1 : ℤ) ^ n := by
    exact?;
  split_ifs;
  · have h_even : 2 ∣ pellNumber n ∧ 2 ∣ pellLucasNumber n := by
      have h_even : ∀ n, Even n → 2 ∣ pellNumber n ∧ 2 ∣ pellLucasNumber n := by
        intro n hn; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +arith +decide [ ← even_iff_two_dvd, parity_simps ] ;
        exact ⟨ by rw [ show pellNumber ( n + 2 ) = 2 * pellNumber ( n + 1 ) + pellNumber n from rfl ] ; simp +arith +decide [ *, parity_simps ], by rw [ show pellLucasNumber ( n + 2 ) = 2 * pellLucasNumber ( n + 1 ) + pellLucasNumber n from rfl ] ; simp +arith +decide [ *, parity_simps ] ⟩;
      exact h_even n ‹_›;
    obtain ⟨ k, hk ⟩ := h_even.left; obtain ⟨ m, hm ⟩ := h_even.right; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
    norm_num [ Nat.gcd_mul_left ];
    -- From the equation $m^2 - 8k^2 = 1$, we can see that $m$ and $k$ are coprime.
    have h_coprime : Nat.gcd (m ^ 2) (k ^ 2) = 1 := by
      norm_num [ show m ^ 2 = 8 * k ^ 2 + 1 by linarith ];
    simpa [ Nat.coprime_comm ] using h_coprime;
  · -- If $n$ is odd, then $-1$ is not a quadratic residue modulo $p$, so $p$ cannot divide both $P_n$ and $Q_n$.
    by_contra h_contra
    obtain ⟨p, hp_prime, hp_div_pell, hp_div_lucas⟩ : ∃ p, Nat.Prime p ∧ p ∣ pellNumber n ∧ p ∣ pellLucasNumber n := by
      exact Nat.Prime.not_coprime_iff_dvd.mp h_contra;
    replace h_pell_lucas := congr_arg ( ( ↑ ) : ℤ → ZMod p ) h_pell_lucas ; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
    erw [ ZMod.natCast_eq_zero_iff ] at *;
    have := Nat.le_of_dvd ( by decide ) h_pell_lucas; interval_cases p <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
    exact absurd hp_div_pell ( by rw [ pellNumber_even_iff ] ; aesop )