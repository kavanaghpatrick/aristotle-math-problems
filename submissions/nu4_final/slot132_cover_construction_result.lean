/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b6583b41-4d03-44a7-bdb8-b14e63674ea7
-/

/-
Constructed an explicit edge cover of size ≤ 8 for the Cycle4 case.
The cover consists of 4 edges covering the M-elements (one per element) and 4 edges covering the external triangles at the shared vertices.
The main results are `full_cover_card_le_8` and `full_cover_covers_all`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

/-- M-edges incident to vertex v -/
def M_edges_at (M : Finset (Finset V)) (v : V) : Finset (Sym2 V) :=
  M.biUnion (fun X => X.sym2.filter (fun e => v ∈ e))

/-- Triangles that share an M-edge containing v -/
def trianglesSharingMEdgeAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => ∃ e ∈ M_edges_at M v, e ∈ t.sym2)

def externalTrianglesAt (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  trianglesSharingMEdgeAt G M v \ M

/-- Triangle covering number -/
noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  sInf { n | ∃ E : Finset (Sym2 V), E.card = n ∧ E ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E, e ∈ t.sym2 }

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A
  h_diag_AC : (A ∩ C).card ≤ 1
  h_diag_BD : (B ∩ D).card ≤ 1
  h_vab_ne_vbc : v_ab ≠ v_bc
  h_vbc_ne_vcd : v_bc ≠ v_cd
  h_vcd_ne_vda : v_cd ≠ v_da
  h_vda_ne_vab : v_da ≠ v_ab

variable (cycle4_all_triangles_contain_shared : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3),
    cfg.v_ab ∈ t ∨ cfg.v_bc ∈ t ∨ cfg.v_cd ∈ t ∨ cfg.v_da ∈ t)

variable (external_share_common_vertex : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (v : V) (h_shared : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da),
    ∃ x : V, x ≠ v ∧ ∀ t ∈ externalTrianglesAt G M v, x ∈ t)

/-- The 4 edges covering M-elements -/
def M_cover_edges {G : SimpleGraph V} [DecidableRel G.Adj] {M : Finset (Finset V)} (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, cfg.v_da), s(cfg.v_ab, cfg.v_bc), s(cfg.v_bc, cfg.v_cd), s(cfg.v_cd, cfg.v_da)}

lemma M_cover_edges_card {G : SimpleGraph V} [DecidableRel G.Adj]
    {M : Finset (Finset V)} (cfg : Cycle4 G M) :
    (M_cover_edges cfg).card ≤ 4 := by
      -- Since the set has exactly four elements, its cardinality is 4.
      have h_card : (M_cover_edges cfg).card = 4 := by
        -- Since the edges are distinct, the set has exactly four elements.
        have h_distinct : cfg.v_ab ≠ cfg.v_bc ∧ cfg.v_ab ≠ cfg.v_cd ∧ cfg.v_ab ≠ cfg.v_da ∧ cfg.v_bc ≠ cfg.v_cd ∧ cfg.v_bc ≠ cfg.v_da ∧ cfg.v_cd ≠ cfg.v_da := by
          have := cfg.h_vab_ne_vbc; have := cfg.h_vbc_ne_vcd; have := cfg.h_vcd_ne_vda; have := cfg.h_vda_ne_vab; aesop;
          · have := cfg.hAB; have := cfg.hBC; have := cfg.hCD; have := cfg.hDA; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
          · have := cfg.hBC; have := cfg.hCD; have := cfg.hDA; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
        unfold M_cover_edges;
        rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_singleton ] <;> simp +decide [ *, Sym2.eq_iff ];
        tauto;
      exact h_card.le

lemma M_cover_covers_M {G : SimpleGraph V} [DecidableRel G.Adj]
    {M : Finset (Finset V)} (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (X : Finset V) (hX : X ∈ M) :
    ∃ e ∈ M_cover_edges cfg, e ∈ X.sym2 := by
      -- Since X is in M and M is a maximum packing, X must be one of the triangles A, B, C, or D.
      have hX_triangle : X = cfg.A ∨ X = cfg.B ∨ X = cfg.C ∨ X = cfg.D := by
        have := cfg.hM_eq ▸ hX; aesop;
      -- By definition of cycle4, each of the triangles A, B, C, and D has at least one edge that is part of the M_cover_edges.
      cases' hX_triangle with hX_A hX_B hX_C hX_D;
      · simp_all +decide [ M_cover_edges ];
        exact Or.inl ⟨ cfg.h_vab_A, cfg.h_vda_A ⟩;
      · rcases hX_B with ( rfl | rfl | rfl );
        · simp +decide [ M_cover_edges, cfg.hAB ];
          exact Or.inr <| Or.inl ⟨ cfg.h_vab_B, cfg.h_vbc_B ⟩;
        · use s(cfg.v_bc, cfg.v_cd);
          simp +decide [ M_cover_edges ];
          exact ⟨ cfg.h_vbc_C, cfg.h_vcd_C ⟩;
        · -- Since cfg.D contains v_cd and v_da, the edge {v_cd, v_da} is in cfg.D's sym2.
          use s(cfg.v_cd, cfg.v_da)
          simp [M_cover_edges];
          exact ⟨ cfg.h_vcd_D, cfg.h_vda_D ⟩

noncomputable def get_x_ab (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_ab (Or.inl rfl)).choose

noncomputable def get_x_bc (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_bc (Or.inr (Or.inl rfl))).choose

noncomputable def get_x_cd (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_cd (Or.inr (Or.inr (Or.inl rfl)))).choose

noncomputable def get_x_da (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : V :=
  (external_share_common_vertex G M hM cfg cfg.v_da (Or.inr (Or.inr (Or.inr rfl)))).choose

#check get_x_ab

/-- The 4 edges covering external triangles -/
noncomputable def external_cover_edges (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  {s(cfg.v_ab, get_x_ab external_share_common_vertex G M hM cfg),
   s(cfg.v_bc, get_x_bc external_share_common_vertex G M hM cfg),
   s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg),
   s(cfg.v_da, get_x_da external_share_common_vertex G M hM cfg)}

#check M_cover_covers_M

lemma external_cover_edges_card (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) :
    (external_cover_edges external_share_common_vertex G M hM cfg).card ≤ 4 := by
      -- Since the set has exactly 4 elements, its cardinality is 4.
      simp [external_cover_edges];
      grind

lemma external_triangle_contains_v (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (t : Finset V)
    (ht : t ∈ externalTrianglesAt G M v) : v ∈ t := by
      -- By definition of externalTrianglesAt, there exists an e in M_edges_at M v such that e is in t.sym2.
      obtain ⟨e, heM, heT⟩ : ∃ e ∈ M_edges_at M v, e ∈ t.sym2 := by
        have h_def : t ∈ externalTrianglesAt G M v := ht
        -- By definition of trianglesSharingMEdgeAt, if t is in this set, then there exists an e in M_edges_at M v such that e is in t.sym2.
        have h_def : t ∈ trianglesSharingMEdgeAt G M v := by
          exact Finset.mem_sdiff.mp h_def |>.1;
        unfold trianglesSharingMEdgeAt at h_def; aesop;
      unfold M_edges_at at heM; aesop;

#check external_cover_edges

lemma external_cover_covers_vab (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_ab) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
  -- Since $t$ is an external triangle at $v_ab$, it must contain the vertex $x_{ab}$.
  have h_x_ab_in_t : get_x_ab external_share_common_vertex G M hM cfg ∈ t := by
    exact (external_share_common_vertex G M hM cfg cfg.v_ab (Or.inl rfl)).choose_spec.2 t ht;
  -- Since t contains v_ab and x_ab, the edge {v_ab, x_ab} is in t.sym2.
  use s(cfg.v_ab, get_x_ab external_share_common_vertex G M hM cfg);
  simp +decide [ external_cover_edges, h_x_ab_in_t ];
  exact?

lemma external_cover_covers_vbc (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_bc) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- By definition of `get_x_bc`, we know that `get_x_bc` is in `t`.
      have h_get_x_bc_in_t : get_x_bc external_share_common_vertex G M hM cfg ∈ t := by
        exact ( external_share_common_vertex G M hM cfg cfg.v_bc ( Or.inr ( Or.inl rfl ) ) |> Exists.choose_spec |> And.right ) t ht;
      use s(cfg.v_bc, get_x_bc external_share_common_vertex G M hM cfg);
      -- By definition of `external_cover_edges`, the edge `s(cfg.v_bc, get_x_bc)` is included.
      simp [external_cover_edges];
      exact ⟨ by simpa using external_triangle_contains_v G M cfg.v_bc t ht, h_get_x_bc_in_t ⟩

lemma external_cover_covers_vcd (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_cd) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- By definition of `external_cover_edges`, the edge `{v_cd, x_cd}` is in the cover.
      use s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg);
      -- By definition of `external_cover_edges`, we know that `s(cfg.v_cd, get_x_cd external_share_common_vertex G M hM cfg)` is in the cover.
      simp [external_cover_edges];
      -- Since $t \in \text{externalTrianglesAt } G M cfg.v_cd$, by definition, $cfg.v_cd \in t$.
      have h_vcd : cfg.v_cd ∈ t := by
        -- By definition of `externalTrianglesAt`, we know that `cfg.v_cd ∈ t`.
        apply external_triangle_contains_v G M cfg.v_cd t ht;
      exact ⟨ h_vcd, ( external_share_common_vertex G M hM cfg cfg.v_cd ( Or.inr ( Or.inr ( Or.inl rfl ) ) ) |> Exists.choose_spec |> And.right ) t ht ⟩

lemma external_cover_covers_vda (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ externalTrianglesAt G M cfg.v_da) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
      -- Since $t$ is in the externalTrianglesAt $G$ $M$ $cfg.v_da$, by definition, $cfg.v_da$ is in $t$.
      have h_vda_in_t : cfg.v_da ∈ t := by
        exact?
      generalize_proofs at *;
      -- By definition of `external_cover_edges`, the edge `{cfg.v_da, get_x_da}` is in the external cover edges.
      use s(cfg.v_da, get_x_da external_share_common_vertex G M hM cfg);
      -- The edge {cfg.v_da, get_x_da} is in the external cover edges by definition.
      simp [external_cover_edges];
      exact ⟨ h_vda_in_t, ( external_share_common_vertex G M hM cfg cfg.v_da ( Or.inr ( Or.inr ( Or.inr rfl ) ) ) |> Exists.choose_spec |> And.right ) t ht ⟩

/-- The full cover: M edges + external edges -/
noncomputable def full_cover (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) : Finset (Sym2 V) :=
  M_cover_edges cfg ∪ external_cover_edges external_share_common_vertex G M hM cfg

#check external_cover_edges_card

theorem full_cover_card_le_8 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M) :
    (full_cover external_share_common_vertex G M hM cfg).card ≤ 8 := by
  unfold full_cover
  calc (M_cover_edges cfg ∪ external_cover_edges external_share_common_vertex G M hM cfg).card
    ≤ (M_cover_edges cfg).card + (external_cover_edges external_share_common_vertex G M hM cfg).card := Finset.card_union_le _ _
    _ ≤ 4 + 4 := Nat.add_le_add (M_cover_edges_card cfg) (external_cover_edges_card external_share_common_vertex G M hM cfg)
    _ = 8 := rfl

variable (shares_edge_with_packing : ∀ (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_notin_M : t ∉ M),
    ∃ X ∈ M, ∃ e ∈ X.sym2, e ∈ t.sym2)

lemma insert_is_packing_of_disjoint (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3)
    (h_disjoint : ∀ X ∈ M, (t ∩ X).card ≤ 1) :
    isTrianglePacking G (insert t M) := by
      -- Since $t$ is in $G.cliqueFinset 3$, adding it to $M$ will still keep it within the cliqueFinset.
      have h_clique : Insert.insert t M ⊆ G.cliqueFinset 3 := by
        exact Finset.insert_subset ht hM.1;
      refine' ⟨ h_clique, _ ⟩;
      intro x hx y hy hxy; by_cases hx' : x = t <;> by_cases hy' : y = t <;> simp_all +decide ;
      · simpa only [ Finset.inter_comm ] using h_disjoint x hx;
      · exact hM.2 hx hy hxy

lemma pairwise_disjoint_symmetric : Symmetric (fun (t1 t2 : Finset V) => (t1 ∩ t2).card ≤ 1) := by
  intro t1 t2 h
  rwa [Finset.inter_comm]

#print insert_is_packing_of_disjoint

lemma triangle_card_eq_3 (G : SimpleGraph V) [DecidableRel G.Adj]
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) : t.card = 3 :=
  (SimpleGraph.mem_cliqueFinset_iff.mp ht).2

/-- Every packing element is a triangle -/
lemma packing_element_is_triangle (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isTrianglePacking G M) (X : Finset V) (hX : X ∈ M) :
    X ∈ G.cliqueFinset 3 := hM.1 hX

lemma mem_trianglesSharingMEdgeAt_iff (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (v : V) (hv : ∃ X ∈ M, v ∈ X) (t : Finset V) :
    t ∈ trianglesSharingMEdgeAt G M v ↔ t ∈ G.cliqueFinset 3 ∧ v ∈ t := by
      -- By definition of trianglesSharingMEdgeAt, if t is in it, then t is a triangle and there exists an edge e in M_edges_at M v that's in t.sym2.
      simp [trianglesSharingMEdgeAt, M_edges_at];
      -- If $t$ is a triangle in $G$ and $v \in t$, then there exists an edge $e$ in $M_edges_at M v$ that is in $t.sym2$.
      intro ht
      constructor
      intro h
      obtain ⟨e, heM, he_t⟩ := h
      aesop;
      intro hv_in_t;
      -- Since $v \in t$ and $t$ is a triangle, there exists an edge $e$ in $t$ that includes $v$.
      use s(v, v);
      aesop

lemma edges_of_clique3_incident_to_two_of_nodiag {V : Type*} [DecidableEq V]
    (T : Finset V) (hT : T.card = 3) (u v : V) (hu : u ∈ T) (hv : v ∈ T) (huv : u ≠ v)
    (e : Sym2 V) (he : e ∈ T.sym2) (h_nodiag : ¬ e.IsDiag) :
    u ∈ e ∨ v ∈ e := by
      -- Since e is in T.sym2, it must be a pair of distinct elements from T. Given that u and v are in T and u ≠ v, the pair u-v is exactly e. Therefore, either u is in e or v is in e.
      have h_pair : ∃ x y : V, x ∈ T ∧ y ∈ T ∧ x ≠ y ∧ e = s(x, y) := by
        rcases e with ⟨ x, y ⟩ ; aesop;
      -- Since $x$ and $y$ are distinct elements of $T$, and $u$ and $v$ are also distinct elements of $T$, the pair $s(x, y)$ must contain either $u$ or $v$.
      obtain ⟨x, y, hx, hy, hxy, rfl⟩ := h_pair;
      by_cases hxu : x = u ∨ y = u;
      aesop;
      by_cases hyv : x = v ∨ y = v;
      aesop;
      exact False.elim (huv (by
      have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset hx ( Finset.insert_subset hy ( Finset.singleton_subset_iff.mpr hv ) ) ) ; aesop;))

lemma shares_real_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_notin_M : t ∉ M) :
    ∃ X ∈ M, ∃ e ∈ X.sym2, e ∈ t.sym2 ∧ ¬e.IsDiag := by
      have h_disjoint : ∃ X ∈ M, (t ∩ X).card ≥ 2 := by
        by_contra h_contra;
        have h_insert : isTrianglePacking G (insert t M) := by
          apply insert_is_packing_of_disjoint G M hM.1 t ht (by
          exact fun X hX => not_lt.1 fun contra => h_contra ⟨ X, hX, contra ⟩);
        have h_insert_card : (insert t M).card > M.card := by
          exact Finset.card_lt_card ( Finset.ssubset_insert ht_notin_M );
        have := hM.2;
        unfold trianglePackingNumber at this;
        have h_insert_card : (insert t M).card ≤ (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max.getD 0 := by
          have h_insert_card : (insert t M).card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
            simp +zetaDelta at *;
            use Insert.insert t M;
            simp_all +decide [ Finset.subset_iff, isTrianglePacking ];
          have h_insert_card : ∀ x ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset), x ≤ (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max.getD 0 := by
            intros x hx;
            have := Finset.le_max hx;
            cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
          exact h_insert_card _ ‹_›;
        linarith;
      obtain ⟨ X, hX₁, hX₂ ⟩ := h_disjoint; obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.mp hX₂; use X, hX₁; use s(u, v); aesop;

#check Finset.one_lt_card_iff
#check Sym2.isDiag_iff_proj_eq

lemma card_inter_le_one_of_no_shared_edge {V : Type*} [DecidableEq V]
    (t X : Finset V)
    (h_no_share : ∀ e ∈ X.sym2, e ∈ t.sym2 → e.IsDiag) :
    (t ∩ X).card ≤ 1 := by
      -- If t and X share an element, that element must be the same in both, so the intersection can't have more than one element.
      have h_disjoint : ∀ x ∈ t ∩ X, ∀ y ∈ t ∩ X, x = y := by
        intro x hx y hy; specialize h_no_share ( Sym2.mk ( x, y ) ) ; aesop;
      exact Finset.card_le_one.mpr fun x hx y hy => h_disjoint x hx y hy

lemma edge_in_cycle_incident_to_shared (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (X : Finset V) (hX : X ∈ M) (e : Sym2 V) (he : e ∈ X.sym2) (h_nodiag : ¬e.IsDiag) :
    ∃ v, (v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da) ∧ v ∈ e := by
  rw [cfg.hM_eq] at hX
  simp only [Finset.mem_insert, Finset.mem_singleton] at hX
  rcases hX with rfl | rfl | rfl | rfl
  · -- X = A
    have h_inc : cfg.v_ab ∈ e ∨ cfg.v_da ∈ e :=
      edges_of_clique3_incident_to_two_of_nodiag cfg.A (triangle_card_eq_3 G cfg.A (hM.1.1 cfg.hA))
        cfg.v_ab cfg.v_da cfg.h_vab_A cfg.h_vda_A cfg.h_vda_ne_vab.symm e he h_nodiag
    cases h_inc with
    | inl h => use cfg.v_ab; simp [h]
    | inr h => use cfg.v_da; simp [h]
  · -- X = B
    have h_inc : cfg.v_ab ∈ e ∨ cfg.v_bc ∈ e :=
      edges_of_clique3_incident_to_two_of_nodiag cfg.B (triangle_card_eq_3 G cfg.B (hM.1.1 cfg.hB))
        cfg.v_ab cfg.v_bc cfg.h_vab_B cfg.h_vbc_B cfg.h_vab_ne_vbc e he h_nodiag
    cases h_inc with
    | inl h => use cfg.v_ab; simp [h]
    | inr h => use cfg.v_bc; simp [h]
  · -- X = C
    have h_inc : cfg.v_bc ∈ e ∨ cfg.v_cd ∈ e :=
      edges_of_clique3_incident_to_two_of_nodiag cfg.C (triangle_card_eq_3 G cfg.C (hM.1.1 cfg.hC))
        cfg.v_bc cfg.v_cd cfg.h_vbc_C cfg.h_vcd_C cfg.h_vbc_ne_vcd e he h_nodiag
    cases h_inc with
    | inl h => use cfg.v_bc; simp [h]
    | inr h => use cfg.v_cd; simp [h]
  · -- X = D
    have h_inc : cfg.v_cd ∈ e ∨ cfg.v_da ∈ e :=
      edges_of_clique3_incident_to_two_of_nodiag cfg.D (triangle_card_eq_3 G cfg.D (hM.1.1 cfg.hD))
        cfg.v_cd cfg.v_da cfg.h_vcd_D cfg.h_vda_D cfg.h_vcd_ne_vda e he h_nodiag
    cases h_inc with
    | inl h => use cfg.v_cd; simp [h]
    | inr h => use cfg.v_da; simp [h]

lemma exists_external_triangle_at_shared_vertex (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (ht_notin_M : t ∉ M) :
    ∃ v, (v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da) ∧ t ∈ externalTrianglesAt G M v := by
  obtain ⟨X, hX, e, he_X, he_t, he_nodiag⟩ := shares_real_edge_with_packing G M hM t ht ht_notin_M
  obtain ⟨v, hv_eq, hv_in_e⟩ := edge_in_cycle_incident_to_shared G M hM cfg X hX e he_X he_nodiag
  use v
  constructor
  · exact hv_eq
  · rw [externalTrianglesAt, Finset.mem_sdiff]
    constructor
    · rw [mem_trianglesSharingMEdgeAt_iff G M v ⟨X, hX, by
        -- v ∈ e and e ∈ X.sym2. Does this imply v ∈ X?
        -- Yes, e = {a, b} ⊆ X. v ∈ e → v ∈ X.
        rw [Finset.mem_sym2_iff] at he_X
        exact he_X v hv_in_e
      ⟩]
      constructor
      · exact ht
      · -- v ∈ e and e ∈ t.sym2 → v ∈ t
        rw [Finset.mem_sym2_iff] at he_t
        exact he_t v hv_in_e
    · exact ht_notin_M

theorem full_cover_covers_all (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ e ∈ full_cover external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
  by_cases h_in_M : t ∈ M
  · obtain ⟨e, he, he_t⟩ := M_cover_covers_M hM cfg t h_in_M
    use e
    constructor
    · apply Finset.mem_union_left
      exact he
    · exact he_t
  · obtain ⟨v, hv_eq, hv_ext⟩ := exists_external_triangle_at_shared_vertex G M hM cfg t ht h_in_M
    rcases hv_eq with rfl | rfl | rfl | rfl
    · obtain ⟨e, he, he_t⟩ := external_cover_covers_vab external_share_common_vertex G M hM cfg t hv_ext
      use e
      constructor
      · apply Finset.mem_union_right
        exact he
      · exact he_t
    · obtain ⟨e, he, he_t⟩ := external_cover_covers_vbc external_share_common_vertex G M hM cfg t hv_ext
      use e
      constructor
      · apply Finset.mem_union_right
        exact he
      · exact he_t
    · obtain ⟨e, he, he_t⟩ := external_cover_covers_vcd external_share_common_vertex G M hM cfg t hv_ext
      use e
      constructor
      · apply Finset.mem_union_right
        exact he
      · exact he_t
    · obtain ⟨e, he, he_t⟩ := external_cover_covers_vda external_share_common_vertex G M hM cfg t hv_ext
      use e
      constructor
      · apply Finset.mem_union_right
        exact he
      · exact he_t

lemma external_cover_works (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (cfg : Cycle4 G M)
    (t : Finset V)
    (v : V) (hv : v = cfg.v_ab ∨ v = cfg.v_bc ∨ v = cfg.v_cd ∨ v = cfg.v_da)
    (ht : t ∈ externalTrianglesAt G M v) :
    ∃ e ∈ external_cover_edges external_share_common_vertex G M hM cfg, e ∈ t.sym2 := by
  rcases hv with rfl | rfl | rfl | rfl
  · exact external_cover_covers_vab external_share_common_vertex G M hM cfg t ht
  · exact external_cover_covers_vbc external_share_common_vertex G M hM cfg t ht
  · exact external_cover_covers_vcd external_share_common_vertex G M hM cfg t ht
  · exact external_cover_covers_vda external_share_common_vertex G M hM cfg t ht