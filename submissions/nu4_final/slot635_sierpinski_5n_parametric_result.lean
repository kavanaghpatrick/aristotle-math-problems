/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3d41cf7a-83c4-4baf-8827-e6e8b02f8e14

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for the Sierpinski conjecture: a solution is a triple of positive integers (x, y, z) satisfying 5/n = 1/x + 1/y + 1/z. The conjecture holds for n if such a solution exists. An integer n is exceptional if it is of the form 1260k + 1 where all prime factors of k are 1 mod 4.
-/
def is_sierpinski_sol (n x y z : ℕ) : Prop :=
  x ≠ 0 ∧ y ≠ 0 ∧ z ≠ 0 ∧ (5 : ℚ) / n = 1 / x + 1 / y + 1 / z

def sierpinski_conjecture_holds_for (n : ℕ) : Prop :=
  ∃ x y z : ℕ, is_sierpinski_sol n x y z

def is_exceptional (n : ℕ) : Prop :=
  ∃ k, n = 1260 * k + 1 ∧ ∀ p, Nat.Prime p → p ∣ k → p ≡ 1 [MOD 4]

/-
If n is a non-zero even number, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_div_2 (n : ℕ) (h_pos : n ≠ 0) (h : 2 ∣ n) : sierpinski_conjecture_holds_for n := by
  -- If $2|n$, write $n=2m$. Then $5/n = 5/(2m) = 1/m + 1/m + 1/(2m)$.
  obtain ⟨m, rfl⟩ : ∃ m, n = 2 * m := h
  use m, m, 2 * m;
  exact ⟨ by aesop_cat, by aesop_cat, by aesop_cat, by push_cast; ring ⟩

/-
If n is a non-zero multiple of 3, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_div_3 (n : ℕ) (h_pos : n ≠ 0) (h : 3 ∣ n) : sierpinski_conjecture_holds_for n := by
  -- If 3 divides n, write n = 3m. Then 5/n = 5/(3m) = 1/m + 1/(2m) + 1/(6m).
  obtain ⟨m, rfl⟩ : ∃ m, n = 3 * m := h
  use m, 2 * m, 6 * m
  simp [is_sierpinski_sol];
  grind

/-
If n is a non-zero multiple of 5, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_div_5 (n : ℕ) (h_pos : n ≠ 0) (h : 5 ∣ n) : sierpinski_conjecture_holds_for n := by
  obtain ⟨ m, rfl ⟩ := h;
  -- We use the identity $1/m = 1/(m+2) + 1/((m+1)(m+2)) + 1/(m(m+1))$.
  use m + 2, (m + 1) * (m + 2), m * (m + 1);
  constructor <;> norm_num;
  field_simp;
  exact ⟨ by aesop_cat, by rw [ add_div' ] <;> ring ; aesop_cat ⟩

/-
If n is congruent to 4 modulo 5, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_mod_5_4 (n : ℕ) (h : n % 5 = 4) : sierpinski_conjecture_holds_for n := by
  -- Let's choose x = (n + 1) / 5 + 1, y = ((n + 1) / 5) * (n + 1) + 1, and z = ((n + 1) / 5) * x * y.
  obtain ⟨q, hq⟩ : ∃ q : ℕ, n = 5 * q + 4 := by
    exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- Let's choose x = q + 2, y = (q + 1)(q + 2), and z = (q + 1)n.
  use q + 2, (q + 1) * (q + 2), (q + 1) * (5 * q + 4);
  exact ⟨ by positivity, by positivity, by positivity, by push_cast [ hq ] ; rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> ring <;> positivity ⟩

/-
If n is congruent to 3 modulo 5, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_mod_5_3 (n : ℕ) (h : n % 5 = 3) : sierpinski_conjecture_holds_for n := by
  -- Let's choose $x = q + 1$, $y = (q + 1)n$, and $z = (q + 1)n$.
  obtain ⟨q, hq⟩ : ∃ q : ℕ, n = 5 * q + 3 := by
    exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩
  use q + 1, (q + 1) * n, (q + 1) * n;
  exact ⟨ by linarith, by nlinarith, by nlinarith, by push_cast [ hq ] ; rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> ring <;> positivity ⟩

/-
If n is congruent to 2 modulo 5, the Sierpinski conjecture holds for n.
-/
lemma sierpinski_mod_5_2 (n : ℕ) (h : n % 5 = 2) : sierpinski_conjecture_holds_for n := by
  -- Let $n = 5q + 2$. We analyze $m = (q+1)n$ modulo 3.
  obtain ⟨q, hq⟩ : ∃ q, n = 5 * q + 2 := by
    exact ⟨ n / 5, by rw [ ← h, Nat.div_add_mod ] ⟩;
  -- We analyze $m = (q+1)n$ modulo 3.
  by_cases h_mod3 : (q + 1) * (5 * q + 2) % 3 = 0;
  · -- If $m = 3k$, then $3/m = 1/k = 1/(k+1) + 1/(k(k+1))$.
    obtain ⟨k, hk⟩ : ∃ k, (q + 1) * (5 * q + 2) = 3 * k := by
      exact Nat.modEq_zero_iff_dvd.mp h_mod3
    have h_sol : is_sierpinski_sol (5 * q + 2) (q + 1) (k + 1) (k * (k + 1)) := by
      constructor <;> norm_num;
      field_simp;
      exact ⟨ by nlinarith, by rw [ add_div', mul_div_assoc', eq_div_iff ] <;> norm_cast <;> nlinarith ⟩
    use q + 1, k + 1, k * (k + 1);
    aesop;
  · -- If $m = 3k + 2$, then $3/m = 1/(k+1) + 1/((k+1)m)$.
    obtain ⟨k, hk⟩ : ∃ k, (q + 1) * (5 * q + 2) = 3 * k + 2 := by
      exact ⟨ ( ( q + 1 ) * ( 5 * q + 2 ) ) / 3, by linarith [ Nat.mod_add_div ( ( q + 1 ) * ( 5 * q + 2 ) ) 3, show ( ( q + 1 ) * ( 5 * q + 2 ) ) % 3 = 2 from by norm_num [ Nat.add_mod, Nat.mul_mod ] at *; have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> trivial ] ⟩;
    -- So $5/n = 1/(q+1) + 1/(k+1) + 1/((k+1)(q+1)(5q+2))$.
    have h_solution : (5 : ℚ) / (5 * q + 2) = 1 / (q + 1) + 1 / (k + 1) + 1 / ((k + 1) * (q + 1) * (5 * q + 2)) := by
      field_simp;
      norm_cast; nlinarith only [ hk ] ;
    use q + 1, k + 1, (k + 1) * (q + 1) * (5 * q + 2);
    unfold is_sierpinski_sol; aesop

/-
Definition of numbers generated by the first polynomial identity p1.
-/
def is_p1_generated (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ n = z * (x * (5 * y - 1) - y) - x

/-
Definition of numbers generated by the second polynomial identity p2.
-/
def is_p2_generated (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ n = z * (x * (5 * y - 1) - y) - y

/-
Definition of numbers generated by the third polynomial identity p3.
-/
def is_p3_generated (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ n = z * (x * (5 * y + 1) + y) - x

/-
Test cases for n=61, 121, 181.
-/
lemma sol_61 : sierpinski_conjecture_holds_for 61 := by
  -- For n=61, we can use the solution (x, y, z) = (14, 95, 81130).
  use 14, 95, 81130;
  exact ⟨ by decide, by decide, by decide, by norm_num ⟩
lemma sol_121 : sierpinski_conjecture_holds_for 121 := by
  by_contra h_contra;
  -- Let's choose any solution $x, y, z$ for $n = 121$.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ (5 : ℚ) / 121 = 1 / x + 1 / y + 1 / z := by
    use 33, 121, 363
    norm_num;
  exact h_contra ⟨ x, y, z, by positivity, by positivity, by positivity, h_eq ⟩
lemma sol_181 : sierpinski_conjecture_holds_for 181 := by
  by_contra! h_contra;
  -- Let's choose any solution $x, y, z$ for $n = 181$ and derive a contradiction.
  obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 5 * x * y * z = 181 * (y * z + x * z + x * y) := by
    by_contra h_contra;
    -- Let's choose any solution $x, y, z$ for $n = 181$.
    obtain ⟨x, y, z, hx_pos, hy_pos, hz_pos, h_eq⟩ : ∃ x y z : ℕ, 1 ≤ x ∧ 1 ≤ y ∧ 1 ≤ z ∧ 5 * x * y * z = 181 * (y * z + x * z + x * y) := by
      have h_solutions : ∃ x y : ℕ, 1 ≤ x ∧ 1 ≤ y ∧ 5 * x * y > 181 * (y + x) ∧ (5 * x * y - 181 * (y + x)) ∣ (181 * x * y) := by
        by_cases h₂ : ∃ x ∈ Finset.Icc 1 1000, ∃ y ∈ Finset.Icc 1 1000, 5 * x * y > 181 * (y + x) ∧ (5 * x * y - 181 * (y + x)) ∣ (181 * x * y);
        · exact ⟨ _, _, Finset.mem_Icc.mp h₂.choose_spec.1 |>.1, Finset.mem_Icc.mp h₂.choose_spec.2.choose_spec.1 |>.1, h₂.choose_spec.2.choose_spec.2.1, h₂.choose_spec.2.choose_spec.2.2 ⟩;
        · exact absurd h₂ ( by native_decide );
      obtain ⟨ x, y, hx, hy, hxy, h ⟩ := h_solutions;
      obtain ⟨ z, hz ⟩ := h;
      exact ⟨ x, y, z, hx, hy, by nlinarith [ Nat.sub_add_cancel hxy.le ], by nlinarith [ Nat.sub_add_cancel hxy.le ] ⟩;
    exact h_contra ⟨ x, y, z, hx_pos, hy_pos, hz_pos, h_eq ⟩;
  exact h_contra ⟨ x, y, z, hx_pos.ne', hy_pos.ne', hz_pos.ne', by rw [ div_add_div, div_add_div, div_eq_div_iff ] <;> norm_cast <;> first |linarith|aesop ⟩

/-
Definition of p3_witness and verification that it generates 60s+1.
-/
def p3_witness (x y z : ℕ) : ℕ := z * (x * (5 * y + 1) + y) - x

lemma p3_generates_60s_plus_1 (s : ℕ) : p3_witness 1 (5 * s) 2 = 60 * s + 1 := by
  exact show 2 * ( 1 * ( 5 * ( 5 * s ) + 1 ) + 5 * s ) - 1 = 60 * s + 1 from Nat.sub_eq_of_eq_add <| by ring;

/-
Definition of the first polynomial witness p1.
-/
def p1_witness (x y z : ℕ) : ℕ := z * (x * (5 * y - 1) - y) - x

/-
Definition of the second polynomial witness p2.
-/
def p2_witness (x y z : ℕ) : ℕ := z * (x * (5 * y - 1) - y) - y