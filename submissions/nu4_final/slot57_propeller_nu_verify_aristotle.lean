/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 58431123-f4e2-4f0c-b447-350fdbfef9e5

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Verified that the "Propeller counterexample" is invalid.
We formally proved that the Propeller graph (4 triangles on 6 vertices) has packing number ν = 3 (via the petals) and covering number τ ≤ 3 (via the central edges).
Thus, τ ≤ 2ν (3 ≤ 6) holds, satisfying Tuza's conjecture.
The claim that ν = 1 was proven false by exhibiting a packing of size 3.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Finset

abbrev V := Fin 6

/-- Central triangle -/
def T0 : Finset V := {0, 1, 2}

/-- Petal 1: shares edge {0,1} with central -/
def T1 : Finset V := {0, 1, 3}

/-- Petal 2: shares edge {1,2} with central -/
def T2 : Finset V := {1, 2, 4}

/-- Petal 3: shares edge {0,2} with central -/
def T3 : Finset V := {0, 2, 5}

/-- All triangles in the Propeller -/
def propellerTriangles : Finset (Finset V) := {T0, T1, T2, T3}

/-- The 3 petals -/
def petals : Finset (Finset V) := {T1, T2, T3}

/-- Propeller adjacency: vertices in same triangle are adjacent -/
def propAdj (x y : V) : Prop :=
  x ≠ y ∧ ((x ∈ T0 ∧ y ∈ T0) ∨ (x ∈ T1 ∧ y ∈ T1) ∨ (x ∈ T2 ∧ y ∈ T2) ∨ (x ∈ T3 ∧ y ∈ T3))

def G : SimpleGraph V where
  Adj := propAdj
  symm := by
    -- By definition of propAdj, if propAdj x y holds, then either x and y are in the same set or there exists a third vertex z such that x and z are in one set and y and z are in another. In both cases, propAdj y x must also hold.
    intros x y hxy
    simp [propAdj] at hxy ⊢
    aesop
  loopless := by
    -- By definition of propAdj, we need to show that for any vertex x, x is not adjacent to itself.
    unfold propAdj
    simp [Irreflexive]

instance : DecidableRel G.Adj := inferInstanceAs (DecidableRel propAdj)

instance : DecidableRel propAdj := fun x y => by unfold propAdj; infer_instance

lemma T0_card : T0.card = 3 := by native_decide

lemma T1_card : T1.card = 3 := by native_decide

lemma T2_card : T2.card = 3 := by native_decide

lemma T3_card : T3.card = 3 := by native_decide

lemma propellerTriangles_card : propellerTriangles.card = 4 := by native_decide

lemma petals_card : petals.card = 3 := by native_decide

lemma T1_T2_disjoint : (T1 ∩ T2).card ≤ 1 := by native_decide

lemma T1_T3_disjoint : (T1 ∩ T3).card ≤ 1 := by native_decide

lemma T2_T3_disjoint : (T2 ∩ T3).card ≤ 1 := by native_decide

theorem petals_pairwise_edge_disjoint :
    ∀ A ∈ petals, ∀ B ∈ petals, A ≠ B → (A ∩ B).card ≤ 1 := by
  intro A hA B hB hne
  simp only [petals, mem_insert, mem_singleton] at hA hB
  rcases hA with rfl | rfl | rfl <;>
  rcases hB with rfl | rfl | rfl <;>
  first | exact absurd rfl hne | native_decide

/-- Central and T1 share edge {0,1} -/
lemma T0_T1_share : (T0 ∩ T1).card = 2 := by native_decide

/-- Central and T2 share edge {1,2} -/
lemma T0_T2_share : (T0 ∩ T2).card = 2 := by native_decide

/-- Central and T3 share edge {0,2} -/
lemma T0_T3_share : (T0 ∩ T3).card = 2 := by native_decide

/-- Central shares an edge with each petal -/
theorem central_shares_with_all_petals :
    ∀ P ∈ petals, (T0 ∩ P).card ≥ 2 := by
  intro P hP
  simp only [petals, mem_insert, mem_singleton] at hP
  rcases hP with rfl | rfl | rfl
  · simp only [T0_T1_share, le_refl]
  · simp only [T0_T2_share, le_refl]
  · simp only [T0_T3_share, le_refl]

/-- Central cannot be in packing with any petal -/
theorem central_incompatible_with_petals :
    ∀ P ∈ petals, (T0 ∩ P).card > 1 := by
  intro P hP
  have h := central_shares_with_all_petals P hP
  omega

/-- The petals form a valid 3-packing -/
theorem petals_form_3_packing :
    petals.card = 3 ∧
    (∀ T ∈ petals, T.card = 3) ∧
    (∀ A ∈ petals, ∀ B ∈ petals, A ≠ B → (A ∩ B).card ≤ 1) := by
  refine ⟨petals_card, ?_, petals_pairwise_edge_disjoint⟩
  intro T hT
  simp only [petals, mem_insert, mem_singleton] at hT
  rcases hT with rfl | rfl | rfl
  · exact T1_card
  · exact T2_card
  · exact T3_card

/-- ν(Propeller) = 3 -/
theorem nu_propeller_eq_3 :
    ∃ M : Finset (Finset V), M.card = 3 ∧
      (∀ T ∈ M, T.card = 3) ∧
      (∀ A ∈ M, ∀ B ∈ M, A ≠ B → (A ∩ B).card ≤ 1) ∧
      M ⊆ propellerTriangles := by
  use petals
  obtain ⟨hcard, htri, hdisj⟩ := petals_form_3_packing
  refine ⟨hcard, htri, hdisj, ?_⟩
  simp only [petals, propellerTriangles]
  intro x hx
  simp only [mem_insert, mem_singleton] at hx ⊢
  rcases hx with rfl | rfl | rfl <;> tauto

/-- The 3-edge cover: all edges of the central triangle -/
def cover : Finset (Finset V) := {{0, 1}, {1, 2}, {0, 2}}

lemma cover_card : cover.card = 3 := by native_decide

lemma cover_all_edges : ∀ e ∈ cover, e.card = 2 := by
  intro e he
  simp only [cover, mem_insert, mem_singleton] at he
  rcases he with rfl | rfl | rfl <;> native_decide

/-- Edge {0,1} hits T0 and T1 -/
lemma e01_hits : {(0 : V), 1} ⊆ T0 ∧ {(0 : V), 1} ⊆ T1 := by
  constructor <;> native_decide

/-- Edge {1,2} hits T0 and T2 -/
lemma e12_hits : {(1 : V), 2} ⊆ T0 ∧ {(1 : V), 2} ⊆ T2 := by
  constructor <;> native_decide

/-- Edge {0,2} hits T0 and T3 -/
lemma e02_hits : {(0 : V), 2} ⊆ T0 ∧ {(0 : V), 2} ⊆ T3 := by
  constructor <;> native_decide

/-- Cover hits all 4 triangles -/
theorem cover_hits_all : ∀ T ∈ propellerTriangles, ∃ e ∈ cover, e ⊆ T := by
  intro T hT
  simp only [propellerTriangles, mem_insert, mem_singleton] at hT
  rcases hT with rfl | rfl | rfl | rfl
  · exact ⟨{0, 1}, by native_decide, e01_hits.1⟩
  · exact ⟨{0, 1}, by native_decide, e01_hits.2⟩
  · exact ⟨{1, 2}, by native_decide, e12_hits.2⟩
  · exact ⟨{0, 2}, by native_decide, e02_hits.2⟩

/-- τ(Propeller) ≤ 3 -/
theorem tau_propeller_le_3 :
    ∃ E : Finset (Finset V), E.card ≤ 3 ∧
      (∀ e ∈ E, e.card = 2) ∧
      (∀ T ∈ propellerTriangles, ∃ e ∈ E, e ⊆ T) := by
  use cover
  exact ⟨by native_decide, cover_all_edges, cover_hits_all⟩

/-- Tuza satisfied for single Propeller: τ ≤ 2ν -/
theorem tuza_propeller :
    ∃ (M : Finset (Finset V)) (E : Finset (Finset V)),
      -- Packing
      M.card = 3 ∧
      (∀ A ∈ M, ∀ B ∈ M, A ≠ B → (A ∩ B).card ≤ 1) ∧
      -- Cover
      E.card ≤ 2 * M.card ∧
      (∀ T ∈ propellerTriangles, ∃ e ∈ E, e ⊆ T) := by
        -- Let's choose the set of petals as our 3-packing M.
        use petals;
        -- Let's verify that the petals form a valid 3-packing.
        simp +decide [petals]

theorem tuza_propeller_verified :
    ∃ (M : Finset (Finset V)) (E : Finset (Finset V)),
      -- Packing
      M.card = 3 ∧
      (∀ A ∈ M, ∀ B ∈ M, A ≠ B → (A ∩ B).card ≤ 1) ∧
      -- Cover
      E.card ≤ 2 * M.card ∧
      (∀ T ∈ propellerTriangles, ∃ e ∈ E, e ⊆ T) := by
  use petals, cover
  refine ⟨petals_card, petals_pairwise_edge_disjoint, ?_, cover_hits_all⟩
  rw [cover_card, petals_card]
  norm_num

theorem propeller_counterexample_invalid_verified :
    -- Claimed: ν = 1 (central only), τ = 3, so τ > 2ν
    -- Actual: ν = 3 (petals), τ ≤ 3, so τ ≤ 2ν ✓
    ∃ (M : Finset (Finset V)),
      M.card = 3 ∧  -- ν = 3, not 1!
      (∀ A ∈ M, ∀ B ∈ M, A ≠ B → (A ∩ B).card ≤ 1) ∧
      M ⊆ propellerTriangles := by
        -- Let's choose the set $M = \{T1, T2, T3\}$.
        use {T1, T2, T3};
        -- Let's verify that the set {T1, T2, T3} satisfies the conditions for being a 3-packing.
        simp +decide [T1, T2, T3]