/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2f455f85-638e-4bd9-8e76-9f23ecbb68c2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We derived a formula for k mod A under the assumption 3^q ≡ 1 (mod A).
The formula is k ≡ q - 1 + q²δ₁ - qδ₂ + 3⁻¹(6q+4) (mod A), where δ₁ and δ₂ are defined in terms of q.
We verified numerically that for q=71, this derived value (1103) differs from the actual value of k mod A (2641), which confirms that 3^71 ≢ 1 (mod A) for q=71.
The derived formula provides a strong structural constraint on k for any potential counterexample q.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of A = q² + q + 1 and k = (3^q - 1)/A.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

def k (q : ℕ) : ℕ := (3^q - 1) / A q

/-
q³ ≡ 1 (mod A).
-/
lemma q_cube_mod_A (q : ℕ) : q^3 ≡ 1 [MOD A q] := by
  exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by use q - 1; cases q <;> norm_num [ A ] at * ; linarith )

/-
3 = -q²(1-q)² + A(q²-3q+3).
-/
lemma poly_identity (q : ℕ) :
    3 = -((q : ℤ)^2 * (1 - q)^2) + (A q : ℤ) * (q^2 - 3*q + 3) := by
  unfold A; ring;
  grind

/-
q^(2q) ≡ q (mod A).
-/
lemma q_pow_2q_mod_A (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71) :
    (q : ZMod (A q))^(2*q) = q := by
  -- We know $q^3 \equiv 1 \pmod{A}$.
  have hq3 : q^3 ≡ 1 [MOD A q] := by
    exact?;
  -- Since $q \equiv 71 \pmod{72}$, we have $2q \equiv 1 \pmod{3}$.
  have h2q_mod_3 : 2 * q % 3 = 1 := by
    norm_num [ ← Nat.mod_mod_of_dvd q ( by decide : 3 ∣ 72 ), hq_mod, Nat.mul_mod ];
  rw [ ← Nat.mod_add_div ( 2 * q ) 3, h2q_mod_3 ] ; simp_all +decide [ pow_add, pow_mul, ← ZMod.natCast_eq_natCast_iff ] ;

/-
(1-q)^(2q) ≡ -q² (mod A), assuming 3^q ≡ 1 (mod A).
-/
lemma one_sub_q_pow_2q_mod_A (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (h3q : 3^q ≡ 1 [MOD A q]) :
    (1 - (q : ZMod (A q)))^(2*q) = -(q : ZMod (A q))^2 := by
  -- First, let's use the fact that $(1-q)^2 \equiv -3q \pmod{A}$.
  have h1 : (1 - q : ZMod (A q))^2 = -3 * q := by
    have h1 : (1 - q : ℤ)^2 ≡ -3 * q [ZMOD A q] := by
      exact Int.modEq_iff_dvd.mpr ⟨ -1, by push_cast [ show A q = q ^ 2 + q + 1 from rfl ] ; ring ⟩;
    erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
  -- Since $q = 3m + 2$, we have $q^q \equiv q^2 \pmod{A}$.
  have h_q_pow : (q : ZMod (A q))^q = q^2 := by
    -- Since $q \equiv 2 \pmod{3}$, we have $q = 3m + 2$ for some integer $m$.
    obtain ⟨m, hm⟩ : ∃ m, q = 3 * m + 2 := by
      exact ⟨ q / 3, by omega ⟩;
    -- Since $q^3 \equiv 1 \pmod{A}$, we can write $q^{3m+2} \equiv q^2 \pmod{A}$.
    have hq3 : (q : ZMod (A q))^3 = 1 := by
      convert q_cube_mod_A q using 1;
      norm_num [ ← ZMod.natCast_eq_natCast_iff ];
    rw [ hm, pow_add, pow_mul ] ; aesop;
  simp_all +decide [ pow_mul ];
  rw [ neg_pow ] ; ring;
  rw [ h_q_pow, neg_one_pow_eq_pow_mod_two ] ; norm_num [ Nat.odd_iff.mp ( hq_prime.odd_of_ne_two <| by aesop_cat ) ];
  simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

/-
X ≡ 3 (mod A).
-/
def X (q : ℕ) : ℤ := -((q : ℤ)^2 * (1 - q)^2)
def Y (q : ℕ) : ℤ := (q : ℤ)^2 - 3*q + 3

lemma X_mod_A (q : ℕ) : X q ≡ 3 [ZMOD A q] := by
  -- By definition of $X$, we know that $X q ≡ 3 [ZMOD A q]$ if and only if $3 + q^2 * (1 - q)^2 ≡ 0 [ZMOD A q]$.
  suffices h_cong : (3 + q^2 * (1 - q)^2 : ℤ) ≡ 0 [ZMOD (A q : ℤ)] by
    unfold X; ring_nf at *; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
    linear_combination -h_cong;
  exact Int.modEq_zero_iff_dvd.mpr ⟨ q ^ 2 - 3 * q + 3, by push_cast [ A ] ; ring ⟩

/-
3^q ≡ X^q + q*X^(q-1)*A*Y (mod A²).
-/
lemma expansion_congruence (q : ℕ) (hq_prime : Nat.Prime q) (hA_prime : Nat.Prime (A q)) :
    (3 : ℤ)^q ≡ X q ^ q + q * (X q)^(q-1) * (A q) * Y q [ZMOD (A q)^2] := by
  have h_expand : 3 ^ q = (X q + (A q : ℤ) * Y q) ^ q := by
    unfold X Y A; ring;
    exact congr_arg ( · ^ q ) ( by push_cast; ring );
  -- Expanding $(X + AY)^q$ using the binomial theorem gives us terms up to $A^q$.
  have h_expand : (X q + (A q : ℤ) * Y q) ^ q = X q ^ q + (q : ℤ) * X q ^ (q - 1) * (A q : ℤ) * Y q + ∑ k ∈ Finset.Icc 2 q, Nat.choose q k * X q ^ (q - k) * (A q : ℤ) ^ k * Y q ^ k := by
    rw [ add_comm, add_pow ];
    erw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ mul_pow, mul_assoc, mul_comm, mul_left_comm, Finset.sum_range_succ ];
    linarith [ hq_prime.two_le ];
  norm_num [ Int.modEq_iff_dvd, * ];
  exact Finset.dvd_sum fun x hx => dvd_mul_of_dvd_left ( dvd_mul_of_dvd_right ( pow_dvd_pow _ <| Finset.mem_Icc.mp hx |>.1 ) _ ) _

/-
k ≡ (X^q - 1)/A + q * 3⁻¹ * Y (mod A).
-/
lemma k_congruence (q : ℕ) (hq_prime : Nat.Prime q) (hA_prime : Nat.Prime (A q))
    (h3q : 3^q ≡ 1 [MOD A q]) :
    (k q : ZMod (A q)) = ((X q ^ q - 1) / A q : ℤ) + (q : ZMod (A q)) * (3 : ZMod (A q))⁻¹ * (Y q : ZMod (A q)) := by
  -- From expansion_congruence: 3^q ≡ X^q + q*X^(q-1)*A*Y (mod A^2).
  have h_expansion_congruence : 3^q ≡ X q ^ q + q * X q^(q-1) * (A q : ℤ) * Y q [ZMOD (A q)^2] := by
    exact?;
  -- From 3^q = 1 + k*A, we have 1 + k*A ≡ X^q + q*X^(q-1)*A*Y (mod A^2).
  have h_congruence : (k q : ℤ) * (A q : ℤ) ≡ (X q ^ q - 1) + q * X q^(q-1) * (A q : ℤ) * Y q [ZMOD (A q)^2] := by
    rw [ show ( k q : ℤ ) * ( A q : ℤ ) = ( 3 ^ q - 1 ) from ?_ ];
    · convert h_expansion_congruence.sub_right 1 using 1 ; ring;
    · norm_cast;
      rw [ Int.subNatNat_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ] ; norm_cast;
      exact Nat.div_mul_cancel ( show A q ∣ 3 ^ q - 1 from by simpa [ ← Int.natCast_dvd_natCast ] using h3q.symm.dvd );
  -- Dividing by A: k = (X^q - 1)/A + q*X^(q-1)*Y + m*A.
  obtain ⟨m, hm⟩ : ∃ m : ℤ, (k q : ℤ) = ((X q ^ q - 1) / (A q : ℤ)) + q * X q^(q-1) * Y q + m * (A q : ℤ) := by
    obtain ⟨ m, hm ⟩ := h_congruence.symm.dvd;
    use m;
    have h_div : (X q ^ q - 1) % (A q : ℤ) = 0 := by
      have h_div : (X q ^ q : ℤ) ≡ 1 [ZMOD (A q : ℤ)] := by
        have h_div : (X q : ℤ) ≡ 3 [ZMOD (A q : ℤ)] := by
          exact?;
        exact Eq.trans ( h_div.pow _ ) ( by simpa [ ← Int.natCast_modEq_iff ] using h3q );
      exact h_div.sub_right _;
    exact mul_left_cancel₀ ( Nat.cast_ne_zero.mpr hA_prime.ne_zero ) ( by linarith [ Int.ediv_mul_cancel ( show ( A q : ℤ ) ∣ X q ^ q - 1 from Int.dvd_of_emod_eq_zero h_div ) ] );
  -- Since $X \equiv 3 \pmod{A}$, we have $X^{q-1} \equiv 3^{q-1} \equiv 3^{-1} \pmod{A}$ by Fermat's Little Theorem.
  have h_X_mod_A : (X q : ZMod (A q)) = 3 := by
    have h_X_mod_A : (X q : ℤ) ≡ 3 [ZMOD (A q : ℤ)] := by
      exact?;
    erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop
  have h_X_pow_mod_A : (X q ^ (q - 1) : ZMod (A q)) = 3⁻¹ := by
    haveI := Fact.mk hA_prime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    rw [ inv_eq_of_mul_eq_one_right ] ; cases q <;> simp_all +decide [ pow_succ' ];
  replace hm := congr_arg ( ( ↑ ) : ℤ → ZMod ( A q ) ) hm ; aesop;

/-
k ≡ (X^q - 1)/A + q * X^(q-1) * Y (mod A).
-/
lemma k_mod_A_intermediate (q : ℕ) (hq_prime : Nat.Prime q) (hA_prime : Nat.Prime (A q))
    (h3q : 3^q ≡ 1 [MOD A q]) :
    (k q : ZMod (A q)) = ((X q ^ q - 1) / A q : ℤ) + (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q)) := by
  -- From the expansion_congruence, we have $3^q ≡ X^q + q*X^(q-1)*A*Y (mod A^2)$.
  have h_expansion : (3 : ℤ)^q ≡ X q ^ q + q * X q ^ (q - 1) * (A q : ℤ) * Y q [ZMOD (A q : ℤ)^2] := by
    convert expansion_congruence q hq_prime hA_prime using 1;
  -- Since $3^q = 1 + k*A$, we have $1 + k*A ≡ X^q + q*X^(q-1)*A*Y (mod A^2)$.
  have h1 : (1 + (k q : ℤ) * (A q : ℤ) : ℤ) ≡ X q ^ q + q * X q ^ (q - 1) * (A q : ℤ) * Y q [ZMOD (A q : ℤ)^2] := by
    rw_mod_cast [ Nat.modEq_iff_dvd ] at *;
    rw [ show ( 1 + k q * A q : ℕ ) = 3 ^ q from ?_ ] ; aesop;
    rw [ show k q = ( 3 ^ q - 1 ) / A q from rfl, Nat.div_mul_cancel ];
    · rw [ add_tsub_cancel_of_le ( Nat.one_le_pow _ _ ( by decide ) ) ];
    · simpa [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( Nat.one_le_pow q 3 zero_lt_three ) ] using h3q.neg_right;
  -- This implies $k*A = X^q - 1 + q*X^(q-1)*A*Y + m*A^2$ for some integer $m$.
  obtain ⟨m, hm⟩ : ∃ m : ℤ, (k q : ℤ) * (A q : ℤ) = X q ^ q - 1 + q * X q ^ (q - 1) * (A q : ℤ) * Y q + m * (A q : ℤ)^2 := by
    exact h1.symm.dvd.imp fun m hm => by linarith;
  -- Dividing by A: k = (X^q - 1)/A + q*X^(q-1)*Y + m*A.
  have h_div : (k q : ℤ) = ((X q ^ q - 1) / (A q : ℤ)) + q * X q ^ (q - 1) * Y q + m * (A q : ℤ) := by
    have h_div : (X q ^ q - 1) % (A q : ℤ) = 0 := by
      have h_div : (X q ^ q : ℤ) ≡ 1 [ZMOD (A q : ℤ)] := by
        have h_div : (X q : ℤ) ≡ 3 [ZMOD (A q : ℤ)] := by
          exact?;
        exact Eq.trans ( h_div.pow _ ) ( by simpa [ ← Int.natCast_modEq_iff ] using h3q );
      exact Int.emod_eq_zero_of_dvd <| h_div.symm.dvd;
    nlinarith [ Int.emod_add_mul_ediv ( X q ^ q - 1 ) ( A q : ℤ ), show ( A q : ℤ ) > 0 from Nat.cast_pos.mpr hA_prime.pos ];
  simpa [ ← ZMod.intCast_eq_intCast_iff ] using congr_arg ( fun x : ℤ => x : ℤ → ZMod ( A q ) ) h_div

/-
Evaluate k, term1, and term2 modulo A for q=71.
-/
def term1 (q : ℕ) : ℤ := (X q ^ q - 1) / A q
def term2 (q : ℕ) : ZMod (A q) := (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q))

def val_k (q : ℕ) : ZMod (A q) := k q
def val_term1 (q : ℕ) : ZMod (A q) := term1 q
def val_term2 (q : ℕ) : ZMod (A q) := term2 q

#eval val_k 71
#eval val_term1 71
#eval val_term2 71
#eval (val_term1 71 + val_term2 71)

/-
Evaluate the user's claimed formula for k mod A at q=71.
-/
def target_val (q : ℕ) : ZMod (A q) := 2 * (3 : ZMod (A q))⁻¹ * (q : ZMod (A q))⁻¹

#eval target_val 71

/-
Check if (X^q - 1)/A ≡ q - 1 + q²δ₁ - qδ₂ (mod A).
-/
def delta1 (q : ℕ) : ℤ := ((q : ℤ)^(2*q) - q) / A q
def delta2 (q : ℕ) : ℤ := ((1 - (q : ℤ))^(2*q) + q^2) / A q

def term1_simplified (q : ℕ) : ZMod (A q) :=
  (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * delta1 q - (q : ZMod (A q)) * delta2 q

#eval term1_simplified 71
#eval val_term1 71

/-
Evaluate the actual value of k mod A and the predicted value for q=71.
-/
def q_val : ℕ := 71
def A_val : ℕ := A q_val
def k_val : ℕ := k q_val
def k_mod_A_val : ℕ := k_val % A_val

def predicted_val : ZMod A_val := 2 * (3 : ZMod A_val)⁻¹ * (q_val : ZMod A_val)⁻¹

#eval k_mod_A_val
#eval predicted_val.val

/-
Compute k mod A and the predicted value for q=71. Note that (3*71)^-1 = -24 mod A.
-/
def A_71 : ℕ := 71^2 + 71 + 1
def k_71 : ℕ := (3^71 - 1) / A_71
def k_mod_A_71 : ℕ := k_71 % A_71

def predicted_k_71 : ℕ := (2 * (24 * A_71 - 24)) % A_71 -- 2 * (-24) mod A

#eval k_mod_A_71
#eval predicted_k_71

/-
q^(3n) ≡ 1 + n(q-1)A (mod A²).
-/
lemma q_pow_3n_mod_A_sq (n : ℕ) (q : ℕ) (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2))^(3*n) = 1 + (n : ZMod (A q^2)) * (q - 1) * (A q) := by
  -- Let's rewrite the expression using the binomial theorem.
  have h_binom : (1 + (q - 1) * A q) ^ n ≡ 1 + n * (q - 1) * A q [ZMOD A q ^ 2] := by
    induction' n with n ih;
    · norm_num;
    · convert ih.mul_right ( 1 + ( q - 1 ) * A q ) |> Int.ModEq.trans <| ?_ using 1;
      exact Int.modEq_of_dvd ⟨ -n * ( q - 1 ) ^ 2, by push_cast; ring ⟩;
  -- Since $q^3 \equiv 1 + (q-1)A \pmod{A^2}$, we have $q^{3n} \equiv (1 + (q-1)A)^n \pmod{A^2}$.
  have h_cong : (q ^ 3 : ℤ) ≡ 1 + (q - 1) * A q [ZMOD A q ^ 2] := by
    exact Int.modEq_of_dvd ⟨ 0, by push_cast [ hA ] ; ring ⟩;
  erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; simp_all +decide [ pow_mul ]

/-
Evaluate k mod A for q=71.
-/
def test_q : ℕ := 71
def test_A : ℕ := test_q^2 + test_q + 1
def test_k : ℕ := (3^test_q - 1) / test_A
def test_val : ℕ := test_k % test_A

#eval test_val

/-
Evaluate actual and predicted k mod A for q=71.
-/
def q_test : ℕ := 71
def A_test : ℕ := q_test^2 + q_test + 1

-- We compute k mod A directly
def k_mod_A_test : ℕ :=
  let num := 3^q_test - 1
  let den := A_test
  let k := num / den
  k % den

-- We compute the user's predicted value: 2 * 3⁻¹ * q⁻¹ mod A
-- We need modular inverse.
def inv_mod (a n : ℕ) : ℕ :=
  (a : ZMod n)⁻¹.val

def predicted_test : ℕ :=
  let i3 := inv_mod 3 A_test
  let iq := inv_mod q_test A_test
  (2 * i3 * iq) % A_test

#eval k_mod_A_test
#eval predicted_test

/-
Check if k ≡ (A-1)/2 + q + 14 (mod A) for q=71 and q=359.
-/
def check_hypothesis (q : ℕ) : ℕ :=
  let a := A q
  let k_val := (k q) % a
  let half_minus_one := (a - 1) / 2
  let pred := (half_minus_one + q + 14) % a
  let diff := (k_val + a - pred) % a
  diff

#eval check_hypothesis 71
#eval check_hypothesis 359

/-
Check if 3^71 ≡ 1 mod A for q=71.
-/
def check_3_pow_71_mod_A : ℕ := (3^71) % (71^2 + 71 + 1)
#eval check_3_pow_71_mod_A

/-
Compute term1 and term1 mod q for q=71.
-/
def q_debug : ℕ := 71
def A_debug : ℕ := q_debug^2 + q_debug + 1
def X_debug : ℤ := -((q_debug : ℤ)^2 * (1 - q_debug)^2)
def term1_debug : ℤ := (X_debug ^ q_debug - 1) / A_debug
def term1_mod_q : ℤ := term1_debug % q_debug

#eval term1_debug
#eval term1_mod_q

/-
q * X^(q-1) * Y ≡ 3⁻¹ * (6q + 4) (mod A).
-/
lemma term2_simplification_corrected (q : ℕ) (hq_prime : Nat.Prime q) (hA_prime : Nat.Prime (A q))
    (h3q : 3^q ≡ 1 [MOD A q]) :
    (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q)) = (3 : ZMod (A q))⁻¹ * (6 * q + 4) := by
  -- Since $q^2 ≡ -q - 1 (mod A)$, we have $Y ≡ -q - 1 - 3q + 3 = -4q + 2$.
  have hY : (Y q : ZMod (A q)) = (-4 * q + 2 : ZMod (A q)) := by
    unfold Y; norm_num [ A ] ; ring; norm_cast;
    rw [ show A q = q ^ 2 + q + 1 from rfl ] ; erw [ ZMod.intCast_eq_intCast_iff ] ; norm_num;
    exact Int.modEq_of_dvd ⟨ -1, by push_cast [ Int.subNatNat_eq_coe ] ; ring ⟩;
  -- Since $X \equiv 3 \mod A$, we have $X^{q-1} \equiv 3^{q-1} \equiv 3^{-1} \mod A$.
  have hX_inv : (X q : ZMod (A q))^(q-1) = 3⁻¹ := by
    have hX_inv : (X q : ZMod (A q)) = 3 := by
      have hX : (X q : ℤ) ≡ 3 [ZMOD A q] := by
        exact?;
      erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
    haveI := Fact.mk hA_prime; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    rw [ inv_eq_of_mul_eq_one_right ] ; cases q <;> simp_all +decide [ pow_succ' ];
  rw [ hX_inv, hY ] ; ring;
  have hq_sq : (q : ZMod (A q))^2 + q + 1 = 0 := by
    norm_cast;
    erw [ ZMod.natCast_eq_zero_iff ] ; exact dvd_refl _;
  grind

/-
Compute (X^q - 1)/A mod A for q=71.
-/
def term1_mod_A_debug : ℕ :=
  let t1 := term1_debug
  let a := A_debug
  (t1 % (a : ℤ) + (a : ℤ)) % (a : ℤ) |>.toNat

#eval term1_mod_A_debug

/-
Verify the corrected formula for term1 with the +q term.
-/
def term1_corrected (q : ℕ) : ZMod (A q) :=
  (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * delta1 q - (q : ZMod (A q)) * delta2 q + (q : ZMod (A q))

#eval term1_corrected 71
#eval val_term1 71

/-
Evaluate the consistency check for q=71. If non-zero, we have a contradiction.
-/
def consistency_check (q : ℕ) : ZMod (A q) :=
  let n := (2 * q - 1) / 3
  let m := (q - 2) / 3
  let q_z := (q : ZMod (A q))
  let inv3 := (3 : ZMod (A q))⁻¹
  let term2 := q_z * inv3 * (-4 * q_z + 2)
  let delta1_equiv := (n : ZMod (A q)) * q_z * (q_z - 1)
  let term_from_delta2 := q_z * (m : ZMod (A q)) * (q_z - 1) * q_z^2 - inv3
  (2 * q_z - 1) + q_z^2 * delta1_equiv + term_from_delta2 + term2

#eval consistency_check 71

/-
q^(2q) ≡ q + n(q²-q)A (mod A²).
-/
def n_val (q : ℕ) : ℕ := (2 * q - 1) / 3

lemma q_pow_2q_expansion (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2))^(2*q) = (q : ZMod (A q^2)) + (n_val q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
  have h_factor : (q : ZMod (A q ^ 2)) ^ (2 * q) = (q : ZMod (A q ^ 2)) * (q : ZMod (A q ^ 2)) ^ (3 * (n_val q)) := by
    rw [ ← pow_succ' ];
    rw [ show 2 * q = 3 * n_val q + 1 from by rw [ n_val ] ; omega ];
  have := q_pow_3n_mod_A_sq ( n_val q ) q hA; simp_all +decide [ pow_mul ] ;
  ring

/-
k ≡ Z - q(q-1) + 3⁻¹ (mod A).
-/
lemma k_Z_relation (q : ℕ) (hq_prime : Nat.Prime q) (hA_prime : Nat.Prime (A q))
    (h3q : 3^q ≡ 1 [MOD A q]) :
    (k q : ZMod (A q)) = (term1 q : ZMod (A q)) - (q : ZMod (A q)) * (q - 1) + (3 : ZMod (A q))⁻¹ := by
  have := @term2_simplification_corrected q hq_prime hA_prime h3q; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ; ring;
  -- Substitute the expression for term2 from term2_simplification_corrected into the equation for k.
  have h_subst : (k q : ZMod (A q)) = (term1 q : ZMod (A q)) + (3⁻¹ * (6 * q + 4) : ZMod (A q)) := by
    have h_sub : (k q : ZMod (A q)) = (term1 q : ZMod (A q)) + (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q)) := by
      convert k_mod_A_intermediate q hq_prime hA_prime _ using 1;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
    rw [h_sub, this]
  generalize_proofs at *; (
  have h_simplify : (6 * q + 4 : ZMod (A q)) = 3 * (q - q^2 + 3⁻¹) := by
    have h_simplify : (3 : ZMod (A q)) * (q^2 + q + 1) = 0 := by
      norm_cast; aesop;
    generalize_proofs at *; (
    have h_inv : (3 : ZMod (A q)) * (3⁻¹ : ZMod (A q)) = 1 := by
      haveI := Fact.mk hA_prime; exact mul_inv_cancel₀ ( by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by nlinarith only [ hq_prime.two_le, show A q > 3 by exact lt_add_of_lt_of_nonneg ( lt_add_of_lt_of_nonneg ( by nlinarith only [ hq_prime.two_le ] ) ( by nlinarith only [ hq_prime.two_le ] ) ) ( by nlinarith only [ hq_prime.two_le ] ) ] ) ) ;
    generalize_proofs at *; (
    grind +ring))
  generalize_proofs at *; (
  haveI := Fact.mk hA_prime; simp_all +decide [ mul_comm, mul_assoc, mul_left_comm ] ; ring;
  haveI := Fact.mk hA_prime; norm_num [ sq, mul_assoc, mul_comm, mul_left_comm ] ; ring;
  by_cases h : ( 3 : ZMod ( A q ) ) = 0 <;> simp_all +decide [ sq, mul_assoc ];
  cases q <;> simp_all +decide [ pow_succ' ]))

/-
Debug delta terms and sum for q=71.
-/
def debug_delta (q : ℕ) : List ℕ :=
  let a := A q
  let d1 := delta1 q
  let d2 := delta2 q
  let d1_mod := (d1 % (a : ℤ) + (a : ℤ)) % (a : ℤ)
  let d2_mod := (d2 % (a : ℤ) + (a : ℤ)) % (a : ℤ)
  let t1 := (q - 1) % a
  let t2 := (q^2 * d1_mod) % a
  let t3 := (a - (q * d2_mod) % a) % a
  let sum := (t1 + t2 + t3) % a
  let actual := term1_mod_A_debug
  let diff := (actual + a - sum) % a
  [d1_mod.toNat, d2_mod.toNat, t1, t2.toNat, t3.toNat, sum.toNat, actual, diff.toNat]

#eval debug_delta 71

/-
Compare the derived formula for k with the user's target formula for q=71.
-/
def k_formula (q : ℕ) : ZMod (A q) :=
  (2 * q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * delta1 q - (q : ZMod (A q)) * delta2 q + (3 : ZMod (A q))⁻¹ * (6 * q + 4)

def target_k_user (q : ℕ) : ZMod (A q) :=
  2 * (3 : ZMod (A q))⁻¹ * (q : ZMod (A q))⁻¹

#eval k_formula 71
#eval target_k_user 71

/-
Evaluate the difference between X^q and its expansion for q=71.
-/
def debug_expansion_diff (q : ℕ) : ℤ :=
  let lhs := X q ^ q
  let rhs := (q : ℤ)^3 - (q : ℤ) * (A q) * delta2 q + (q : ℤ)^2 * (A q) * delta1 q - (A q : ℤ)^2 * delta1 q * delta2 q
  lhs - rhs

#eval debug_expansion_diff 71

/-
Properties of m and n.
-/
def m (q : ℕ) : ℕ := (q - 2) / 3
def n (q : ℕ) : ℕ := (2 * q - 1) / 3

lemma m_n_prop (q : ℕ) (hq_mod : q % 72 = 71) :
    3 * m q + 2 = q ∧ 3 * n q + 1 = 2 * q ∧ m q + n q + 1 = q := by
      unfold m n; omega;

/-
Evaluate delta2 mod A for q=71 and q=359.
-/
def debug_delta2 (q : ℕ) : ℕ :=
  let a := A q
  let d2 := delta2 q
  let d2_mod := (d2 % (a : ℤ) + (a : ℤ)) % (a : ℤ)
  d2_mod.toNat

#eval debug_delta2 71
#eval debug_delta2 359

/-
Definitions of m_q and n_q and their properties.
-/
def m_q (q : ℕ) : ℕ := (q - 2) / 3
def n_q (q : ℕ) : ℕ := (2 * q - 1) / 3

lemma m_n_q_prop (q : ℕ) (hq_mod : q % 72 = 71) :
    3 * m_q q + 2 = q ∧ 3 * n_q q + 1 = 2 * q ∧ m_q q + n_q q + 1 = q := by
      exact m_n_prop q hq_mod

/-
q^(2q) ≡ q + n(q²-q)A (mod A²).
-/
lemma q_pow_2q_expansion_v2 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2))^(2*q) = (q : ZMod (A q^2)) + (n q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
  convert q_pow_2q_expansion q hq_prime hq_mod hA using 1

/-
Debug the expansion of X^q by checking each step.
-/
def check_X_pow (q : ℕ) : ℤ :=
  X q ^ q + (q : ℤ)^(2*q) * (1 - (q : ℤ))^(2*q)

def check_q_pow (q : ℕ) : ℤ :=
  (q : ℤ)^(2*q) - ((q : ℤ) + (A q : ℤ) * delta1 q)

def check_one_sub_q_pow (q : ℕ) : ℤ :=
  (1 - (q : ℤ))^(2*q) - (-(q : ℤ)^2 + (A q : ℤ) * delta2 q)

#eval check_X_pow 71
#eval check_q_pow 71
#eval check_one_sub_q_pow 71

/-
q^q ≡ q² + m(q+2)A (mod A²).
-/
lemma q_pow_q_mod_A_sq_v2 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2)) ^ q = (q : ZMod (A q^2))^2 + (m q : ZMod (A q^2)) * (q + 2) * (A q) := by
      -- Substitute $q = 3m + 2$ into the expression.
      have h_sub : q ^ q = q ^ 2 * (q ^ 3) ^ m q := by
        rw [ ← pow_mul, ← pow_add ];
        rw [ show 2 + 3 * m q = q by linarith [ m_n_prop q hq_mod ] ];
      -- By Lemma 2, we know that $(q^3)^m \equiv 1 + m(q-1)A \pmod{A^2}$.
      have h_lemma2 : (q ^ 3) ^ m q ≡ 1 + (m q : ℕ) * (q - 1) * (A q : ℕ) [MOD (A q ^ 2)] := by
        convert q_pow_3n_mod_A_sq ( m q ) q hA |> Eq.symm using 1;
        norm_num [ ← ZMod.natCast_eq_natCast_iff, pow_mul ];
        rw [ Nat.cast_sub hq_prime.pos ] ; ring;
        rw [ eq_comm ];
      -- Substitute Lemma 2 into the expression for $q^q$.
      have h_subst : q ^ q ≡ q ^ 2 * (1 + (m q : ℕ) * (q - 1) * (A q : ℕ)) [MOD (A q ^ 2)] := by
        exact h_sub.symm ▸ h_lemma2.mul_left _;
      -- Simplify the expression inside the congruence.
      have h_simplify : q ^ 2 * (1 + (m q : ℕ) * (q - 1) * (A q : ℕ)) ≡ q ^ 2 + (m q : ℕ) * (q + 2) * (A q : ℕ) [MOD (A q ^ 2)] := by
        rw [ Nat.modEq_iff_dvd ];
        rcases q with ( _ | _ | q ) <;> simp_all +decide [ Nat.succ_mul ] ; ring_nf;
        exact ⟨ -m ( 2 + q ) * q, by ring ⟩;
      simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_subst.trans h_simplify

/-
q^(2q) ≡ q + n(q²-q)A (mod A²).
-/
lemma q_pow_2q_expansion_v3 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2))^(2*q) = (q : ZMod (A q^2)) + (n q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
      convert q_pow_2q_expansion_v2 q hq_prime hq_mod hA using 1

/-
Evaluate delta_u mod A for q=71.
-/
def delta_u (q : ℕ) : ℤ := ((1 - (q : ℤ))^(2*q) + q^2) / A q

def debug_delta_u (q : ℕ) : ℕ :=
  let a := A q
  let du := delta_u q
  (du % (a : ℤ) + (a : ℤ)) % (a : ℤ) |>.toNat

#eval debug_delta_u 71

/-
Check if X^q + q^(2q)(1-q)^(2q) = 0.
-/
def check_sign (q : ℕ) : ℤ :=
  X q ^ q + (q : ℤ)^(2*q) * (1 - (q : ℤ))^(2*q)

#eval check_sign 71

/-
Check if (1-q)^(2q) + q^2 is divisible by A for q=71.
-/
def check_div (q : ℕ) : ℤ :=
  ((1 - (q : ℤ))^(2*q) + (q : ℤ)^2) % (A q : ℤ)

#eval check_div 71

/-
Check the congruence term1 ≡ 2q - 1 + q²δ₁ - qδ₂ (mod A) for q=71.
-/
def check_term1_congruence_val (q : ℕ) : Bool :=
  let a := A q
  let t1 := (term1 q : ZMod a)
  let rhs := (2 * q - 1 : ZMod a) + (q : ZMod a)^2 * (delta1 q : ZMod a) - (q : ZMod a) * (delta2 q : ZMod a)
  t1 == rhs

#eval check_term1_congruence_val 71

/-
q^(2q) ≡ q + n(q²-q)A (mod A²).
-/
lemma q_pow_2q_expansion_final (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (q : ZMod (A q^2))^(2*q) = (q : ZMod (A q^2)) + (n q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
  convert q_pow_2q_expansion_v3 q hq_prime hq_mod hA using 1

/-
Exact relations for delta1 and delta2.
-/
lemma delta1_exact (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (A q : ℤ) * delta1 q = (q : ℤ)^(2*q) - q := by
      -- By definition of $delta1$, we know that $A * delta1 = q^{2q} - q$.
      have h_delta1 : (A q : ℤ) ∣ (q^(2*q) - q) := by
        have h_q_pow_2q_mod_A : (q : ZMod (A q))^(2*q) = (q : ZMod (A q)) := by
          exact?;
        erw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
      exact Int.mul_ediv_cancel' h_delta1

lemma delta2_exact (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (A q : ℤ) * delta2 q = (1 - (q : ℤ))^(2*q) + q^2 := by
      -- By definition of delta2, we know that (1 - q)^(2q) + q^2 is divisible by A q.
      have h_div : (A q : ℤ) ∣ (1 - q)^(2 * q) + q^2 := by
        -- By definition of $A$, we know that $(1 - q)^{2q} \equiv -q^2 \mod A$.
        have h_cong : (1 - q : ℤ)^(2 * q) ≡ -q^2 [ZMOD A q] := by
          convert one_sub_q_pow_2q_mod_A q hq_prime hq_mod h3q using 1
          generalize_proofs at *; (
          norm_cast; erw [ ← ZMod.intCast_eq_intCast_iff ] ; aesop;)
        generalize_proofs at *; (
        simpa using h_cong.symm.dvd)
      generalize_proofs at *; (
      exact Int.mul_ediv_cancel' h_div)

/-
A * delta1 = q^(2q) - q and A * delta2 = (1-q)^(2q) + q^2.
-/
def delta1_v2 (q : ℕ) : ℤ := ((q : ℤ)^(2*q) - q) / A q
def delta2_v2 (q : ℕ) : ℤ := ((1 - (q : ℤ))^(2*q) + q^2) / A q

lemma delta1_exact_v2 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (A q : ℤ) * delta1_v2 q = (q : ℤ)^(2*q) - q := by
      convert delta1_exact q hq_prime hq_mod hA using 1

lemma delta2_exact_v2 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (A q : ℤ) * delta2_v2 q = (1 - (q : ℤ))^(2*q) + q^2 := by
      convert delta2_exact q hq_prime hq_mod hA h3q using 1

/-
Evaluate the difference between term1 and the formula q - 1 + q²δ₁ - qδ₂ modulo A.
-/
def debug_term1_diff (q : ℕ) : ℕ :=
  let a := A q
  let t1 := (term1 q % (a : ℤ) + (a : ℤ)) % (a : ℤ)
  let rhs := ((q - 1 : ℤ) + (q : ℤ)^2 * delta1 q - (q : ℤ) * delta2 q) % (a : ℤ)
  let rhs_mod := (rhs + (a : ℤ)) % (a : ℤ)
  ((t1 - rhs_mod + (a : ℤ)) % (a : ℤ)).toNat

#eval debug_term1_diff 71

/-
Check if term1 ≡ q - 1 + q²δ₁ - qδ₂ (mod A) for q=71.
-/
def check_term1_q_minus_1 (q : ℕ) : Bool :=
  let a := A q
  let t1 := (term1 q : ZMod a)
  let rhs := (q - 1 : ZMod a) + (q : ZMod a)^2 * (delta1 q : ZMod a) - (q : ZMod a) * (delta2 q : ZMod a)
  t1 == rhs

#eval check_term1_q_minus_1 71

/-
Debug expansion components. Check if u = q + A d1 and v = -q^2 + A d2.
-/
def check_expansion_components (q : ℕ) : List ℤ :=
  let a := (A q : ℤ)
  let d1 := delta1 q
  let d2 := delta2 q
  let u := (q : ℤ)^(2*q)
  let v := (1 - (q : ℤ))^(2*q)
  let prod := u * v
  let expansion := (q : ℤ)^3 - (q : ℤ) * a * d2 + (q : ℤ)^2 * a * d1 - a^2 * d1 * d2
  let diff := -prod - expansion
  [u - (q + a * d1), v - (-q^2 + a * d2), diff]

#eval check_expansion_components 71

/-
Expansion of X^q using delta1 and delta2 (v2).
-/
lemma X_pow_q_expansion_correct (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    X q ^ q = (q : ℤ)^3 - (q : ℤ) * (A q) * delta2_v2 q + (q : ℤ)^2 * (A q) * delta1_v2 q - (A q : ℤ)^2 * delta1_v2 q * delta2_v2 q := by
      -- By definition of $X$, we know that $X^q = (-1)^q \cdot (q^2 \cdot (1-q)^2)^q$.
      have hX_q : X q ^ q = (-1 : ℤ) ^ q * (q ^ (2 * q) * (1 - (q : ℤ)) ^ (2 * q)) := by
        unfold X; ring;
        rw [ show ( - ( q : ℤ ) ^ 2 + ( q ^ 3 * 2 - q ^ 4 ) ) = ( -1 ) * ( q ^ 2 * ( 1 - q ) ^ 2 ) by ring ] ; rw [ mul_pow ] ; norm_num [ pow_mul' ] ; ring;
        rw [ show ( q : ℤ ) ^ 2 - q ^ 3 * 2 + q ^ 4 = q ^ 2 * ( 1 - q * 2 + q ^ 2 ) by ring, mul_pow ] ; ring;
      -- By definition of $delta1_v2$ and $delta2_v2$, we know that $q^{2q} = q + A q \cdot delta1_v2 q$ and $(1 - q)^{2q} = -q^2 + A q \cdot delta2_v2 q$.
      have h_delta1 : q ^ (2 * q) = q + A q * delta1_v2 q := by
        linarith [ delta1_exact_v2 q hq_prime hq_mod hA ]
      have h_delta2 : (1 - (q : ℤ)) ^ (2 * q) = -q ^ 2 + A q * delta2_v2 q := by
        have := delta2_exact_v2 q hq_prime hq_mod hA h3q; norm_num [ hA ] at *; linarith;
      generalize_proofs at *; (
      by_cases h : Even q <;> simp_all +decide;
      · simp_all +decide [ Nat.Prime.even_iff ];
      · ring)

/-
term1 ≡ q - 1 + q²δ₁ - qδ₂ (mod A).
-/
lemma term1_congruence (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) := by
      -- Substitute the expansion of `X^q` into `term1`.
      have h_subst : (X q ^ q - 1) = (A q : ℤ) * ((q : ℤ) - 1 + (q : ℤ)^2 * (delta1_v2 q : ℤ) - (q : ℤ) * (delta2_v2 q : ℤ)) - (A q : ℤ)^2 * (delta1_v2 q : ℤ) * (delta2_v2 q : ℤ) := by
        convert congr_arg ( · - 1 ) ( X_pow_q_expansion_correct q hq_prime hq_mod hA h3q ) using 1 ; ring;
        rw [ show ( A q : ℤ ) = q ^ 2 + q + 1 by exact_mod_cast hA ] ; ring;
      -- We perform the integer division and then reduce modulo A.
      have h_div : (term1 q : ℤ) = ((q : ℤ) - 1 + (q : ℤ)^2 * (delta1_v2 q : ℤ) - (q : ℤ) * (delta2_v2 q : ℤ)) - (A q : ℤ) * (delta1_v2 q : ℤ) * (delta2_v2 q : ℤ) := by
        unfold term1; rw [ Int.ediv_eq_of_eq_mul_left ] <;> push_cast [ h_subst ] <;> ring;
        grind;
      simp +decide [ h_div, mul_assoc ]

/-
X^q - 1 = A(q-1 + q²δ₁ - qδ₂) - A²δ₁δ₂.
-/
lemma X_pow_q_sub_one_eq (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    X q ^ q - 1 = (A q : ℤ) * ((q : ℤ) - 1 + (q : ℤ)^2 * delta1_v2 q - (q : ℤ) * delta2_v2 q) - (A q : ℤ)^2 * delta1_v2 q * delta2_v2 q := by
      -- Substitute the expansion of X^q from X_pow_q_expansion_correct.
      rw [X_pow_q_expansion_correct q hq_prime hq_mod hA h3q];
      rw [ hA ] ; ring;
      grind

/-
Debug q^3/A, X^q mod A^2, and term1 mod A.
-/
def check_q3_div_A (q : ℕ) : ℕ :=
  (q^3 - 1) / (q^2 + q + 1)

def check_X_pow_mod_A2 (q : ℕ) : ℤ :=
  let a := (A q : ℤ)
  let xq := X q ^ q
  (xq % (a^2) + a^2) % (a^2)

def check_term1_val (q : ℕ) : ℤ :=
  let a := (A q : ℤ)
  let t1 := term1 q
  (t1 % a + a) % a

#eval check_q3_div_A 71
#eval check_X_pow_mod_A2 71
#eval check_term1_val 71

/-
term1 ≡ q - 1 + q²δ₁ - qδ₂ (mod A).
-/
lemma term1_congruence_final (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) := by
      convert term1_congruence q hq_prime hq_mod hA h3q using 1

/-
Evaluate the derived formula for k mod A and compare with actual k and user's prediction.
-/
def k_derived (q : ℕ) : ZMod (A q) :=
  let t1 := (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q))
  t1 - (q : ZMod (A q)) * (q - 1) + (3 : ZMod (A q))⁻¹

#eval k_derived 71
#eval val_k 71
#eval target_val 71

/-
X^q - 1 = A(q-1 + q²δ₁ - qδ₂) - A²δ₁δ₂.
-/
lemma X_pow_q_sub_one_eq_v2 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    X q ^ q - 1 = (A q : ℤ) * ((q : ℤ) - 1 + (q : ℤ)^2 * delta1_v2 q - (q : ℤ) * delta2_v2 q) - (A q : ℤ)^2 * delta1_v2 q * delta2_v2 q := by
      convert X_pow_q_sub_one_eq q hq_prime hq_mod hA h3q using 1

/-
term1 = q - 1 + q²δ₁ - qδ₂ - Aδ₁δ₂ (in ℤ).
-/
lemma term1_eq_int (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ℤ) = ((q : ℤ) - 1 + (q : ℤ)^2 * delta1_v2 q - (q : ℤ) * delta2_v2 q) - (A q : ℤ) * delta1_v2 q * delta2_v2 q := by
      convert Int.ediv_eq_of_eq_mul_left _ _ using 1;
      · exact Nat.cast_ne_zero.mpr ( by rw [ hA ] ; positivity );
      · convert X_pow_q_sub_one_eq_v2 q hq_prime hq_mod hA h3q using 1 ; ring

/-
term1 ≡ q - 1 + q²δ₁ - qδ₂ (mod A).
-/
lemma term1_congruence_v3 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) := by
      convert term1_congruence_final q hq_prime hq_mod hA h3q using 1

/-
Debug term1 components to resolve the q-1 vs 2q-1 discrepancy.
-/
def debug_term1_components (q : ℕ) : List ℤ :=
  let a := (A q : ℤ)
  let d1 := delta1_v2 q
  let d2 := delta2_v2 q
  let term_q_sq_d1 := ((q : ℤ)^2 * d1) % a
  let term_q_d2 := ((q : ℤ) * d2) % a
  let term_q_minus_1 := (q : ℤ) - 1
  let term_2q_minus_1 := 2 * (q : ℤ) - 1
  let predicted_q := (term_q_minus_1 + term_q_sq_d1 - term_q_d2) % a
  let predicted_2q := (term_2q_minus_1 + term_q_sq_d1 - term_q_d2) % a
  let actual := (term1 q) % a
  [term_q_sq_d1, term_q_d2, predicted_q, predicted_2q, actual]

#eval debug_term1_components 71

/-
Debug term2 values. Check X mod A, X^(q-1) mod A, Y mod A, term2, and formula.
-/
def debug_term2_values (q : ℕ) : List ℕ :=
  let a := A q
  let q_z := (q : ZMod a)
  let x_z := (X q : ZMod a)
  let y_z := (Y q : ZMod a)
  let x_pow := x_z^(q-1)
  let t2 := q_z * x_pow * y_z
  let formula := (3 : ZMod a)⁻¹ * (6 * q_z + 4)
  [x_z.val, x_pow.val, y_z.val, t2.val, formula.val]

#eval debug_term2_values 71

/-
Debug modular arithmetic steps for (1-q)^(2q) + q^2 mod A.
-/
def check_mod_steps (q : ℕ) : List ℤ :=
  let a := (A q : ℤ)
  let one_minus_q := 1 - (q : ℤ)
  let sq := one_minus_q^2
  let sq_mod := sq % a
  let term := -3 * (q : ℤ)
  let term_mod := term % a
  let pow_val := one_minus_q^(2*q)
  let pow_mod := pow_val % a
  let q_sq := (q : ℤ)^2
  let q_sq_mod := q_sq % a
  let sum := pow_val + q_sq
  let sum_mod := sum % a
  [sq_mod, term_mod, pow_mod, q_sq_mod, sum_mod]

#eval check_mod_steps 71

/-
term1 ≡ q - 1 + q²δ₁ - qδ₂ (mod A).
-/
lemma term1_congruence_proven (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) := by
      convert term1_congruence q hq_prime hq_mod hA h3q using 1

/-
Reduction of term1 modulo A.
-/
lemma term1_mod_A_reduction (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (h3q : 3^q ≡ 1 [MOD A q]) :
    (term1 q : ZMod (A q)) = ((q : ℤ) - 1 + (q : ℤ)^2 * delta1_v2 q - (q : ℤ) * delta2_v2 q : ZMod (A q)) := by
      convert term1_congruence_proven q hq_prime hq_mod hA h3q using 1

/-
k ≡ q - 1 + q²δ₁ - qδ₂ + 3⁻¹(6q+4) (mod A).
-/
lemma k_congruence_final_v4 (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (hA_prime : Nat.Prime (A q)) (h3q : 3^q ≡ 1 [MOD A q]) :
    (k q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) + (3 : ZMod (A q))⁻¹ * (6 * q + 4) := by
      have h_term2_simplified : (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q)) = (3 : ZMod (A q))⁻¹ * (6 * (q : ZMod (A q)) + 4) := by
        convert term2_simplification_corrected q hq_prime hA_prime h3q using 1;
      have h_k_mod_A : (k q : ZMod (A q)) = (term1 q : ZMod (A q)) + (q : ZMod (A q)) * (X q : ZMod (A q))^(q-1) * (Y q : ZMod (A q)) := by
        have := k_mod_A_intermediate q hq_prime hA_prime h3q; aesop;
      convert h_k_mod_A using 1 ; rw [ term1_congruence q hq_prime hq_mod hA h3q ] ; ring;
      rw [ h_term2_simplified ] ; ring

/-
-q(q-1) + 3⁻¹ = 3⁻¹(6q+4) (mod A).
-/
lemma term2_equiv (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (hA_prime : Nat.Prime (A q)) :
    -(q : ZMod (A q)) * (q - 1) + (3 : ZMod (A q))⁻¹ = (3 : ZMod (A q))⁻¹ * (6 * q + 4) := by
      haveI := Fact.mk hA_prime;
      field_simp;
      rw [ eq_comm, div_eq_iff ] <;> norm_num ; ring;
      · rw [ inv_mul_cancel₀ ] <;> norm_num;
        · have h_eq : (q : ZMod (A q))^2 + q + 1 = 0 := by
            norm_cast;
            erw [ ZMod.natCast_eq_zero_iff ] ; aesop;
          linear_combination' h_eq * 3;
        · erw [ ZMod.natCast_eq_zero_iff ] ; intro H ; have := Nat.le_of_dvd ( by norm_num ) H ; nlinarith [ show q > 2 by contrapose! H; interval_cases q <;> trivial ];
      · erw [ ZMod.natCast_eq_zero_iff ] ; intro h; have := Nat.le_of_dvd ( by norm_num ) h; nlinarith [ show q > 1 from hq_prime.two_le ] ;

/-
Verify the k formula with 2q-1.
-/
def k_formula_2q (q : ℕ) : ZMod (A q) :=
  (2 * q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) + (3 : ZMod (A q))⁻¹ * (6 * q + 4)

#eval k_formula_2q 71
#eval val_k 71

/-
δ₁ ≡ n(q²-q) (mod A).
-/
lemma delta1_mod_A (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) :
    (delta1_v2 q : ZMod (A q)) = (n q : ZMod (A q)) * (q^2 - q) := by
  have h_exp : (q : ZMod (A q^2))^(2*q) = (q : ZMod (A q^2)) + (n q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
    apply q_pow_2q_expansion_final q hq_prime hq_mod hA
  have h_lift : (q : ZMod (A q^2))^(2*q) - (q : ZMod (A q^2)) = (n q : ZMod (A q^2)) * (q^2 - q) * (A q) := by
    rw [h_exp]
    ring
  -- We need to relate this to delta1.
  -- delta1 = (q^(2q) - q) / A.
  -- So A * delta1 = q^(2q) - q.
  -- The equation in ZMod (A^2) implies:
  -- q^(2q) - q = n(q^2-q)A + m A^2.
  -- Dividing by A: delta1 = n(q^2-q) + m A.
  -- Modulo A: delta1 = n(q^2-q).
  -- By definition of $delta1_v2$, we know that $delta1_v2 q * A q = q^{2q} - q$.
  have h_delta_prod : (delta1_v2 q : ℤ) * (A q : ℤ) = (q : ℤ)^(2*q) - q := by
    convert delta1_exact_v2 q hq_prime hq_mod hA using 1;
    ring;
  -- Since $A q$ is non-zero in $ZMod (A q^2)$, we can cancel it out from both sides of the equation.
  have h_cancel : (delta1_v2 q : ℤ) ≡ (n q : ℤ) * (q^2 - q) [ZMOD (A q : ℤ)] := by
    have h_cancel : (delta1_v2 q : ℤ) * (A q : ℤ) ≡ (n q : ℤ) * (q^2 - q) * (A q : ℤ) [ZMOD (A q^2 : ℤ)] := by
      erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
    rw [ Int.modEq_iff_dvd ] at *;
    exact h_cancel.imp fun x hx => by nlinarith;
  erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;

/-
k ≡ q - 1 + q²δ₁ - qδ₂ + 3⁻¹(6q+4) (mod A).
-/
lemma k_congruence_final_proven (q : ℕ) (hq_prime : Nat.Prime q) (hq_mod : q % 72 = 71)
    (hA : A q = q^2 + q + 1) (hA_prime : Nat.Prime (A q)) (h3q : 3^q ≡ 1 [MOD A q]) :
    (k q : ZMod (A q)) = (q - 1 : ZMod (A q)) + (q : ZMod (A q))^2 * (delta1_v2 q : ZMod (A q)) - (q : ZMod (A q)) * (delta2_v2 q : ZMod (A q)) + (3 : ZMod (A q))⁻¹ * (6 * q + 4) := by
      rw [ ← term1_congruence q hq_prime hq_mod hA h3q, k_Z_relation ];
      · haveI := Fact.mk hA_prime; linear_combination' term2_equiv q hq_prime hq_mod hA hA_prime;
      · assumption;
      · assumption;
      · assumption

/-
Check if the derived k value satisfies k ≡ 2 (mod q) for q=71. Expecting false.
-/
def check_contradiction (q : ℕ) : Bool :=
  let a := A q
  let k_mod_a := k_derived q
  -- We want to check if k_mod_a % q == 2
  -- But k_mod_a is in ZMod A.
  -- We lift it to Nat (it will be < A) and then take mod q.
  -- Note: A = q^2 + q + 1 = 1 mod q.
  -- So taking mod q is well-defined if we treat it as an integer.
  let k_val := k_mod_a.val
  k_val % q == 2

#eval check_contradiction 71

/-
(3⁻¹ mod A) mod q = 1.
-/
lemma inv3_mod_q (q : ℕ) (hq_mod : q % 72 = 71) (hA : A q = q^2 + q + 1) (hA_prime : Nat.Prime (A q)) :
    ((3 : ZMod (A q))⁻¹.val : ℕ) % q = 1 := by
      -- Let's calculate the inverse of 3 modulo A q.
      have h_inv : (3 : ZMod (A q))⁻¹.val = ((2 * (A q) + 1) / 3 : ℕ) := by
        have h_inv : (3 : ZMod (A q)) * ((2 * (A q) + 1) / 3 : ℕ) = 1 := by
          norm_cast;
          rw [ Nat.mul_div_cancel' ] <;> norm_num [ hA ];
          exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 72, hq_mod ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] );
        haveI := Fact.mk hA_prime; rw [ inv_eq_of_mul_eq_one_right h_inv ] ; norm_num;
        rw [ Nat.mod_eq_of_lt ( Nat.div_lt_of_lt_mul <| by nlinarith only [ hA_prime.two_le ] ) ];
      rw [ h_inv, hA ];
      rw [ ← Nat.mod_add_div q 72, hq_mod ] ; ring_nf;
      norm_num [ show 10227 + q / 72 * 20592 + ( q / 72 ) ^ 2 * 10368 = ( 71 + q / 72 * 72 ) * ( q / 72 * 144 + 144 ) + 3 by ring, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ];
      norm_num [ show ( 71 + q / 72 * 72 ) * ( q / 72 * 144 + 144 ) = ( 71 + q / 72 * 72 ) * ( q / 72 * 48 + 48 ) * 3 by ring, Nat.mul_mod_mul_right ];
      rw [ Nat.mod_eq_of_lt ( by linarith [ Nat.zero_le ( q / 72 ) ] ) ]