/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6c08fe44-7acf-410d-95ec-189d59c853a9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 43d74efd-fcc7-41e9-8172-f25933931c1b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Squarefree

example : Decidable (Squarefree 10) := inferInstance
#eval (decide (Squarefree 10))

/-
A computable function to check Erdős Problem 11 for a given n, and a proof that it implies the existential statement.
-/
def check_erdos_11 (n : ℕ) : Bool :=
  (List.range (Nat.log2 n + 1)).any fun l =>
    let k := n - 2^l
    decide (k > 0 ∧ Squarefree k)

theorem check_erdos_11_correct (n : ℕ) (h : check_erdos_11 n = true) :
    ∃ k l : ℕ, Squarefree k ∧ n = k + 2 ^ l := by
      unfold check_erdos_11 at h;
      grind

/-
A computable function to check Erdős Problem 11 for a range, and a proof that it implies the bounded conjecture.
-/
def check_erdos_11_range (limit : ℕ) : Bool :=
  (List.range limit).all fun n =>
    if n % 2 == 1 && n > 1 then check_erdos_11 n else true

theorem erdos_11_bounded_of_check (limit : ℕ) (h : check_erdos_11_range limit = true) :
    ∀ n < limit, Odd n → 1 < n → ∃ k l, Squarefree k ∧ n = k + 2 ^ l := by
      -- By definition of `check_erdos_11_range`, if `check_erdos_11_range limit` is true, then for all `n` such that `0 ≤ n < limit`, if `Odd n` and `1 < n`, then `check_erdos_11 n` must be true.
      have h_check_all : ∀ n, 0 ≤ n → n < limit → Odd n → 1 < n → check_erdos_11 n = Bool.true := by
        unfold check_erdos_11_range at h;
        grind;
      exact fun n hn hn' hn'' => check_erdos_11_correct n ( h_check_all n ( Nat.zero_le n ) hn hn' hn'' )

/-
Verification of Erdős Problem 11 for n < 1000.
-/
theorem erdos_11_upto_1000 : check_erdos_11_range 1000 = true := by native_decide

/-
Definition of a Wieferich prime: a prime p such that 2^(p-1) ≡ 1 (mod p^2).
-/
def IsWieferichPrime (p : ℕ) : Prop :=
  p.Prime ∧ 2 ^ (p - 1) ≡ 1 [MOD p ^ 2]

/-
Definitions for the set of candidates n - 2^k and a function to count those divisible by p^2.
-/
def erdos_candidates (n : ℕ) : Finset ℕ :=
  (Finset.range (Nat.log2 n + 1)).image (fun k => n - 2^k)

def count_divisible_candidates (n p : ℕ) : ℕ :=
  (erdos_candidates n).filter (fun m => m % (p^2) == 0) |>.card

lemma candidates_subset (n : ℕ) : erdos_candidates n ⊆ Finset.range (n + 1) := by
  exact Finset.subset_iff.mpr fun x hx => Finset.mem_range.mpr ( by obtain ⟨ y, hy, rfl ⟩ := Finset.mem_image.mp hx; linarith [ Nat.sub_le n ( 2 ^ y ) ] )

/-
Definition of natural density: A set A has natural density d if the proportion of elements in A below n converges to d as n goes to infinity.
-/
def HasNaturalDensity (A : Set ℕ) (d : ℝ) : Prop :=
  Filter.Tendsto (fun n => ((Finset.range n).filter (fun k => k ∈ A)).card / (n : ℝ)) Filter.atTop (nhds d)

/-
The statement of Erdős Problem 11: Every odd n > 1 is the sum of a squarefree number and a power of 2.
-/
def Erdos11Statement : Prop :=
  ∀ n : ℕ, Odd n → 1 < n → ∃ k l : ℕ, Squarefree k ∧ n = k + 2 ^ l

/-
Verification of Erdős Problem 11 for n < 10000.
-/
theorem erdos_11_upto_10000 : check_erdos_11_range 10000 = true := by
  native_decide +revert

/-
Verification of Erdős Problem 11 for n < 100000.
-/
theorem erdos_11_upto_100000 : check_erdos_11_range 100000 = true := by
  native_decide +revert

/-
The set of odd n > 1 that fail the Erdős Problem 11 condition.
-/
def FailSet := {n : ℕ | Odd n ∧ n > 1 ∧ ∀ l ≤ Nat.log2 n, ¬Squarefree (n - 2^l)}

/-
Computable verification for the two-powers variant of Erdős Problem 11.
-/
def check_erdos_11_two_pow (n : ℕ) : Bool :=
  (List.range (Nat.log2 n + 1)).any fun l =>
    (List.range (Nat.log2 n + 1)).any fun m =>
      let s := 2^l + 2^m
      if n > s then
        let k := n - s
        decide (Squarefree k)
      else false

def check_erdos_11_two_pow_range (limit : ℕ) : Bool :=
  (List.range limit).all fun n =>
    if n % 2 == 1 && n > 1 then check_erdos_11_two_pow n else true

theorem erdos_11_two_pow_bounded_of_check (limit : ℕ) (h : check_erdos_11_two_pow_range limit = true) :
    ∀ n < limit, Odd n → 1 < n → ∃ k l m, Squarefree k ∧ n = k + 2 ^ l + 2 ^ m := by
      -- By definition of `check_erdos_11_two_pow_range`, if it returns true, then for every odd n < limit, there exist k, l, m such that k is squarefree and n = k + 2^l + 2^m.
      intros n hn hn_odd hn_gt_one
      have h_check : check_erdos_11_two_pow n = true := by
        unfold check_erdos_11_two_pow_range at h;
        grind;
      unfold check_erdos_11_two_pow at h_check;
      grind

/-
Verification of the two-powers variant for n < 100000.
-/
theorem erdos_11_two_pow_upto_100000 : check_erdos_11_two_pow_range 100000 = true := by
  native_decide +revert

/-
2 is a unit modulo p^2 for odd primes p.
-/
lemma two_is_unit_mod_sq {p : ℕ} (hp : p.Prime) (hp_odd : p ≠ 2) : IsUnit (2 : ZMod (p^2)) := by
  have h_coprime : Nat.gcd 2 (p ^ 2) = 1 := by
    exact Nat.prime_two.coprime_iff_not_dvd.mpr ( by rw [ Nat.dvd_iff_mod_eq_zero ] ; exact by rw [ Nat.pow_mod ] ; exact by rw [ hp.eq_two_or_odd.resolve_left hp_odd ] ; decide );
  rw [ isUnit_iff_exists_inv ];
  have := Nat.exists_mul_emod_eq_one_of_coprime h_coprime;
  exact Exists.elim ( this ( by nlinarith [ hp.two_le ] ) ) fun m hm => ⟨ m, by simpa [ ← ZMod.natCast_eq_natCast_iff' ] using congr_arg ( fun x : ℕ => x : ℕ → ZMod ( p ^ 2 ) ) hm ⟩

/-
If p is not a Wieferich prime, then the order of 2 modulo p^2 is divisible by p.
-/
lemma not_wieferich_order_div_p {p : ℕ} (hp : p.Prime) (hp_odd : p ≠ 2) (hW : ¬ IsWieferichPrime p) :
  p ∣ orderOf (2 : ZMod (p^2)) := by
    -- By definition of order, $d$ divides $\phi(p^2) = p(p-1)$.
    have h_order_div : orderOf (2 : ZMod (p^2)) ∣ p * (p - 1) := by
      -- By Euler's theorem, since $2$ is coprime to $p^2$, we have $2^{\phi(p^2)} \equiv 1 \pmod{p^2}$.
      have h_euler : 2 ^ Nat.totient (p^2) ≡ 1 [MOD p^2] := by
        exact Nat.ModEq.pow_totient <| Nat.coprime_comm.mp <| by exact Nat.Coprime.pow_left _ <| hp.coprime_iff_not_dvd.mpr fun h => hp_odd <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases p <;> trivial;
      rw [ orderOf_dvd_iff_pow_eq_one ];
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Nat.totient_prime_pow ];
    -- If $p$ does not divide $d$, then $d$ must divide $p-1$ (since $d | p(p-1)$ and $\gcd(d, p) = 1$).
    by_contra h_contra
    have h_div_p_minus_1 : orderOf (2 : ZMod (p^2)) ∣ p - 1 := by
      exact ( Nat.Coprime.dvd_of_dvd_mul_left ( show Nat.Coprime ( orderOf 2 ) p from Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr h_contra ) h_order_div );
    have h_contradiction : 2 ^ (p - 1) ≡ 1 [MOD p ^ 2] := by
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, orderOf_dvd_iff_pow_eq_one ];
    exact hW ⟨ hp, h_contradiction ⟩

/-
Bound on the number of times a residue appears in the powers of 2 modulo p^2.
-/
lemma count_powers_mod_p_sq {p : ℕ} (hp : p.Prime) (hp_odd : p ≠ 2) (L : ℕ) (r : ZMod (p^2)) :
  ((Finset.range (L + 1)).filter (fun l => (2 : ZMod (p^2))^l = r)).card ≤ (L / orderOf (2 : ZMod (p^2))) + 1 := by
    have h_proj : ∀ l m : ℕ, (2 : ZMod (p^2)) ^ l = (2 : ZMod (p^2)) ^ m → (l % (orderOf (2 : ZMod (p^2))) = m % (orderOf (2 : ZMod (p^2)))) := by
      intro l m h_eq
      have h_div : orderOf (2 : ZMod (p ^ 2)) ∣ (l - m) := by
        cases le_total l m <;> simp_all +decide [ orderOf_dvd_iff_pow_eq_one ];
        have h_unit : IsUnit (2 : ZMod (p ^ 2)) := by
          exact?;
        cases le_iff_exists_add'.mp ‹_› ; simp_all +decide [ pow_add, pow_mul ];
        exact h_unit.pow m |> fun h => h.mul_left_cancel <| by linear_combination' h_eq;
      cases le_total l m <;> simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.mod_eq_of_lt ];
      · refine Nat.modEq_of_dvd ?_;
        have h_div : (2 : ZMod (p ^ 2)) ^ (m - l) = 1 := by
          have h_div : (2 : ZMod (p ^ 2)) ^ l * (2 : ZMod (p ^ 2)) ^ (m - l) = (2 : ZMod (p ^ 2)) ^ l := by
            rw [ ← pow_add, Nat.add_sub_of_le ‹_›, h_eq ];
          have h_inv : IsUnit (2 ^ l : ZMod (p ^ 2)) := by
            have h_inv : IsUnit (2 : ZMod (p ^ 2)) := by
              exact?;
            exact h_inv.pow _;
          exact h_inv.mul_left_cancel ( by linear_combination' h_div );
        exact_mod_cast orderOf_dvd_iff_pow_eq_one.mpr h_div |> dvd_trans <| by simp +decide [ *, Nat.cast_sub ‹l ≤ m› ] ;
      · exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, * ] using Nat.dvd_of_mod_eq_zero h_div );
    -- The indices l where 2^l = r form a congruence class modulo d (if any exist).
    -- In the range [0, L], the number of elements congruent to x mod d is at most L/d + 1.
    have h_card : ∀ x : ℕ, Finset.card (Finset.filter (fun l => l % (orderOf (2 : ZMod (p^2))) = x % (orderOf (2 : ZMod (p^2)))) (Finset.range (L + 1))) ≤ L / (orderOf (2 : ZMod (p^2))) + 1 := by
      intros x
      have h_filter : Finset.filter (fun l => l % (orderOf (2 : ZMod (p^2))) = x % (orderOf (2 : ZMod (p^2)))) (Finset.range (L + 1)) ⊆ Finset.image (fun k => x % (orderOf (2 : ZMod (p^2))) + k * (orderOf (2 : ZMod (p^2)))) (Finset.range ((L / (orderOf (2 : ZMod (p^2)))) + 1)) := by
        intros l hl;
        simp +zetaDelta at *;
        exact ⟨ l / orderOf 2, Nat.lt_succ_of_le ( Nat.div_le_div_right ( by linarith ) ), by linarith [ Nat.mod_add_div l ( orderOf ( 2 : ZMod ( p ^ 2 ) ) ) ] ⟩;
      exact le_trans ( Finset.card_le_card h_filter ) ( Finset.card_image_le.trans ( by norm_num ) );
    by_cases hr : ∃ l, (2 : ZMod (p^2)) ^ l = r;
    · obtain ⟨ l, rfl ⟩ := hr;
      exact le_trans ( Finset.card_le_card fun x hx => by aesop ) ( h_card l );
    · rw [ Finset.card_eq_zero.mpr ] <;> aesop

/-
Definition of upper natural density.
-/
def UpperNaturalDensity (A : Set ℕ) : ℝ :=
  Filter.limsup (fun n => ((Finset.range n).filter (fun k => k ∈ A)).card / (n : ℝ)) Filter.atTop

/-
For large enough n, the FailSet condition implies failure for the first k powers of 2.
-/
lemma fail_set_subset_k (k : ℕ) :
  ∃ N, ∀ n > N, n ∈ FailSet → (∀ l < k, ¬ Squarefree (n - 2^l)) := by
    use 2^k;
    -- Assume there exists an $n > 2^k$ such that $n$ is in the FailSet.
    intro n hn hfail l hl
    have hlog : k ≤ Nat.log2 n := by
      rw [ Nat.le_log2 ] <;> linarith [ Nat.one_le_pow k 2 zero_lt_two ];
    exact hfail.2.2 l ( by linarith )

/-
If the upper natural density is 0, then the natural density is 0.
-/
lemma upper_density_zero_implies_density_zero {A : Set ℕ} (h : UpperNaturalDensity A = 0) :
  HasNaturalDensity A 0 := by
    rw [ UpperNaturalDensity ] at h;
    convert tendsto_order.2 ⟨ _, _ ⟩;
    all_goals try infer_instance;
    · exact fun x hx => Filter.Eventually.of_forall fun n => hx.trans_le <| by positivity;
    · rw [ Filter.limsup_eq ] at h;
      contrapose! h;
      refine' ne_of_gt ( lt_of_lt_of_le _ ( le_csInf _ _ ) );
      exact h.choose_spec.1;
      · exact ⟨ 1, Filter.eventually_atTop.mpr ⟨ 1, fun n hn => div_le_one_of_le₀ ( mod_cast le_trans ( Finset.card_filter_le _ _ ) ( by norm_num ) ) ( by positivity ) ⟩ ⟩;
      · intro b hb;
        exact le_of_not_gt fun h' => h.choose_spec.2 <| hb.mono fun n hn => lt_of_le_of_lt hn h'