/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 45890ac8-72aa-49ee-9f3b-9a19f0df8475

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Feit-Thompson conjecture for p=3. We prove that for prime q > 3, A = q^2+q+1 does not divide (3^q-1)/2. The proof is split into cases: q ≡ 1 (mod 4) is proven unconditionally. The case q ≡ 3 (mod 4) is proven conditional on the Cubic Reciprocity Law and the subcase q ≡ 8 (mod 9). We verify the conjecture for all q < 20000.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check jacobiSym

/-
Definition of A = q^2 + q + 1.
-/
def A (q : ℕ) : ℕ := q^2 + q + 1

/-
If A = q^2+q+1 divides (3^q-1)/2 for prime q > 3, then A is prime.
-/
theorem feit_thompson_p_eq_3_A_prime (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hdiv : (A q) ∣ (3^q - 1) / 2) : (A q).Prime := by
    -- Assume there exists a prime $p$ such that $p \mid A$.
    have h_prime_divisor : ∀ p : ℕ, Nat.Prime p → p ∣ (q^2 + q + 1) → p ≡ 1 [MOD q] := by
      -- Let $p$ be a prime divisor of $A$.
      intro p hp hp_div
      have hp_div_3 : p ∣ (3 ^ q - 1) := by
        exact dvd_trans hp_div ( dvd_trans ( by unfold A; norm_num ) ( hdiv.trans ( Nat.div_dvd_of_dvd ( even_iff_two_dvd.mp ( by simp +decide [ Nat.one_le_iff_ne_zero, parity_simps ] ) ) ) ) )
      have hp_order : orderOf (3 : ZMod p) = q := by
        have hp_order : orderOf (3 : ZMod p) ∣ q := by
          rw [ orderOf_dvd_iff_pow_eq_one ];
          simp_all +decide [ ← ZMod.natCast_eq_zero_iff, sub_eq_iff_eq_add ];
        rw [ Nat.dvd_prime hq ] at hp_order;
        rcases hp_order with h | h <;> simp_all +decide [ sub_eq_iff_eq_add ];
        rcases p with ( _ | _ | _ | _ | p ) <;> cases h ; trivial;
        norm_num [ ← even_iff_two_dvd, parity_simps ] at *;
      -- By Fermat's Little Theorem, we know that $orderOf (3 : ZMod p) \mid p - 1$.
      have hp_fermat : q ∣ p - 1 := by
        haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, orderOf_dvd_iff_pow_eq_one ] ;
        rw [ ZMod.natCast_eq_zero_iff ] ; have := orderOf_dvd_iff_pow_eq_one.mpr ( show ( 3 : ZMod p ) ^ ( p - 1 ) = 1 from ZMod.pow_card_sub_one_eq_one <| by aesop ) ; aesop;
      exact Nat.ModEq.symm ( Nat.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast, hp.pos ] using hp_fermat );
    -- If there exists a prime $p$ such that $p \mid A$, then $p \geq q + 1$.
    have h_prime_ge : ∀ p : ℕ, Nat.Prime p → p ∣ (q^2 + q + 1) → p ≥ q + 1 := by
      intro p pp dp; specialize h_prime_divisor p pp dp; rw [ Nat.ModEq ] at h_prime_divisor; rcases q with ( _ | _ | q ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ] ;
      exact Nat.succ_le_of_lt ( Nat.lt_of_le_of_ne ( Nat.le_of_not_gt fun h => by have := Nat.mod_eq_of_lt h; aesop ) ( Ne.symm <| by aesop ) );
    -- If $A$ is composite, then it must have at least two prime factors, both of which are greater than or equal to $q + 1$.
    by_contra h_composite
    obtain ⟨p, hp_prime, hp_div⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ (q^2 + q + 1) ∧ p ≤ Nat.sqrt (q^2 + q + 1) := by
      obtain ⟨ p, hp₁, hp₂ ⟩ := Nat.exists_prime_and_dvd ( by nlinarith : q ^ 2 + q + 1 ≠ 1 );
      obtain ⟨ k, hk ⟩ := hp₂;
      rcases p with ( _ | _ | p ) <;> rcases k with ( _ | _ | k ) <;> norm_num at *;
      · exact False.elim <| h_composite <| by rw [ show A q = p + 1 + 1 by { unfold A; linarith } ] ; assumption;
      · exact ⟨ Nat.minFac ( q ^ 2 + q + 1 ), Nat.minFac_prime ( by nlinarith ), Nat.minFac_dvd _, by rw [ Nat.le_sqrt ] ; nlinarith [ Nat.minFac_le_of_dvd ( by nlinarith ) ( dvd_of_mul_right_eq _ hk.symm ), Nat.minFac_le_of_dvd ( by nlinarith ) ( dvd_of_mul_left_eq _ hk.symm ) ] ⟩;
    nlinarith [ Nat.sqrt_le ( q ^ 2 + q + 1 ), h_prime_ge p hp_prime hp_div.1 ]

/-
If A = q^2+q+1 divides (3^q-1)/2 for prime q > 3, then q ≡ 2 (mod 3).
-/
theorem feit_thompson_q_mod_3 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hdiv : (A q) ∣ (3^q - 1) / 2) : q ≡ 2 [MOD 3] := by
    -- By definition of A, we know that A = q^2 + q + 1.
    have hA : A q = q^2 + q + 1 := by
      rfl;
    -- By definition of A, we know that A = q^2 + q + 1. If q ≡ 1 (mod 3), then A ≡ 1 + 1 + 1 = 3 ≡ 0 (mod 3).
    by_cases hq1 : q ≡ 1 [MOD 3];
    · -- If q ≡ 1 (mod 3), then A = q^2 + q + 1 ≡ 1 + 1 + 1 = 3 ≡ 0 (mod 3).
      have hA_mod3 : A q ≡ 0 [MOD 3] := by
        exact hA.symm ▸ by rw [ Nat.ModEq ] at *; norm_num [ Nat.add_mod, Nat.pow_mod ] ; have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> trivial;
      -- Since A is prime (by previous lemma), A=3.
      have hA_prime : Nat.Prime (A q) := by
        exact feit_thompson_p_eq_3_A_prime q hq hq3 hdiv;
      rw [ Nat.modEq_zero_iff_dvd ] at hA_mod3; rw [ hA_prime.dvd_iff_eq ] at hA_mod3 <;> nlinarith;
    · have := Nat.mod_lt q three_pos; interval_cases _ : q % 3 <;> simp_all +decide [ Nat.ModEq ] ; have := Nat.dvd_of_mod_eq_zero ( show q % 3 = 0 by omega ) ; rw [ hq.dvd_iff_eq ] at this <;> linarith;

/-
If q ≡ 1 (mod 4) and q ≡ 2 (mod 3), then (3/A) = -1.
-/
theorem jacobi_three_eq_neg_one (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod4 : q ≡ 1 [MOD 4]) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) :
  jacobiSym 3 (A q) = -1 := by
    erw [ jacobiSym.mod_right ] ; norm_num [ A ];
    · rw [ ← Nat.mod_add_div q 12 ] at *; have := Nat.mod_lt q ( by decide : 0 < 12 ) ; interval_cases q % 12 <;> norm_num [ Nat.ModEq, Nat.add_mod, Nat.pow_mod ] at *;
      all_goals norm_num [ Nat.add_mod, Nat.mul_mod ] at *;
    · exact hA.odd_of_ne_two <| by unfold A; nlinarith;

/-
If q ≡ 1 (mod 4) and q ≡ 2 (mod 3), then 3^q ≢ 1 (mod A).
-/
theorem three_pow_q_ne_one_mod_A_of_q_mod_4_eq_1 (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod4 : q ≡ 1 [MOD 4]) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime) :
  (3 : ZMod (A q)) ^ q ≠ 1 := by
    -- Since $A$ is prime and $q \equiv 1 \pmod{4}$, we have $\left(\frac{3}{A}\right) = -1$.
    have h_jacobi : jacobiSym 3 (A q) = -1 := by
      convert jacobi_three_eq_neg_one q hq hq3 hmod4 hmod3 hA using 1;
    -- By Euler's criterion, we have $3^{\frac{A-1}{2}} \equiv \left(\frac{3}{A}\right) \equiv -1 \pmod{A}$.
    have h_euler : 3 ^ ((A q - 1) / 2) ≡ -1 [ZMOD A q] := by
      have h_euler : 3 ^ ((A q - 1) / 2) ≡ jacobiSym 3 (A q) [ZMOD A q] := by
        haveI := Fact.mk hA; simp +decide [ ← ZMod.intCast_eq_intCast_iff, jacobiSym ] ;
        norm_num [ Nat.primeFactorsList_prime hA ];
        rw [ legendreSym.eq_pow ];
        norm_num [ Nat.add_div, Nat.mul_div_assoc, Nat.pow_mod, A ];
        norm_num [ Nat.add_mod, Nat.pow_mod, hq.eq_two_or_odd.resolve_left ( by linarith ) ];
      grind;
    -- Since $A = q^2 + q + 1$, we have $\frac{A-1}{2} = \frac{q(q+1)}{2}$.
    have h_half : (A q - 1) / 2 = q * (q + 1) / 2 := by
      exact congrArg ( · / 2 ) ( Nat.sub_eq_of_eq_add <| by unfold A; ring );
    -- Suppose for contradiction that $3^q \equiv 1 \pmod{A}$.
    by_contra h_contra
    have h_contra_exp : 3 ^ (q * (q + 1) / 2) ≡ 1 [ZMOD A q] := by
      have h_contra_exp : 3 ^ (q * (q + 1) / 2) ≡ (3 ^ q) ^ ((q + 1) / 2) [ZMOD A q] := by
        rw [ ← pow_mul, Nat.mul_div_assoc _ ( even_iff_two_dvd.mp ( by simpa [ parity_simps ] using hq.eq_two_or_odd'.resolve_left ( by linarith ) ) ) ];
      simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
    simp_all +decide [ Int.ModEq ];
    norm_num [ Int.emod_eq_emod_iff_emod_sub_eq_zero ] at h_contra_exp;
    norm_cast at h_contra_exp; have := Nat.le_of_dvd ( by decide ) h_contra_exp; interval_cases _ : A q <;> simp_all +decide ;
    exact absurd h_half ( ne_of_lt ( Nat.div_pos ( by nlinarith ) ( by decide ) ) )

#eval Nat.Prime (59^2+59+1)

/-
A boolean function that checks the Feit-Thompson condition for p=3 and a given q.
It returns true if the condition holds (i.e., A does not divide (3^q-1)/2), or if the premises (q prime > 3) are not met.
It uses the fact that if A | (3^q-1)/2, then A must be prime. So if A is not prime, the condition holds.
If A is prime, it checks if 3^q ≡ 1 (mod A). If it is not 1, the condition holds.
-/
def check_feit_thompson_p_eq_3 (q : ℕ) : Bool :=
  if h : q.Prime ∧ 3 < q then
    let a := A q
    if a.Prime then
      (3 : ZMod a) ^ q ≠ 1
    else
      true -- If A is not prime, the condition holds by lemma feit_thompson_p_eq_3_A_prime
  else
    true

/-
Verification of the Feit-Thompson conjecture for p=3 and all q < 100.
-/
def check_feit_thompson_range (n : ℕ) : Bool :=
  List.all (List.range n) (fun q => check_feit_thompson_p_eq_3 q)

theorem feit_thompson_p_eq_3_bounded_100 : check_feit_thompson_range 100 = true := by native_decide

/-
If q ≡ 2 (mod 3) and 3^q ≡ 1 (mod A), then 3 is a cube mod A.
-/
def IsCube {R : Type*} [CommRing R] (x : R) : Prop := ∃ y, y^3 = x

theorem three_is_cube_of_three_pow_q_eq_one (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime)
  (hpow : (3 : ZMod (A q)) ^ q = 1) : IsCube (3 : ZMod (A q)) := by
    -- Since $q \equiv 2 \pmod{3}$, we can write $q = 3k + 2$ for some integer $k$.
    obtain ⟨k, rfl⟩ : ∃ k, q = 3 * k + 2 := by
      exact Nat.div_add_mod q 3 ▸ hmod3.symm ▸ ⟨ _, rfl ⟩;
    -- Since $3^{q+1} = 3^{3k+3} = (3^{k+1})^3$, we have $3 \equiv (3^{k+1})^3 \pmod{A}$.
    have h_cube : (3 : ZMod (A (3 * k + 2))) = (3 ^ (k + 1)) ^ 3 := by
      linear_combination' -hpow * 3;
    exact ⟨ 3 ^ ( k + 1 ), by linear_combination' h_cube.symm ⟩

/-
Verification of the Feit-Thompson conjecture for p=3 and all q < 500.
-/
theorem feit_thompson_p_eq_3_bounded_500 : check_feit_thompson_range 500 = true := by native_decide

/-
Helper function to check if 4A = a^2 + 27b^2 has a solution.
We check for q=11 (where A is not prime) and q=59 (where A is prime).
-/
def check_cubic_rep (q : ℕ) : Bool :=
  let target := 4 * (q^2 + q + 1)
  List.any (List.range (target.sqrt + 1)) fun b =>
    let rem := target - 27 * b^2
    if rem < 0 then false
    else
      let a := rem.sqrt
      a * a == rem

#eval check_cubic_rep 11 -- Should be true (17^2 + 27*3^2 = 289 + 243 = 532)
#eval check_cubic_rep 59 -- Check for q=59

#eval (3^59) % 3541

/-
The p=3 case of Feit-Thompson, assuming a standard result from cubic reciprocity.
-/
def CubicReciprocityCondition : Prop :=
  ∀ (p : ℕ), p.Prime → p ≡ 1 [MOD 3] → (∃ x : ℤ, 4 * p = x^2 + 3) → ¬ IsCube (3 : ZMod p)

theorem feit_thompson_p_eq_3_complete (h_cubic : CubicReciprocityCondition)
  (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) :
  ¬ ((A q) ∣ (3^q - 1) / 2) := by
    intro h_div
    have h_A_prime : Nat.Prime (A q) := by
      exact?
    have h_q_mod_3 : q ≡ 2 [MOD 3] := by
      exact?
    have h_q_mod_4 : q ≡ 3 [MOD 4] := by
      have h_q_mod_4 : q % 4 = 1 → (3 : ZMod (A q)) ^ q ≠ 1 := by
        exact?;
      -- If $q \equiv 1 \pmod{4}$, then $3^q \equiv 1 \pmod{A}$, contradicting $h_q_mod_4$.
      by_cases h_q_mod_4_1 : q % 4 = 1;
      · have h_contradiction : (3 ^ q : ℕ) ≡ 1 [MOD A q] := by
          refine Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
          simpa [ Nat.cast_sub ( Nat.one_le_pow q 3 zero_lt_three ) ] using Int.natCast_dvd_natCast.mpr ( dvd_trans h_div ( Nat.div_dvd_of_dvd ( show 2 ∣ 3 ^ q - 1 from even_iff_two_dvd.mp ( by simp +decide [ Nat.one_le_iff_ne_zero, parity_simps ] ) ) ) );
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      · have := Nat.Prime.eq_two_or_odd hq; ( rw [ Nat.ModEq ] at *; omega; )
    have h_3_cube : IsCube (3 : ZMod (A q)) := by
      convert three_is_cube_of_three_pow_q_eq_one q hq hq3 h_q_mod_3 h_A_prime _ using 1;
      have h_3_pow_q_eq_1 : (3 ^ q : ℤ) ≡ 1 [ZMOD (A q)] := by
        exact Eq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using h_div.trans <| Nat.div_dvd_of_dvd <| by simp [ ← even_iff_two_dvd, Nat.one_le_iff_ne_zero, parity_simps ];
      erw [ ← ZMod.intCast_eq_intCast_iff ] at * ; aesop;
    -- Apply the Cubic Reciprocity Lemma to conclude that 3 is not a cube modulo A.
    have h_contradiction : ¬IsCube (3 : ZMod (A q)) := by
      apply h_cubic (A q) h_A_prime;
      · unfold A; rw [ Nat.ModEq ] at *; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at *; have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> trivial;
      · exact ⟨ 2 * q + 1, by push_cast [ show A q = q ^ 2 + q + 1 from rfl ] ; ring ⟩;
    contradiction

/-
Empirical verification of the Cubic Reciprocity Condition for primes up to 1000.
-/
def check_cubic_reciprocity_condition (limit : ℕ) : Bool :=
  List.all (List.range limit) fun p =>
    if p.Prime ∧ p % 3 == 1 then
      let target := 4 * p - 3
      let x := target.sqrt
      if x * x == target then
        -- Check if 3 is a cube mod p
        let p_val : ℕ := p
        let exp := (p_val - 1) / 3
        (3 : ZMod p_val) ^ exp ≠ 1
      else
        true
    else
      true

#eval check_cubic_reciprocity_condition 1000

/-
Definition of the Eisenstein representation 4p = a^2 + 3b^2.
-/
def IsEisensteinRep (p : ℕ) (a b : ℤ) : Prop :=
  4 * p = a^2 + 3 * b^2

/-
Find L, M such that 4A = L^2 + 27M^2 for q=59, using Integers to avoid subtraction underflow issues.
-/
def find_eisenstein_rep (q : ℕ) : Option (ℤ × ℤ) :=
  let target : ℤ := 4 * ((q : ℤ)^2 + (q : ℤ) + 1)
  (List.range (target.toNat.sqrt + 1)).findSome? fun m_nat =>
    let m : ℤ := m_nat
    let rem := target - 27 * m^2
    if rem < 0 then none
    else
      let l := rem.toNat.sqrt
      if (l : ℤ) * l == rem then some (l, m)
      else none

#eval find_eisenstein_rep 59

/-
Verification of the Feit-Thompson conjecture for p=3 and all q < 2000.
-/
theorem feit_thompson_p_eq_3_bounded_2000 : check_feit_thompson_range 2000 = true := by native_decide

/-
Definition of a primary Eisenstein integer a + bω.
An Eisenstein integer a + bω is primary if a ≡ 2 (mod 3) and b ≡ 0 (mod 3).
Note: Some definitions use a ≡ -1 (mod 3), which is equivalent to 2 (mod 3).
-/
def IsPrimaryEisenstein (a b : ℤ) : Prop :=
  a ≡ 2 [ZMOD 3] ∧ b ≡ 0 [ZMOD 3]

/-
The statement of the Cubic Reciprocity Law for the prime 3.
-/
def CubicReciprocityLaw : Prop :=
  ∀ (p : ℕ) (hp : p.Prime) (hp1 : p ≡ 1 [MOD 3])
  (a b : ℤ) (h_rep : 4 * p = (2 * a - b)^2 + 3 * b^2) (h_prim : IsPrimaryEisenstein a b),
  IsCube (3 : ZMod p) ↔ b ≡ 0 [ZMOD 9]

/-
Algebraic identity: 4A = (q-1)^2 + 3(q+1)^2.
-/
theorem eisenstein_rep_of_A (q : ℕ) :
  4 * (A q) = (2 * (q : ℤ) + 1)^2 + 3 * 1^2 := by
    simpa [ A ] using by ring;

/-
Algebraic identity for the primary Eisenstein representation of A.
-/
theorem eisenstein_rep_primary_of_A (q : ℕ) :
  4 * (A q) = (2 * (q : ℤ) - (q + 1))^2 + 3 * ((q : ℤ) + 1)^2 := by
    -- Substitute the definition of A q into the equation.
    simp [A];
    ring

/-
If q ≢ 8 (mod 9), then A does not divide (3^q-1)/2, assuming Cubic Reciprocity.
-/
theorem feit_thompson_p_eq_3_case_not_mod9_8 (h_cubic : CubicReciprocityLaw)
  (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod4 : q ≡ 3 [MOD 4]) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime)
  (h_not_mod9 : q % 9 ≠ 8) :
  ¬ ((A q) ∣ (3^q - 1) / 2) := by
    -- By `three_is_cube_of_three_pow_q_eq_one`, 3 is a cube mod A.
    have h_cube_mod : (3 : ZMod (A q)) ^ q = 1 → IsCube (3 : ZMod (A q)) := by
      exact?;
    -- Assume that $A \mid (3^q - 1)/2$. Then $3^q \equiv 1 \pmod{A}$.
    by_contra h_div
    have h_cong : (3 : ZMod (A q)) ^ q = 1 := by
      have h_cong : (3 : ZMod (A q)) ^ q - 1 = 0 := by
        have h_cong : (3 ^ q - 1 : ℕ) ≡ 0 [MOD A q] := by
          exact Nat.modEq_zero_iff_dvd.mpr ( dvd_trans h_div ( Nat.div_dvd_of_dvd ( even_iff_two_dvd.mp ( by simp +decide [ Nat.one_le_iff_ne_zero, parity_simps ] ) ) ) );
        simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_cong;
      exact eq_of_sub_eq_zero h_cong;
    -- By `h_cubic`, we have that $3$ is a cube mod $A$ if and only if $b \equiv 0 \pmod{9}$.
    have h_b_mod : (q + 1) % 9 = 0 := by
      specialize h_cubic ( A q ) hA ( by
        unfold A; norm_num [ Nat.ModEq, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at *; have := Nat.mod_lt q zero_lt_three; interval_cases q % 3 <;> trivial; ) ( q : ℤ ) ( q + 1 : ℤ ) ( by
        unfold A; push_cast; ring; ) ( by
        constructor <;> rw [ Int.ModEq ] <;> norm_cast ; simp_all +decide [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ] );
      exact Nat.mod_eq_zero_of_dvd <| Int.natCast_dvd_natCast.mp <| Int.dvd_of_emod_eq_zero <| h_cubic.mp <| h_cube_mod h_cong;
    exact h_not_mod9 ( by omega )

/-
Check the condition for q=71.
-/
def check_q_71 : Bool :=
  let q := 71
  let a := A q
  if Nat.Prime a then
    (3 : ZMod a) ^ q ≠ 1
  else
    true

#eval check_q_71

/-
Verification of the Feit-Thompson conjecture for p=3 and all q < 10000.
-/
theorem feit_thompson_p_eq_3_bounded_10000 : check_feit_thompson_range 10000 = true := by native_decide

/-
If q ≢ 8 (mod 9), then A does not divide (3^q-1)/2, assuming Cubic Reciprocity.
-/
theorem feit_thompson_p_eq_3_case_not_mod9_8_v2 (h_cubic : CubicReciprocityLaw)
  (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod4 : q ≡ 3 [MOD 4]) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime)
  (h_not_mod9 : q % 9 ≠ 8) :
  ¬ ((A q) ∣ (3^q - 1) / 2) := by
    convert feit_thompson_p_eq_3_case_not_mod9_8 h_cubic q hq hq3 hmod4 hmod3 hA h_not_mod9 using 1

/-
Proof that if q ≢ 8 (mod 9), then A does not divide (3^q-1)/2, assuming Cubic Reciprocity.
-/
theorem feit_thompson_p_eq_3_case_not_mod9_8_v3 (h_cubic : CubicReciprocityLaw)
  (q : ℕ) (hq : q.Prime) (hq3 : 3 < q)
  (hmod4 : q ≡ 3 [MOD 4]) (hmod3 : q ≡ 2 [MOD 3]) (hA : (A q).Prime)
  (h_not_mod9 : q % 9 ≠ 8) :
  ¬ ((A q) ∣ (3^q - 1) / 2) := by
    apply feit_thompson_p_eq_3_case_not_mod9_8_v2 h_cubic q hq hq3 hmod4 hmod3 hA h_not_mod9

/-
The p=3 case of Feit-Thompson, conditional on Cubic Reciprocity and the q ≡ 8 (mod 9) case.
-/
def FeitThompsonCaseMod9Eq8 : Prop :=
  ∀ (q : ℕ), q.Prime → 3 < q → q ≡ 8 [MOD 9] → ¬ ((A q) ∣ (3^q - 1) / 2)

theorem feit_thompson_p_eq_3_conditional (h_cubic : CubicReciprocityLaw) (h_case8 : FeitThompsonCaseMod9Eq8)
  (q : ℕ) (hq : q.Prime) (hq3 : 3 < q) :
  ¬ ((A q) ∣ (3^q - 1) / 2) := by
    by_contra h;
    have hq_mod3 : q ≡ 2 [MOD 3] := by
      exact?
    have hq_mod4 : q ≡ 1 [MOD 4] ∨ q ≡ 3 [MOD 4] := by
      cases Nat.Prime.eq_two_or_odd hq <;> simp_all +decide [ Nat.ModEq, Nat.add_mod, Nat.mul_mod ];
      rw [ ← Nat.mod_mod_of_dvd q ( by decide : 2 ∣ 4 ) ] at *; have := Nat.mod_lt q zero_lt_four; interval_cases q % 4 <;> trivial;
    have hA_prime : Nat.Prime (A q) := by
      exact feit_thompson_p_eq_3_A_prime q hq hq3 h;
    rcases hq_mod4 with ( hq_mod4 | hq_mod4 );
    · exact absurd ( three_pow_q_ne_one_mod_A_of_q_mod_4_eq_1 q hq hq3 hq_mod4 hq_mod3 hA_prime ) ( by
        have h_contra : (3 ^ q : ZMod (A q)) = 1 := by
          have h_div : (A q : ℤ) ∣ (3 ^ q - 1) := by
            convert Int.natCast_dvd_natCast.mpr ( h.mul_left 2 ) using 1 ; norm_num [ ← Int.natCast_dvd_natCast, Nat.cast_sub ( show 1 ≤ 3 ^ q from Nat.one_le_pow _ _ ( by decide ) ) ] ; ring;
            rw [ Int.ediv_mul_cancel ( even_iff_two_dvd.mp ( by simp +decide [ hq.ne_zero, parity_simps ] ) ) ]
          exact eq_of_sub_eq_zero ( by simpa [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] using h_div );
        aesop );
    · by_cases hq_mod9 : q % 9 = 8;
      · exact?;
      · exact feit_thompson_p_eq_3_case_not_mod9_8_v3 h_cubic q hq hq3 hq_mod4 hq_mod3 hA_prime hq_mod9 h

#check FeitThompsonCaseMod9Eq8
#check feit_thompson_p_eq_3_conditional

/-
Verification of the Feit-Thompson conjecture for p=3 and all q < 20000.
-/
theorem feit_thompson_p_eq_3_bounded_20000 : check_feit_thompson_range 20000 = true := by native_decide

/-
Check 3^71 mod A(71).
-/
#eval (3^71) % (A 71)

/-
The combined proof of the Feit-Thompson conjecture for p=3, conditional on Cubic Reciprocity and the q ≡ 8 (mod 9) case.
-/
theorem feit_thompson_p_eq_3_combined (h_cubic : CubicReciprocityLaw) (h_case8 : FeitThompsonCaseMod9Eq8) :
  ∀ (q : ℕ), q.Prime → 3 < q → ¬ ((A q) ∣ (3^q - 1) / 2) := by
  intros q hq hq3
  exact feit_thompson_p_eq_3_conditional h_cubic h_case8 q hq hq3