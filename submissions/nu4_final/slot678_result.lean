/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 76c28d5e-e592-42e0-bebc-d54f72e4b630

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the definition of a regular prime and the Regular Prime Conjecture.
A prime $p$ is regular if it does not divide the class number of the $p$-th cyclotomic field $\mathbb{Q}(\zeta_p)$.
We have defined `IsRegularPrime` and `RegularPrimeConjecture`.
We have also proven that 2 is a regular prime (`isRegularPrime_two`).
The conjecture `regularprime_conjecture` states that there are infinitely many regular primes. This is an open problem, so we cannot prove it.
The statement `theorem regularprime_conjecture : RegularPrimeConjecture := by sorry` times out because the ATP attempts to prove the open conjecture.
The definitions are available in the workspace.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A prime p is regular if p does not divide the class number of Q(zeta_p).
-/
def IsRegularPrime (p : ℕ) : Prop :=
  p.Prime ∧ ¬ (p ∣ NumberField.classNumber (CyclotomicField p ℚ))

/-
The Regular Prime Conjecture states that there are infinitely many regular primes.
-/
def RegularPrimeConjecture : Prop := Set.Infinite {p : ℕ | IsRegularPrime p}

#check 1

/-
2 is a regular prime.
-/
theorem isRegularPrime_two : IsRegularPrime 2 := by
  constructor <;> norm_num [ IsRegularPrime ];
  rw [ Nat.mod_eq_of_lt ] <;> norm_num [ NumberField.classNumber ];
  · -- Since the ring of integers of ℚ(ζ_2) is ℤ, which is a principal ideal domain, its class group is trivial.
    have h_trivial : ∀ I : Ideal (NumberField.RingOfIntegers (CyclotomicField 2 ℚ)), I.IsPrincipal := by
      -- The ring of integers of ℚ(ζ_2) is ℤ, which is a principal ideal domain.
      have h_ring_of_integers : NumberField.RingOfIntegers (CyclotomicField 2 ℚ) ≃+* ℤ := by
        -- The cyclotomic field ℚ(ζ_2) is equal to ℚ, and the ring of integers of ℚ is ℤ.
        have h_cyclotomic : (CyclotomicField 2 ℚ) ≃+* ℚ := by
          -- The cyclotomic field of order 2 is just ℚ itself, so the isomorphism is the identity map.
          have h_iso : CyclotomicField 2 ℚ ≃ₐ[ℚ] ℚ := by
            have h_cyclotomic_field : IsCyclotomicExtension {2} ℚ (CyclotomicField 2 ℚ) := by
              infer_instance
            have h_cyclotomic_field : IsCyclotomicExtension {2} ℚ ℚ := by
              constructor;
              · norm_num [ IsPrimitiveRoot.iff_def ];
                exact Or.inr fun l hl => even_iff_two_dvd.mp ( by by_cases h : Even l <;> simp_all +decide );
              · exact fun x => Subalgebra.algebraMap_mem _ x
            have h_iso : CyclotomicField 2 ℚ ≃ₐ[ℚ] ℚ := by
              exact?
            exact h_iso;
          exact h_iso.toRingEquiv;
        have h_ring_of_integers : NumberField.RingOfIntegers (CyclotomicField 2 ℚ) ≃+* NumberField.RingOfIntegers ℚ := by
          exact?;
        exact h_ring_of_integers.trans <| by exact?;
      intro I
      obtain ⟨J, hJ⟩ : ∃ J : Ideal ℤ, I = Ideal.map h_ring_of_integers.symm.toRingHom J := by
        use Ideal.map h_ring_of_integers.toRingHom I;
        simp +decide [ Ideal.map_map ]
      have h_principal : Submodule.IsPrincipal J := by
        exact?
      have h_principal_I : Submodule.IsPrincipal I := by
        obtain ⟨ x, hx ⟩ := h_principal;
        use h_ring_of_integers.symm x;
        simp +decide [ hJ, hx, Ideal.map_span ]
      exact h_principal_I;
    rw [ Fintype.card_eq_one_iff ];
    refine' ⟨ 1, fun y => _ ⟩;
    obtain ⟨ I, hI ⟩ := ClassGroup.mk0_surjective y;
    rw [ ← hI, ClassGroup.mk0_eq_one_iff ];
    exact h_trivial _;
  · -- The class group of the ring of integers of the cyclotomic field of order 2 is trivial.
    have h_trivial : IsPrincipalIdealRing (NumberField.RingOfIntegers (CyclotomicField 2 ℚ)) := by
      have h_int : NumberField.RingOfIntegers (CyclotomicField 2 ℚ) ≃+* ℤ := by
        -- The cyclotomic field ℚ(ζ_2) is equal to ℚ, and the ring of integers of ℚ is ℤ.
        have h_cyclotomic : (CyclotomicField 2 ℚ) ≃+* ℚ := by
          -- The cyclotomic field of order 2 is just ℚ itself, so the isomorphism is the identity map.
          have h_iso : CyclotomicField 2 ℚ ≃ₐ[ℚ] ℚ := by
            have h_cyclotomic_field : IsCyclotomicExtension {2} ℚ (CyclotomicField 2 ℚ) := by
              infer_instance
            have h_cyclotomic_field : IsCyclotomicExtension {2} ℚ ℚ := by
              constructor;
              · norm_num [ IsPrimitiveRoot.iff_def ];
                exact Or.inr fun l hl => even_iff_two_dvd.mp ( by by_cases h : Even l <;> simp_all +decide );
              · exact fun x => Subalgebra.algebraMap_mem _ x
            have h_iso : CyclotomicField 2 ℚ ≃ₐ[ℚ] ℚ := by
              exact?
            exact h_iso;
          exact h_iso.toRingEquiv;
        have h_ring_of_integers : NumberField.RingOfIntegers (CyclotomicField 2 ℚ) ≃+* NumberField.RingOfIntegers ℚ := by
          exact?;
        exact h_ring_of_integers.trans <| by exact?;
      have h_int : IsPrincipalIdealRing (NumberField.RingOfIntegers (CyclotomicField 2 ℚ)) := by
        have h_iso : Nonempty (NumberField.RingOfIntegers (CyclotomicField 2 ℚ) ≃+* ℤ) := by
          exact ⟨ h_int ⟩
        obtain ⟨ f ⟩ := h_iso;
        have h_iso : ∀ I : Ideal (NumberField.RingOfIntegers (CyclotomicField 2 ℚ)), ∃ J : Ideal ℤ, I = Ideal.map f.symm.toRingHom J := by
          intro I
          use Ideal.map f.toRingHom I
          ext x
          simp [Ideal.mem_map_iff_of_surjective];
        have h_iso : ∀ J : Ideal ℤ, ∃ x : ℤ, J = Ideal.span {x} := by
          exact fun J => ⟨ _, Eq.symm <| Ideal.span_singleton_generator J ⟩;
        constructor;
        intro I; obtain ⟨ J, rfl ⟩ := ‹∀ I : Ideal ( NumberField.RingOfIntegers ( CyclotomicField 2 ℚ ) ), ∃ J : Ideal ℤ, I = Ideal.map f.symm.toRingHom J› I; obtain ⟨ x, rfl ⟩ := h_iso J; use f.symm x; simp +decide [ Ideal.map_span ] ;
      exact h_int;
    have h_card : Fintype.card (ClassGroup (NumberField.RingOfIntegers (CyclotomicField 2 ℚ))) = 1 := by
      exact?
    exact h_card.symm ▸ by decide;