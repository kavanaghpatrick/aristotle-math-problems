/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dad82404-dc75-429b-a456-6733d47f550f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized Kurepa's conjecture and provided a computational verification for $n < 2000$.

Key results:
- `kurepa_reduction_to_primes`: The conjecture reduces to checking prime numbers.
- `kurepa_implies_gcd_fixed`: The conjecture implies $\gcd(n!, !n) = 2$ for $n > 2$.
- `kurepa_conjecture_bound_2000`: The conjecture holds for all $n < 2000$, verified using `native_decide` with an efficient modular implementation of the left factorial.
- `left_factorial_mod_prime_lt`: For prime $q < n$, $!n \equiv !q \pmod q$.
- `left_factorial_mod_four`: For $n \ge 4$, $!n \equiv 2 \pmod 4$.

The computational verification uses `efficient_left_factorial_mod`, which computes $!n \pmod m$ in linear time relative to $n$, avoiding large integer arithmetic. Correctness is proven in `efficient_left_factorial_mod_correct`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open BigOperators Nat Finset

/-
The left factorial !n is the sum of factorials from 0! to (n-1)!.
-/
def Kurepa.left_factorial (n : ℕ) := ∑ m ∈ Finset.range n, m !

/-
Verify Kurepa's conjecture for n < 150 using computation.
-/
theorem kurepa_conjecture_bound : ∀ n, 2 < n → n < 150 → (Kurepa.left_factorial n) % n ≠ 0 := by
  -- By checking each $n$ from $3$ to $149$, we can verify that $!n$ is not divisible by $n$.
  have h_check : ∀ n ∈ Finset.Icc 3 149, Kurepa.left_factorial n % n ≠ 0 := by
    native_decide;
  exact fun n hn hn' => h_check n ( Finset.mem_Icc.mpr ⟨ hn, Nat.le_of_lt_succ hn' ⟩ )

/-
If gcd(n!, !n) = 2, then !n is not divisible by n (for n > 2).
-/
theorem kurepa_gcd_implies_not_divisible (n : ℕ) (h_n : 2 < n) (h_gcd : Nat.gcd (n !) (Kurepa.left_factorial n) = 2) : (Kurepa.left_factorial n) % n ≠ 0 := by
  intro h_div
  have h_dvd : n ∣ Kurepa.left_factorial n := Nat.dvd_of_mod_eq_zero h_div
  have h_dvd_fact : n ∣ n ! := Nat.dvd_factorial (by linarith) (by linarith)
  have h_dvd_gcd : n ∣ Nat.gcd (n !) (Kurepa.left_factorial n) := Nat.dvd_gcd h_dvd_fact h_dvd
  rw [h_gcd] at h_dvd_gcd
  have h_le : n ≤ 2 := Nat.le_of_dvd (by decide) h_dvd_gcd
  linarith

/-
For a prime p, !p ≡ (sum_{k=0}^{p-2} k!) - 1 (mod p). This follows from Wilson's theorem (p-1)! ≡ -1 (mod p).
-/
theorem left_factorial_prime_congruence (p : ℕ) (hp : p.Prime) : Kurepa.left_factorial p ≡ (∑ k ∈ Finset.range (p - 1), k !) - 1 [MOD p] := by
  rcases p with ( _ | _ | p ) <;> simp_all +arith +decide [ Finset.sum_range_succ ];
  -- By Wilson's theorem, we know that $(p+1)! \equiv -1 \pmod{p+2}$.
  have h_wilson : (p + 1)! ≡ -1 [ZMOD (p + 2)] := by
    have h_wilson : ∀ p : ℕ, Nat.Prime p → (p - 1)! ≡ -1 [ZMOD p] := by
      intro p pp; haveI := Fact.mk pp; norm_num [ ← ZMod.intCast_eq_intCast_iff ] ;
    exact h_wilson _ hp;
  simp_all +decide [ ← Int.natCast_modEq_iff, Kurepa.left_factorial ];
  rw [ Nat.cast_sub ] <;> norm_num [ Finset.sum_range_succ ];
  · simpa [ sub_eq_add_neg ] using h_wilson.add_left ( ∑ x ∈ Finset.range p, ( x ! : ℤ ) + p ! );
  · exact Nat.one_le_iff_ne_zero.mpr ( by positivity )

/-
Reduction of Kurepa's conjecture to primes: if !p is not divisible by p for all primes p, then !n is not divisible by n for all n > 2.
-/
theorem kurepa_reduction (h : ∀ p, p.Prime → (Kurepa.left_factorial p) % p ≠ 0) : ∀ n, 2 < n → (Kurepa.left_factorial n) % n ≠ 0 := by
  -- By definition of left factorial, we know that !n is the sum of factorials from 0! to (n-1)!.
  intro n hn
  by_contra h_contra
  have h_div : ∃ p, Nat.Prime p ∧ p ∣ n ∧ p ∣ Kurepa.left_factorial n := by
    exact ⟨ Nat.minFac n, Nat.minFac_prime ( by linarith ), Nat.minFac_dvd n, Nat.dvd_trans ( Nat.minFac_dvd n ) ( Nat.dvd_of_mod_eq_zero h_contra ) ⟩
  obtain ⟨p, hp_prime, hp_div_n, hp_div_left_factorial⟩ := h_div
  have h_contra_prime : Kurepa.left_factorial p % p = 0 := by
    -- Since $p \mid n$, we have $Kurepa.left_factorial n = \sum_{k=0}^{n-1} k! = \sum_{k=0}^{p-1} k! + \sum_{k=p}^{n-1} k!$.
    have h_split_sum : Kurepa.left_factorial n = Kurepa.left_factorial p + ∑ k ∈ Finset.Ico p n, k ! := by
      unfold Kurepa.left_factorial; rw [ Finset.sum_range_add_sum_Ico _ ( Nat.le_of_dvd ( by linarith ) hp_div_n ) ] ;
    -- Since $p \mid n$, we have $\sum_{k=p}^{n-1} k! \equiv 0 \pmod{p}$.
    have h_sum_zero : ∑ k ∈ Finset.Ico p n, k ! ≡ 0 [MOD p] := by
      exact Nat.modEq_zero_iff_dvd.mpr <| Finset.dvd_sum fun x hx => Nat.dvd_factorial hp_prime.pos <| Finset.mem_Ico.mp hx |>.1;
    simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero, Nat.add_mod ]
  exact h p hp_prime h_contra_prime

/-
For a prime p, p divides the sum of factorials from p! to (n-1)!.
-/
theorem dvd_sum_factorial_Ico {p n : ℕ} (hp : p.Prime) : p ∣ ∑ k ∈ Finset.Ico p n, k ! := by
  apply Finset.dvd_sum
  intro k hk
  rw [Finset.mem_Ico] at hk
  apply Nat.dvd_factorial hp.pos hk.left

/-
Reduction of Kurepa's conjecture to primes: if !p is not divisible by p for all primes p, then !n is not divisible by n for all n > 2.
-/
theorem kurepa_reduction_to_primes (h : ∀ p, p.Prime → (Kurepa.left_factorial p) % p ≠ 0) : ∀ n, 2 < n → (Kurepa.left_factorial n) % n ≠ 0 := by
  convert kurepa_reduction h

/-
For n >= 4, !n ≡ 2 (mod 4).
-/
theorem left_factorial_mod_four (n : ℕ) (h : 4 ≤ n) : Kurepa.left_factorial n ≡ 2 [MOD 4] := by
  induction h <;> simp_all +arith +decide [ Nat.ModEq, Nat.factorial_succ, Finset.sum_range_succ ];
  unfold Kurepa.left_factorial at * ; simp_all +arith +decide [ Nat.factorial_succ, Finset.sum_range_succ ];
  norm_num [ Nat.add_mod, Nat.mod_eq_zero_of_dvd ( Nat.dvd_factorial ( by linarith ) ( by linarith ) : 4 ∣ _ ) ] at * ; aesop

/-
Verify Kurepa's conjecture for n < 200 using computation.
-/
theorem kurepa_conjecture_bound_200 : ∀ n, 2 < n → n < 200 → (Kurepa.left_factorial n) % n ≠ 0 := by
  -- By definition of left factorial, we know that $!n \equiv 2 \pmod{4}$ for all $n \geq 4$.
  intros n hn_pos hn_lt_200
  interval_cases n <;> native_decide

/-
If q < n is prime, then !n ≡ !q (mod q).
-/
theorem left_factorial_mod_prime_lt (n q : ℕ) (hq : q.Prime) (h_qn : q < n) : Kurepa.left_factorial n ≡ Kurepa.left_factorial q [MOD q] := by
  -- By definition of $Kurepa.left_factorial$, we can split the sum at $q$.
  have h_split : (Kurepa.left_factorial n) = (∑ m ∈ Finset.range q, m !) + (∑ m ∈ Finset.Ico q n, m !) := by
    rw [ Finset.sum_range_add_sum_Ico _ h_qn.le ];
    rfl;
  simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
  simp +decide [ Kurepa.left_factorial ];
  exact Finset.sum_eq_zero fun x hx => by rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.dvd_factorial hq.pos ( Finset.mem_Ico.mp hx |>.1 ) ;

/-
Reduction of Kurepa's conjecture to primes: if !p is not divisible by p for all primes p, then !n is not divisible by n for all n > 2.
-/
theorem kurepa_reduction_clean (h : ∀ p, p.Prime → (Kurepa.left_factorial p) % p ≠ 0) : ∀ n, 2 < n → (Kurepa.left_factorial n) % n ≠ 0 := by
  exact?

/-
Reduction of Kurepa's conjecture to primes: if !p is not divisible by p for all primes p, then !n is not divisible by n for all n > 2.
-/
theorem kurepa_reduction_final (h : ∀ p, p.Prime → (Kurepa.left_factorial p) % p ≠ 0) : ∀ n, 2 < n → (Kurepa.left_factorial n) % n ≠ 0 := by
  intro n hn
  by_cases hp : n.Prime
  · exact h n hp
  · let p := n.minFac
    have p_prime : p.Prime := Nat.minFac_prime (by linarith)
    have p_dvd_n : p ∣ n := Nat.minFac_dvd n
    have p_lt_n : p < n := by
      rw [← Nat.not_prime_iff_minFac_lt (by linarith)]
      exact hp
    have p_le_n : p ≤ n := le_of_lt p_lt_n
    intro h_div
    have p_dvd_left_fact : p ∣ Kurepa.left_factorial n := Nat.dvd_trans p_dvd_n (Nat.dvd_of_mod_eq_zero h_div)
    have split_sum : Kurepa.left_factorial n = Kurepa.left_factorial p + ∑ k ∈ Finset.Ico p n, k ! := by
      rw [Kurepa.left_factorial, Kurepa.left_factorial]
      rw [← Finset.sum_range_add_sum_Ico _ p_le_n]
    have p_dvd_sum : p ∣ ∑ k ∈ Finset.Ico p n, k ! := dvd_sum_factorial_Ico p_prime
    have p_dvd_left_fact_p : p ∣ Kurepa.left_factorial p := by
      rw [split_sum] at p_dvd_left_fact
      exact (Nat.dvd_add_iff_left p_dvd_sum).mpr p_dvd_left_fact
    have p_mod_ne_zero : (Kurepa.left_factorial p) % p ≠ 0 := h p p_prime
    apply p_mod_ne_zero
    exact Nat.mod_eq_zero_of_dvd p_dvd_left_fact_p

/-
If Kurepa's conjecture holds (for all m > 2), then gcd(n!, !n) = 2 for all n > 2.
-/
theorem kurepa_implies_gcd (h : ∀ m, 2 < m → (Kurepa.left_factorial m) % m ≠ 0) : ∀ n, 2 < n → Nat.gcd (n !) (Kurepa.left_factorial n) = 2 := by
  -- By definition of gcd, we know that gcd(n!, !n) divides both n! and !n.
  intros n hn
  have h_div : Nat.gcd (Nat.factorial n) (Kurepa.left_factorial n) ∣ Nat.gcd (Nat.factorial n) (2 * (Kurepa.left_factorial n)) := by
    exact Nat.dvd_gcd ( Nat.gcd_dvd_left _ _ ) ( dvd_mul_of_dvd_right ( Nat.gcd_dvd_right _ _ ) _ );
  -- Since !n is not divisible by p for any prime p, gcd(n!, !n) cannot have any prime factors other than 2.
  have h_no_prime_factors : ∀ p, p.Prime → p ∣ Nat.gcd (Nat.factorial n) (Kurepa.left_factorial n) → p = 2 := by
    intro p pp dp; have := Nat.dvd_trans dp ( Nat.gcd_dvd_right _ _ ) ; have := Nat.dvd_trans dp ( Nat.gcd_dvd_left _ _ ) ; simp_all +decide [ Nat.Prime.dvd_factorial ] ;
    -- By definition of gcd, we know that gcd(n!, !n) divides both n! and !n. Since p divides gcd(n!, !n), it must divide both n! and !n.
    have h_divides_left_factorial : Kurepa.left_factorial p ≡ Kurepa.left_factorial n [MOD p] := by
      by_cases h_cases : p < n;
      · exact?;
      · cases eq_or_lt_of_le this <;> aesop;
    simp_all +decide [ Nat.ModEq, Nat.dvd_iff_mod_eq_zero ];
    exact Classical.not_not.1 fun hp => h p ( lt_of_le_of_ne pp.two_le ( Ne.symm hp ) ) h_divides_left_factorial;
  -- Since gcd(n!, !n) cannot have any prime factors other than 2, it must be a power of 2.
  have h_power_of_two : ∃ k, Nat.gcd (Nat.factorial n) (Kurepa.left_factorial n) = 2 ^ k := by
    rw [ ← Nat.prod_primeFactorsList ( Nat.ne_of_gt ( Nat.gcd_pos_of_pos_left _ ( Nat.factorial_pos _ ) ) ) ] ; rw [ List.prod_eq_pow_single 2 ] ; aesop;
    exact fun p hp₁ hp₂ => False.elim <| hp₁ <| h_no_prime_factors p ( Nat.prime_of_mem_primeFactorsList hp₂ ) <| Nat.dvd_of_mem_primeFactorsList hp₂;
  -- Since !n is not divisible by 4 for n ≥ 4, gcd(n!, !n) cannot have 4 as a factor.
  have h_not_div_four : ¬(4 ∣ Nat.gcd (Nat.factorial n) (Kurepa.left_factorial n)) := by
    rw [ Nat.dvd_gcd_iff ];
    by_cases hn4 : n < 4;
    · interval_cases n ; trivial;
    · exact fun h => absurd ( Nat.mod_eq_zero_of_dvd h.2 ) ( by rw [ left_factorial_mod_four n ( by linarith ) ] ; norm_num );
  rcases h_power_of_two with ⟨ k, hk ⟩ ; rcases k with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ] ;
  · -- Since $n!$ is even for $n \geq 2$, and $!n$ is also even for $n \geq 2$, their gcd must be at least 2.
    have h_even : Even (Nat.factorial n) ∧ Even (Kurepa.left_factorial n) := by
      constructor;
      · exact even_iff_two_dvd.mpr ( Nat.dvd_factorial ( by decide ) ( by linarith ) );
      · unfold Kurepa.left_factorial;
        rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide [ Finset.sum_range_succ', parity_simps ];
        exact even_iff_two_dvd.mpr ( Finset.dvd_sum fun x hx => Nat.dvd_factorial ( by linarith ) ( by linarith ) );
    exact absurd ( Nat.dvd_gcd ( even_iff_two_dvd.mp h_even.1 ) ( even_iff_two_dvd.mp h_even.2 ) ) ( by aesop );
  · exact h_not_div_four ⟨ 2 ^ k, by ring ⟩

/-
If Kurepa's conjecture holds (for all m > 2), then gcd(n!, !n) = 2 for all n > 2.
-/
theorem kurepa_implies_gcd_fixed (h : ∀ m, 2 < m → (Kurepa.left_factorial m) % m ≠ 0) : ∀ n, 2 < n → Nat.gcd (n !) (Kurepa.left_factorial n) = 2 := by
  convert kurepa_implies_gcd h using 1

/-
Recurrence relation for left factorial: !(n+1) = !n + n!.
-/
theorem left_factorial_succ (n : ℕ) : Kurepa.left_factorial (n + 1) = Kurepa.left_factorial n + n ! := by
  rw [Kurepa.left_factorial, Kurepa.left_factorial, Finset.sum_range_succ]

/-
Efficient calculation of !n mod m using a fold that maintains the current factorial modulo m.
-/
def efficient_left_factorial_mod (n m : ℕ) : ℕ :=
  let step := fun (state : ℕ × ℕ) (k : ℕ) =>
    let (sum, fact) := state
    ((sum + fact) % m, (fact * (k + 1)) % m)
  (List.range n).foldl step (0, 1) |>.1

theorem efficient_left_factorial_mod_correct (n m : ℕ) (hm : m > 0) : efficient_left_factorial_mod n m = (Kurepa.left_factorial n) % m := by
  unfold efficient_left_factorial_mod;
  rw [ show Kurepa.left_factorial n = ∑ k ∈ Finset.range n, Nat.factorial k from rfl ];
  induction' n with n ih;
  · exact?;
  · -- By induction on $n$, we can show that the second component of the foldl result is congruent to $n!$ modulo $m$.
    have h_ind : ∀ n, (List.foldl (fun (state : ℕ × ℕ) (k : ℕ) => ((state.1 + state.2) % m, state.2 * (k + 1) % m)) (0, 1) (List.range n)).2 ≡ Nat.factorial n [MOD m] := by
      intro n; induction n <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, List.range_succ ] ;
      simp +decide [ Nat.factorial_succ, mul_comm ];
    simp_all +decide [ Finset.sum_range_succ, List.range_succ ];
    exact Nat.ModEq.add_left _ ( h_ind n )

/-
Verify Kurepa's conjecture for n < 1000 using the efficient modular computation.
-/
theorem kurepa_conjecture_bound_1000 : ∀ n, 2 < n → n < 1000 → (Kurepa.left_factorial n) % n ≠ 0 := by
  -- By checking each n from 3 to 999, we can verify that none of them divide the left factorial.
  have h_check : ∀ n ∈ Finset.Ico 3 1000, ¬(n ∣ ∑ m ∈ Finset.range n, Nat.factorial m) := by
    native_decide;
  exact fun n hn hn' => fun h => h_check n ( Finset.mem_Ico.mpr ⟨ hn, hn' ⟩ ) ( Nat.dvd_of_mod_eq_zero h )

/-
Verify Kurepa's conjecture for n < 1000 using the efficient modular computation (version 2).
-/
theorem kurepa_conjecture_bound_1000_v2 : ∀ n, 2 < n → n < 1000 → (Kurepa.left_factorial n) % n ≠ 0 := by
  intro n hn_gt hn_lt
  have h_check : ∀ k ∈ Finset.Icc 3 999, efficient_left_factorial_mod k k ≠ 0 := by
    native_decide
  have h_eff : efficient_left_factorial_mod n n = (Kurepa.left_factorial n) % n := efficient_left_factorial_mod_correct n n (by linarith)
  rw [← h_eff]
  apply h_check n
  rw [Finset.mem_Icc]
  constructor
  · exact hn_gt
  · exact Nat.le_of_lt_succ hn_lt

#check List.range_succ
#check List.foldl_append

/-
Helper function for efficient modular left factorial.
-/
def Kurepa.efficient_step (m : ℕ) (state : ℕ × ℕ) (k : ℕ) : ℕ × ℕ :=
  let (sum, fact) := state
  ((sum + fact) % m, (fact * (k + 1)) % m)

def Kurepa.efficient_left_factorial_mod (n m : ℕ) : ℕ :=
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) |>.1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    induction' n with n ih;
    · unfold Kurepa.left_factorial; norm_num;
      rw [ Nat.mod_eq_of_lt hm ];
    · simp_all +decide [ List.range_succ ];
      unfold Kurepa.efficient_step; simp +decide [ Nat.factorial_succ, Nat.mul_mod, Nat.add_mod ] ;
      simp +decide [ ← Nat.mul_mod, ← Nat.add_mod, Kurepa.left_factorial ];
      exact ⟨ by rw [ Finset.sum_range_succ ], by rw [ mul_comm ] ⟩

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v2 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    exact?

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v3 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_v2 n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v4 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_v3 n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v5 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    -- Apply the theorem that states the foldl of the efficient step function with initial state (0, 1) is equal to the tuple (Kurepa.left_factorial n % m, n ! % m).
    apply Kurepa.efficient_step_correct_v4 n m hm

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_final (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    exact?

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v6 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    -- By definition of `List.foldl`, we can rewrite the goal in terms of the foldl operation.
    apply Kurepa.efficient_step_correct_final n m hm

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v7 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    exact?

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v8 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
  induction n with
  | zero =>
    simp [Kurepa.left_factorial, Kurepa.efficient_step]
    rw [Nat.mod_eq_of_lt hm]
  | succ n ih =>
    rw [List.range_succ, List.foldl_append]
    rw [ih]
    simp only [List.foldl_cons, List.foldl_nil]
    unfold Kurepa.efficient_step
    simp only [Prod.mk.injEq]
    constructor
    · rw [left_factorial_succ]
      rw [Nat.add_mod]
      conv_rhs => rw [Nat.add_mod]
      simp [Nat.mod_mod]
    · rw [Nat.factorial_succ]
      rw [Nat.mul_mod]
      conv_rhs => rw [Nat.mul_mod]
      simp [Nat.mod_mod, mul_comm]

/-
Correctness of the efficient modular left factorial function.
-/
theorem Kurepa.efficient_left_factorial_mod_correct (n m : ℕ) (hm : 1 < m) :
  Kurepa.efficient_left_factorial_mod n m = (Kurepa.left_factorial n) % m := by
  rw [Kurepa.efficient_left_factorial_mod]
  rw [Kurepa.efficient_step_correct_v8 n m hm]

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v9 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v10 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v11 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v12 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    exact?

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v13 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v14 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Lemma showing that the efficient step function correctly updates the state from n to n+1.
-/
theorem Kurepa.efficient_step_equiv (n m : ℕ) :
  Kurepa.efficient_step m (Kurepa.left_factorial n % m, Nat.factorial n % m) n =
  (Kurepa.left_factorial (n + 1) % m, Nat.factorial (n + 1) % m) := by
    simp +arith +decide [ Kurepa.left_factorial, Nat.factorial_succ _, Kurepa.efficient_step ];
    rw [ Finset.sum_range_succ, mul_comm ];
    grind

/-
Verify Kurepa's conjecture for n < 2000 using the efficient modular computation.
-/
theorem kurepa_conjecture_bound_2000 : ∀ n, 2 < n → n < 2000 → (Kurepa.left_factorial n) % n ≠ 0 := by
  intro n hn_gt hn_lt
  have h_check : ∀ k ∈ Finset.Icc 3 1999, Kurepa.efficient_left_factorial_mod k k ≠ 0 := by
    native_decide
  have h_eff : Kurepa.efficient_left_factorial_mod n n = (Kurepa.left_factorial n) % n := Kurepa.efficient_left_factorial_mod_correct n n (by linarith)
  rw [← h_eff]
  apply h_check n
  rw [Finset.mem_Icc]
  constructor
  · exact hn_gt
  · exact Nat.le_of_lt_succ hn_lt

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v15 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    -- Apply the theorem Kurepa.efficient_step_correct_v14 to conclude the proof.
    apply Kurepa.efficient_step_correct_v14 n m hm

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_v16 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    -- We'll use induction to prove that the foldl of the efficient step function over the range n gives us the correct result.
    apply_rules [Kurepa.efficient_step_correct]

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_proof (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
    convert Kurepa.efficient_step_correct_final n m hm using 1

/-
Correctness of the efficient step function (assuming m > 1).
-/
theorem Kurepa.efficient_step_correct_final_v2 (n m : ℕ) (hm : 1 < m) :
  (List.range n).foldl (Kurepa.efficient_step m) (0, 1) = (Kurepa.left_factorial n % m, Nat.factorial n % m) := by
  induction n with
  | zero =>
    simp [Kurepa.left_factorial, Kurepa.efficient_step]
    rw [Nat.mod_eq_of_lt hm]
  | succ n ih =>
    rw [List.range_succ, List.foldl_append]
    rw [ih]
    simp only [List.foldl_cons, List.foldl_nil]
    apply Kurepa.efficient_step_equiv