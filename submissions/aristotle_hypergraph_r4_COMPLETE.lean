/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6dc644d-bf54-4d89-87c5-65bf45dde87f

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of r-uniform hypergraph, covering number tau, and packing number nu.
-/
open Finset

variable {α : Type*} [DecidableEq α] [Fintype α]

/-- An r-uniform hypergraph is a collection of sets of size r. -/
def IsUniform (H : Finset (Finset α)) (r : ℕ) : Prop :=
  ∀ e ∈ H, e.card = r

/-- A set f is an (r-1)-face of e if f ⊆ e and |f| = r-1. -/
def IsFace (f e : Finset α) (r : ℕ) : Prop :=
  f ⊆ e ∧ f.card = r - 1

/-- A set of (r-1)-faces C covers H if every edge in H contains a face in C. -/
def IsCover (H : Finset (Finset α)) (C : Finset (Finset α)) (r : ℕ) : Prop :=
  (∀ f ∈ C, f.card = r - 1) ∧
  ∀ e ∈ H, ∃ f ∈ C, f ⊆ e

/-- τ(H) is the minimum size of a cover. -/
noncomputable def tau (H : Finset (Finset α)) (r : ℕ) : ℕ :=
  sInf {n | ∃ C, IsCover H C r ∧ C.card = n}

/-- Two edges are face-disjoint if they don't share an (r-1)-face. -/
def FaceDisjoint (e₁ e₂ : Finset α) (r : ℕ) : Prop :=
  ∀ f, f.card = r - 1 → f ⊆ e₁ → ¬ f ⊆ e₂

/-- A packing is a set of edges that are pairwise face-disjoint. -/
def IsPacking (H : Finset (Finset α)) (M : Finset (Finset α)) (r : ℕ) : Prop :=
  M ⊆ H ∧ ∀ e₁ ∈ M, ∀ e₂ ∈ M, e₁ ≠ e₂ → FaceDisjoint e₁ e₂ r

/-- ν(H) is the maximum size of a packing. -/
noncomputable def nu (H : Finset (Finset α)) (r : ℕ) : ℕ :=
  sSup {n | ∃ M, IsPacking H M r ∧ M.card = n}

/-
If two 4-edges intersect in at least 3 vertices, their union has size at most 5.
-/
lemma union_size_pair (e₁ e₂ : Finset α)
    (h₁ : e₁.card = 4) (h₂ : e₂.card = 4)
    (h_inter : (e₁ ∩ e₂).card ≥ 3) :
    (e₁ ∪ e₂).card ≤ 5 := by
  have := Finset.card_union_add_card_inter e₁ e₂; linarith;

/-
If e₁, e₂ share exactly 3 vertices, and e₃ shares ≥3 vertices with both but doesn't contain their intersection, then e₃ is contained in e₁ ∪ e₂.
-/
lemma third_edge_structure (e₁ e₂ e₃ : Finset α)
    (h₁ : e₁.card = 4) (h₂ : e₂.card = 4) (h₃ : e₃.card = 4)
    (hne : e₁ ≠ e₂)
    (h12 : (e₁ ∩ e₂).card = 3)
    (h13 : (e₁ ∩ e₃).card ≥ 3)
    (h23 : (e₂ ∩ e₃).card ≥ 3)
    (h_not_subset : ¬ (e₁ ∩ e₂ ⊆ e₃)) :
    e₃ ⊆ e₁ ∪ e₂ := by
  -- Let f = e₁ ∩ e₂. Since |e₁|=4, |e₂|=4, |f|=3, and e₁≠e₂, we have |e₁ ∪ e₂| = 5.
  set f := e₁ ∩ e₂ with hf_def
  have hf_card : f.card = 3 := by
    exact h12
  have he1_union_e2_card : (e₁ ∪ e₂).card = 5 := by
    have := Finset.card_union_add_card_inter e₁ e₂; aesop;
  -- Since $|e₁ ∩ e₃| ≥ 3$ and $|e₂ ∩ e₃| ≥ 3$, $e₃$ must contain at least 3 vertices from $e₁$ and 3 vertices from $e₂$.
  have h_e3_subset : (e₁ ∩ e₃).card + (e₂ ∩ e₃).card - (f ∩ e₃).card ≥ 3 + 3 - 2 := by
    have h_e3_subset : (f ∩ e₃).card ≤ 2 := by
      have h_e3_subset : (f ∩ e₃).card < f.card := by
        exact Finset.card_lt_card ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.inter_subset_left, fun h => h_not_subset <| h.symm ▸ Finset.inter_subset_right ⟩ );
      linarith;
    exact Nat.sub_le_sub_right ( add_le_add h13 h23 ) _ |> le_trans ( by omega );
  have h_e3_subset : (e₁ ∩ e₃).card + (e₂ ∩ e₃).card - (f ∩ e₃).card = (e₁ ∩ e₃ ∪ e₂ ∩ e₃).card := by
    rw [ ← Finset.card_union_add_card_inter, show e₁ ∩ e₃ ∩ ( e₂ ∩ e₃ ) = f ∩ e₃ by ext; aesop ] ; ring;
    rw [ Nat.add_sub_cancel ];
  have h_e3_subset : (e₁ ∩ e₃ ∪ e₂ ∩ e₃) = e₃ := by
    exact Finset.eq_of_subset_of_card_le ( Finset.union_subset ( Finset.inter_subset_right ) ( Finset.inter_subset_right ) ) ( by linarith );
  exact h_e3_subset ▸ Finset.union_subset ( Finset.inter_subset_left.trans ( Finset.subset_union_left ) ) ( Finset.inter_subset_left.trans ( Finset.subset_union_right ) )

/-
If 4-edges pairwise share faces (≥3 common vertices), either all share a common 3-face, or their union has at most 5 vertices.
-/
lemma pairwise_intersect_structure (S : Finset (Finset α))
    (h_unif : ∀ e ∈ S, e.card = 4)
    (h_pair : ∀ e₁ ∈ S, ∀ e₂ ∈ S, (e₁ ∩ e₂).card ≥ 3) :
    (∃ f, f.card = 3 ∧ ∀ e ∈ S, f ⊆ e) ∨ (S.biUnion id).card ≤ 5 := by
  by_cases h : ∃ e₁ ∈ S, ∃ e₂ ∈ S, e₁ ≠ e₂ ∧ (e₁ ∩ e₂).card = 3;
  · obtain ⟨ e₁, he₁, e₂, he₂, hne, h_inter ⟩ := h;
    -- Let $f = e₁ ∩ e₂$. Then $|f| = 3$.
    set f := e₁ ∩ e₂ with hf_def
    have hf_card : f.card = 3 := by
      exact h_inter;
    by_cases h_empty : ∃ e₃ ∈ S, ¬ f ⊆ e₃;
    · -- By `third_edge_structure`, we have $e₃ ⊆ e₁ ∪ e₂$.
      obtain ⟨ e₃, he₃, h_not_subset ⟩ := h_empty
      have h_e3_subset : e₃ ⊆ e₁ ∪ e₂ := by
        apply third_edge_structure e₁ e₂ e₃ (h_unif e₁ he₁) (h_unif e₂ he₂) (h_unif e₃ he₃) hne hf_card (h_pair e₁ he₁ e₃ he₃) (h_pair e₂ he₂ e₃ he₃) h_not_subset;
      -- Now consider any arbitrary $e ∈ S$.
      have h_arbitrary : ∀ e ∈ S, e ⊆ e₁ ∪ e₂ := by
        intro e he
        by_cases h_subset : f ⊆ e;
        · have h_e_subset : (e ∩ e₃).card ≥ 3 := by
            exact h_pair e he e₃ he₃;
          have h_e_subset : (e ∩ (e₁ ∪ e₂)).card ≥ 4 := by
            have h_e_subset : (e ∩ (e₁ ∪ e₂)).card ≥ (e ∩ e₃).card + (f \ e₃).card := by
              rw [ ← Finset.card_union_of_disjoint ];
              · refine Finset.card_le_card ?_;
                simp_all +decide [ Finset.subset_iff ];
                grind;
              · exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => Finset.mem_sdiff.mp hx₂ |>.2 ( Finset.mem_inter.mp hx₁ |>.2 );
            linarith [ show Finset.card ( f \ e₃ ) ≥ 1 from Finset.card_pos.mpr ⟨ Classical.choose ( Finset.not_subset.mp h_not_subset ), by have := Classical.choose_spec ( Finset.not_subset.mp h_not_subset ) ; aesop ⟩ ];
          contrapose! h_e_subset;
          exact lt_of_lt_of_le ( Finset.card_lt_card ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.inter_subset_left, fun h => h_e_subset <| h.symm ▸ Finset.inter_subset_right ⟩ ) ) ( by simp +decide [ h_unif e he ] );
        · -- By `third_edge_structure`, we have $e ⊆ e₁ ∪ e₂$.
          apply third_edge_structure e₁ e₂ e;
          all_goals solve_by_elim;
      refine' Or.inr _;
      exact le_trans ( Finset.card_le_card ( Finset.biUnion_subset.mpr h_arbitrary ) ) ( by have := union_size_pair e₁ e₂ ( h_unif e₁ he₁ ) ( h_unif e₂ he₂ ) ( by linarith ) ; aesop );
    · exact Or.inl ⟨ f, hf_card, fun e he => Classical.not_not.1 fun h => h_empty ⟨ e, he, h ⟩ ⟩;
  · by_cases hS : S.card ≤ 1;
    · rw [ Finset.card_le_one_iff_subset_singleton ] at hS ; aesop;
    · obtain ⟨ e₁, he₁, e₂, he₂, hne ⟩ := Finset.one_lt_card.1 ( lt_of_not_ge hS );
      have := h_pair e₁ he₁ e₂ he₂;
      have : (e₁ ∩ e₂).card ≤ 4 := Nat.le_trans ( Finset.card_le_card ( Finset.inter_subset_left ) ) ( h_unif e₁ he₁ ▸ le_rfl ) ; interval_cases _ : ( e₁ ∩ e₂ ).card <;> simp_all +decide ;
      have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : e₁ ∩ e₂ ⊆ e₁ ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : e₁ ∩ e₂ ⊆ e₂ ) ; aesop;

/-
If all 4-edges contain a common 3-face f, then τ(S) ≤ 1.
-/
lemma common_face_implies_tau_le_one (S : Finset (Finset α))
    (h_unif : ∀ e ∈ S, e.card = 4)
    (f : Finset α) (hf : f.card = 3)
    (h_common : ∀ e ∈ S, f ⊆ e) :
    tau S 4 ≤ 1 := by
  refine' Nat.sInf_le _;
  unfold IsCover; use { f } ; aesop;

/-
Counterexample to the claim that union size ≤ 5 implies τ ≤ 2. The complete 4-uniform hypergraph on 5 vertices has τ = 3.
-/
lemma bounded_union_counterexample :
    ∃ S : Finset (Finset (Fin 5)),
      (∀ e ∈ S, e.card = 4) ∧
      (S.biUnion id).card ≤ 5 ∧
      tau S 4 > 2 := by
  -- Let S be the set of all subsets of Fin 5 of size 4.
  let S := Finset.powersetCard 4 (Finset.univ : Finset (Fin 5));
  -- We need to show that $\tau(S) > 2$. Suppose for contradiction that $\tau(S) \leq 2$.
  by_contra h_contra;
  -- Then there exists a cover C with |C| ≤ 2.
  obtain ⟨C, hC⟩ : ∃ C : Finset (Finset (Fin 5)), (∀ f ∈ C, f.card = 3) ∧ (∀ e ∈ S, ∃ f ∈ C, f ⊆ e) ∧ C.card ≤ 2 := by
    have h_tau_le_two : tau S 4 ≤ 2 := by
      aesop;
    have h_exists_C : ∃ C : Finset (Finset (Fin 5)), IsCover S C 4 ∧ C.card = tau S 4 := by
      have h_exists_cover : ∃ C : Finset (Finset (Fin 5)), IsCover S C 4 := by
        use Finset.powersetCard 3 (Finset.univ : Finset (Fin 5));
        constructor <;> native_decide;
      exact ( Nat.sInf_mem <| show { n | ∃ C : Finset ( Finset ( Fin 5 ) ), IsCover S C 4 ∧ C.card = n }.Nonempty from ⟨ _, ⟨ h_exists_cover.choose, h_exists_cover.choose_spec, rfl ⟩ ⟩ ) |> fun ⟨ C, hC₁, hC₂ ⟩ => ⟨ C, hC₁, hC₂ ⟩;
    exact ⟨ h_exists_C.choose, h_exists_C.choose_spec.1.1, h_exists_C.choose_spec.1.2, h_exists_C.choose_spec.2.symm ▸ h_tau_le_two ⟩;
  -- Each element of C is a 3-subset of Fin 5.
  have hC_subsets : ∀ f ∈ C, f ∈ Finset.powersetCard 3 (Finset.univ : Finset (Fin 5)) := by
    exact fun f hf => Finset.mem_powersetCard.mpr ⟨ Finset.subset_univ _, hC.1 f hf ⟩;
  -- Let's list all possible covers C with |C| ≤ 2 and check if they cover all edges in S.
  have h_possible_covers : ∀ C : Finset (Finset (Fin 5)), C ⊆ Finset.powersetCard 3 (Finset.univ : Finset (Fin 5)) → C.card ≤ 2 → ¬(∀ e ∈ S, ∃ f ∈ C, f ⊆ e) := by
    native_decide;
  exact h_possible_covers C hC_subsets hC.2.2 hC.2.1

/-
Disproof of the strong Aharoni-Zerbib conjecture (τ ≤ 2.5ν) for r=4.
-/
theorem strong_aharoni_zerbib_counterexample :
    ∃ H : Finset (Finset (Fin 5)),
      IsUniform H 4 ∧
      2 * tau H 4 > 5 * nu H 4 := by
  -- Let's choose the specific hypergraph H as described in the provided solution.
  obtain ⟨H, h_unif, h_union⟩ : ∃ H : Finset (Finset (Fin 5)),
      (∀ e ∈ H, e.card = 4) ∧ (H.biUnion id).card ≤ 5 ∧ tau H 4 > 2 := by
        exact bounded_union_counterexample
  -- Since any two edges in H share 3 vertices, they are not face-disjoint. Thus, any packing has size at most 1.
  have h_packing : nu H 4 ≤ 1 := by
    -- Since any two edges in H share 3 vertices, they are not face-disjoint. Thus, any packing has size at most 1. Use this fact.
    have h_packing : ∀ e₁ ∈ H, ∀ e₂ ∈ H, e₁ ≠ e₂ → ¬FaceDisjoint e₁ e₂ 4 := by
      intros e₁ he₁ e₂ he₂ hne h_disjoint
      have h_inter : (e₁ ∩ e₂).card ≥ 3 := by
        have := Finset.card_union_add_card_inter e₁ e₂; simp_all +decide ;
        linarith [ show Finset.card ( e₁ ∪ e₂ ) ≤ 5 by exact le_trans ( Finset.card_mono <| Finset.union_subset ( Finset.subset_biUnion_of_mem id he₁ ) ( Finset.subset_biUnion_of_mem id he₂ ) ) h_union.1 ];
      contrapose! h_disjoint;
      simp_all +decide [ FaceDisjoint ];
      exact Exists.elim ( Finset.exists_subset_card_eq h_inter ) fun x hx => ⟨ x, hx.2, hx.1.trans ( Finset.inter_subset_left ), hx.1.trans ( Finset.inter_subset_right ) ⟩;
    refine' csSup_le _ _;
    · exact ⟨ 0, ⟨ ∅, by unfold IsPacking; aesop ⟩ ⟩;
    · rintro n ⟨ M, hM₁, rfl ⟩;
      exact Finset.card_le_one.mpr fun x hx y hy => Classical.not_not.1 fun hxy => h_packing x ( hM₁.1 hx ) y ( hM₁.1 hy ) hxy ( hM₁.2 x hx y hy hxy );
  exact ⟨ H, h_unif, by linarith ⟩

/-
If the union of 4-edges has size at most 5, then τ(S) ≤ 3.
-/
lemma union_le_5_implies_tau_le_3 (S : Finset (Finset α))
    (h_unif : ∀ e ∈ S, e.card = 4)
    (h_union : (S.biUnion id).card ≤ 5) :
    tau S 4 ≤ 3 := by
  by_contra h_contra;
  -- Since $|U| \leq 5$, we can check all possible subsets of $U$ of size 3 to find a cover.
  have h_check : ∃ C : Finset (Finset α), C ⊆ Finset.powersetCard 3 (S.biUnion id) ∧ C.card ≤ 3 ∧ (∀ e ∈ S, ∃ f ∈ C, f ⊆ e) := by
    have h_check : ∀ (U : Finset α), U ⊆ S.biUnion id → U.card ≤ 5 → ∃ C : Finset (Finset α), C ⊆ Finset.powersetCard 3 U ∧ C.card ≤ 3 ∧ (∀ e ∈ Finset.powersetCard 4 U, ∃ f ∈ C, f ⊆ e) := by
      intro U hU hU_card
      by_cases hU_card_eq_5 : U.card = 5;
      · -- Let $U = \{a, b, c, d, e\}$.
        obtain ⟨a, b, c, d, e, ha, hb, hc, hd, he, hU_eq⟩ : ∃ a b c d e : α, a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ a ≠ e ∧ b ≠ c ∧ b ≠ d ∧ b ≠ e ∧ c ≠ d ∧ c ≠ e ∧ d ≠ e ∧ U = {a, b, c, d, e} := by
          simp_rw +decide [ Finset.card_eq_succ ] at hU_card_eq_5;
          rcases hU_card_eq_5 with ⟨ a, t, hat, rfl, b, u, hbu, rfl, c, v, hcv, rfl, d, w, hdw, rfl, e, x, hex, rfl, hx ⟩ ; use a, b, c, d, e; aesop;
        use { { a, b, c }, { a, d, e }, { b, d, e } };
        simp +decide [ Finset.subset_iff, Finset.mem_powersetCard, * ];
        refine' ⟨ _, _ ⟩;
        · exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _;
        · intro e he he_card;
          rw [ Finset.card_eq_succ ] at he_card;
          rcases he_card with ⟨ x, t, hxt, rfl, ht ⟩ ; rw [ Finset.card_eq_three ] at ht; obtain ⟨ y, z, w, hy, hz, hw, h ⟩ := ht; simp_all +decide ;
          grind;
      · interval_cases _ : #U <;> simp_all +decide;
        · exact ⟨ ∅, by simp +decide ⟩;
        · exact ⟨ ∅, by simp +decide, by simp +decide, by intros; rw [ Finset.card_eq_one ] at *; aesop ⟩;
        · exact ⟨ ∅, by simp +decide, by simp +decide, fun e he he' => by have := Finset.card_le_card he; simp_all +decide ⟩;
        · exact ⟨ ∅, by simp +decide, by simp +decide, fun e he he' => by have := Finset.card_le_card he; simp_all +decide ⟩;
        · have h_check : ∀ (U : Finset α), U.card = 4 → ∃ C : Finset (Finset α), C ⊆ Finset.powersetCard 3 U ∧ C.card ≤ 3 ∧ (∀ e ∈ Finset.powersetCard 4 U, ∃ f ∈ C, f ⊆ e) := by
            intro U hU_card
            obtain ⟨a, b, c, d, hU⟩ : ∃ a b c d : α, U = {a, b, c, d} ∧ a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d := by
              rcases Finset.card_eq_succ.mp hU_card with ⟨ a, ha ⟩;
              obtain ⟨ t, hat, rfl, ht ⟩ := ha; rcases Finset.card_eq_three.mp ht with ⟨ b, c, d, hbc, hcd, hbd ⟩ ; use a, b, c, d; aesop;
            refine' ⟨ { { a, b, c }, { a, b, d }, { a, c, d } }, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
            · exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _;
            · intro e he he'; have := Finset.eq_of_subset_of_card_le ( show e ⊆ { a, b, c, d } by intros x hx; aesop ) ; aesop;
          exact h_check U ‹_› |> fun ⟨ C, hC₁, hC₂, hC₃ ⟩ => ⟨ C, hC₁, hC₂, fun e he₁ he₂ => hC₃ e ( Finset.mem_powersetCard.mpr ⟨ he₁, he₂ ⟩ ) ⟩;
    exact Exists.elim ( h_check ( S.biUnion id ) ( Finset.Subset.refl _ ) h_union ) fun C hC => ⟨ C, hC.1.trans ( Finset.powersetCard_mono ( Finset.Subset.refl _ ) ), hC.2.1, fun e he => hC.2.2 e ( Finset.mem_powersetCard.mpr ⟨ Finset.subset_biUnion_of_mem id he, h_unif e he ⟩ ) ⟩;
  obtain ⟨ C, hC₁, hC₂, hC₃ ⟩ := h_check;
  refine' h_contra ( le_trans ( csInf_le _ ⟨ C, _, rfl ⟩ ) hC₂ );
  · exact ⟨ 0, fun n hn => hn.choose_spec.2.symm ▸ Nat.zero_le _ ⟩;
  · exact ⟨ fun f hf => by have := hC₁ hf; exact Finset.mem_powersetCard.mp this |>.2, hC₃ ⟩

/-
Corrected structural lemma: If 4-edges pairwise share faces, then τ ≤ 3.
-/
lemma structural_lemma_corrected (S : Finset (Finset α))
    (h_unif : ∀ e ∈ S, e.card = 4)
    (h_pair : ∀ e₁ ∈ S, ∀ e₂ ∈ S, (e₁ ∩ e₂).card ≥ 3) :
    tau S 4 ≤ 3 := by
  -- By `pairwise_intersect_structure`, either (∃ f, f ⊆ all e) or (union size ≤ 5).
  by_cases h_case : ∃ f : Finset α, f.card = 3 ∧ ∀ e ∈ S, f ⊆ e;
  · exact le_trans ( common_face_implies_tau_le_one S h_unif _ h_case.choose_spec.1 h_case.choose_spec.2 ) ( by decide );
  · -- Since the union of S has size at most 5, we can apply the lemma union_le_5_implies_tau_le_3.
    apply union_le_5_implies_tau_le_3 S h_unif;
    exact Or.resolve_left ( pairwise_intersect_structure S h_unif h_pair ) h_case

/-
In a maximum packing, the set of edges sharing a face ONLY with e must pairwise share faces.
-/
lemma Se_pairwise_intersect (H : Finset (Finset α))
    (h_unif : ∀ e ∈ H, e.card = 4)
    (M : Finset (Finset α))
    (hM_packing : IsPacking H M 4)
    (hM_max : ∀ M', IsPacking H M' 4 → M'.card ≤ M.card)
    (e : Finset α) (he : e ∈ M)
    (Se : Finset (Finset α))
    (hSe_def : Se = {h ∈ H | ¬FaceDisjoint h e 4 ∧ ∀ f ∈ M, f ≠ e → FaceDisjoint h f 4}) :
    ∀ h₁ ∈ Se, ∀ h₂ ∈ Se, ¬FaceDisjoint h₁ h₂ 4 := by
  contrapose! hM_max;
  obtain ⟨ h₁, hh₁, h₂, hh₂, h_disjoint ⟩ := hM_max;
  refine' ⟨ ( M \ { e } ) ∪ { h₁, h₂ }, _, _ ⟩ <;> simp_all +decide [ IsPacking ];
  · simp_all +decide [ FaceDisjoint ];
    grind;
  · rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> simp_all +decide [ Finset.subset_iff ];
    · grind;
    · grind;
    · exact ⟨ by rintro rfl; exact hh₁.2.1 ( by tauto ), fun h => Classical.not_not.1 fun hne => hh₁.2.1 ( hM_packing.2 _ h _ he hne ) ⟩

/-
If a 4-edge shares a 3-face with two face-disjoint 4-edges, it is contained in their union.
-/
lemma bridge_lemma (e₁ e₂ h : Finset α)
    (he₁ : e₁.card = 4) (he₂ : e₂.card = 4) (hh : h.card = 4)
    (h_disjoint : FaceDisjoint e₁ e₂ 4)
    (h_share1 : ¬FaceDisjoint h e₁ 4)
    (h_share2 : ¬FaceDisjoint h e₂ 4) :
    h ⊆ e₁ ∪ e₂ := by
  -- Since h shares a 3-face with e₁ and e₂, the intersection of h with e₁ ∪ e₂ has at least 4 elements.
  have h_inter_ge_4 : (h ∩ (e₁ ∪ e₂)).card ≥ 4 := by
    have h_inter_ge_4 : (h ∩ e₁).card ≥ 3 ∧ (h ∩ e₂).card ≥ 3 := by
      simp_all +decide [ FaceDisjoint ];
      exact ⟨ h_share1.choose_spec.1 ▸ Finset.card_mono ( Finset.subset_inter h_share1.choose_spec.2.1 h_share1.choose_spec.2.2 ), h_share2.choose_spec.1 ▸ Finset.card_mono ( Finset.subset_inter h_share2.choose_spec.2.1 h_share2.choose_spec.2.2 ) ⟩;
    have h_inter_ge_4 : (h ∩ e₁ ∩ e₂).card ≤ 2 := by
      have h_inter_le_2 : ∀ f ⊆ e₁ ∩ e₂, f.card = 3 → False := by
        exact fun f hf hf' => h_disjoint f hf' ( hf.trans ( Finset.inter_subset_left ) ) ( hf.trans ( Finset.inter_subset_right ) );
      exact Nat.le_of_not_lt fun h => h_inter_le_2 ( Finset.exists_subset_card_eq h |>.choose ) ( Finset.exists_subset_card_eq h |>.choose_spec.1.trans ( by aesop_cat ) ) ( Finset.exists_subset_card_eq h |>.choose_spec.2 );
    have := Finset.card_union_add_card_inter ( h ∩ e₁ ) ( h ∩ e₂ ) ; simp_all +decide [ Finset.inter_union_distrib_left ] ;
    simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ] ; linarith;
  have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : h ∩ ( e₁ ∪ e₂ ) ⊆ h ) ; aesop;

/-
If h is a bridge between e and f, then e and f share exactly 2 vertices, and h contains them.
-/
lemma bridge_structure (e f h : Finset α)
    (he : e.card = 4) (hf : f.card = 4) (hh : h.card = 4)
    (h_disjoint : FaceDisjoint e f 4)
    (h_share_e : ¬FaceDisjoint h e 4)
    (h_share_f : ¬FaceDisjoint h f 4) :
    (e ∩ f).card = 2 ∧ e ∩ f ⊆ h := by
  -- By Lemma 2, $h \cap e \cap f \subseteq e \cap f$.
  have h_inter_subset : (h ∩ e ∩ f) ⊆ (e ∩ f) := by
    aesop_cat;
  -- By Lemma 2, $|h \cap e \cap f| \geq 2$.
  have h_inter_card : (h ∩ e ∩ f).card ≥ 2 := by
    -- Since $h$ shares a face with $e$ and $f$, and $e$ and $f$ are face-disjoint, $h$ must intersect both $e$ and $f$ in at least 3 vertices.
    have h_inter_e : (h ∩ e).card ≥ 3 := by
      contrapose! h_share_e;
      intro g hg₁ hg₂; have := Finset.card_le_card hg₂; simp_all +decide ;
      exact fun hg₃ => h_share_e.not_le ( hg₁ ▸ Finset.card_le_card ( Finset.subset_inter hg₂ hg₃ ) )
    have h_inter_f : (h ∩ f).card ≥ 3 := by
      contrapose! h_share_f;
      intro g hg₁ hg₂ hg₃; have := Finset.card_le_card hg₂; simp_all +decide ;
      exact h_share_f.not_le ( by rw [ ← hg₁ ] ; exact Finset.card_le_card fun x hx => Finset.mem_inter.mpr ⟨ hg₂ hx, hg₃ hx ⟩ );
    have := Finset.card_union_add_card_inter ( h ∩ e ) ( h ∩ f ) ; simp_all +decide ;
    have h_inter_card : (h ∩ e ∪ h ∩ f) ⊆ h := by
      aesop_cat;
    have := Finset.card_le_card h_inter_card; simp_all +decide ;
    simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ] ; linarith;
  -- By Lemma 2, $|e \cap f| \leq 2$.
  have h_inter_card_le : (e ∩ f).card ≤ 2 := by
    contrapose! h_disjoint;
    -- If $|e \cap f| \geq 3$, then there exists a 3-face in $e$ that is also in $f$.
    obtain ⟨g, hg⟩ : ∃ g : Finset α, g ⊆ e ∧ g ⊆ f ∧ g.card = 3 := by
      exact Exists.elim ( Finset.exists_subset_card_eq h_disjoint ) fun g hg => ⟨ g, Finset.Subset.trans hg.1 ( Finset.inter_subset_left ), Finset.Subset.trans hg.1 ( Finset.inter_subset_right ), hg.2 ⟩;
    exact fun h => h g ( by linarith ) hg.1 hg.2.1;
  have h_inter_card_eq : (e ∩ f).card = 2 := by
    exact le_antisymm h_inter_card_le ( h_inter_card.trans ( Finset.card_mono h_inter_subset ) );
  have := Finset.eq_of_subset_of_card_le h_inter_subset ; aesop

/-
Bridges between e and f are covered by at most 2 faces of e.
-/
lemma bridges_covered_by_inter_faces (e f : Finset α)
    (he : e.card = 4) (hf : f.card = 4)
    (h_disjoint : FaceDisjoint e f 4)
    (B : Finset (Finset α))
    (hB_def : B = {h | h.card = 4 ∧ ¬FaceDisjoint h e 4 ∧ ¬FaceDisjoint h f 4}) :
    ∃ C : Finset (Finset α), C ⊆ Finset.powersetCard 3 e ∧ C.card ≤ 2 ∧ ∀ h ∈ B, ∃ c ∈ C, c ⊆ h := by
  by_cases hB_empty : B = ∅ <;> simp_all +decide [ Set.ext_iff ];
  · exact ⟨ ∅, Finset.empty_subset _, by norm_num ⟩;
  · -- Let $K = e \cap f$.
    set K := e ∩ f with hK_def
    have hK_card : K.card = 2 := by
      -- Since $h$ shares a 3-face with both $e$ and $f$, it must contain a 3-face of $e$.
      obtain ⟨h, hh⟩ : ∃ h ∈ B, ¬FaceDisjoint h e 4 ∧ ¬FaceDisjoint h f 4 := by
        exact Exists.elim ( Finset.nonempty_of_ne_empty hB_empty ) fun x hx => ⟨ x, hx, by aesop ⟩;
      have := bridge_structure e f h he hf ( hB_def h |>.1 hh.1 |>.1 ) h_disjoint hh.2.1 hh.2.2; aesop;
    have hK_subset : K ⊆ e := by
      exact Finset.inter_subset_left
    have hK_subset_f : K ⊆ f := by
      exact Finset.inter_subset_right;
    -- The 3-faces of $e$ containing $K$ are formed by $K \cup \{x\}$ for $x \in e \setminus K$.
    set C := Finset.image (fun x => K ∪ {x}) (e \ K) with hC_def
    have hC_subset : C ⊆ Finset.powersetCard 3 e := by
      grind
    have hC_card : C.card ≤ 2 := by
      grind
    have hC_cover : ∀ h ∈ B, ∃ c ∈ C, c ⊆ h := by
      intro h hh
      obtain ⟨x, hx⟩ : ∃ x ∈ e \ K, x ∈ h := by
        have := hB_def h |>.1 hh; simp_all +decide [ FaceDisjoint ] ;
        grind;
      -- Since $h$ shares a face with $e$, and $K$ is the intersection of $e$ and $f$, then $K$ must be a subset of $h$.
      have hK_subset_h : K ⊆ h := by
        have := bridge_structure e f h; aesop;
      exact ⟨ K ∪ { x }, Finset.mem_image_of_mem _ hx.1, Finset.union_subset hK_subset_h ( Finset.singleton_subset_iff.mpr hx.2 ) ⟩;
    exact ⟨ C, hC_subset, hC_card, fun h hh₁ hh₂ hh₃ => hC_cover h ( by aesop ) ⟩

/-
Removing the neighborhood of an edge in a packing reduces the packing number by at least 1.
-/
lemma nu_decreases_by_removing_Te (H : Finset (Finset α))
    (h_unif : ∀ e ∈ H, e.card = 4)
    (M : Finset (Finset α))
    (hM_packing : IsPacking H M 4)
    (hM_max : ∀ M', IsPacking H M' 4 → M'.card ≤ M.card)
    (e : Finset α) (he : e ∈ M)
    (Te : Finset (Finset α))
    (hTe_def : Te = {h ∈ H | ¬FaceDisjoint h e 4}) :
    nu (H \ Te) 4 ≤ nu H 4 - 1 := by
  refine' Nat.le_sub_one_of_lt ( lt_of_le_of_lt ( csSup_le _ _ ) _ );
  exact Finset.card ( M \ { e } );
  · exact ⟨ 0, ⟨ ∅, by unfold IsPacking; aesop ⟩ ⟩;
  · rintro _ ⟨ M', hM'_packing, rfl ⟩;
    have := hM_max ( Insert.insert e M' ) ?_ <;> simp_all +decide [ Finset.subset_iff ];
    · by_cases he' : e ∈ M' <;> simp_all +decide [ Finset.card_sdiff, Finset.subset_iff ];
      · have := hM'_packing.1 he'; simp_all +decide [ Finset.subset_iff ] ;
        have := this.2 this.1; simp_all +decide [ FaceDisjoint ] ;
        contrapose! this;
        exact fun _ => ⟨ by aesop, by obtain ⟨ f, hf ⟩ := Finset.exists_subset_card_eq ( show 3 ≤ #e from by linarith [ h_unif e ( by aesop ) ] ) ; exact ⟨ f, hf.2, hf.1 ⟩ ⟩;
      · exact Nat.le_sub_one_of_lt this;
    · simp_all +decide [ IsPacking ];
      simp_all +decide [ Finset.subset_iff ];
      exact fun x hx hx' => by have := hM'_packing.1 hx; tauto;
  · refine' lt_of_lt_of_le _ ( le_csSup _ ⟨ M, hM_packing, rfl ⟩ );
    · grind;
    · exact ⟨ _, fun n hn => hn.choose_spec.2 ▸ hM_max _ hn.choose_spec.1 ⟩

/-
The set of 3-faces of e covers Te.
-/
def Faces (e : Finset α) : Finset (Finset α) :=
  Finset.powersetCard 3 e

lemma faces_cover_Te (H : Finset (Finset α))
    (h_unif : ∀ e ∈ H, e.card = 4)
    (e : Finset α)
    (Te : Finset (Finset α))
    (hTe_def : Te = {h ∈ H | ¬FaceDisjoint h e 4}) :
    IsCover Te (Faces e) 4 := by
  constructor;
  · -- By definition of `Faces`, every element in `Faces e` is a 3-element subset of `e`.
    simp [Faces];
  · unfold FaceDisjoint at hTe_def;
    unfold Faces;
    aesop

/-
If a 4-set contains two distinct 3-faces of another 4-set, the sets are equal.
-/
lemma eq_of_two_faces_subset (e h : Finset α)
    (he : e.card = 4) (hh : h.card = 4)
    (F₁ F₂ : Finset α)
    (hF₁ : F₁ ⊆ e ∧ F₁.card = 3)
    (hF₂ : F₂ ⊆ e ∧ F₂.card = 3)
    (h_ne : F₁ ≠ F₂)
    (h_sub₁ : F₁ ⊆ h)
    (h_sub₂ : F₂ ⊆ h) :
    e = h := by
  -- Since $F₁$ and $F₂$ are distinct 3-subsets of $e$, their union is a 4-subset of $e$.
  have h_union : (F₁ ∪ F₂) ⊆ e ∧ (F₁ ∪ F₂).card = 4 := by
    have h_union : (F₁ ∪ F₂) ⊆ e ∧ (F₁ ∪ F₂).card ≥ 4 := by
      have h_inter_card : (F₁ ∩ F₂).card ≤ 2 := by
        have := Finset.card_le_card ( Finset.inter_subset_left : F₁ ∩ F₂ ⊆ F₁ ) ; ( have := Finset.card_le_card ( Finset.inter_subset_right : F₁ ∩ F₂ ⊆ F₂ ) ; simp_all +decide ; );
        interval_cases _ : # ( F₁ ∩ F₂ ) <;> simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : F₁ ∩ F₂ ⊆ F₁ ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : F₁ ∩ F₂ ⊆ F₂ ) ; aesop;
      grind;
    exact ⟨ h_union.1, le_antisymm ( le_trans ( Finset.card_le_card h_union.1 ) he.le ) h_union.2 ⟩;
  -- Since $F₁ \cup F₂ \subseteq e$ and $|e| = 4$, we have $F₁ \cup F₂ = e$.
  have h_union_eq_e : F₁ ∪ F₂ = e := by
    exact Finset.eq_of_subset_of_card_le h_union.1 ( by simp +decide [ * ] );
  have := Finset.eq_of_subset_of_card_le ( show F₁ ∪ F₂ ⊆ h from Finset.union_subset h_sub₁ h_sub₂ ) ; aesop;