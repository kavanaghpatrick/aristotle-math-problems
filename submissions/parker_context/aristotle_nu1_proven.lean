/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f398b5a5-c432-4625-9863-5b17a924f1d7

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of triangle packing number and triangle covering number.
Triangle packing number: maximum size of a set of edge-disjoint triangles.
Triangle covering number: minimum size of a set of edges that hits every triangle.
-/
variable {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]

def isEdgeDisjoint (S : Finset (Finset V)) : Prop :=
  (S : Set (Finset V)).Pairwise fun t1 t2 ↦ (t1 ∩ t2).card ≤ 1

def isTriangleCover (E' : Finset (Sym2 V)) : Prop :=
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

noncomputable def trianglePackingNumber : ℕ :=
  G.cliqueFinset 3 |>.powerset.filter isEdgeDisjoint |>.image Finset.card |>.max |>.getD 0

noncomputable def triangleCoveringNumber : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

/-
If the triangle packing number is 0, then the triangle covering number is 0.
-/
lemma tuza_case_nu_0 (h : trianglePackingNumber G = 0) : triangleCoveringNumber G = 0 := by
  -- If the triangle packing number is 0, then there are no edge-disjoint triangles in $G$.
  have h_no_edge_disjoint_triangles : ∀ t ∈ G.cliqueFinset 3, False := by
    unfold trianglePackingNumber at h;
    unfold Option.getD at h;
    aesop;
    · rw [ Finset.max_eq_sup_coe ] at heq;
      refine' absurd ( heq ▸ Finset.le_sup ( f := WithBot.some ) ( Finset.mem_image_of_mem _ ( show { t } ∈ Finset.filter isEdgeDisjoint ( G.cliqueFinset 3 |> Finset.powerset ) from _ ) ) ) _;
      · simp +decide;
      · simp +decide [ isEdgeDisjoint ];
        exact a;
    · rw [ Finset.max_eq_sup_coe ] at heq;
      rw [ WithBot.none_eq_bot ] at heq;
      rw [ Finset.sup_eq_bot_iff ] at heq ; aesop;
      exact heq 0 ∅ ( Finset.empty_subset _ ) ( by simp +decide [ isEdgeDisjoint ] ) rfl;
  simp_all +decide [ triangleCoveringNumber ];
  unfold isTriangleCover; aesop;
  rw [ Finset.min_eq_inf_withTop ] ; aesop;
  rw [ Finset.inf_eq_iInf ];
  rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ];
  rotate_left;
  exact 0;
  · exact fun _ => zero_le _;
  · exact fun w hw => ⟨ ∅, by aesop ⟩;
  · rfl

/-
If the triangle packing number is 1, then any two distinct triangles share at least 2 vertices.
-/
lemma packing_one_implies_intersecting (h : trianglePackingNumber G = 1) :
    ∀ t1 ∈ G.cliqueFinset 3, ∀ t2 ∈ G.cliqueFinset 3, t1 ≠ t2 → (t1 ∩ t2).card ≥ 2 := by
      intro t1 ht1 t2 ht2 hne;
      by_contra h_contra;
      have h_valid_packing : isEdgeDisjoint {t1, t2} := by
        intro t3 ht3 t4 ht4 hne;
        aesop;
        · grind;
        · rwa [ Finset.inter_comm, Nat.lt_succ_iff ] at h_contra;
      -- Since {t1, t2} is a valid packing of size 2, this contradicts the assumption that the triangle packing number is 1.
      have h_contradiction : ∃ S : Finset (Finset V), S.card = 2 ∧ isEdgeDisjoint S ∧ ∀ t ∈ S, t ∈ G.cliqueFinset 3 := by
        aesop;
      obtain ⟨ S, hS₁, hS₂, hS₃ ⟩ := h_contradiction;
      have h_contradiction : (Finset.image Finset.card (Finset.filter isEdgeDisjoint (Finset.powerset (G.cliqueFinset 3)))).max ≥ 2 := by
        exact Finset.le_max ( Finset.mem_image.mpr ⟨ S, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr fun t ht => hS₃ t ht, hS₂ ⟩, hS₁ ⟩ );
      unfold trianglePackingNumber at h;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter isEdgeDisjoint ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop

/-
If the triangle packing number is 1, and we have three triangles t1, t2, t3 such that t1 and t2 share exactly 2 vertices, and t3 does not contain those 2 shared vertices, then the union of t1, t2, and t3 has cardinality 4.
-/
lemma packing_one_K4_structure (h : trianglePackingNumber G = 1)
    (t1 t2 t3 : Finset V) (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (ht3 : t3 ∈ G.cliqueFinset 3)
    (h_neq : t1 ≠ t2)
    (h_inter : (t1 ∩ t2).card = 2)
    (h_not_subset : ¬ (t1 ∩ t2) ⊆ t3) :
    (t1 ∪ t2 ∪ t3).card = 4 := by
      have h_union : t1 ∪ t2 ∪ t3 ⊆ t1 ∪ t2 := by
        -- Since $|t3 \cap t1| \geq 2$ and $|t3 \cap t2| \geq 2$, and $t3$ is not a subset of $t1 \cap t2$, it must be that $|t3 \cap (t1 \cup t2)| = 3$.
        have h_inter_union : (t3 ∩ (t1 ∪ t2)).card = 3 := by
          have h_inter_union : (t3 ∩ t1).card ≥ 2 ∧ (t3 ∩ t2).card ≥ 2 := by
            have := packing_one_implies_intersecting G h; aesop;
          have h_inter_union : (t3 ∩ (t1 ∪ t2)).card ≥ 3 := by
            have h_inter_union : (t3 ∩ (t1 ∪ t2)).card ≥ (t3 ∩ t1).card + (t3 ∩ t2).card - (t3 ∩ t1 ∩ t2).card := by
              rw [ ← Finset.card_union_add_card_inter ];
              simp +decide [ Finset.inter_union_distrib_left, Finset.inter_assoc ];
              exact Finset.card_le_card fun x hx => by aesop;
            have h_inter_union : (t3 ∩ t1 ∩ t2).card ≤ 1 := by
              contrapose! h_not_subset;
              have := Finset.eq_of_subset_of_card_le ( show t3 ∩ t1 ∩ t2 ⊆ t1 ∩ t2 from fun x hx => by aesop ) ; aesop;
            omega;
          simp +zetaDelta at *;
          exact le_antisymm ( le_trans ( Finset.card_le_card ( Finset.inter_subset_left ) ) ( by simpa using ht3.card_eq.le ) ) h_inter_union;
        have h_inter_union : t3 ⊆ t1 ∪ t2 := by
          have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t3 ∩ ( t1 ∪ t2 ) ⊆ t3 ) ; aesop;
          exact this ( by linarith [ ht3.card_eq ] );
        grind;
      have h_card_union : (t1 ∪ t2).card = 4 := by
        have := Finset.card_union_add_card_inter t1 t2; simp_all +decide ;
        linarith [ ht1.card_eq, ht2.card_eq ];
      have h_card_union : t1 ∪ t2 ⊆ t1 ∪ t2 ∪ t3 := by
        exact Finset.subset_union_left;
      rw [ Finset.Subset.antisymm h_union h_card_union, ‹ ( t1 ∪ t2 |> Finset.card ) = 4 › ]

/-
If all triangles in the graph are contained within a set of 4 vertices, then the triangle covering number is at most 2.
-/
lemma covering_number_le_two_of_subset_four (U : Finset V) (hU : U.card ≤ 4)
    (h_subset : ∀ t ∈ G.cliqueFinset 3, t ⊆ U) :
    triangleCoveringNumber G ≤ 2 := by
      -- Since $U$ can contain at most 4 vertices, $G$ restricted to $U$ can be at most $K_4$.
      have h_subgraph_superset : ∃ E' ⊆ G.edgeFinset, E'.card ≤ 2 ∧ isTriangleCover G E' := by
        -- Consider all possible triangles in $U$ and check if we can find a pair of edges that covers them all.
        have h_triangles : ∀ (triangles : Finset (Finset V)), (∀ t ∈ triangles, t ⊆ U ∧ t.card = 3) → ∃ E' ⊆ U.powersetCard 2, E'.card ≤ 2 ∧ ∀ t ∈ triangles, ∃ e ∈ E', e ⊆ t := by
          intro triangles h_triangles
          have h_triangles_subset : ∀ t ∈ triangles, t ⊆ U := by
            exact fun t ht => h_triangles t ht |>.1;
          interval_cases _ : Finset.card U <;> simp_all +decide;
          · induction triangles using Finset.induction <;> aesop;
          · exact ⟨ ∅, by simp +decide, by simp +decide, fun t ht => by have := Finset.card_le_card ( h_triangles_subset t ht ) ; aesop ⟩;
          · exact ⟨ ∅, by simp +decide, by simp +decide, fun t ht => by have := Finset.card_le_card ( h_triangles_subset t ht ) ; simp_all +decide ⟩;
          · have := Finset.card_eq_three.mp ‹_›;
            obtain ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ := this; use { { x, y }, { x, z } } ; simp +decide [ *, Finset.subset_iff ] ;
            simp_all +decide [ Finset.subset_iff ];
            exact ⟨ Finset.card_insert_le _ _, fun t ht => by have := h_triangles_subset t ht; have := Finset.card_eq_three.mp ( h_triangles t ht ) ; obtain ⟨ a, b, c, ha, hb, hc, habc ⟩ := this; aesop ⟩;
          · -- Let's denote the vertices in $U$ as $a, b, c, d$.
            obtain ⟨a, b, c, d, hU⟩ : ∃ a b c d : V, U = {a, b, c, d} ∧ a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d := by
              simp_all +decide [ Finset.card_eq_succ ];
              rcases ‹∃ a t, a∉t ∧ Insert.insert a t = U ∧ _› with ⟨ a, t, hat, rfl, b, u, hbu, rfl, c, v, hcv, rfl, d, w, hdw, rfl, e, he ⟩ ; use a, b, c, d ; aesop;
            -- Consider the edges $\{a, b\}$ and $\{c, d\}$.
            use {{a, b}, {c, d}};
            simp_all +decide [ Finset.subset_iff ];
            refine' ⟨ _, _ ⟩;
            · exact Finset.card_insert_le _ _;
            · intro t ht; specialize h_triangles_subset t ht; specialize h_triangles t ht; rw [ Finset.card_eq_three ] at h_triangles; aesop;
        obtain ⟨ E', hE₁, hE₂, hE₃ ⟩ := h_triangles ( G.cliqueFinset 3 ) ( fun t ht => ⟨ h_subset t ht, by simpa using SimpleGraph.mem_cliqueFinset_iff.mp ht |>.2 ⟩ );
        refine' ⟨ Finset.filter ( fun e => ∃ v w, e = Sym2.mk ( v, w ) ∧ G.Adj v w ) ( E'.biUnion fun e => e.sym2 ), _, _, _ ⟩;
        · intro e he; aesop;
        · refine' le_trans ( Finset.card_le_card _ ) _;
          exact Finset.biUnion E' fun e => Finset.filter ( fun e' => ∃ v w, e' = Sym2.mk ( v, w ) ∧ G.Adj v w ) ( e.sym2 );
          · simp +contextual [ Finset.subset_iff ];
          · refine' le_trans ( Finset.card_biUnion_le ) _;
            refine' le_trans ( Finset.sum_le_sum fun x hx => Finset.card_le_one.mpr _ ) _;
            · have := hE₁ hx; rw [ Finset.mem_powersetCard ] at this; aesop;
              rw [ Finset.card_eq_two ] at right ; aesop;
            · aesop;
        · intro t ht;
          obtain ⟨ e, he₁, he₂ ⟩ := hE₃ t ht;
          have := Finset.mem_powersetCard.mp ( hE₁ he₁ );
          obtain ⟨ v, w, hvw ⟩ := Finset.card_eq_two.mp this.2;
          simp_all +decide [ Finset.subset_iff ];
          exact ⟨ s(v, w), ⟨ ⟨ _, he₁, by aesop ⟩, v, w, rfl, ht.1 he₂.1 he₂.2 ( by aesop ) ⟩, by aesop ⟩;
      unfold triangleCoveringNumber;
      cases h : ( Finset.filter ( isTriangleCover G ) G.edgeFinset.powerset |> Finset.image Finset.card |> Finset.min ) <;> aesop;
      have := Finset.min_le ( Finset.mem_image_of_mem Finset.card ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( show w ⊆ G.edgeFinset from fun x hx => by aesop ), right ⟩ ) ) ; aesop;
      exact Nat.cast_le.mpr ( le_trans this left_1 )

/-
If the triangle packing number is 1, then the intersection of any two distinct triangles has cardinality exactly 2.
-/
lemma card_inter_eq_two_of_packing_one (h : trianglePackingNumber G = 1)
    (t1 t2 : Finset V) (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (hne : t1 ≠ t2) :
    (t1 ∩ t2).card = 2 := by
      -- By Lemma 2, any two distinct triangles must share at least 2 vertices.
      have h_inter_ge_2 : (t1 ∩ t2).card ≥ 2 := by
        exact?;
      have h_inter_le_2 : (t1 ∩ t2).card ≤ t1.card ∧ (t1 ∩ t2).card ≤ t2.card := by
        exact ⟨ Finset.card_le_card fun x hx => by aesop, Finset.card_le_card fun x hx => by aesop ⟩;
      cases lt_or_eq_of_le h_inter_le_2.1 <;> cases lt_or_eq_of_le h_inter_le_2.2 <;> aesop;
      · linarith [ ht1.2, ht2.2 ];
      · have := ht1.2; have := ht2.2; aesop;
      · have := ht1.card_eq; have := ht2.card_eq; aesop;
      · have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; aesop;
        exact absurd ( Finset.eq_of_subset_of_card_le this ( by linarith ) ) hne

/-
If the triangle packing number is 1 and there is a set of 4 vertices containing three triangles that do not share a common edge, then all triangles are contained in that set.
-/
lemma packing_one_K4_closure (h : trianglePackingNumber G = 1)
    (U : Finset V) (hU_card : U.card = 4)
    (t1 t2 t3 : Finset V) (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (ht3 : t3 ∈ G.cliqueFinset 3)
    (h_subset : t1 ⊆ U ∧ t2 ⊆ U ∧ t3 ⊆ U)
    (h_no_common_edge : ¬ ∃ e : Sym2 V, e ∈ t1.sym2 ∧ e ∈ t2.sym2 ∧ e ∈ t3.sym2) :
    ∀ t ∈ G.cliqueFinset 3, t ⊆ U := by
      -- Since $\nu(G)=1$, any triangle $t$ must intersect each of $t1, t2, t3$ in at least 2 vertices.
      have h_inter : ∀ t ∈ G.cliqueFinset 3, (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2 := by
        have h_inter : ∀ t1 t2 : Finset V, t1 ∈ G.cliqueFinset 3 → t2 ∈ G.cliqueFinset 3 → t1 ≠ t2 → (t1 ∩ t2).card ≥ 2 := by
          exact?
        generalize_proofs at *; aesop; (
        by_cases h : t = t1 <;> aesop;
        exact ht1.card_eq.symm ▸ by decide;);
        · by_cases h : t = t2 <;> aesop;
          exact Finset.one_lt_card.2 ( by obtain ⟨ x, hx ⟩ := Finset.card_eq_three.1 ht2.2; aesop );
        · by_cases h : t = t3 <;> aesop;
          have := ht3.2; aesop;
      -- If $t \not\subseteq U$, then $t$ must contain at least one vertex not in $U$.
      intro t ht
      by_contra h_not_subset;
      -- Since $t$ is not contained in $U$, $t$ must have exactly 2 vertices in $U$ and 1 vertex outside $U$.
      have h_card_inter : (t ∩ U).card = 2 := by
        have h_card_inter : (t ∩ U).card ≥ 2 := by
          exact le_trans ( h_inter t ht |>.1 ) ( Finset.card_mono fun x hx => by aesop );
        have h_card_t : t.card = 3 := by
          exact Finset.mem_filter.mp ht |>.2.2;
        have h_card_t_inter_U : (t ∩ U).card + (t \ U).card = t.card := by
          rw [ Finset.card_inter_add_card_sdiff ];
        linarith [ show ( t \ U ).card ≥ 1 from Finset.card_pos.mpr ⟨ Classical.choose ( Finset.not_subset.mp h_not_subset ), by simpa using Classical.choose_spec ( Finset.not_subset.mp h_not_subset ) ⟩ ];
      -- Since $t$ intersects $t1$, $t2$, and $t3$ in at least 2 vertices each, and $t$ has exactly 2 vertices in $U$, these intersections must be the same set of 2 vertices.
      have h_inter_eq : (t ∩ t1) = (t ∩ U) ∧ (t ∩ t2) = (t ∩ U) ∧ (t ∩ t3) = (t ∩ U) := by
        have h_inter_eq : (t ∩ t1) ⊆ (t ∩ U) ∧ (t ∩ t2) ⊆ (t ∩ U) ∧ (t ∩ t3) ⊆ (t ∩ U) := by
          exact ⟨ Finset.inter_subset_inter ( Finset.Subset.refl _ ) h_subset.1, Finset.inter_subset_inter ( Finset.Subset.refl _ ) h_subset.2.1, Finset.inter_subset_inter ( Finset.Subset.refl _ ) h_subset.2.2 ⟩;
        have := Finset.eq_of_subset_of_card_le h_inter_eq.1; have := Finset.eq_of_subset_of_card_le h_inter_eq.2.1; have := Finset.eq_of_subset_of_card_le h_inter_eq.2.2; aesop;
      -- This implies that $\{u, v\} \subseteq t1$, $\{u, v\} \subseteq t2$, $\{u, v\} \subseteq t3$.
      obtain ⟨u, v, huv⟩ : ∃ u v : V, u ≠ v ∧ u ∈ t ∧ v ∈ t ∧ u ∈ t1 ∧ v ∈ t1 ∧ u ∈ t2 ∧ v ∈ t2 ∧ u ∈ t3 ∧ v ∈ t3 := by
        obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.1 ( by linarith : 1 < Finset.card ( t ∩ U ) ) ; use u, v; simp_all +decide [ Finset.ext_iff ] ;
      exact h_no_common_edge ⟨ Sym2.mk ( u, v ), by aesop ⟩

/-
If the triangle packing number is 1 and there is no edge common to all triangles, then there exist three triangles t1, t2, t3 such that t1 and t2 share an edge that is not contained in t3.
-/
lemma exists_triple_of_not_common_edge (h : trianglePackingNumber G = 1)
    (h_no_common : ¬ ∃ e : Sym2 V, ∀ t ∈ G.cliqueFinset 3, e ∈ t.sym2) :
    ∃ t1 t2 t3 : Finset V, t1 ∈ G.cliqueFinset 3 ∧ t2 ∈ G.cliqueFinset 3 ∧ t3 ∈ G.cliqueFinset 3 ∧
    t1 ≠ t2 ∧ (t1 ∩ t2).card = 2 ∧ ¬ (t1 ∩ t2 ⊆ t3) := by
      -- Since there is no common edge, we can pick any two distinct triangles t1 and t2.
      obtain ⟨t1, t2, ht1, ht2, h_neq⟩ : ∃ t1 t2 : Finset V, t1 ∈ G.cliqueFinset 3 ∧ t2 ∈ G.cliqueFinset 3 ∧ t1 ≠ t2 := by
        by_cases h1 : ∃ t : Finset V, t ∈ G.cliqueFinset 3;
        · contrapose! h_no_common;
          cases' h1 with t ht;
          rcases Finset.card_eq_three.mp ( G.mem_cliqueFinset_iff.mp ht |>.2 ) with ⟨ a, b, c, ha, hb, hc, hab, hbc, hca ⟩ ; use Sym2.mk ( a, b ) ; intro u hu ; specialize h_no_common _ _ hu ht ; aesop;
        · unfold trianglePackingNumber at h;
          rw [ show ( Finset.filter isEdgeDisjoint ( G.cliqueFinset 3 ).powerset ) = { ∅ } from Finset.eq_singleton_iff_unique_mem.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.empty_subset _ ), by simp +decide [ isEdgeDisjoint ] ⟩, fun t ht => Finset.eq_empty_of_forall_notMem fun x hx => h1 ⟨ x, Finset.mem_powerset.mp ( Finset.mem_filter.mp ht |>.1 ) hx ⟩ ⟩ ] at h ; simp +decide at h;
      -- By `card_inter_eq_two_of_packing_one`, $|t1 \cap t2| = 2$.
      have h_inter : (t1 ∩ t2).card = 2 := by
        exact?;
      contrapose! h_no_common;
      obtain ⟨ e, he ⟩ := Finset.card_eq_two.mp h_inter;
      obtain ⟨ f, hne, h ⟩ := he; use Sym2.mk ( e, f ) ; intro t ht; specialize h_no_common t1 t2 t ht1 ht2 ht; simp_all +decide [ Finset.subset_iff ] ;

/-
If two triangles share exactly 2 vertices and a third triangle does not contain those 2 vertices, then there is no non-diagonal edge common to all three triangles.
-/
lemma no_common_edge_of_triple (t1 t2 t3 : Finset V)
    (h_inter : (t1 ∩ t2).card = 2)
    (h_not_subset : ¬ (t1 ∩ t2) ⊆ t3) :
    ¬ ∃ e : Sym2 V, ¬e.IsDiag ∧ e ∈ t1.sym2 ∧ e ∈ t2.sym2 ∧ e ∈ t3.sym2 := by
      contrapose! h_not_subset; aesop;
      cases w;
      aesop;
      have h_inter_subset : (t1 ∩ t2) = {x, y} := by
        rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ Finset.mem_inter.mpr ⟨ left_1, left_2 ⟩, Finset.singleton_subset_iff.mpr ( Finset.mem_inter.mpr ⟨ right_1, right_2 ⟩ ) ⟩ ) ( by aesop ) ];
      aesop_cat

/-
If a finite set s has cardinality 2 and contains two distinct elements u and v, then s is exactly the set {u, v}.
-/
lemma subset_eq_of_card_eq_two {α : Type*} [DecidableEq α] (s : Finset α) (u v : α)
    (h_card : s.card = 2) (h_subset : {u, v} ⊆ s) (h_neq : u ≠ v) :
    s = {u, v} := by
      rw [ Finset.eq_of_subset_of_card_le h_subset ( by rw [ h_card, Finset.card_insert_of_notMem ] <;> aesop ) ]

/-
If the triangle packing number is 1 and there is a set of 4 vertices containing three triangles that do not share a common non-diagonal edge, then all triangles are contained in that set.
-/
lemma packing_one_K4_closure_weak (h : trianglePackingNumber G = 1)
    (U : Finset V) (hU_card : U.card = 4)
    (t1 t2 t3 : Finset V) (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (ht3 : t3 ∈ G.cliqueFinset 3)
    (h_subset : t1 ⊆ U ∧ t2 ⊆ U ∧ t3 ⊆ U)
    (h_no_common_edge : ¬ ∃ e : Sym2 V, ¬e.IsDiag ∧ e ∈ t1.sym2 ∧ e ∈ t2.sym2 ∧ e ∈ t3.sym2) :
    ∀ t ∈ G.cliqueFinset 3, t ⊆ U := by
      intro t ht;
      -- By the properties of the triangle packing number, any two distinct triangles in the graph share exactly 2 vertices.
      have h_inter : ∀ t1 t2 : Finset V, t1 ∈ G.cliqueFinset 3 → t2 ∈ G.cliqueFinset 3 → t1 ≠ t2 → (t1 ∩ t2).card = 2 := by
        exact?;
      -- If $t$ intersects $U$ in exactly 2 vertices, then those 2 vertices form an edge in $U$ that is shared by $t$ and $U$.
      by_cases h_inter_U : (t ∩ U).card = 2;
      · have h_edge_common : (t ∩ U) ⊆ t1 ∧ (t ∩ U) ⊆ t2 ∧ (t ∩ U) ⊆ t3 := by
          have h_edge_common : ∀ t1 : Finset V, t1 ∈ G.cliqueFinset 3 → t1 ⊆ U → (t ∩ U) ⊆ t1 := by
            intro t1 ht1 ht1_subset
            by_cases h_inter_t1 : t = t1;
            · aesop;
            · have := h_inter t t1 ht ht1 h_inter_t1;
              have h_edge_common : (t ∩ t1) = (t ∩ U) := by
                have h_edge_common : (t ∩ t1) ⊆ (t ∩ U) := by
                  exact Finset.inter_subset_inter ( Finset.Subset.refl _ ) ht1_subset;
                exact Finset.eq_of_subset_of_card_le h_edge_common ( by linarith );
              exact h_edge_common ▸ Finset.inter_subset_right;
          exact ⟨ h_edge_common t1 ht1 h_subset.1, h_edge_common t2 ht2 h_subset.2.1, h_edge_common t3 ht3 h_subset.2.2 ⟩;
        contrapose! h_no_common_edge;
        obtain ⟨ u, v, huv ⟩ := Finset.card_eq_two.mp h_inter_U;
        use Sym2.mk (u, v);
        simp_all +decide [ Finset.subset_iff ];
      · by_cases h_inter_U : (t ∩ U).card = 1;
        · have := h_inter t t1 ht ht1; simp_all +decide [ Finset.card_eq_one ] ;
          obtain ⟨ a, ha ⟩ := h_inter_U; specialize h_inter t t1 ht ht1; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
          by_cases h : t = t1 <;> simp_all +decide [ Finset.card_eq_two ];
          obtain ⟨ x, y, hxy, h ⟩ := h_inter; simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ] ;
        · by_cases h_inter_U : (t ∩ U).card = 0;
          · have := h_inter t t1 ht ht1; simp_all +decide [ Finset.ext_iff ] ;
            contrapose! this;
            exact ⟨ Classical.choose ( Finset.card_pos.mp ( by linarith [ ht.2 ] ) ), Or.inl ⟨ Classical.choose_spec ( Finset.card_pos.mp ( by linarith [ ht.2 ] ) ), fun h => h_inter_U _ ( Classical.choose_spec ( Finset.card_pos.mp ( by linarith [ ht.2 ] ) ) ) ( h_subset.1 h ) ⟩, by rw [ Finset.card_eq_zero.mpr ( Finset.disjoint_iff_inter_eq_empty.mp ( Finset.disjoint_left.mpr fun x hx hx' => h_inter_U _ hx ( h_subset.1 hx' ) ) ) ] ; decide ⟩;
          · have := Finset.card_le_card ( Finset.inter_subset_left : t ∩ U ⊆ t ) ; simp_all +decide ;
            have := ht.card_eq; simp_all +decide ;
            interval_cases _ : Finset.card ( t ∩ U ) <;> simp_all +decide;
            have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ U ⊆ t ) ; aesop;