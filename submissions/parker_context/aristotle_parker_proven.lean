/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 55d1ec45-9aea-450d-a129-50faafce2b0c

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A set of triangles S is a triangle packing if every element is a triangle in G and they are edge-disjoint (share at most 1 vertex).
-/
def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

/-
The triangle packing number ν(G) is the maximum number of edge-disjoint triangles in G.
-/
noncomputable def trianglePackingNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

/-
A set of edges E' is a triangle cover if it is a subset of the edges of G and every triangle in G contains at least one edge from E'.
-/
def isTriangleCover {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

/-
The triangle covering number τ(G) is the minimum number of edges needed to hit all triangles in G.
-/
noncomputable def triangleCoveringNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

/-
T_e is the set of triangles sharing an edge with e. S_e is the set of triangles sharing an edge with e but not with any other f ∈ M.
-/
def trianglesSharingEdge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def S {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) (M : Finset (Finset V)) : Finset (Finset V) :=
  (trianglesSharingEdge G t).filter (fun x => ∀ m ∈ M, m ≠ t → (x ∩ m).card ≤ 1)

/-
Lemma 2.2: Any two triangles in S_e share an edge.
-/
def isMaxPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

def shareEdge {V : Type*} [DecidableEq V] (t1 t2 : Finset V) : Prop :=
  (t1 ∩ t2).card ≥ 2

lemma lemma_2_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    ∀ t1 t2, t1 ∈ S G e M → t2 ∈ S G e M → shareEdge t1 t2 := by
      unfold shareEdge S at *; aesop;
      -- If t1 and t2 do not share an edge, then they are disjoint triangles in S_e.
      by_contra h_not_share;
      -- Consider $M' = (M \setminus \{e\}) \cup \{t1, t2\}$.
      set M' : Finset (Finset V) := (M \ {e}) ∪ {t1, t2};
      -- M' is a triangle packing.
      have hM'_packing : isTrianglePacking G M' := by
        constructor <;> simp_all +decide [ Finset.subset_iff ];
        · aesop;
          · unfold trianglesSharingEdge at left; aesop;
          · unfold trianglesSharingEdge at left_1; aesop;
          · exact hM.1.1 left_2 |> fun h => by simpa using h;
        · intro x hx y hy hxy; aesop;
          · linarith;
          · rw [ Finset.inter_comm ] ; linarith;
          · rw [ Finset.inter_comm ] ; aesop;
          · exact right_1 x left_2 right_2 |> le_trans ( Finset.card_mono <| by aesop_cat );
          · have := hM.1;
            exact this.2 left_2 left_3 hxy;
      -- The size of M' is |M| - 1 + 2 = |M| + 1.
      have hM'_size : M'.card = M.card + 1 := by
        rw [ Finset.card_union_of_disjoint ] <;> aesop;
        · rw [ Finset.card_sdiff ] ; aesop;
          rw [ Finset.card_insert_of_notMem, Finset.card_singleton ] ; aesop;
          · rw [ Nat.sub_add_cancel ( Finset.card_pos.mpr ⟨ e, he ⟩ ) ];
          · unfold trianglesSharingEdge at *; aesop;
            exact h_not_share.not_le ( by have := left_1.card_eq; aesop );
        · unfold trianglesSharingEdge at left; aesop;
          specialize right t1 a ; aesop;
          exact Classical.not_not.1 fun h => by have := left.card_eq; aesop;
        · unfold trianglesSharingEdge at *; aesop;
          have := right _ a; have := right_1 _ a; simp_all +decide [ Finset.inter_comm ] ;
          exact Classical.not_not.1 fun h => by have := this h; linarith [ left_1.card_eq ] ;
      unfold isMaxPacking at hM; aesop;
      have hM'_size_le : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ trianglePackingNumber G := by
        unfold trianglePackingNumber; aesop;
        have hM'_size_le : S ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset := by
          exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( a.1 ), a ⟩;
        have hM'_size_le : S.card ≤ Finset.max (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)) := by
          exact Finset.le_max ( Finset.mem_image_of_mem _ hM'_size_le );
        cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
        exact WithBot.coe_le_coe.mp hM'_size_le;
      linarith [ hM'_size_le _ hM'_packing ]

/-
Helper definitions for removing edges from a graph.
-/
def edgesOfTriangle {V : Type*} [DecidableEq V] (t : Finset V) : Finset (Sym2 V) :=
  t.sym2.filter (fun e => !e.IsDiag)

def edgesOfTriangles {V : Type*} [DecidableEq V] (ts : Finset (Finset V)) : Finset (Sym2 V) :=
  ts.biUnion edgesOfTriangle

def deleteEdges {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (edges : Finset (Sym2 V)) : SimpleGraph V :=
  { Adj := fun v w => G.Adj v w ∧ s(v, w) ∉ edges,
    symm := fun v w ⟨h1, h2⟩ => ⟨G.symm h1, by rw [Sym2.eq_swap]; exact h2⟩,
    loopless := fun v ⟨h1, _⟩ => G.loopless v h1 }

instance {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (edges : Finset (Sym2 V)) : DecidableRel (deleteEdges G edges).Adj :=
  fun v w => inferInstance

/-
Lemma 2.3: The packing number restricted to triangles not in T_e is exactly ν - 1.
-/
noncomputable def trianglePackingNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  triangles.powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

lemma lemma_2_3 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    trianglePackingNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) = trianglePackingNumber G - 1 := by
      simp +decide [ trianglePackingNumberOn ];
      -- Since $M$ is a maximum packing, we have $\nu(G) = |M|$.
      have h_max_packing : trianglePackingNumber G = M.card := by
        unfold isMaxPacking at hM; aesop;
      have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) → M'.card ≤ M.card - 1 := by
        intro M' hM' hM'_allowed
        have hM'_allowed_card : (M' ∪ {e}).card ≤ M.card := by
          have hM'_allowed_card : isTrianglePacking G (M' ∪ {e}) := by
            constructor;
            · simp_all +decide [ Finset.subset_iff ];
              have := hM.1.1 he; aesop;
            · simp_all +decide [ Set.Pairwise ];
              simp_all +decide [ Finset.subset_iff, isTrianglePacking ];
              simp_all +decide [ Finset.inter_comm, trianglesSharingEdge ];
              exact ⟨ fun x hx hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun x hx => ⟨ fun hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun y hy hy' => hM'.2 hx hy hy' ⟩ ⟩;
          have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ M.card := by
            intros M' hM'
            have h_max_packing_allowed : M'.card ≤ trianglePackingNumber G := by
              have h_max_packing_allowed : M' ∈ (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) := by
                exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hM'.1, hM' ⟩;
              unfold trianglePackingNumber;
              have h_max_packing_allowed : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
                exact Finset.mem_image_of_mem _ h_max_packing_allowed;
              have := Finset.le_max h_max_packing_allowed; aesop;
              cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
            exact h_max_packing ▸ h_max_packing_allowed;
          exact h_max_packing_allowed _ hM'_allowed_card;
        have hM'_allowed_card : e ∉ M' := by
          intro h; have := hM'_allowed h; simp_all +decide [ trianglesSharingEdge ] ;
          exact absurd ( this.2 this.1 ) ( by rw [ this.1.2 ] ; decide );
        rw [ Finset.card_union ] at * ; aesop;
        exact Nat.le_sub_one_of_lt hM'_allowed_card_1;
      have h_max_packing_allowed_eq : ∃ M' : Finset (Finset V), isTrianglePacking G M' ∧ M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) ∧ M'.card = M.card - 1 := by
        refine' ⟨ M.erase e, _, _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
        · have := hM.1; aesop;
          · exact fun x hx => this.1 ( Finset.mem_of_mem_erase hx );
          · exact fun x hx y hy hxy => this.2 ( by aesop ) ( by aesop ) hxy;
        · intro t ht; specialize hM; have := hM.1; aesop;
          · exact Finset.mem_filter.mp ( this.1 right ) |>.2;
          · have := this.2;
            exact absurd ( this right he left ) ( by unfold trianglesSharingEdge at a; aesop );
      rw [ show ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 \ trianglesSharingEdge G e |> Finset.powerset ) ) ).max = ↑ ( M.card - 1 ) from ?_ ];
      · aesop;
      · refine' le_antisymm _ _;
        · aesop;
          exact WithBot.coe_le_coe.mpr ( h_max_packing_allowed x a_2 a_1 );
        · exact Finset.le_max ( Finset.mem_image.mpr ⟨ h_max_packing_allowed_eq.choose, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr h_max_packing_allowed_eq.choose_spec.2.1, h_max_packing_allowed_eq.choose_spec.1 ⟩, h_max_packing_allowed_eq.choose_spec.2.2 ⟩ )

/-
The covering number of G is at most the sum of the covering numbers of T_e and the rest of the triangles.
-/
noncomputable def triangleCoveringNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

lemma inductive_bound {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumber G ≤ triangleCoveringNumberOn G (trianglesSharingEdge G e) + triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) := by
      by_contra h_contra;
      -- Let $C_e$ be a minimal cover for $T_e$.
      obtain ⟨C_e, hC_e⟩ : ∃ C_e : Finset (Sym2 V), C_e ⊆ G.edgeFinset ∧ (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) ∧ C_e.card = triangleCoveringNumberOn G (trianglesSharingEdge G e) := by
        have h_min_cover : ∃ C_e : Finset (Sym2 V), C_e ∈ Finset.powerset G.edgeFinset ∧ (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) ∧ ∀ C_e' ∈ Finset.powerset G.edgeFinset, (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e', e ∈ t.sym2) → C_e.card ≤ C_e'.card := by
          have h_min_cover : ∃ C_e ∈ Finset.powerset G.edgeFinset, (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) := by
            refine' ⟨ G.edgeFinset, Finset.mem_powerset.mpr ( Finset.Subset.refl _ ), fun t ht => _ ⟩;
            unfold trianglesSharingEdge at ht; aesop;
            rcases left with ⟨ h₁, h₂ ⟩;
            rcases Finset.card_eq_three.mp h₂ with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; use s(a, b) ; aesop;
          have h_min_cover : ∃ C_e ∈ Finset.filter (fun C_e => ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) (Finset.powerset G.edgeFinset), ∀ C_e' ∈ Finset.filter (fun C_e => ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) (Finset.powerset G.edgeFinset), C_e.card ≤ C_e'.card := by
            exact Finset.exists_min_image _ _ ⟨ h_min_cover.choose, Finset.mem_filter.mpr ⟨ h_min_cover.choose_spec.1, h_min_cover.choose_spec.2 ⟩ ⟩;
          exact ⟨ h_min_cover.choose, Finset.mem_filter.mp h_min_cover.choose_spec.1 |>.1, Finset.mem_filter.mp h_min_cover.choose_spec.1 |>.2, fun C_e' hC_e' hC_e'' => h_min_cover.choose_spec.2 C_e' ( Finset.mem_filter.mpr ⟨ hC_e', hC_e'' ⟩ ) ⟩;
        unfold triangleCoveringNumberOn;
        obtain ⟨ C_e, hC_e₁, hC_e₂, hC_e₃ ⟩ := h_min_cover;
        rw [ Finset.min_eq_inf_withTop ];
        refine' ⟨ C_e, Finset.mem_powerset.mp hC_e₁, hC_e₂, _ ⟩;
        rw [ show ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2 } ) ).inf WithTop.some = WithTop.some C_e.card from ?_ ];
        · rfl;
        · refine' le_antisymm _ _;
          · exact Finset.inf_le ( Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ hC_e₁, hC_e₂ ⟩ ) );
          · simp +zetaDelta at *;
            exact hC_e₃;
      -- Let $C_{\text{rest}}$ be a minimal cover for the rest of the triangles.
      obtain ⟨C_rest, hC_rest⟩ : ∃ C_rest : Finset (Sym2 V), C_rest ⊆ G.edgeFinset ∧ (∀ t ∈ (G.cliqueFinset 3) \ trianglesSharingEdge G e, ∃ e ∈ C_rest, e ∈ t.sym2) ∧ C_rest.card = triangleCoveringNumberOn G ((G.cliqueFinset 3) \ trianglesSharingEdge G e) := by
        unfold triangleCoveringNumberOn;
        have h_min_exists : ∃ C_rest ∈ Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset)), C_rest = Option.getD (Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset))).min 0 := by
          have h_nonempty : Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset)) ≠ ∅ := by
            simp +decide [ Finset.ext_iff ];
            refine' ⟨ _, G.edgeFinset, _, _, rfl ⟩;
            · exact fun x hx => by simpa using hx;
            · intro t ht ht'; obtain ⟨ u, v, w, hu, hv, hw, h ⟩ := Finset.card_eq_three.mp ht.2; use s(u, v); simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          have h_min_exists : ∀ {S : Finset ℕ}, S ≠ ∅ → ∃ x ∈ S, x = Finset.min S := by
            intro S hS_nonempty
            obtain ⟨x, hx⟩ : ∃ x ∈ S, ∀ y ∈ S, x ≤ y := by
              exact ⟨ Finset.min' S ( Finset.nonempty_of_ne_empty hS_nonempty ), Finset.min'_mem _ _, fun y hy => Finset.min'_le _ _ hy ⟩;
            exact ⟨ x, hx.1, le_antisymm ( Finset.le_min fun y hy => WithTop.coe_le_coe.mpr ( hx.2 y hy ) ) ( Finset.min_le hx.1 ) ⟩;
          obtain ⟨ x, hx₁, hx₂ ⟩ := h_min_exists h_nonempty;
          exact ⟨ x, hx₁, by rw [ ← hx₂ ] ; rfl ⟩;
        obtain ⟨ C_rest, hC_rest₁, hC_rest₂ ⟩ := h_min_exists; rw [ Finset.mem_image ] at hC_rest₁; obtain ⟨ E', hE', rfl ⟩ := hC_rest₁; use E'; aesop;
      refine' h_contra _;
      -- Since $C_e \cup C_{\text{rest}}$ is a cover for $G$, we have $\tau(G) \leq |C_e \cup C_{\text{rest}}|$.
      have h_cover : isTriangleCover G (C_e ∪ C_rest) := by
        refine' ⟨ Finset.union_subset hC_e.1 hC_rest.1, _ ⟩;
        intro t ht; by_cases h : t ∈ trianglesSharingEdge G e <;> simp_all +decide ;
        · exact Exists.elim ( hC_e.2.1 t h ) fun e he => ⟨ e, Or.inl he.1, he.2 ⟩;
        · exact Exists.elim ( hC_rest.2.1 t ht h ) fun e he => ⟨ e, Or.inr he.1, he.2 ⟩;
      have h_tau_le : triangleCoveringNumber G ≤ (C_e ∪ C_rest).card := by
        unfold triangleCoveringNumber;
        unfold Option.getD; aesop;
        have := Finset.min_le ( Finset.mem_image_of_mem Finset.card ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.union_subset ( show C_e ⊆ G.edgeFinset from by simpa [ Finset.subset_iff, Set.subset_def ] using left ) ( show C_rest ⊆ G.edgeFinset from by simpa [ Finset.subset_iff, Set.subset_def ] using left_1 ) ), h_cover ⟩ ) ) ; aesop;
        exact WithTop.coe_le_coe.mp this;
      exact h_tau_le.trans ( Finset.card_union_le _ _ ) |> le_trans <| by rw [ hC_e.2.2, hC_rest.2.2 ] ;

/-
Definitions for star and K4 structures in a family of sets.
-/
def isStar {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ e : Finset V, e.card = 2 ∧ ∀ t ∈ S, e ⊆ t

def isK4 {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ s : Finset V, s.card = 4 ∧ ∀ t ∈ S, t ⊆ s

/-
If three triangles pairwise share an edge but don't share a common edge, their union has size 4.
-/
lemma intersecting_triples_structure {V : Type*} [DecidableEq V]
    (t1 t2 t3 : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3)
    (h12 : (t1 ∩ t2).card ≥ 2) (h13 : (t1 ∩ t3).card ≥ 2) (h23 : (t2 ∩ t3).card ≥ 2)
    (h_not_star : ¬ ∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 ∧ e ⊆ t3) :
    (t1 ∪ t2 ∪ t3).card = 4 := by
      -- Since $t1$, $t2$, and $t3$ do not form a star, they must form a $K4$, which means their union has exactly four vertices.
      have h_union_card : (t1 ∪ t2 ∪ t3).card ≤ 4 := by
        -- Since $t3$ intersects with both $t1$ and $t2$, and there's no common edge, the intersection of $t3$ with $(t1 ∪ t2)$ must be at least 2.
        have h_inter_card : (t3 ∩ (t1 ∪ t2)).card ≥ 3 := by
          have h_inter_card : (t3 ∩ (t1 ∪ t2)).card ≥ (t1 ∩ t3).card + (t2 ∩ t3).card - (t1 ∩ t2 ∩ t3).card := by
            rw [ ← Finset.card_union_add_card_inter ];
            simp +decide [ Finset.inter_comm, Finset.inter_left_comm, Finset.inter_assoc ];
            exact Finset.card_le_card fun x hx => by aesop;
          have h_inter_card : (t1 ∩ t2 ∩ t3).card ≤ 1 := by
            contrapose! h_not_star;
            obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq h_not_star;
            exact ⟨ e, he.2, Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ) ⟩;
          omega;
        grind;
      interval_cases _ : ( t1 ∪ t2 ∪ t3 ).card <;> simp_all +decide;
      · rw [ Finset.card_eq_one ] at * ; aesop;
        rw [ Finset.eq_singleton_iff_unique_mem ] at h ; aesop;
        · exact absurd left ( by rw [ show t1 = { w } by ext x; specialize right_1 x; aesop ] ; simp +decide [ * ] );
        · exact absurd ( Finset.card_le_card ( show t2 ⊆ { w } by intros x hx; aesop ) ) ( by aesop );
        · exact absurd ( Finset.card_le_card ( show t3 ⊆ { w } by intros x hx; aesop ) ) ( by aesop );
      · have := Finset.card_le_card ( show t1 ⊆ t1 ∪ ( t2 ∪ t3 ) by exact Finset.subset_union_left ) ; simp_all +decide ;
      · -- Since $t1$, $t2$, and $t3$ are all subsets of $t1 ∪ t2 ∪ t3$ and each has 3 elements, they must all be equal to $t1 ∪ t2 ∪ t3$.
        have h_eq : t1 = t1 ∪ t2 ∪ t3 ∧ t2 = t1 ∪ t2 ∪ t3 ∧ t3 = t1 ∪ t2 ∪ t3 := by
          have h_eq : t1 ⊆ t1 ∪ t2 ∪ t3 ∧ t2 ⊆ t1 ∪ t2 ∪ t3 ∧ t3 ⊆ t1 ∪ t2 ∪ t3 := by
            simp +decide [ Finset.subset_iff ];
            tauto;
          exact ⟨ Finset.eq_of_subset_of_card_le h_eq.1 ( by aesop ), Finset.eq_of_subset_of_card_le h_eq.2.1 ( by aesop ), Finset.eq_of_subset_of_card_le h_eq.2.2 ( by aesop ) ⟩;
        obtain ⟨ x, hx ⟩ := Finset.exists_subset_card_eq ( show 2 ≤ Finset.card t1 from by linarith );
        grind

/-
If a triangle shares an edge with three distinct triangles in a 4-set, it must be in the 4-set.
-/
lemma triangle_in_k4_of_intersects_triples {V : Type*} [DecidableEq V]
    (t1 t2 t3 t : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 ∧ t.card = 3)
    (h_union : (t1 ∪ t2 ∪ t3).card = 4)
    (h_subset : t1 ⊆ t1 ∪ t2 ∪ t3 ∧ t2 ⊆ t1 ∪ t2 ∪ t3 ∧ t3 ⊆ t1 ∪ t2 ∪ t3)
    (h_distinct : t1 ≠ t2 ∧ t1 ≠ t3 ∧ t2 ≠ t3)
    (h_inter : (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2) :
    t ⊆ t1 ∪ t2 ∪ t3 := by
      intro a ha; by_cases ha1 : a ∈ t1 <;> by_cases ha2 : a ∈ t2 <;> by_cases ha3 : a ∈ t3 <;> simp_all +decide [ Finset.subset_iff ] ;
      -- Since $a \notin t1$, $a \notin t2$, and $a \notin t3$, the intersections $t \cap t1$, $t \cap t2$, and $t \cap t3$ can each have at most 2 elements from $t$. However, since $t$ has 3 elements, this is impossible.
      have h_inter_card : (t ∩ t1).card ≤ 2 ∧ (t ∩ t2).card ≤ 2 ∧ (t ∩ t3).card ≤ 2 := by
        exact ⟨ Nat.le_of_lt_succ ( lt_of_lt_of_le ( Finset.card_lt_card ( Finset.filter_ssubset.mpr ⟨ a, by aesop ⟩ ) ) ( by simp +decide [ * ] ) ), Nat.le_of_lt_succ ( lt_of_lt_of_le ( Finset.card_lt_card ( Finset.filter_ssubset.mpr ⟨ a, by aesop ⟩ ) ) ( by simp +decide [ * ] ) ), Nat.le_of_lt_succ ( lt_of_lt_of_le ( Finset.card_lt_card ( Finset.filter_ssubset.mpr ⟨ a, by aesop ⟩ ) ) ( by simp +decide [ * ] ) ) ⟩;
      have h_inter_eq : t ∩ t1 = t \ {a} ∧ t ∩ t2 = t \ {a} ∧ t ∩ t3 = t \ {a} := by
        have h_inter_eq : t ∩ t1 ⊆ t \ {a} ∧ t ∩ t2 ⊆ t \ {a} ∧ t ∩ t3 ⊆ t \ {a} := by
          grind;
        have h_inter_eq : (t ∩ t1).card = (t \ {a}).card ∧ (t ∩ t2).card = (t \ {a}).card ∧ (t ∩ t3).card = (t \ {a}).card := by
          simp_all +decide [ Finset.card_sdiff ];
          exact ⟨ le_antisymm h_inter_card.1 h_inter.1, le_antisymm h_inter_card.2.1 h_inter.2.1, le_antisymm h_inter_card.2.2 h_inter.2.2 ⟩;
        exact ⟨ Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ), Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ), Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ) ⟩;
      -- Since $t \cap t1 = t \cap t2 = t \cap t3 = t \setminus \{a\}$, it follows that $t1$, $t2$, and $t3$ must all contain the same two elements as $t \setminus \{a\}$.
      have h_common_elements : t1 ⊇ t \ {a} ∧ t2 ⊇ t \ {a} ∧ t3 ⊇ t \ {a} := by
        simp_all +decide [ Finset.ext_iff ];
        simp_all +decide [ Finset.subset_iff ];
      have h_common_elements_card : (t1 \ (t \ {a})).card = 1 ∧ (t2 \ (t \ {a})).card = 1 ∧ (t3 \ (t \ {a})).card = 1 := by
        grind;
      rw [ Finset.card_eq_one, Finset.card_eq_one, Finset.card_eq_one ] at h_common_elements_card ; aesop;
      simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
      have h_common_elements_card : (t1 ∪ t2 ∪ t3).card ≥ (t \ {a} ∪ {w, w_1, w_2}).card := by
        refine Finset.card_le_card ?_;
        simp_all +decide [ Finset.subset_iff ];
      grind

/-
An intersecting family of triangles is either a star or contained in a K4.
-/
lemma intersecting_family_structure_corrected {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS_nonempty : S.Nonempty) (hS : S ⊆ G.cliqueFinset 3)
    (h_pair : Set.Pairwise (S : Set (Finset V)) shareEdge) :
    isStar S ∨ isK4 S := by
      by_contra h_not_star;
      -- Assume S is not a star, then there exist three distinct triangles T1, T2, T3 in S that pairwise share edges but don't share a common edge.
      obtain ⟨T1, T2, T3, hT1, hT2, hT3, hT_inter⟩ : ∃ T1 T2 T3 : Finset V, T1 ∈ S ∧ T2 ∈ S ∧ T3 ∈ S ∧ T1 ≠ T2 ∧ T1 ≠ T3 ∧ T2 ≠ T3 ∧ (T1 ∩ T2).card ≥ 2 ∧ (T1 ∩ T3).card ≥ 2 ∧ (T2 ∩ T3).card ≥ 2 ∧ ¬∃ e : Finset V, e.card = 2 ∧ e ⊆ T1 ∧ e ⊆ T2 ∧ e ⊆ T3 := by
        obtain ⟨T1, T2, hT1T2⟩ : ∃ T1 T2 : Finset V, T1 ∈ S ∧ T2 ∈ S ∧ T1 ≠ T2 ∧ (T1 ∩ T2).card ≥ 2 := by
          by_cases h_card : S.card = 1;
          · rw [ Finset.card_eq_one ] at h_card;
            obtain ⟨ x, rfl ⟩ := h_card;
            simp_all +decide [ isStar, isK4 ];
            exact h_not_star.1 ( Finset.exists_subset_card_eq ( show 2 ≤ x.card from by linarith [ hS.2 ] ) |> Classical.choose ) ( Finset.exists_subset_card_eq ( show 2 ≤ x.card from by linarith [ hS.2 ] ) |> Classical.choose_spec |> And.right ) ( Finset.exists_subset_card_eq ( show 2 ≤ x.card from by linarith [ hS.2 ] ) |> Classical.choose_spec |> And.left );
          · obtain ⟨ T1, hT1, T2, hT2, hne ⟩ := Finset.one_lt_card.1 ( lt_of_le_of_ne ( Finset.card_pos.2 hS_nonempty ) ( Ne.symm h_card ) ) ; exact ⟨ T1, T2, hT1, hT2, hne, h_pair hT1 hT2 hne ⟩ ;
        -- Since S is not a star, there exists a triangle T3 in S that does not contain the common edge of T1 and T2.
        obtain ⟨T3, hT3⟩ : ∃ T3 : Finset V, T3 ∈ S ∧ ¬∃ e : Finset V, e.card = 2 ∧ e ⊆ T1 ∧ e ⊆ T2 ∧ e ⊆ T3 := by
          contrapose! h_not_star;
          refine' Or.inl _;
          choose! e he using h_not_star;
          -- Since e is a function from S to Finset V and e x is a subset of T1 and T2 for all x in S, e must be constant.
          have h_const : ∀ x y : Finset V, x ∈ S → y ∈ S → e x = e y := by
            intro x y hx hy; have := he x hx; have := he y hy; simp_all +decide [ Finset.subset_iff ] ;
            have := Finset.eq_of_subset_of_card_le ( show e x ⊆ T1 ∩ T2 from fun z hz => Finset.mem_inter.mpr ⟨ by tauto, by tauto ⟩ ) ; have := Finset.eq_of_subset_of_card_le ( show e y ⊆ T1 ∩ T2 from fun z hz => Finset.mem_inter.mpr ⟨ by tauto, by tauto ⟩ ) ; aesop;
            have := Finset.eq_of_subset_of_card_le ( show T1 ∩ T2 ⊆ T1 from Finset.inter_subset_left ) ; have := Finset.eq_of_subset_of_card_le ( show T1 ∩ T2 ⊆ T2 from Finset.inter_subset_right ) ; aesop;
            have := hS left; have := hS left_3; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            grind;
          use e T1;
          exact ⟨ he T1 hT1T2.1 |>.1, fun t ht => h_const t T1 ht hT1T2.1 ▸ he t ht |>.2.2.2 ⟩;
        by_cases hT3T1 : T3 = T1;
        · use T2, T3, T1;
          simp_all +decide [ Finset.inter_comm ];
          obtain ⟨ x, hx ⟩ := Finset.exists_subset_card_eq hT1T2.2.2.2;
          exact hT3 x hx.2 ( Finset.Subset.trans hx.1 ( Finset.inter_subset_left ) ) ( Finset.Subset.trans hx.1 ( Finset.inter_subset_right ) );
        · by_cases hT3T2 : T3 = T2;
          · simp_all +decide;
            obtain ⟨e, he⟩ : ∃ e : Finset V, e.card = 2 ∧ e ⊆ T1 ∩ T2 := by
              exact Exists.imp ( by tauto ) ( Finset.exists_subset_card_eq hT1T2.2.2.2 );
            exact False.elim ( hT3 e he.1 ( he.2.trans ( Finset.inter_subset_left ) ) ( he.2.trans ( Finset.inter_subset_right ) ) );
          · use T1, T2, T3;
            have := h_pair hT1T2.1 hT3.1; have := h_pair hT1T2.2.1 hT3.1; aesop;
      -- By `intersecting_triples_structure`, |T1 ∪ T2 ∪ T3| = 4.
      have h_union : (T1 ∪ T2 ∪ T3).card = 4 := by
        apply intersecting_triples_structure;
        · have := hS hT1; have := hS hT2; have := hS hT3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
          exact ⟨ by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop ⟩;
        · exact hT_inter.2.2.2.1;
        · exact hT_inter.2.2.2.2.1;
        · linarith;
        · exact hT_inter.2.2.2.2.2.2;
      -- For any T ∈ S, if T = T1, T2, or T3, T ⊆ K.
      have h_subset : ∀ T ∈ S, T ⊆ T1 ∪ T2 ∪ T3 := by
        intros T hT
        by_cases hT_eq : T = T1 ∨ T = T2 ∨ T = T3;
        · aesop_cat;
        · apply_rules [ triangle_in_k4_of_intersects_triples ];
          · have := hS hT; have := hS hT1; have := hS hT2; have := hS hT3; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          · grind;
          · tauto;
          · exact ⟨ h_pair hT hT1 ( by tauto ), h_pair hT hT2 ( by tauto ), h_pair hT hT3 ( by tauto ) ⟩;
      exact h_not_star <| Or.inr ⟨ T1 ∪ T2 ∪ T3, h_union, h_subset ⟩