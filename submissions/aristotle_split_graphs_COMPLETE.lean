/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ee09f2e2-fc27-4168-9bbf-98791c7ceeeb

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check SimpleGraph.IsClique

/-
A graph is a split graph if its vertices can be partitioned into a clique and an independent set.
-/
variable {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]

def IsSplitGraph (G : SimpleGraph V) : Prop :=
  ∃ (K I : Set V), K ∪ I = Set.univ ∧ Disjoint K I ∧ G.IsClique K ∧ G.IsIndepSet I

/-
The set of edges in a triangle (or any set of vertices).
-/
def triangle_edges {V : Type*} [DecidableEq V] (t : Finset V) : Finset (Sym2 V) :=
  t.offDiag.image Sym2.mk

/-
A set of edges is a triangle hitting set if it contains at least one edge from every triangle in the graph.
-/
def is_triangle_hitting_set {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Sym2 V)) : Prop :=
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ S, e ∈ triangle_edges t

/-
A set of triangles is an edge-disjoint packing if every element is a triangle in the graph and no two triangles share an edge.
-/
def is_edge_disjoint_triangle_packing {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  (∀ t ∈ M, t ∈ G.cliqueFinset 3) ∧
  (M : Set (Finset V)).PairwiseDisjoint triangle_edges

/-
tau(G) is the minimum number of edges needed to hit all triangles in G.
-/
noncomputable def tau {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  sInf {n | ∃ S, is_triangle_hitting_set G S ∧ S.card = n}

/-
nu(G) is the maximum number of edge-disjoint triangles in G.
-/
noncomputable def nu {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  sSup {n | ∃ M, is_edge_disjoint_triangle_packing G M ∧ M.card = n}

/-
In a split graph, every triangle contains at least 2 vertices from the clique part.
-/
lemma triangle_vertices_in_clique {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (hG : IsSplitGraph G) (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
  ∃ (K I : Set V), K ∪ I = Set.univ ∧ Disjoint K I ∧ G.IsClique K ∧ G.IsIndepSet I ∧ 2 ≤ (t.filter (· ∈ K)).card := by
    obtain ⟨ K, I, hK, hI, hclique, hinde ⟩ := hG;
    refine' ⟨ K, I, hK, hI, hclique, hinde, _ ⟩;
    by_contra h_contra;
    -- Since $t$ is a clique of size 3, it must contain at least two vertices from $I$.
    have h_two_in_I : ∃ u v : V, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ u ∈ I ∧ v ∈ I := by
      have h_two_in_I : (Finset.filter (fun x => x ∈ I) t).card ≥ 2 := by
        have h_two_in_I : (Finset.filter (fun x => x ∈ K) t).card + (Finset.filter (fun x => x ∈ I) t).card = t.card := by
          rw [ ← Finset.card_union_of_disjoint ];
          · congr with x ; replace hK := Set.ext_iff.mp hK x ; aesop;
          · exact Finset.disjoint_filter.mpr fun x _ hxK hxI => hI.le_bot ⟨ hxK, hxI ⟩;
        simp_all +decide [ SimpleGraph.cliqueFinset ];
        linarith [ show t.card = 3 by exact ht.card_eq ];
      obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.mp h_two_in_I; use u, v; aesop;
    simp_all +decide [ SimpleGraph.isClique_iff, SimpleGraph.isIndepSet_iff ];
    obtain ⟨ u, hu, v, hv, hne, huI, hvI ⟩ := h_two_in_I; have := ht.1; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
    exact hinde huI hvI hne ( this hu hv hne )

/-
If two triangles share an edge, they share at least 2 vertices.
-/
lemma triangle_edge_intersection_card {V : Type*} [DecidableEq V]
  (t1 t2 : Finset V)
  (h1 : t1.card = 3)
  (h2 : t2.card = 3)
  (h_edge : (triangle_edges t1 ∩ triangle_edges t2).Nonempty) :
  2 ≤ (t1 ∩ t2).card := by
    -- Let $e$ be an edge shared by $t1$ and $t2$.
    obtain ⟨e, he⟩ : ∃ e, e ∈ triangle_edges t1 ∩ triangle_edges t2 := by
      exact h_edge;
    unfold triangle_edges at he;
    rcases e with ⟨ x, y ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
    exact Finset.one_lt_card.2 ⟨ x, by aesop, y, by aesop ⟩

/-
The union of two triangles sharing an edge has size at most 4.
-/
lemma union_of_two_intersecting_triangles_le_4 {V : Type*} [DecidableEq V]
  (t1 t2 : Finset V)
  (h1 : t1.card = 3)
  (h2 : t2.card = 3)
  (h_edge : (triangle_edges t1 ∩ triangle_edges t2).Nonempty) :
  (t1 ∪ t2).card ≤ 4 := by
    -- Since they share an edge, |t1 ∩ t2| ≥ 2 (by `triangle_edge_intersection_card`).
    have h_inter_card : 2 ≤ (t1 ∩ t2).card := by
      apply triangle_edge_intersection_card t1 t2 h1 h2 h_edge;
    have := Finset.card_union_add_card_inter t1 t2; linarith;

/-
If three triangles pairwise share edges but don't share a common edge, their union has size at most 4.
-/
lemma three_intersecting_triangles_structure {V : Type*} [DecidableEq V]
  (t1 t2 t3 : Finset V)
  (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3)
  (h12 : (triangle_edges t1 ∩ triangle_edges t2).Nonempty)
  (h13 : (triangle_edges t1 ∩ triangle_edges t3).Nonempty)
  (h23 : (triangle_edges t2 ∩ triangle_edges t3).Nonempty)
  (h_no_common : (triangle_edges t1 ∩ triangle_edges t2 ∩ triangle_edges t3) = ∅) :
  (t1 ∪ t2 ∪ t3).card ≤ 4 := by
    -- Let's denote the edge shared by t1 and t2 as e12, the edge shared by t1 and t3 as e13, and the edge shared by t2 and t3 as e23.
    obtain ⟨e12, he12⟩ : ∃ e12, e12 ∈ triangle_edges t1 ∧ e12 ∈ triangle_edges t2 := by
      exact h12.imp fun x hx => by aesop;
    obtain ⟨e13, he13⟩ : ∃ e13, e13 ∈ triangle_edges t1 ∧ e13 ∈ triangle_edges t3 := by
      exact h13.imp fun x hx => by aesop;
    obtain ⟨e23, he23⟩ : ∃ e23, e23 ∈ triangle_edges t2 ∧ e23 ∈ triangle_edges t3 := by
      exact h23.imp fun x hx => ⟨ Finset.mem_inter.mp hx |>.1, Finset.mem_inter.mp hx |>.2 ⟩;
    -- Since t1 and t2 share an edge, they must share at least 2 vertices. Similarly for t1 and t3, and t2 and t3.
    have h_inter_12 : (t1 ∩ t2).card ≥ 2 := by
      apply triangle_edge_intersection_card;
      · exact h_card.1;
      · exact h_card.2.1;
      · exact ⟨ e12, Finset.mem_inter.mpr ⟨ he12.1, he12.2 ⟩ ⟩
    have h_inter_13 : (t1 ∩ t3).card ≥ 2 := by
      have := triangle_edge_intersection_card t1 t3 h_card.1 h_card.2.2 ( by aesop ) ; aesop;
    have h_inter_23 : (t2 ∩ t3).card ≥ 2 := by
      have := triangle_edge_intersection_card t2 t3 h_card.2.1 h_card.2.2 ( by aesop ) ; aesop;
    have h_union_card : (t1 ∪ t2 ∪ t3).card = t1.card + t2.card + t3.card - (t1 ∩ t2).card - (t1 ∩ t3).card - (t2 ∩ t3).card + (t1 ∩ t2 ∩ t3).card := by
      rw [ tsub_tsub, tsub_tsub, tsub_add_eq_add_tsub ];
      · rw [ tsub_eq_of_eq_add ];
        have := Finset.card_union_add_card_inter t1 ( t2 ∪ t3 ) ; have := Finset.card_union_add_card_inter t2 t3 ; have := Finset.card_union_add_card_inter t1 t2 ; have := Finset.card_union_add_card_inter t1 t3 ; have := Finset.card_union_add_card_inter t2 t3 ; simp_all +decide [ Finset.inter_union_distrib_left ] ;
        have := Finset.card_union_add_card_inter ( t1 ∩ t2 ) ( t1 ∩ t3 ) ; simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ] ; linarith;
      · linarith [ Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ), Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ), Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t3 ⊆ t1 ), Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t3 ⊆ t3 ), Finset.card_le_card ( Finset.inter_subset_left : t2 ∩ t3 ⊆ t2 ), Finset.card_le_card ( Finset.inter_subset_right : t2 ∩ t3 ⊆ t3 ) ];
    have h_inter_123 : (t1 ∩ t2 ∩ t3).card ≤ 1 := by
      have h_inter_123 : ∀ x ∈ t1 ∩ t2 ∩ t3, ∀ y ∈ t1 ∩ t2 ∩ t3, x = y := by
        simp_all +decide [ triangle_edges ];
        simp_all +decide [ Finset.ext_iff, Sym2.eq ];
        grind;
      exact Finset.card_le_one.mpr fun x hx y hy => h_inter_123 x hx y hy;
    omega

/-
If a triangle shares an edge with each of three triangles that form a 'bad triple' (pairwise intersecting but no common edge), it must be contained in their union.
-/
lemma triangle_in_union_of_bad_triple {V : Type*} [DecidableEq V]
  (t1 t2 t3 t : Finset V)
  (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 ∧ t.card = 3)
  (h12 : (triangle_edges t1 ∩ triangle_edges t2).Nonempty)
  (h13 : (triangle_edges t1 ∩ triangle_edges t3).Nonempty)
  (h23 : (triangle_edges t2 ∩ triangle_edges t3).Nonempty)
  (h_no_common : (triangle_edges t1 ∩ triangle_edges t2 ∩ triangle_edges t3) = ∅)
  (ht1 : (triangle_edges t ∩ triangle_edges t1).Nonempty)
  (ht2 : (triangle_edges t ∩ triangle_edges t2).Nonempty)
  (ht3 : (triangle_edges t ∩ triangle_edges t3).Nonempty) :
  t ⊆ t1 ∪ t2 ∪ t3 := by
    -- Assume that $t$ is a triangle intersecting $t1$, $t2$, and $t3$ pairwise, but not sharing a common edge with them. Then there exists an element $x \in t$ such that $x \notin t1 \cup t2 \cup t3$.
    by_contra h_not_subset
    obtain ⟨x, hx⟩ : ∃ x ∈ t, x ∉ t1 ∪ t2 ∪ t3 := by
      exact Finset.not_subset.mp h_not_subset;
    -- Since $t$ shares an edge with $t1 \subseteq K$, and $x \notin K$, the shared edge must be formed by the other two vertices of $t$, say $u$ and $v$.
    obtain ⟨u, v, hu, hv, huv⟩ : ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ u ≠ x ∧ v ≠ x ∧ u ∈ t1 ∧ v ∈ t1 := by
      -- Since $t$ and $t1$ share an edge $(y, z)$, and $x \notin t1$, both $y$ and $z$ must be in $t1$.
      obtain ⟨y, z, hyz⟩ : ∃ y z, y ∈ t ∧ z ∈ t ∧ y ≠ z ∧ y ∈ t1 ∧ z ∈ t1 ∧ (Sym2.mk (y, z)) ∈ triangle_edges t ∩ triangle_edges t1 := by
        obtain ⟨ e, he ⟩ := ht1;
        rcases e with ⟨ y, z ⟩ ; use y, z ; simp_all +decide [ triangle_edges ] ;
        grind;
      grind;
    -- Similarly, since $t2$ and $t3$ share an edge with $t$, and $x \notin K$, the shared edge must be formed by the other two vertices of $t$, say $u$ and $v$.
    obtain ⟨u2, v2, hu2, hv2, huv2⟩ : ∃ u2 v2, u2 ∈ t ∧ v2 ∈ t ∧ u2 ≠ v2 ∧ u2 ≠ x ∧ v2 ≠ x ∧ u2 ∈ t2 ∧ v2 ∈ t2 := by
      rcases ht2 with ⟨ e, he ⟩ ; simp_all +decide [ triangle_edges ] ;
      rcases he with ⟨ ⟨ a, b, ⟨ ha, hb, hab ⟩, rfl ⟩, ⟨ c, d, ⟨ hc, hd, hcd ⟩, he ⟩ ⟩ ; use a, ha, b, hb ; aesop;
    obtain ⟨u3, v3, hu3, hv3, huv3⟩ : ∃ u3 v3, u3 ∈ t ∧ v3 ∈ t ∧ u3 ≠ v3 ∧ u3 ≠ x ∧ v3 ≠ x ∧ u3 ∈ t3 ∧ v3 ∈ t3 := by
      obtain ⟨ e, he ⟩ := ht3;
      rcases e with ⟨ u3, v3 ⟩ ; simp_all +decide [ triangle_edges ] ;
      grind;
    -- Since $u$ and $v$ are in $t1$, $t2$, and $t3$, and $t1$, $t2$, and $t3$ are triangles, $u$ and $v$ must be adjacent in $t1$, $t2$, and $t3$.
    have h_adj : u ∈ t1 ∧ v ∈ t1 ∧ u ∈ t2 ∧ v ∈ t2 ∧ u ∈ t3 ∧ v ∈ t3 := by
      have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset hu ( Finset.insert_subset hv ( Finset.singleton_subset_iff.mpr hx.1 ) ) ) ; aesop;
    simp_all +decide [ Finset.ext_iff, triangle_edges ];
    exact h_no_common _ _ _ h_adj.1 h_adj.2.1 huv.1 rfl _ _ h_adj.2.2.1 h_adj.2.2.2.1 huv.1 rfl _ _ h_adj.2.2.2.2.1 h_adj.2.2.2.2.2 huv.1 rfl

/-
If a nonempty set of pairwise intersecting triangles has no common edge, there exist three triangles with no common edge.
-/
lemma exists_bad_triple_of_no_common_edge {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (T : Finset (Finset V))
  (hT_nonempty : T.Nonempty)
  (hT : ∀ t ∈ T, t ∈ G.cliqueFinset 3)
  (hp : (T : Set (Finset V)).Pairwise (fun t1 t2 => (triangle_edges t1 ∩ triangle_edges t2).Nonempty))
  (h_no_common : ¬ ∃ e : Sym2 V, ∀ t ∈ T, e ∈ triangle_edges t) :
  ∃ t1 ∈ T, ∃ t2 ∈ T, ∃ t3 ∈ T, (triangle_edges t1 ∩ triangle_edges t2 ∩ triangle_edges t3) = ∅ := by
    by_contra h_contra;
    -- Since T is nonempty and there is no common edge, T must have at least 2 triangles.
    have hT_two_triangles : ∃ t1 ∈ T, ∃ t2 ∈ T, t1 ≠ t2 := by
      by_cases h_eq : ∀ t1 ∈ T, ∀ t2 ∈ T, t1 = t2;
      · -- Since T is nonempty and all triangles in T are equal, T can only contain one triangle.
        obtain ⟨t, ht⟩ : ∃ t ∈ T, ∀ t' ∈ T, t' = t := by
          exact ⟨ hT_nonempty.choose, hT_nonempty.choose_spec, fun t' ht' => h_eq _ ht' _ hT_nonempty.choose_spec ⟩;
        have h_triangle_edges_nonempty : ∃ e ∈ triangle_edges t, True := by
          simp_all +decide [ Finset.ext_iff ];
          exact h_contra _ ht.1 _ ht.1;
        exact False.elim ( h_no_common ⟨ h_triangle_edges_nonempty.choose, fun t' ht' => ht.2 t' ht' ▸ h_triangle_edges_nonempty.choose_spec.1 ⟩ );
      · exact by push_neg at h_eq; exact h_eq;
    obtain ⟨ t1, ht1, t2, ht2, hne ⟩ := hT_two_triangles;
    -- Since $t1$ and $t2$ are distinct triangles, they share exactly one edge $e$.
    obtain ⟨e, he⟩ : ∃ e, e ∈ triangle_edges t1 ∩ triangle_edges t2 ∧ ∀ f ∈ triangle_edges t1 ∩ triangle_edges t2, f = e := by
      have h_common_edge : (t1 ∩ t2).card = 2 := by
        have := hp ht1 ht2 hne;
        have := hT t1 ht1; have := hT t2 ht2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
        have := triangle_edge_intersection_card t1 t2 ( hT t1 ht1 |>.2 ) ( hT t2 ht2 |>.2 ) this;
        have := Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; ( have := Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; simp_all +decide ; );
        interval_cases _ : Finset.card ( t1 ∩ t2 ) <;> simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; simp_all +decide ;
      -- Since $t1$ and $t2$ are distinct triangles, they share exactly one edge $e$. Let $e = \{u, v\}$ where $u, v \in t1 \cap t2$.
      obtain ⟨u, v, huv⟩ : ∃ u v : V, u ∈ t1 ∧ v ∈ t1 ∧ u ∈ t2 ∧ v ∈ t2 ∧ u ≠ v ∧ t1 ∩ t2 = {u, v} := by
        rw [ Finset.card_eq_two ] at h_common_edge;
        obtain ⟨ u, v, huv, h ⟩ := h_common_edge; exact ⟨ u, v, by rw [ Finset.ext_iff ] at h; specialize h u; aesop, by rw [ Finset.ext_iff ] at h; specialize h v; aesop, by rw [ Finset.ext_iff ] at h; specialize h u; aesop, by rw [ Finset.ext_iff ] at h; specialize h v; aesop, huv, h ⟩ ;
      use Sym2.mk (u, v);
      simp_all +decide [ triangle_edges ];
      refine' ⟨ ⟨ ⟨ u, v, ⟨ huv.1, huv.2.1, huv.2.2.2.2.1 ⟩, Or.inl ⟨ rfl, rfl ⟩ ⟩, ⟨ u, v, ⟨ huv.2.2.1, huv.2.2.2.1, huv.2.2.2.2.1 ⟩, Or.inl ⟨ rfl, rfl ⟩ ⟩ ⟩, _ ⟩;
      rintro f x y hx hy hxy rfl a b ha hb hab h; simp_all +decide [ Finset.ext_iff, Set.ext_iff ] ;
      grind;
    refine' h_no_common ⟨ e, fun t ht => _ ⟩;
    by_cases h : e ∈ triangle_edges t <;> simp_all +decide [ Finset.ext_iff ];
    grind

/-
A set of triangles that pairwise share edges either all share a common edge or are all contained in a set of 4 vertices.
-/
lemma intersecting_triangles_structure {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (T : Finset (Finset V))
  (hT : ∀ t ∈ T, t ∈ G.cliqueFinset 3)
  (hp : (T : Set (Finset V)).Pairwise (fun t1 t2 => (triangle_edges t1 ∩ triangle_edges t2).Nonempty)) :
  (∃ e : Sym2 V, ∀ t ∈ T, e ∈ triangle_edges t) ∨ (T.sup id).card ≤ 4 := by
    by_contra! h;
    -- By `exists_bad_triple_of_no_common_edge`, there exist t1, t2, t3 in T forming a bad triple (pairwise intersecting, no common edge).
    obtain ⟨t1, ht1, t2, ht2, t3, ht3, h_no_common⟩ : ∃ t1 ∈ T, ∃ t2 ∈ T, ∃ t3 ∈ T, (triangle_edges t1 ∩ triangle_edges t2 ∩ triangle_edges t3) = ∅ := by
      apply Classical.byContradiction
      intro h_no_common_edges;
      exact absurd ( exists_bad_triple_of_no_common_edge G T ( Finset.nonempty_of_ne_empty ( by aesop_cat ) ) hT hp fun ⟨ e, he ⟩ => h.1 e |> fun ⟨ t, ht, hne ⟩ => hne <| he t ht ) ( by aesop );
    -- By `three_intersecting_triangles_structure`, |t1 ∪ t2 ∪ t3| ≤ 4. Let K = t1 ∪ t2 ∪ t3.
    have h_union_le_4 : (t1 ∪ t2 ∪ t3).card ≤ 4 := by
      have h_union_le_4 : (t1 ∪ t2 ∪ t3).card ≤ 4 := by
        have h1 : t1.card = 3 := by
          simp_all +decide [ SimpleGraph.cliqueFinset ];
          exact hT t1 ht1 |>.2
        have h2 : t2.card = 3 := by
          have := hT t2 ht2; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
          exact hT t2 ht2 |>.2
        have h3 : t3.card = 3 := by
          have := hT t3 ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
          exact hT t3 ht3 |>.2
        have h12 : (triangle_edges t1 ∩ triangle_edges t2).Nonempty := by
          by_cases h12 : t1 = t2;
          · rw [ h12 ];
            simp +decide [ triangle_edges ];
            exact Finset.card_pos.mp ( by simp +decide [ h2 ] );
          · exact hp ht1 ht2 h12
        have h13 : (triangle_edges t1 ∩ triangle_edges t3).Nonempty := by
          by_cases h13 : t1 = t3 <;> simp_all +decide;
          · exact h12.imp fun x hx => by aesop;
          · exact hp ht1 ht3 h13
        have h23 : (triangle_edges t2 ∩ triangle_edges t3).Nonempty := by
          exact hp ht2 ht3 ( by aesop_cat )
        apply three_intersecting_triangles_structure t1 t2 t3 ⟨ h1, h2, h3 ⟩ h12 h13 h23 h_no_common;
      exact h_union_le_4;
    -- For any t in T, t intersects t1, t2, t3 (by pairwise property).
    have h_inter : ∀ t ∈ T, (triangle_edges t ∩ triangle_edges t1).Nonempty ∧ (triangle_edges t ∩ triangle_edges t2).Nonempty ∧ (triangle_edges t ∩ triangle_edges t3).Nonempty := by
      intro t ht
      have h_inter_t1 : (triangle_edges t ∩ triangle_edges t1).Nonempty := by
        by_cases h : t = t1 <;> simp_all +decide [ Set.Pairwise ];
        have := hT t1 ht1;
        rcases this with ⟨ h1, h2 ⟩;
        rcases Finset.card_eq_three.mp h2 with ⟨ x, y, z, hxy, hyz, hxz ⟩ ; simp_all +decide [ Finset.ext_iff, Set.ext_iff ];
        exact ⟨ Sym2.mk ( x, y ), Finset.mem_image.mpr ⟨ ( x, y ), by aesop ⟩ ⟩
      have h_inter_t2 : (triangle_edges t ∩ triangle_edges t2).Nonempty := by
        by_cases h_eq : t = t2;
        · exact h_inter_t1.imp fun x hx => by aesop;
        · exact hp ht ht2 h_eq
      have h_inter_t3 : (triangle_edges t ∩ triangle_edges t3).Nonempty := by
        by_cases h : t = t3 <;> simp_all +decide [ Set.Pairwise ];
        exact h_inter_t1.imp fun x hx => by aesop;
      exact ⟨h_inter_t1, h_inter_t2, h_inter_t3⟩;
    -- By `triangle_in_union_of_bad_triple`, t ⊆ K.
    have h_subset : ∀ t ∈ T, t ⊆ t1 ∪ t2 ∪ t3 := by
      intro t ht;
      apply triangle_in_union_of_bad_triple;
      all_goals simp_all +decide [ SimpleGraph.cliqueFinset ];
      exact ⟨ hT t1 ht1 |>.2, hT t2 ht2 |>.2, hT t3 ht3 |>.2, hT t ht |>.2 ⟩;
    exact h.2.not_le ( le_trans ( Finset.card_le_card ( show ( T.sup id ) ⊆ t1 ∪ t2 ∪ t3 from fun x hx => by rcases Finset.mem_sup.mp hx with ⟨ t, ht, hxt ⟩ ; exact h_subset t ht hxt ) ) h_union_le_4 )

/-
If a set of triangles is contained in a set of 4 vertices, they can be hit by at most 2 edges.
-/
lemma cover_triangles_in_size_4 {V : Type*} [DecidableEq V]
  (S : Finset V)
  (hS : S.card ≤ 4)
  (T : Finset (Finset V))
  (hT : ∀ t ∈ T, t ⊆ S ∧ t.card = 3) :
  ∃ H : Finset (Sym2 V), H.card ≤ 2 ∧ ∀ t ∈ T, (triangle_edges t ∩ H).Nonempty := by
    -- If |S| = 3, T has at most 1 element (S itself). Any edge in S works.
    by_cases hS3 : S.card = 3;
    · -- If |S| = 3, T has at most 1 element (S itself). Any edge in S works. Let's choose any edge from S.
      obtain ⟨e, he⟩ : ∃ e ∈ triangle_edges S, True := by
        unfold triangle_edges;
        simp +decide [ Finset.card_eq_three ] at hS3 ⊢;
        rcases hS3 with ⟨ x, y, hxy, z, hxz, hyz, rfl ⟩ ; exact ⟨ _, x, y, by aesop ⟩;
      refine' ⟨ { e }, _, _ ⟩ <;> simp_all +decide;
      intro t ht; specialize hT t ht; have := Finset.eq_of_subset_of_card_le hT.1; aesop;
    · -- If |S| = 2, then T is empty, so H=empty works.
      by_cases hS2 : S.card ≤ 2;
      · exact ⟨ ∅, by norm_num, fun t ht => by have := hT t ht; linarith [ Finset.card_le_card this.1 ] ⟩;
      · interval_cases _ : S.card <;> simp_all +decide;
        -- Let S = {a, b, c, d}.
        obtain ⟨a, b, c, d, hS⟩ : ∃ a b c d : V, S = {a, b, c, d} ∧ a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d := by
          simp_rw +decide [ Finset.card_eq_succ ] at * ; aesop;
        -- Possible triangles are {a,b,c}, {a,b,d}, {a,c,d}, {b,c,d}.
        have h_triangles : ∀ t ∈ T, t = {a, b, c} ∨ t = {a, b, d} ∨ t = {a, c, d} ∨ t = {b, c, d} := by
          intro t ht
          obtain ⟨ht_sub, ht_card⟩ := hT t ht
          have ht_cases : t ⊆ {a, b, c, d} ∧ t.card = 3 := by
            aesop;
          have := Finset.card_eq_three.mp ht_cases.2;
          rcases this with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
          rcases ht_cases with ⟨ rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl ⟩ <;> simp +decide [ *, Finset.Subset.antisymm_iff, Finset.subset_iff ] at hxy hxz hyz ⊢;
        -- H = {{a,b}, {c,d}} covers all.
        use {Sym2.mk (a, b), Sym2.mk (c, d)};
        unfold triangle_edges; simp +decide [ *, Finset.Nonempty ] ;
        intro t ht; rcases h_triangles t ht with ( rfl | rfl | rfl | rfl ) <;> simp +decide [ *, Sym2.eq_swap ] ;
        · exact ⟨ _, ⟨ a, b, by aesop ⟩, Or.inl rfl ⟩;
        · exact ⟨ _, ⟨ a, b, by aesop ⟩, Or.inl rfl ⟩;
        · exact ⟨ _, ⟨ c, d, by aesop ⟩, Or.inr rfl ⟩;
        · exact ⟨ _, ⟨ c, d, by aesop ⟩, Or.inr rfl ⟩

/-
A set of triangles that pairwise share edges can be hit by at most 2 edges.
-/
lemma structural_cover {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (T : Finset (Finset V))
  (hT : ∀ t ∈ T, t ∈ G.cliqueFinset 3)
  (hp : (T : Set (Finset V)).Pairwise (fun t1 t2 => (triangle_edges t1 ∩ triangle_edges t2).Nonempty)) :
  ∃ H : Finset (Sym2 V), H.card ≤ 2 ∧ ∀ t ∈ T, (triangle_edges t ∩ H).Nonempty := by
    by_cases h_common : ∃ e : Sym2 V, ∀ t ∈ T, e ∈ triangle_edges t;
    · exact ⟨ { h_common.choose }, by simp +decide, fun t ht => ⟨ h_common.choose, Finset.mem_inter_of_mem ( h_common.choose_spec t ht ) ( Finset.mem_singleton_self _ ) ⟩ ⟩;
    · -- Otherwise, the union of all triangles in T has size at most 4.
      have h_union_size : (T.sup id).card ≤ 4 := by
        exact intersecting_triangles_structure G T hT hp |>.resolve_left h_common;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      -- By `cover_triangles_in_size_4`, there exists H with |H| ≤ 2 covering all triangles.
      apply cover_triangles_in_size_4 (T.sup id) h_union_size T (fun t ht => by
        exact ⟨ Finset.le_sup ( f := id ) ht, by have := hT t ht; exact this.card_eq ⟩)

/-
If the maximum number of edge-disjoint triangles is 1, then the minimum number of edges to hit all triangles is at most 2.
-/
lemma nu_eq_one_implies_tau_le_two {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : nu G = 1) :
  tau G ≤ 2 := by
    by_contra h_contra;
    -- If nu(G) = 1, then there are no two edge-disjoint triangles in G.
    have h_no_edge_disjoint_triangles : ∀ t1 t2 : Finset V, t1 ∈ G.cliqueFinset 3 → t2 ∈ G.cliqueFinset 3 → ¬(triangle_edges t1 ∩ triangle_edges t2 = ∅) := by
      intro t1 t2 ht1 ht2 h_empty
      have h_pairwise_intersecting : ∀ (M : Finset (Finset V)), (∀ t ∈ M, t ∈ G.cliqueFinset 3) → (M : Set (Finset V)).PairwiseDisjoint triangle_edges → M.card ≤ 1 := by
        intros M hM hM_pairwise_disjoint
        have hM_card : M.card ≤ nu G := by
          apply le_csSup;
          · exact ⟨ Finset.card ( Finset.univ : Finset ( Finset V ) ), by rintro n ⟨ M, hM, rfl ⟩ ; exact Finset.card_le_univ _ ⟩;
          · exact ⟨ M, ⟨ hM, hM_pairwise_disjoint ⟩, rfl ⟩;
        linarith;
      specialize h_pairwise_intersecting { t1, t2 } ; simp_all +decide [ Set.PairwiseDisjoint ];
      simp_all +decide [ Finset.card_insert_of_notMem, Finset.card_singleton, Set.Pairwise ];
      by_cases h : t1 = t2 <;> simp_all +decide [ Finset.card_insert_of_notMem, Function.onFun, Finset.disjoint_iff_inter_eq_empty ];
      · unfold triangle_edges at h_empty; simp_all +decide [ Finset.ext_iff ] ;
        rcases Finset.card_eq_three.mp ht2.2 with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; specialize h_empty ( s(a, b) ) a b ; aesop;
      · simp_all +decide [ Finset.inter_comm ];
    -- Let T be the set of all triangles in G.
    set T := G.cliqueFinset 3 with hT_def;
    -- By `structural_cover`, there exists a hitting set H with |H| ≤ 2.
    obtain ⟨H, hH_card, hH⟩ : ∃ H : Finset (Sym2 V), H.card ≤ 2 ∧ ∀ t ∈ T, (triangle_edges t ∩ H).Nonempty := by
      apply structural_cover G T;
      · exact fun t ht => ht;
      · exact fun t1 ht1 t2 ht2 h => Finset.nonempty_iff_ne_empty.mpr ( h_no_edge_disjoint_triangles t1 t2 ht1 ht2 );
    refine' h_contra ( le_trans ( csInf_le _ _ ) hH_card );
    · exact ⟨ 0, fun n hn => hn.choose_spec.2.symm ▸ Nat.zero_le _ ⟩;
    · exact ⟨ H, fun t ht => by obtain ⟨ e, he ⟩ := hH t ht; exact ⟨ e, Finset.mem_of_mem_inter_right he, Finset.mem_of_mem_inter_left he ⟩, rfl ⟩

/-
Definitions of tau and nu for a set of triangles, and the lemma that nu=1 implies tau<=2 for any set of triangles in a split graph.
-/
def is_hitting_set_for_triangles {V : Type*} [DecidableEq V] (T : Finset (Finset V)) (S : Finset (Sym2 V)) : Prop :=
  ∀ t ∈ T, ∃ e ∈ S, e ∈ triangle_edges t

def is_packing_for_triangles {V : Type*} [DecidableEq V] (T : Finset (Finset V)) (M : Finset (Finset V)) : Prop :=
  M ⊆ T ∧ (M : Set (Finset V)).PairwiseDisjoint triangle_edges

noncomputable def tau_set {V : Type*} [DecidableEq V] (T : Finset (Finset V)) : ℕ :=
  sInf {n | ∃ S, is_hitting_set_for_triangles T S ∧ S.card = n}

noncomputable def nu_set {V : Type*} [DecidableEq V] (T : Finset (Finset V)) : ℕ :=
  sSup {n | ∃ M, is_packing_for_triangles T M ∧ M.card = n}

lemma nu_set_eq_one_implies_tau_set_le_two {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (T : Finset (Finset V))
  (hT : ∀ t ∈ T, t ∈ G.cliqueFinset 3)
  (h_nu : nu_set T = 1) :
  tau_set T ≤ 2 := by
    -- By the lemma structural_cover, if the maximum number of edge-disjoint triangles is 1, then the minimum number of edges needed to hit all triangles is at most 2. Use this lemma.
    have h_tau_le_two : ∃ H : Finset (Sym2 V), H.card ≤ 2 ∧ ∀ t ∈ T, (triangle_edges t ∩ H).Nonempty := by
      apply structural_cover G T hT;
      intro t1 ht1 t2 ht2 hne;
      contrapose! h_nu;
      refine' ne_of_gt ( lt_of_lt_of_le _ ( le_csSup _ ⟨ { t1, t2 }, _, rfl ⟩ ) );
      · grind;
      · exact ⟨ _, fun n hn => hn.choose_spec.2 ▸ Finset.card_le_univ _ ⟩;
      · refine' ⟨ _, _ ⟩;
        · aesop_cat;
        · simp_all +decide [ Set.PairwiseDisjoint ];
          simp_all +decide [ Set.Pairwise, Finset.disjoint_iff_inter_eq_empty ];
          exact fun h => by rw [ Finset.inter_comm, h_nu ] ;
    obtain ⟨ S, hS₁, hS₂ ⟩ := h_tau_le_two;
    exact Nat.le_trans ( Nat.sInf_le ⟨ S, fun t ht => by obtain ⟨ e, he ⟩ := hS₂ t ht; aesop, rfl ⟩ ) hS₁

/-
If the clique part of a split graph has size at most 3, then Tuza's conjecture holds.
-/
lemma base_case_K_le_3 {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (K : Set V)
  (h_clique : G.IsClique K)
  (h_card : K.toFinset.card ≤ 3)
  (h_cover : ∀ t ∈ G.cliqueFinset 3, 2 ≤ (t ∩ K.toFinset).card) :
  tau G ≤ 2 * nu G := by
    -- By h_cover, every triangle has at least 2 vertices in K, so it contains an edge in E_K.
    have h_hitting_set : ∃ H : Finset (Sym2 V), H.card ≤ 3 ∧ ∀ t ∈ G.cliqueFinset 3, (triangle_edges t ∩ H).Nonempty := by
      use Finset.image ( fun uv => Sym2.mk uv ) ( Finset.offDiag ( K.toFinset ) );
      refine' ⟨ _, _ ⟩;
      · interval_cases _ : K.toFinset.card <;> simp_all +decide;
        · rw [ Finset.card_eq_zero.mpr ] <;> aesop;
        · exact le_trans ( Finset.card_image_le ) ( by simp +decide [ *, Finset.card_le_one ] );
        · exact le_trans ( Finset.card_image_le ) ( by simp +decide [ *, Finset.card_univ ] );
        · have := Finset.card_eq_three.mp ‹_›;
          obtain ⟨ x, y, z, hxy, hxz, hyz, h ⟩ := this; simp_all +decide [ Finset.ext_iff ] ;
          exact le_trans ( Finset.card_le_card ( show Finset.image ( fun uv : V × V => Sym2.mk uv ) ( Finset.offDiag ( Set.toFinset K ) ) ⊆ { Sym2.mk ( x, y ), Sym2.mk ( x, z ), Sym2.mk ( y, z ) } from Finset.image_subset_iff.mpr fun uv huv => by aesop ) ) ( Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _ );
      · intro t ht;
        obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.1 ( h_cover t ht );
        exact ⟨ Sym2.mk ( u, v ), Finset.mem_inter.mpr ⟨ Finset.mem_image.mpr ⟨ ( u, v ), Finset.mem_offDiag.mpr ⟨ Finset.mem_inter.mp hu |>.1, Finset.mem_inter.mp hv |>.1, huv ⟩, rfl ⟩, Finset.mem_image.mpr ⟨ ( u, v ), Finset.mem_offDiag.mpr ⟨ Finset.mem_inter.mp hu |>.2, Finset.mem_inter.mp hv |>.2, huv ⟩, rfl ⟩ ⟩ ⟩;
    -- So tau(G) ≤ |E_K| ≤ 3.
    have h_tau_le_3 : tau G ≤ 3 := by
      refine' le_trans ( csInf_le _ _ ) h_hitting_set.choose_spec.1;
      · exact ⟨ 0, fun n hn => hn.choose_spec.2.symm ▸ Nat.zero_le _ ⟩;
      · refine' ⟨ h_hitting_set.choose, _, rfl ⟩;
        intro t ht; specialize h_hitting_set; have := h_hitting_set.choose_spec.2 t ht; obtain ⟨ e, he ⟩ := this; aesop;
    by_cases h_nu_ge_2 : nu G ≥ 2;
    · linarith;
    · interval_cases _ : nu G <;> simp_all +decide;
      · refine' le_antisymm _ _;
        · refine' Nat.sInf_le _;
          use ∅; simp [is_triangle_hitting_set];
          intro t ht; have := ‹SupSet.sSup { n : ℕ | ∃ M : Finset ( Finset V ), is_edge_disjoint_triangle_packing G M ∧ M.card = n } = 0› ▸ le_csSup ( show BddAbove { n : ℕ | ∃ M : Finset ( Finset V ), is_edge_disjoint_triangle_packing G M ∧ M.card = n } from ⟨ Fintype.card ( Finset V ), fun n hn => by obtain ⟨ M, hM₁, hM₂ ⟩ := hn; exact hM₂ ▸ Finset.card_le_univ _ ⟩ ) ⟨ { t }, ⟨ by aesop_cat, by aesop_cat ⟩, rfl ⟩ ; simp_all +decide ;
        · exact Nat.zero_le _;
      · exact nu_eq_one_implies_tau_le_two G ‹_›

/-
In a split graph, every triangle is either contained in the clique or has exactly two vertices in the clique and one in the independent set.
-/
lemma split_graph_triangle_types {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (hG : IsSplitGraph G) (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
  ∃ (K I : Set V), K ∪ I = Set.univ ∧ Disjoint K I ∧ G.IsClique K ∧ G.IsIndepSet I ∧
  ((t : Set V) ⊆ K ∨ (∃ u v w, t = {u, v, w} ∧ u ∈ K ∧ v ∈ K ∧ w ∈ I)) := by
    -- We know from `triangle_vertices_in_clique` that `t` has at least 2 vertices in `K`.
    obtain ⟨K, I, h_union, h_disjoint, h_clique, h_indep, h_card⟩ : ∃ K I : Set V, K ∪ I = Set.univ ∧ Disjoint K I ∧ G.IsClique K ∧ G.IsIndepSet I ∧ 2 ≤ (t.filter (fun v => v ∈ K)).card := by
      exact triangle_vertices_in_clique G hG t ht
    use K, I;
    by_cases h : ( t.filter fun v => v ∈ K ) = t <;> simp_all +decide [ Finset.ext_iff, Set.ext_iff ];
    · exact Or.inl h;
    · -- Since $t$ is a 3-clique and $K$ is a clique, $t$ must have exactly two vertices in $K$ and one in $I$.
      obtain ⟨u, v, w, hu, hv, hw, huv⟩ : ∃ u v w : V, u ∈ t ∧ v ∈ t ∧ w ∈ t ∧ u ≠ v ∧ u ≠ w ∧ v ≠ w ∧ u ∈ K ∧ v ∈ K ∧ w ∉ K := by
        obtain ⟨ u, hu, hu' ⟩ := h;
        obtain ⟨ v, hv, hv' ⟩ := Finset.exists_mem_ne h_card u;
        obtain ⟨ w, hw, hw' ⟩ := Finset.exists_mem_ne ( show 1 < Finset.card ( Finset.filter ( fun x => x ∈ K ) t ) from h_card ) v; use v, w, u; aesop;
      have h_triangle : t = {u, v, w} := by
        have := ht.2;
        rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ hu, Finset.insert_subset_iff.mpr ⟨ hv, Finset.singleton_subset_iff.mpr hw ⟩ ⟩ ) ] ; aesop;
      exact Or.inr ⟨ u, v, w, by aesop, huv.2.2.2.1, huv.2.2.2.2.1, by simpa using h_union w |> Or.resolve_left <| by aesop ⟩