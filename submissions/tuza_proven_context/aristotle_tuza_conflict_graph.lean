/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aaf89ca2-9a63-4039-b1ac-dbd68ae784a4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Two sets of vertices are edge-disjoint if they share at most 1 vertex.
-/
def is_edge_disjoint {V : Type*} [DecidableEq V] (s t : Finset V) : Prop := (s ∩ t).card ≤ 1

/-
A set of triangles is a packing if every element is a triangle in G and they are pairwise edge-disjoint.
-/
def is_packing {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  (S ⊆ G.cliqueFinset 3) ∧
  (S : Set (Finset V)).Pairwise is_edge_disjoint

/-
The packing number ν(G) is the maximum size of a set of edge-disjoint triangles.
-/
noncomputable def nu {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  ((G.cliqueFinset 3).powerset.filter (is_packing G)).image Finset.card |>.max' (by
  simp;
  -- The empty set is a valid packing since it satisfies the conditions of being edge-disjoint and a subset of the cliqueFinset.
  use ∅; simp [is_packing]
  )

/-
The edges of a triangle `t` are the pairs of distinct vertices in `t`.
-/
def edges_of_triangle {V : Type*} [DecidableEq V] (t : Finset V) : Finset (Sym2 V) :=
  t.sym2.filter (λ e => ¬e.IsDiag)

/-
A set of edges is a covering if it is a subset of the graph's edges and intersects every triangle.
-/
def is_covering {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (E : Finset (Sym2 V)) : Prop :=
  E ⊆ G.edgeFinset ∧
  ∀ t ∈ G.cliqueFinset 3, (edges_of_triangle t ∩ E).Nonempty

/-
The covering number τ(G) is the minimum size of a set of edges that hits every triangle.
-/
noncomputable def tau {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  if h : (G.cliqueFinset 3).Nonempty then
    ((G.edgeFinset.powerset.filter (is_covering G)).image Finset.card).min' (by
    refine' ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.Subset.refl _ ), _ ⟩ ) ⟩;
    unfold is_covering; aesop;
    rcases a with ⟨ h₁, h₂ ⟩;
    obtain ⟨ u, v, w, h ⟩ := Finset.card_eq_three.mp h₂;
    simp_all +decide [ SimpleGraph.isClique_iff, edges_of_triangle ];
    refine' ⟨ Sym2.mk ( u, v ), _ ⟩ ; aesop
    )
  else
    0

/-
The conflict graph C(G) has triangles as vertices, and edges connect two triangles if they share an edge (i.e., share 2 vertices).
-/
def conflict_graph {V : Type*} [DecidableEq V] : SimpleGraph (Finset V) :=
  SimpleGraph.fromRel (λ s t => (s ∩ t).card = 2)

/-
A set of edges E is a covering for a set of triangles T if E is a subset of G's edges and E intersects every triangle in T.
-/
def is_covering_set {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (Triangles : Finset (Finset V)) (E : Finset (Sym2 V)) : Prop :=
  E ⊆ G.edgeFinset ∧
  ∀ t ∈ Triangles, (edges_of_triangle t ∩ E).Nonempty

/-
The covering number τ(T) for a set of triangles T is the minimum size of a set of edges that hits every triangle in T. Defined as 0 if T is empty or not a set of triangles.
-/
noncomputable def tau_set {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (Triangles : Finset (Finset V)) : ℕ :=
  if h : Triangles ⊆ G.cliqueFinset 3 ∧ Triangles.Nonempty then
    ((G.edgeFinset.powerset.filter (is_covering_set G Triangles)).image Finset.card).min' (by
    refine' ⟨ _, Finset.mem_image.mpr ⟨ G.edgeFinset, _, rfl ⟩ ⟩ ; aesop;
    unfold is_covering_set; aesop;
    have := left a; unfold edges_of_triangle; aesop;
    rcases this with ⟨ h₁, h₂ ⟩ ; rcases Finset.card_eq_three.mp h₂ with ⟨ u, v, w, hu, hv, hw, h ⟩ ; use s(u, v) ; aesop;
    )
  else
    0

/-
The conflict graph C(G) is the graph where vertices are triangles of G, and edges connect triangles sharing an edge.
The Parker condition states that for every triangle in a packing M, its neighborhood in C(G) requires at least 3 edges to cover.
-/
def conflict_graph_G {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : SimpleGraph (Finset V) :=
  SimpleGraph.fromRel (λ s t => s ∈ G.cliqueFinset 3 ∧ t ∈ G.cliqueFinset 3 ∧ (s ∩ t).card = 2)

def neighbors_in_conflict_graph {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (conflict_graph_G G).neighborFinset t

def parker_condition {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  M ⊆ G.cliqueFinset 3 ∧
  ∀ t ∈ M, tau_set G (neighbors_in_conflict_graph G t) ≥ 3

/-
If the conflict graph is triangle-free, then the neighbors of any triangle T in the conflict graph form a packing (i.e., are pairwise edge-disjoint).
-/
lemma neighbors_are_packing_of_triangle_free_conflict_graph {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_tf : (conflict_graph_G G).CliqueFree 3) (T : Finset V) (hT : T ∈ G.cliqueFinset 3) :
  is_packing G (neighbors_in_conflict_graph G T) := by
    refine' ⟨ _, _ ⟩;
    · unfold neighbors_in_conflict_graph; aesop;
      intro t ht; unfold conflict_graph_G at ht; aesop;
    · intro t ht t' ht' hne; contrapose! hne; unfold is_edge_disjoint at *; aesop;
      unfold neighbors_in_conflict_graph at *;
      simp_all +decide [ SimpleGraph.mem_neighborFinset, conflict_graph_G ];
      unfold SimpleGraph.CliqueFree at h_tf; aesop;
      · specialize h_tf { T, t, t' } ; simp_all +decide [ SimpleGraph.isNClique_iff ];
        by_cases h : t = t' <;> simp_all +decide [ Finset.inter_comm ];
        have := Finset.card_le_card ( show t ∩ t' ⊆ t from Finset.inter_subset_left ) ; simp_all +decide ;
        interval_cases _ : Finset.card ( t ∩ t' ) ; simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ t' ⊆ t ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t ∩ t' ⊆ t' ) ; aesop;
      · specialize h_tf { T, t, t' } ; simp_all +decide [ SimpleGraph.isNClique_iff ];
        by_cases h : t = t' <;> simp_all +decide [ Finset.inter_comm ];
        have := Finset.card_le_card ( show t ∩ t' ⊆ t from Finset.inter_subset_left ) ; simp_all +decide ;
        interval_cases _ : Finset.card ( t ∩ t' ) ; simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ t' ⊆ t ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t ∩ t' ⊆ t' ) ; aesop;
      · specialize h_tf { T, t, t' } ; simp_all +decide [ SimpleGraph.isNClique_iff ];
        by_cases h : t = t' <;> simp_all +decide [ Finset.inter_comm ];
        have := Finset.card_le_card ( show t ∩ t' ⊆ t from Finset.inter_subset_left ) ; simp_all +decide ;
        interval_cases _ : Finset.card ( t ∩ t' ) ; simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ t' ⊆ t ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t ∩ t' ⊆ t' ) ; aesop;
      · specialize h_tf { T, t, t' } ; simp_all +decide [ SimpleGraph.isNClique_iff ];
        by_cases h : t = t' <;> simp_all +decide [ Finset.inter_comm ];
        have := Finset.card_le_card ( show t ∩ t' ⊆ t from Finset.inter_subset_left ) ; simp_all +decide ;
        interval_cases _ : Finset.card ( t ∩ t' ) ; simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t ∩ t' ⊆ t ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t ∩ t' ⊆ t' ) ; aesop;

/-
If the conflict graph is triangle-free, then every triangle has at most 3 neighbors in the conflict graph.
-/
lemma degree_le_three_of_triangle_free_conflict_graph {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_tf : (conflict_graph_G G).CliqueFree 3) (T : Finset V) (hT : T ∈ G.cliqueFinset 3) :
  (neighbors_in_conflict_graph G T).card ≤ 3 := by
    -- By definition of neighbors_in_conflict_graph, any two neighbors of T in the conflict graph must be edge-disjoint.
    have h_neighbor_edges_disjoint (t1 t2 : Finset V) (ht1 : t1 ∈ neighbors_in_conflict_graph G T) (ht2 : t2 ∈ neighbors_in_conflict_graph G T) (h_eq : t1 ≠ t2) : (t1 ∩ t2).card ≤ 1 := by
      have h_packing : is_packing G (neighbors_in_conflict_graph G T) := by
        exact?;
      have := h_packing.2 ht1 ht2 h_eq; aesop;
    -- Each triangle in the conflict graph can share at most one edge with T, so there can be at most three such triangles.
    have h_neighbor_edges_count : ∀ t ∈ neighbors_in_conflict_graph G T, (t ∩ T).card = 2 := by
      unfold neighbors_in_conflict_graph; aesop;
      unfold conflict_graph_G at a; aesop;
      rwa [ Finset.inter_comm ];
    -- Since each triangle in the conflict graph can share at most one edge with T, there can be at most three such triangles.
    have h_neighbor_edges_count : ∀ t ∈ neighbors_in_conflict_graph G T, (t ∩ T) ∈ Finset.powersetCard 2 T := by
      exact fun t ht => Finset.mem_powersetCard.mpr ⟨ Finset.inter_subset_right, h_neighbor_edges_count t ht ⟩;
    have h_neighbor_edges_count : Finset.card (Finset.image (fun t => t ∩ T) (neighbors_in_conflict_graph G T)) ≤ 3 := by
      have h_neighbor_edges_count : Finset.card (Finset.powersetCard 2 T) ≤ 3 := by
        simp_all +decide [ SimpleGraph.cliqueFinset ];
        rw [ hT.card_eq ] ; decide;
      exact le_trans ( Finset.card_le_card ( Finset.image_subset_iff.mpr ‹_› ) ) h_neighbor_edges_count;
    rwa [ Finset.card_image_of_injOn ] at h_neighbor_edges_count;
    intro t1 ht1 t2 ht2 h_eq;
    contrapose! h_neighbor_edges_disjoint;
    refine' ⟨ t1, t2, ht1, ht2, h_neighbor_edges_disjoint, _ ⟩;
    have h_eq_inter : t1 ∩ t2 ⊇ t1 ∩ T := by
      simp_all +decide [ Finset.ext_iff ];
      intro x hx; specialize h_eq x; aesop;
    exact lt_of_lt_of_le ( by aesop ) ( Finset.card_mono h_eq_inter )

/-
If the conflict graph is triangle-free and a triangle T has at most 2 neighbors, then T and its neighbors can be covered by at most 2 edges.
-/
lemma local_covering_of_triangle_free {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_tf : (conflict_graph_G G).CliqueFree 3) (T : Finset V) (hT : T ∈ G.cliqueFinset 3) :
  (neighbors_in_conflict_graph G T).card ≤ 2 →
  ∃ E : Finset (Sym2 V), E.card ≤ 2 ∧ E ⊆ G.edgeFinset ∧ ∀ T' ∈ insert T (neighbors_in_conflict_graph G T), (edges_of_triangle T' ∩ E).Nonempty := by
    aesop?;
    -- Let $N$ be the set of neighbors of $T$ in the conflict graph.
    set N := neighbors_in_conflict_graph G T with hN_def

    -- Since $N$ has at most 2 elements, we can consider two cases: $N$ has 0 or 1 element, or $N$ has 2 elements.
    by_cases hN_card : N.card ≤ 1;
    · have hN_empty : ∀ t ∈ N, ∃ e ∈ edges_of_triangle T, e ∈ edges_of_triangle t := by
        aesop;
        have hN_empty : (T ∩ t).card = 2 := by
          unfold neighbors_in_conflict_graph at a_1; aesop;
          unfold conflict_graph_G at a_1; aesop;
          rwa [ Finset.inter_comm ];
        obtain ⟨ u, v, huv ⟩ := Finset.card_eq_two.mp hN_empty;
        use Sym2.mk (u, v);
        unfold edges_of_triangle; aesop;
        · rw [ Finset.ext_iff ] at right; specialize right u; aesop;
        · rw [ Finset.ext_iff ] at right; specialize right v; aesop;
        · rw [ Finset.ext_iff ] at right; specialize right u; aesop;
        · rw [ Finset.ext_iff ] at right; specialize right v; aesop;
      obtain ⟨e, heT, heN⟩ : ∃ e ∈ edges_of_triangle T, ∀ t ∈ N, e ∈ edges_of_triangle t := by
        cases hN_card.eq_or_lt <;> aesop;
        · rw [ Finset.card_eq_one ] at h ; aesop;
        · obtain ⟨ v, w, x, hv, hw, hx, h ⟩ := Finset.card_eq_three.mp hT.2; use Sym2.mk ( v, w ) ; simp_all +decide [ edges_of_triangle ] ;
      refine' ⟨ { e }, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
      unfold edges_of_triangle at *; aesop;
      rcases e with ⟨ x, y ⟩ ; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
      exact hT.1 left.1 left.2 right;
    · -- Since $N$ has exactly 2 elements, let's denote them as $T_1$ and $T_2$.
      obtain ⟨T1, T2, hT1, hT2, hN⟩ : ∃ T1 T2 : Finset V, T1 ∈ N ∧ T2 ∈ N ∧ T1 ≠ T2 ∧ N = {T1, T2} := by
        have := Finset.card_eq_two.mp ( le_antisymm a ( not_le.mp hN_card ) ) ; aesop;
      -- Let $e1$ be an edge shared by $T$ and $T1$, and $e2$ be an edge shared by $T$ and $T2$.
      obtain ⟨e1, he1⟩ : ∃ e1 ∈ G.edgeFinset, e1 ∈ edges_of_triangle T ∧ e1 ∈ edges_of_triangle T1 := by
        have h_edges : (T ∩ T1).card = 2 := by
          unfold neighbors_in_conflict_graph at *; aesop;
          unfold conflict_graph_G at *; aesop;
          · rwa [ Finset.inter_comm ];
          · rwa [ Finset.inter_comm ];
        obtain ⟨x, y, hx, hy, hxy⟩ : ∃ x y : V, x ∈ T ∧ y ∈ T ∧ x ∈ T1 ∧ y ∈ T1 ∧ x ≠ y := by
          obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.1 ( by linarith ) ; use x, y; aesop;
        have h_edge : G.Adj x y := by
          exact hT.1 hx hy hxy.2.2;
        use Sym2.mk (x, y);
        unfold edges_of_triangle; aesop;
      obtain ⟨e2, he2⟩ : ∃ e2 ∈ G.edgeFinset, e2 ∈ edges_of_triangle T ∧ e2 ∈ edges_of_triangle T2 := by
        -- Since $T$ and $T2$ are neighbors in the conflict graph, they share exactly two vertices. Therefore, there exists an edge $e2$ that is shared by both $T$ and $T2$.
        have h_edge_exists : ∃ v1 v2 : V, v1 ∈ T ∧ v2 ∈ T ∧ v1 ∈ T2 ∧ v2 ∈ T2 ∧ v1 ≠ v2 := by
          have h_edge_exists : (T ∩ T2).card = 2 := by
            unfold neighbors_in_conflict_graph at *; aesop;
            unfold conflict_graph_G at *; aesop;
            · rwa [ Finset.inter_comm ];
            · rwa [ Finset.inter_comm ];
          obtain ⟨ v1, hv1, v2, hv2, hne ⟩ := Finset.one_lt_card.1 ( by linarith ) ; use v1, v2; aesop;
        obtain ⟨ v1, v2, hv1, hv2, hv1', hv2', hne ⟩ := h_edge_exists; use Sym2.mk ( v1, v2 ) ; simp_all +decide [ edges_of_triangle ] ;
        exact hT.1 hv1 hv2 hne |> fun h => by aesop;
      refine' ⟨ { e1, e2 }, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
      · exact Finset.card_insert_le _ _;
      · grind;
      · intro T' hT'; rw [ ← hN_def ] at *; aesop;
        exact ⟨ e2, by aesop ⟩

/-
If the conflict graph is triangle-free, then every edge of G is contained in at most 2 triangles.
-/
lemma edge_in_at_most_two_triangles {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_tf : (conflict_graph_G G).CliqueFree 3) (e : Sym2 V) (he : e ∈ G.edgeFinset) :
  ((G.cliqueFinset 3).filter (λ T => e ∈ edges_of_triangle T)).card ≤ 2 := by
    unfold edges_of_triangle; aesop;
    rcases e with ⟨ u, v ⟩ ; simp_all +decide [ SimpleGraph.cliqueFinset ];
    -- If there are three triangles sharing the edge $uv$, then these triangles would form a $K_3$ in the conflict graph $C(G)$, contradicting the assumption that $C(G)$ is triangle-free.
    have h_triangle_contradiction : ∀ {T1 T2 T3 : Finset V}, G.IsNClique 3 T1 → G.IsNClique 3 T2 → G.IsNClique 3 T3 → u ∈ T1 → v ∈ T1 → u ∈ T2 → v ∈ T2 → u ∈ T3 → v ∈ T3 → T1 ≠ T2 → T1 ≠ T3 → T2 ≠ T3 → False := by
      intros T1 T2 T3 hT1 hT2 hT3 hu1 hv1 hu2 hv2 hu3 hv3 hT12 hT13 hT23
      have h_triangle_contradiction : (conflict_graph_G G).IsNClique 3 {T1, T2, T3} := by
        have h_triangle_contradiction : (T1 ∩ T2).card = 2 ∧ (T1 ∩ T3).card = 2 ∧ (T2 ∩ T3).card = 2 := by
          have h_triangle_contradiction : ∀ {T1 T2 : Finset V}, G.IsNClique 3 T1 → G.IsNClique 3 T2 → u ∈ T1 → v ∈ T1 → u ∈ T2 → v ∈ T2 → T1 ≠ T2 → (T1 ∩ T2).card = 2 := by
            intros T1 T2 hT1 hT2 hu1 hv1 hu2 hv2 hT12
            have h_triangle_contradiction : (T1 ∩ T2).card ≤ 2 := by
              have h_triangle_contradiction : (T1 ∩ T2).card ≤ T1.card - 1 := by
                refine' Nat.le_sub_one_of_lt ( Finset.card_lt_card _ );
                simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
                exact Finset.not_subset.mp fun h => hT12 <| Finset.eq_of_subset_of_card_le h <| by simp +decide [ hT1.card_eq, hT2.card_eq ] ;
              have := hT1.2; aesop;
            exact le_antisymm h_triangle_contradiction ( Finset.one_lt_card.mpr ⟨ u, by aesop_cat, v, by aesop_cat ⟩ );
          exact ⟨ h_triangle_contradiction hT1 hT2 hu1 hv1 hu2 hv2 hT12, h_triangle_contradiction hT1 hT3 hu1 hv1 hu3 hv3 hT13, h_triangle_contradiction hT2 hT3 hu2 hv2 hu3 hv3 hT23 ⟩;
        simp_all +decide [ SimpleGraph.isNClique_iff ];
        unfold conflict_graph_G; aesop;
        · exact Or.inl ⟨ ⟨ left_1, right_1 ⟩, ⟨ left_2, right_2 ⟩ ⟩;
        · exact Or.inl ⟨ ⟨ left, by aesop ⟩, ⟨ left_1, by aesop ⟩ ⟩;
        · exact Or.inl ⟨ ⟨ left, right ⟩, ⟨ left_2, right_2 ⟩ ⟩;
      exact h_tf _ h_triangle_contradiction;
    contrapose! h_triangle_contradiction;
    obtain ⟨ T1, hT1, T2, hT2, T3, hT3, h ⟩ := Finset.two_lt_card.1 h_triangle_contradiction; use T1, T2, T3; aesop;

/-
A packing M is maximum if its size equals the packing number ν(G).
The private neighbors of a triangle T in a packing M are the neighbors of T in the conflict graph that are not neighbors of any other triangle in M.
-/
def is_maximum_packing {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  is_packing G M ∧ M.card = nu G

def private_neighbors {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (T : Finset V) : Finset (Finset V) :=
  (neighbors_in_conflict_graph G T).filter (λ S => ∀ T' ∈ M, T' ≠ T → S ∉ neighbors_in_conflict_graph G T')

/-
If M is a packing and T is in M, then any neighbor S of T in the conflict graph cannot be in M.
Proof: Neighbors in the conflict graph share 2 vertices (an edge), but elements of a packing share at most 1 vertex.
-/
lemma neighbor_in_conflict_graph_not_in_packing {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (M : Finset (Finset V)) (hM : is_packing G M) (T : Finset V) (hT : T ∈ M) (S : Finset V) (hS : S ∈ neighbors_in_conflict_graph G T) :
  S ∉ M := by
    -- By definition of conflict graph, a neighbor of T in the conflict graph shares 2 vertices with T.
    have h_neighbor_def : (S ∩ T).card = 2 := by
      unfold neighbors_in_conflict_graph at hS; aesop;
      unfold conflict_graph_G at hS; aesop;
      rwa [ Finset.inter_comm ];
    have := hM.2 hT;
    by_cases h : S = T <;> simp_all +decide [ is_edge_disjoint ];
    · unfold neighbors_in_conflict_graph at hS; aesop;
    · exact fun hS' => absurd ( this hS' ( Ne.symm h ) ) ( by rw [ Finset.inter_comm ] ; linarith )

/-
If two distinct triangles S and T' are not neighbors in the conflict graph, then they are edge-disjoint (share at most 1 vertex).
Proof: Neighbors in the conflict graph are defined as sharing exactly 2 vertices. Since S and T' are distinct triangles (size 3), they cannot share 3 vertices. If they don't share 2 vertices (not neighbors), they must share 0 or 1 vertex. Thus, they are edge-disjoint.
-/
lemma not_neighbor_implies_edge_disjoint {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (S T' : Finset V) (hS : S ∈ G.cliqueFinset 3) (hT' : T' ∈ G.cliqueFinset 3) (hne : S ≠ T') :
  S ∉ neighbors_in_conflict_graph G T' → is_edge_disjoint S T' := by
    unfold is_edge_disjoint; unfold neighbors_in_conflict_graph; aesop;
    unfold conflict_graph_G at a; aesop;
    have := Finset.card_le_card ( Finset.inter_subset_left : S ∩ T' ⊆ S ) ; ( have := Finset.card_le_card ( Finset.inter_subset_right : S ∩ T' ⊆ T' ) ; aesop );
    contrapose! a; have := hS.2; have := hT'.2; aesop;
    interval_cases _ : Finset.card ( S ∩ T' ) <;> simp_all +decide;
    have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : S ∩ T' ⊆ S ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : S ∩ T' ⊆ T' ) ; aesop;

/-
A private neighbor S of T in M is edge-disjoint from all triangles in M \ {T}.
Proof: By definition, S is not a neighbor of any T' in M \ {T} in the conflict graph.
Since S is a neighbor of T, S is a triangle. T' is a triangle in M.
If S were equal to T', then T' would be a neighbor of T (since S is). But M is a packing, so T and T' are edge-disjoint, so they can't be neighbors (neighbors share 2 vertices). Thus S ≠ T'.
By `not_neighbor_implies_edge_disjoint`, S and T' are edge-disjoint.
-/
lemma private_neighbor_is_edge_disjoint_from_rest {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (M : Finset (Finset V)) (hM : is_packing G M) (T : Finset V) (hT : T ∈ M)
  (S : Finset V) (hS : S ∈ private_neighbors G M T) :
  ∀ T' ∈ M.erase T, is_edge_disjoint S T' := by
    intro T' hT';
    -- By definition of private neighbors, $S$ is not a neighbor of any $T' \in M \setminus \{T\}$.
    have h_not_neighbor : ∀ T' ∈ M.erase T, S ∉ neighbors_in_conflict_graph G T' := by
      unfold private_neighbors at hS; aesop;
    have h_triangle_S : S ∈ G.cliqueFinset 3 := by
      unfold private_neighbors at hS; aesop;
      unfold neighbors_in_conflict_graph at hS; aesop;
      unfold conflict_graph_G at hS; aesop;
    have h_triangle_T' : T' ∈ G.cliqueFinset 3 := by
      exact hM.1 ( Finset.mem_of_mem_erase hT' )
    have h_distinct : S ≠ T' := by
      rintro rfl;
      simp_all +decide [ private_neighbors ];
      exact neighbor_in_conflict_graph_not_in_packing G M hM T hT S hS hT'.2;
    exact not_neighbor_implies_edge_disjoint G S T' h_triangle_S h_triangle_T' h_distinct ( h_not_neighbor T' hT' )

/-
In a maximum packing M, if the conflict graph is triangle-free, every triangle T in M has at most 1 private neighbor.
-/
lemma private_neighbors_le_one {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_tf : (conflict_graph_G G).CliqueFree 3) (M : Finset (Finset V)) (hM : is_maximum_packing G M) (T : Finset V) (hT : T ∈ M) :
  (private_neighbors G M T).card ≤ 1 := by
    have h_packing : is_packing G (M.erase T ∪ (private_neighbors G M T)) := by
      have h_packing : is_packing G (M.erase T) ∧ is_packing G (private_neighbors G M T) := by
        aesop;
        · exact ⟨ Finset.Subset.trans ( Finset.erase_subset _ _ ) hM.1.1, fun x hx y hy hxy => hM.1.2 ( Finset.mem_of_mem_erase hx ) ( Finset.mem_of_mem_erase hy ) hxy ⟩;
        · have h_max : is_packing G (private_neighbors G M T) := by
            have h_subset : private_neighbors G M T ⊆ neighbors_in_conflict_graph G T := by
              exact Finset.filter_subset _ _
            have h_packing : is_packing G (neighbors_in_conflict_graph G T) := by
              apply neighbors_are_packing_of_triangle_free_conflict_graph G h_tf T;
              exact hM.1.1 hT;
            exact ⟨ Finset.Subset.trans h_subset h_packing.1, h_packing.2.mono h_subset ⟩;
          exact h_max;
      refine' ⟨ _, _ ⟩;
      · exact Finset.union_subset ( h_packing.1.1 ) ( h_packing.2.1 );
      · intro x hx y hy hxy; aesop;
        · exact left.2 ( Finset.mem_erase_of_ne_of_mem right_1 left_1 ) ( Finset.mem_erase_of_ne_of_mem right_2 left_2 ) hxy;
        · unfold private_neighbors at h_2; aesop;
          exact not_neighbor_implies_edge_disjoint G x y ( by
            have := hM.1.1 left_1; aesop; ) ( by
            unfold neighbors_in_conflict_graph at left_2; aesop;
            unfold conflict_graph_G at left_2; aesop; ) ( by
            aesop ) ( by
            contrapose! right_2;
            use x;
            unfold neighbors_in_conflict_graph at *; aesop;
            exact right_2.symm );
        · exact not_neighbor_implies_edge_disjoint G x y ( by
            unfold private_neighbors at h_1; aesop;
            unfold neighbors_in_conflict_graph at left_2; aesop;
            unfold conflict_graph_G at left_2; aesop; ) ( by
            have := hM.1.1; aesop;
            exact Finset.mem_filter.mp ( this left_1 ) |>.2 ) ( by
            exact? ) ( by
            unfold private_neighbors at h_1; aesop; );
        · exact right.2 h_1 h_2 hxy;
    have h_card : (M.erase T ∪ private_neighbors G M T).card ≤ M.card := by
      have h_card : ∀ S : Finset (Finset V), is_packing G S → S.card ≤ M.card := by
        intro S hS; have := hM.2; aesop;
        exact Finset.le_max' _ _ ( Finset.mem_image_of_mem _ <| Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr <| hS.1, hS ⟩ );
      exact h_card _ h_packing;
    rw [ Finset.card_union_of_disjoint ] at h_card;
    · rw [ Finset.card_erase_of_mem hT ] at h_card ; omega;
    · exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => by have := neighbor_in_conflict_graph_not_in_packing G M hM.1 T hT x ( Finset.mem_filter.mp hx₂ |>.1 ) ; aesop;