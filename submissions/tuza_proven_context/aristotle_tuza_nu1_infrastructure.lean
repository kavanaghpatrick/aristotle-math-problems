/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0cbcf556-28ff-4fb4-9584-9d96250de901

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of triangle packing number and triangle covering number.
-/
variable {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]

/-- Two triangles (represented as sets of 3 vertices) are edge-disjoint if they share at most one vertex. -/
def are_edge_disjoint (t₁ t₂ : Finset V) : Prop :=
  (t₁ ∩ t₂).card ≤ 1

/-- A set of triangles is a triangle packing if they are pairwise edge-disjoint. -/
def IsTrianglePacking (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧ Set.Pairwise (S : Set (Finset V)) are_edge_disjoint

/-- The triangle packing number ν(G) is the maximum size of a triangle packing. -/
noncomputable def trianglePackingNumber : ℕ :=
  let packings := {S : Finset (Finset V) | IsTrianglePacking G S}
  if h : packings.Nonempty then
    packings.toFinset.sup Finset.card
  else 0

/-- A set of edges covers all triangles if every triangle contains at least one edge from the set. -/
def IsTriangleCovering (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

/-- The triangle covering number τ(G) is the minimum size of a triangle covering. -/
noncomputable def triangleCoveringNumber : ℕ :=
  let coverings := {E' : Finset (Sym2 V) | IsTriangleCovering G E'}
  if h : coverings.Nonempty then
    (coverings.toFinset.image Finset.card).min' (by
    -- Since coverings is nonempty, there exists some E' in coverings.
    obtain ⟨E', hE'⟩ : ∃ E' ∈ coverings, True := by
      -- Since coverings is nonempty, there exists some E' in coverings by definition of nonemptiness.
      obtain ⟨E', hE'⟩ := h;
      use E';
    exact ⟨ _, Finset.mem_image_of_mem _ ( Set.mem_toFinset.mpr hE'.1 ) ⟩)
  else 0

/-
There exists a triangle packing S such that the size of S is equal to the triangle packing number of G.
-/
lemma exists_max_packing {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
  ∃ S : Finset (Finset V), IsTrianglePacking G S ∧ S.card = trianglePackingNumber G := by
    -- By definition of `trianglePackingNumber`, there exists a triangle packing `S` such that `S.card` is maximal.
    have h_max : ∃ S : Finset (Finset V), S ∈ {S : Finset (Finset V) | IsTrianglePacking G S} ∧ ∀ T ∈ {S : Finset (Finset V) | IsTrianglePacking G S}, T.card ≤ S.card := by
      apply_rules [ Set.exists_max_image ];
      · exact Set.toFinite _;
      · refine' ⟨ ∅, _, _ ⟩ <;> simp +decide [ IsTrianglePacking ];
    unfold trianglePackingNumber; aesop;
    · refine' ⟨ w, left, le_antisymm _ _ ⟩;
      · exact Finset.le_sup ( f := Finset.card ) ( Finset.mem_filter.mpr ⟨ Finset.mem_univ _, left ⟩ );
      · exact Finset.sup_le fun S hS => right S <| Finset.mem_filter.mp hS |>.2;
    · exact ⟨ Finset.empty_subset _, by simp +decide [ Set.Pairwise ] ⟩

/-
The number of edges in a set of triangles is at most 3 times the number of triangles. We intersect with the graph's edge set to exclude diagonal elements.
-/
variable {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]

/-- The set of edges contained in a set of triangles. -/
def edgesOfPacking (S : Finset (Finset V)) : Finset (Sym2 V) :=
  (S.biUnion (fun t => t.sym2)) ∩ G.edgeFinset

lemma card_edgesOfPacking_le (S : Finset (Finset V)) (hS : S ⊆ G.cliqueFinset 3) :
  (edgesOfPacking G S).card ≤ 3 * S.card := by
    have h_num_edges : ∀ t ∈ S, (t.sym2 ∩ G.edgeFinset).card ≤ 3 := by
      aesop;
      have := hS a; aesop;
      have := Finset.card_eq_three.mp this.2; aesop;
      refine' le_trans ( Finset.card_le_card _ ) _;
      exact { Sym2.mk ( w, w_1 ), Sym2.mk ( w, w_2 ), Sym2.mk ( w_1, w_2 ) };
      · intro x hx; aesop;
        rcases x with ⟨ a, b ⟩ ; aesop;
      · exact Finset.card_insert_le _ _ |> le_trans <| add_le_add_right ( Finset.card_insert_le _ _ ) _;
    -- The union of the edges of the triangles in S is exactly the set of edges covered by the triangles in S.
    have h_union_edges : edgesOfPacking G S = Finset.biUnion S (fun t => t.sym2 ∩ G.edgeFinset) := by
      unfold edgesOfPacking; aesop;
    exact h_union_edges ▸ le_trans ( Finset.card_biUnion_le ) ( by simpa [ mul_comm ] using Finset.sum_le_sum h_num_edges )

/-
If a triangle packing is maximal (cannot be extended), then its edges form a triangle covering. This is because if there were a triangle not covered by the edges, it would be edge-disjoint from all triangles in the packing and could be added, contradicting maximality.
-/
variable {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]

/-- A triangle packing is maximal if no other triangle can be added to it. -/
def IsMaximalTrianglePacking (S : Finset (Finset V)) : Prop :=
  IsTrianglePacking G S ∧
  ∀ t ∈ G.cliqueFinset 3, t ∉ S → ¬IsTrianglePacking G (insert t S)

lemma edges_of_maximal_packing_cover (S : Finset (Finset V)) (hS : IsMaximalTrianglePacking G S) :
  IsTriangleCovering G (edgesOfPacking G S) := by
    -- By definition of maximal triangle packing, if there's a triangle t not covered by the edges in S, then t would be edge-disjoint from all triangles in S, contradicting the maximality of S.
    have h_cover : ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ (edgesOfPacking G S), e ∈ t.sym2 := by
      -- By definition of maximality, any triangle t not in S must share an edge with a triangle in S.
      have h_max : ∀ t ∈ G.cliqueFinset 3, t ∉ S → ∃ s ∈ S, ¬are_edge_disjoint t s := by
        unfold IsMaximalTrianglePacking at hS;
        simp_all +decide [ IsTrianglePacking ];
        intro t ht htS; specialize hS; have := hS.2 t ht htS; simp_all +decide [ Set.Pairwise ] ;
        contrapose! this;
        simp_all +decide [ Finset.insert_subset_iff, are_edge_disjoint ];
        exact fun x hx hx' => by simpa only [ Finset.inter_comm ] using this x hx;
      intro t ht;
      by_cases h : t ∈ S <;> simp_all +decide [ are_edge_disjoint ];
      · rcases Finset.card_eq_three.mp ht.card_eq with ⟨ u, v, w, hu, hv, hw, h ⟩ ; use s(u, v) ; aesop;
        simp_all +decide [ edgesOfPacking, SimpleGraph.isNClique_iff ];
        exact ⟨ _, h_1, by simp +decide, by simp +decide ⟩;
      · obtain ⟨ s, hs₁, hs₂ ⟩ := h_max t ht h;
        obtain ⟨ a, ha, b, hb, hab ⟩ := Finset.one_lt_card.mp hs₂;
        refine' ⟨ Sym2.mk ( a, b ), _, _ ⟩ <;> simp_all +decide [ Finset.mem_inter, SimpleGraph.isNClique_iff ];
        exact Finset.mem_inter.mpr ⟨ Finset.mem_biUnion.mpr ⟨ s, hs₁, by aesop ⟩, G.mem_edgeFinset.mpr <| by have := ht.1 ha.1 hb.1; aesop ⟩;
    exact ⟨ Finset.inter_subset_right, h_cover ⟩

/-
The triangle covering number is at most 3 times the triangle packing number. This follows from the fact that the edges of a maximum triangle packing form a covering of size at most 3 times the packing size.
-/
lemma trivial_bound {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
  triangleCoveringNumber G ≤ 3 * trianglePackingNumber G := by
    -- We'll use that there exists a maximal triangle packing S with |S| = trianglePackingNumber G.
    obtain ⟨S, hS_packing, hS_max⟩ : ∃ S : Finset (Finset V), IsTrianglePacking G S ∧ S.card = trianglePackingNumber G := by
      exact?;
    -- Since S is maximal, the edges of S form a triangle covering.
    have h_cover : IsTriangleCovering G (edgesOfPacking G S) := by
      apply edges_of_maximal_packing_cover;
      refine' ⟨ hS_packing, fun t ht htS ht_packing => _ ⟩;
      have h_card_insert : (insert t S).card ≤ trianglePackingNumber G := by
        have h_card_insert : ∀ S' : Finset (Finset V), IsTrianglePacking G S' → S'.card ≤ trianglePackingNumber G := by
          unfold trianglePackingNumber; aesop;
          · exact Finset.le_sup ( f := Finset.card ) ( Finset.mem_filter.mpr ⟨ Finset.mem_univ _, a ⟩ );
          · exact False.elim ( h ⟨ S', a ⟩ );
        exact h_card_insert _ ht_packing;
      rw [ Finset.card_insert_of_notMem htS ] at h_card_insert ; linarith;
    -- Since the edges of S form a triangle covering, we have that the triangle covering number is at most the number of edges in S.
    have h_covering_le : triangleCoveringNumber G ≤ (edgesOfPacking G S).card := by
      unfold triangleCoveringNumber; aesop;
      exact Finset.min'_le _ _ ( Finset.mem_image.mpr ⟨ _, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, h_cover ⟩, rfl ⟩ );
    exact h_covering_le.trans ( by simpa only [ hS_max ] using card_edgesOfPacking_le G S hS_packing.1 )

/-
If the triangle packing number is 1, then any two triangles must share an edge (share at least 2 vertices).
-/
lemma nu_1_implies_intersect {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (t₁ t₂ : Finset V) (ht₁ : t₁ ∈ G.cliqueFinset 3) (ht₂ : t₂ ∈ G.cliqueFinset 3) :
  2 ≤ (t₁ ∩ t₂).card := by
    -- By contradiction, assume that the intersection of t₁ and t₂ has fewer than 2 elements.
    by_contra h_contra;
    -- Since t₁ and t₂ are edge-disjoint and form a packing, this contradicts the assumption that the triangle packing number is 1.
    have h_contradiction : ∃ S : Finset (Finset V), IsTrianglePacking G S ∧ S.card = 2 := by
      refine' ⟨ { t₁, t₂ }, ⟨ _, _ ⟩, _ ⟩ <;> simp_all +decide [ IsTrianglePacking ];
      · simp_all +decide [ Finset.insert_subset_iff, SimpleGraph.isNClique_iff ];
      · intro x hx y hy hxy; aesop;
        · exact Nat.le_of_lt_succ h_contra;
        · exact le_of_not_gt fun h => h_contra.not_le <| by rw [ Finset.inter_comm ] ; exact h;
      · rw [ Finset.card_pair ] ; aesop;
        exact h_contra.not_le ( by rw [ SimpleGraph.isNClique_iff ] at ht₂; aesop );
    obtain ⟨ S, hS₁, hS₂ ⟩ := h_contradiction;
    have h_contradiction : S.card ≤ trianglePackingNumber G := by
      unfold trianglePackingNumber; aesop;
      · exact ⟨ S, hS₁, hS₂.ge ⟩;
      · exact h ⟨ S, hS₁ ⟩;
    linarith

/-
If the triangle packing number is 1, and a triangle t' avoids edges (u,v) and (v,w) of a triangle t={u,v,w}, then t' must contain the edge (u,w).
-/
lemma edge_forced_of_nu_1 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (t : Finset V) (ht : t ∈ G.cliqueFinset 3)
  (u v w : V) (h_t_eq : t = {u, v, w}) (h_distinct : u ≠ v ∧ v ≠ w ∧ u ≠ w)
  (t' : Finset V) (ht' : t' ∈ G.cliqueFinset 3)
  (h_not_uv : Sym2.mk (u, v) ∉ t'.sym2)
  (h_not_vw : Sym2.mk (v, w) ∉ t'.sym2) :
  Sym2.mk (u, w) ∈ t'.sym2 := by
    have := nu_1_implies_intersect G h_nu { u, v, w } t' ?_ ht' <;> simp_all +decide;
    grind

/-
If the triangle packing number is 1, and we have triangles sharing edges with a central triangle t, the outer vertices must be the same.
-/
lemma common_vertex_of_nu_1 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (u v w y z : V)
  (h_distinct : u ≠ v ∧ v ≠ w ∧ u ≠ w)
  (t : Finset V) (ht : t = {u, v, w}) (ht_in : t ∈ G.cliqueFinset 3)
  (t₁ : Finset V) (ht₁ : t₁ = {u, v, y}) (ht₁_in : t₁ ∈ G.cliqueFinset 3)
  (t₂ : Finset V) (ht₂ : t₂ = {v, w, z}) (ht₂_in : t₂ ∈ G.cliqueFinset 3)
  (h_ne₁ : t₁ ≠ t) (h_ne₂ : t₂ ≠ t) :
  y = z := by
    have := nu_1_implies_intersect G h_nu t₁ t₂ ht₁_in ht₂_in;
    grind

/-
If the triangle packing number is 1 and we have triangles t1, t2, t3 missing pairs of edges from a triangle t={u,v,w}, then there is a K4 clique.
-/
lemma K4_of_nu_1_witnesses {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (u v w : V) (h_distinct : u ≠ v ∧ v ≠ w ∧ u ≠ w)
  (t : Finset V) (ht : t = {u, v, w}) (ht_in : t ∈ G.cliqueFinset 3)
  (t₁ : Finset V) (ht₁_in : t₁ ∈ G.cliqueFinset 3) (ht₁_miss : Sym2.mk (v, w) ∉ t₁.sym2 ∧ Sym2.mk (u, w) ∉ t₁.sym2)
  (t₂ : Finset V) (ht₂_in : t₂ ∈ G.cliqueFinset 3) (ht₂_miss : Sym2.mk (u, v) ∉ t₂.sym2 ∧ Sym2.mk (u, w) ∉ t₂.sym2)
  (t₃ : Finset V) (ht₃_in : t₃ ∈ G.cliqueFinset 3) (ht₃_miss : Sym2.mk (u, v) ∉ t₃.sym2 ∧ Sym2.mk (v, w) ∉ t₃.sym2) :
  ∃ s, G.IsNClique 4 s := by
    -- By `edge_forced_of_nu_1`, $t_1$ must contain $(u,v)$. Let $t_1 = \{u,v,y\}$.
    obtain ⟨y, hy⟩ : ∃ y, t₁ = {u, v, y} := by
      -- Since $t₁$ is a triangle missing $(v,w)$ and $(u,w)$, it must contain the edge $(u,v)$.
      have ht₁_edges : s(u, v) ∈ t₁.sym2 := by
        have := edge_forced_of_nu_1 G h_nu t ht_in u v w ht h_distinct t₁ ht₁_in; aesop;
        · grind;
        · by_cases hu : u ∈ t₁ <;> aesop;
      have ht₁_card : t₁.card = 3 := by
        rw [ SimpleGraph.cliqueFinset ] at ht₁_in ; aesop;
        exact ht₁_in.card_eq;
      rw [ Finset.card_eq_three ] at ht₁_card;
      rcases ht₁_card with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; simp_all +decide [ Finset.ext_iff, Sym2.eq ] ;
      use if u = x then if v = y then z else y else if u = y then if v = x then z else x else if u = z then if v = x then y else x else if v = x then z else if v = y then x else y;
      grind;
    -- By `common_vertex_of_nu_1`, $y = z$.
    obtain ⟨z, hz⟩ : ∃ z, t₂ = {v, w, z} := by
      have := edge_forced_of_nu_1 G h_nu t ht_in u v w ht h_distinct t₂ ht₂_in ht₂_miss.1; aesop;
      have := Finset.card_eq_three.mp ht₂_in.2; obtain ⟨ a, b, c, h ⟩ := this; use if a = v then if b = w then c else b else if b = v then if a = w then c else a else if c = v then if a = w then b else a else v; aesop;
    have hyz : y = z := by
      apply common_vertex_of_nu_1 G h_nu u v w y z h_distinct t ht ht_in t₁ hy ht₁_in t₂ hz ht₂_in;
      · simp_all +decide [ Finset.ext_iff ];
        exact ⟨ w, by aesop ⟩;
      · simp_all +decide [ SimpleGraph.cliqueFinset ];
        simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
    use { u, v, w, y } ; simp_all +decide [ SimpleGraph.isNClique_iff ] ;

/-
If the triangle packing number is 1 and the triangle covering number is greater than 2, then the graph contains a K4 clique.
-/
lemma exists_K4_of_nu_1_tau_gt_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (h_tau : triangleCoveringNumber G > 2) :
  ∃ (s : Finset V), G.IsNClique 4 s := by
    unfold triangleCoveringNumber at h_tau; aesop;
    -- Since $\tau(G) > 2$, there exists a triangle $t=\{u,v,w\}$.
    obtain ⟨t, ht⟩ : ∃ t : Finset V, t ∈ G.cliqueFinset 3 := by
      contrapose! h_tau; aesop;
      refine' ⟨ ∅, _, _ ⟩ <;> simp_all +decide [ IsTriangleCovering ];
    -- Let's denote the edges of $t$ as $\{u,v\}$, $\{v,w\}$, and $\{u,w\}$.
    obtain ⟨u, v, w, h_distinct, h_t_eq⟩ : ∃ u v w : V, u ≠ v ∧ v ≠ w ∧ u ≠ w ∧ t = {u, v, w} := by
      rw [ SimpleGraph.mem_cliqueFinset_iff ] at ht;
      rcases Finset.card_eq_three.mp ht.2 with ⟨ u, v, w, h ⟩ ; use u, v, w ; aesop;
    -- Let's denote the edges of $t$ as $\{u,v\}$, $\{v,w\}$, and $\{u,w\}$. Since $\tau(G) > 2$, there exist triangles $t_1$, $t_2$, and $t_3$ that are disjoint from these edges.
    obtain ⟨t₁, ht₁⟩ : ∃ t₁ : Finset V, t₁ ∈ G.cliqueFinset 3 ∧ ¬(Sym2.mk (v, w) ∈ t₁.sym2) ∧ ¬(Sym2.mk (u, w) ∈ t₁.sym2) := by
      contrapose! h_tau;
      refine' ⟨ { s(v, w), s(u, w) }, _, _ ⟩ <;> simp_all +decide [ IsTriangleCovering ];
      · aesop;
        · simp_all +decide [ Set.subset_def, SimpleGraph.isNClique_iff ];
        · grind;
      · exact Finset.card_insert_le _ _
    obtain ⟨t₂, ht₂⟩ : ∃ t₂ : Finset V, t₂ ∈ G.cliqueFinset 3 ∧ ¬(Sym2.mk (u, v) ∈ t₂.sym2) ∧ ¬(Sym2.mk (u, w) ∈ t₂.sym2) := by
      contrapose! h_tau;
      refine' ⟨ { Sym2.mk ( u, v ), Sym2.mk ( u, w ) }, _, _ ⟩ <;> simp_all +decide [ IsTriangleCovering ];
      aesop;
      · simp_all +decide [ Set.subset_def, SimpleGraph.isNClique_iff ];
      · grind
    obtain ⟨t₃, ht₃⟩ : ∃ t₃ : Finset V, t₃ ∈ G.cliqueFinset 3 ∧ ¬(Sym2.mk (u, v) ∈ t₃.sym2) ∧ ¬(Sym2.mk (v, w) ∈ t₃.sym2) := by
      contrapose! h_tau;
      refine' ⟨ { Sym2.mk ( u, v ), Sym2.mk ( v, w ) }, _, _ ⟩ <;> simp_all +decide [ IsTriangleCovering ];
      bound;
      · simp_all +decide [ SimpleGraph.isNClique_iff, Set.subset_def ];
      · grind;
    apply K4_of_nu_1_witnesses G h_nu u v w ⟨ h_distinct, h_t_eq.1, h_t_eq.2.1 ⟩ t h_t_eq.2.2 ht t₁ ht₁.1 ⟨ ht₁.2.1, ht₁.2.2 ⟩ t₂ ht₂.1 ⟨ ht₂.2.1, ht₂.2.2 ⟩ t₃ ht₃.1 ⟨ ht₃.2.1, ht₃.2.2 ⟩

/-
If the triangle packing number is 1 and the graph contains a K4, then all triangles are contained in that K4.
-/
lemma all_triangles_in_K4_of_nu_1 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (h_nu : trianglePackingNumber G = 1)
  (s : Finset V) (hs : G.IsNClique 4 s) :
  ∀ t ∈ G.cliqueFinset 3, t ⊆ s := by
    -- Assume for contradiction that there exists a triangle $t$ in $G$ that is not contained in $s$.
    by_contra h_contra; push_neg at h_contra;
    -- Since $t$ is not contained in $s$, $t$ must have at least one vertex outside $s$.
    obtain ⟨t, ht_clique, ht_not_sub⟩ : ∃ t ∈ G.cliqueFinset 3, ¬t ⊆ s := h_contra
    obtain ⟨u, hu⟩ : ∃ u ∈ t, u ∉ s := by
      exact Finset.not_subset.mp ht_not_sub;
    -- Let $v$ and $w$ be the other two vertices of $t$.
    obtain ⟨v, w, hvw, hv, hw⟩ : ∃ v w, v ∈ t ∧ w ∈ t ∧ v ≠ w ∧ v ≠ u ∧ w ≠ u ∧ v ∈ s ∧ w ∈ s := by
      have h_common_vertex : ∀ t₁ ∈ G.cliqueFinset 3, ∀ t₂ ∈ G.cliqueFinset 3, t₁ ≠ t₂ → (t₁ ∩ t₂).card ≥ 2 := by
        exact?;
      -- Since $s$ is a $K_4$, it contains three triangles. Let $t₁$ be one of these triangles.
      obtain ⟨t₁, ht₁_clique, ht₁_sub⟩ : ∃ t₁ ∈ G.cliqueFinset 3, t₁ ⊆ s := by
        obtain ⟨ t₁, ht₁ ⟩ := Finset.exists_subset_card_eq ( show 3 ≤ s.card from by linarith [ hs.2 ] ) ; use t₁; aesop;
        exact ⟨ by simpa [ right_1 ] using hs.1.subset left_1, right_1 ⟩;
      -- Since $t$ and $t₁$ are distinct triangles, by $h_common_vertex$, their intersection must have at least two elements.
      have h_inter : (t ∩ t₁).card ≥ 2 := by
        exact h_common_vertex t ht_clique t₁ ht₁_clique ( by rintro rfl; exact ht_not_sub ht₁_sub );
      obtain ⟨ v, hv, w, hw, hvw ⟩ := Finset.one_lt_card.mp h_inter;
      exact ⟨ v, w, Finset.mem_of_mem_inter_left hv, Finset.mem_of_mem_inter_left hw, hvw, by rintro rfl; exact hu.2 ( ht₁_sub ( Finset.mem_of_mem_inter_right hv ) ), by rintro rfl; exact hu.2 ( ht₁_sub ( Finset.mem_of_mem_inter_right hw ) ), ht₁_sub ( Finset.mem_of_mem_inter_right hv ), ht₁_sub ( Finset.mem_of_mem_inter_right hw ) ⟩;
    -- The vertices of $s$ are $\{v, w, x, y\}$.
    obtain ⟨x, y, hx, hy, hxy⟩ : ∃ x y, x ∈ s ∧ y ∈ s ∧ x ≠ y ∧ x ≠ v ∧ x ≠ w ∧ y ≠ v ∧ y ≠ w ∧ x ≠ y := by
      have := hs.2;
      have h_card : (s \ {v, w}).card = 2 := by
        rw [ Finset.card_sdiff ] ; aesop_cat;
      obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.1 ( by linarith : 1 < Finset.card ( s \ { v, w } ) ) ; use x, y; aesop;
    have h_triangle : {v, w, u} ∈ G.cliqueFinset 3 ∧ {x, y, v} ∈ G.cliqueFinset 3 := by
      simp_all +decide [ SimpleGraph.isNClique_iff, Finset.card_insert_of_notMem ];
      have := ht_clique.1 hu.1 hv; have := ht_clique.1 hu.1 hvw; have := ht_clique.1 hv hvw; aesop;
    have := nu_1_implies_intersect G h_nu { v, w, u } { x, y, v } h_triangle.1 h_triangle.2; simp_all +decide ;
    simp_all +decide [ Finset.Nonempty ];
    aesop

/-
A K4 clique has a triangle covering of size at most 2. Specifically, two disjoint edges cover all 4 triangles.
-/
lemma K4_covering_number_le_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
  (s : Finset V) (hs : G.IsNClique 4 s) :
  ∃ E' : Finset (Sym2 V), E'.card ≤ 2 ∧ ∀ t ∈ G.cliqueFinset 3, t ⊆ s → ∃ e ∈ E', e ∈ t.sym2 := by
    rcases Finset.card_eq_succ.mp hs.2 with ⟨ a, ha ⟩ ; aesop;
    obtain ⟨ b, c, d, hbc, hbd, hcd ⟩ := Finset.card_eq_three.mp right; use { Sym2.mk ( a, b ), Sym2.mk ( c, d ) } ; aesop;
    have h := Finset.eq_of_subset_of_card_le a_2 ; simp_all +decide [ Finset.subset_iff ] ;
    rcases Finset.card_eq_three.mp a_1.2 with ⟨ x, y, z, hx, hy, hz, hxyz ⟩ ; aesop;