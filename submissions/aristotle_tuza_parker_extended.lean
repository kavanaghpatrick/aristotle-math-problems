/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3057dfda-995d-4125-96d4-c63a0c3b6d68

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isTriangleCover {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

noncomputable def triangleCoveringNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def S {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) (M : Finset (Finset V)) : Finset (Finset V) :=
  (trianglesSharingEdge G t).filter (fun x => ∀ m ∈ M, m ≠ t → (x ∩ m).card ≤ 1)

def isMaxPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

def shareEdge {V : Type*} [DecidableEq V] (t1 t2 : Finset V) : Prop :=
  (t1 ∩ t2).card ≥ 2

lemma lemma_2_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    ∀ t1 t2, t1 ∈ S G e M → t2 ∈ S G e M → shareEdge t1 t2 := by
      unfold shareEdge S at *; aesop;
      -- If t1 and t2 do not share an edge, then they are disjoint triangles in S_e.
      by_contra h_not_share;
      -- Consider $M' = (M \setminus \{e\}) \cup \{t1, t2\}$.
      set M' : Finset (Finset V) := (M \ {e}) ∪ {t1, t2};
      -- M' is a triangle packing.
      have hM'_packing : isTrianglePacking G M' := by
        constructor <;> simp_all +decide [ Finset.subset_iff ];
        · aesop;
          · unfold trianglesSharingEdge at left; aesop;
          · unfold trianglesSharingEdge at left_1; aesop;
          · exact hM.1.1 left_2 |> fun h => by simpa using h;
        · intro x hx y hy hxy; aesop;
          · linarith;
          · rw [ Finset.inter_comm ] ; linarith;
          · rw [ Finset.inter_comm ] ; aesop;
          · exact right_1 x left_2 right_2 |> le_trans ( Finset.card_mono <| by aesop_cat );
          · have := hM.1;
            exact this.2 left_2 left_3 hxy;
      -- The size of M' is |M| - 1 + 2 = |M| + 1.
      have hM'_size : M'.card = M.card + 1 := by
        rw [ Finset.card_union_of_disjoint ] <;> aesop;
        · rw [ Finset.card_sdiff ] ; aesop;
          rw [ Finset.card_insert_of_notMem, Finset.card_singleton ] ; aesop;
          · rw [ Nat.sub_add_cancel ( Finset.card_pos.mpr ⟨ e, he ⟩ ) ];
          · unfold trianglesSharingEdge at *; aesop;
            exact h_not_share.not_le ( by have := left_1.card_eq; aesop );
        · unfold trianglesSharingEdge at left; aesop;
          specialize right t1 a ; aesop;
          exact Classical.not_not.1 fun h => by have := left.card_eq; aesop;
        · unfold trianglesSharingEdge at *; aesop;
          have := right _ a; have := right_1 _ a; simp_all +decide [ Finset.inter_comm ] ;
          exact Classical.not_not.1 fun h => by have := this h; linarith [ left_1.card_eq ] ;
      unfold isMaxPacking at hM; aesop;
      have hM'_size_le : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ trianglePackingNumber G := by
        unfold trianglePackingNumber; aesop;
        have hM'_size_le : S ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset := by
          exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( a.1 ), a ⟩;
        have hM'_size_le : S.card ≤ Finset.max (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)) := by
          exact Finset.le_max ( Finset.mem_image_of_mem _ hM'_size_le );
        cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
        exact WithBot.coe_le_coe.mp hM'_size_le;
      linarith [ hM'_size_le _ hM'_packing ]

noncomputable def trianglePackingNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  triangles.powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

lemma lemma_2_3 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    trianglePackingNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) = trianglePackingNumber G - 1 := by
      simp +decide [ trianglePackingNumberOn ];
      -- Since $M$ is a maximum packing, we have $\nu(G) = |M|$.
      have h_max_packing : trianglePackingNumber G = M.card := by
        unfold isMaxPacking at hM; aesop;
      have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) → M'.card ≤ M.card - 1 := by
        intro M' hM' hM'_allowed
        have hM'_allowed_card : (M' ∪ {e}).card ≤ M.card := by
          have hM'_allowed_card : isTrianglePacking G (M' ∪ {e}) := by
            constructor;
            · simp_all +decide [ Finset.subset_iff ];
              have := hM.1.1 he; aesop;
            · simp_all +decide [ Set.Pairwise ];
              simp_all +decide [ Finset.subset_iff, isTrianglePacking ];
              simp_all +decide [ Finset.inter_comm, trianglesSharingEdge ];
              exact ⟨ fun x hx hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun x hx => ⟨ fun hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun y hy hy' => hM'.2 hx hy hy' ⟩ ⟩;
          have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ M.card := by
            intros M' hM'
            have h_max_packing_allowed : M'.card ≤ trianglePackingNumber G := by
              have h_max_packing_allowed : M' ∈ (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) := by
                exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hM'.1, hM' ⟩;
              unfold trianglePackingNumber;
              have h_max_packing_allowed : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
                exact Finset.mem_image_of_mem _ h_max_packing_allowed;
              have := Finset.le_max h_max_packing_allowed; aesop;
              cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
            exact h_max_packing ▸ h_max_packing_allowed;
          exact h_max_packing_allowed _ hM'_allowed_card;
        have hM'_allowed_card : e ∉ M' := by
          intro h; have := hM'_allowed h; simp_all +decide [ trianglesSharingEdge ] ;
          exact absurd ( this.2 this.1 ) ( by rw [ this.1.2 ] ; decide );
        rw [ Finset.card_union ] at * ; aesop;
        exact Nat.le_sub_one_of_lt hM'_allowed_card_1;
      have h_max_packing_allowed_eq : ∃ M' : Finset (Finset V), isTrianglePacking G M' ∧ M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) ∧ M'.card = M.card - 1 := by
        refine' ⟨ M.erase e, _, _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
        · have := hM.1; aesop;
          · exact fun x hx => this.1 ( Finset.mem_of_mem_erase hx );
          · exact fun x hx y hy hxy => this.2 ( by aesop ) ( by aesop ) hxy;
        · intro t ht; specialize hM; have := hM.1; aesop;
          · exact Finset.mem_filter.mp ( this.1 right ) |>.2;
          · have := this.2;
            exact absurd ( this right he left ) ( by unfold trianglesSharingEdge at a; aesop );
      rw [ show ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 \ trianglesSharingEdge G e |> Finset.powerset ) ) ).max = ↑ ( M.card - 1 ) from ?_ ];
      · aesop;
      · refine' le_antisymm _ _;
        · aesop;
          exact WithBot.coe_le_coe.mpr ( h_max_packing_allowed x a_2 a_1 );
        · exact Finset.le_max ( Finset.mem_image.mpr ⟨ h_max_packing_allowed_eq.choose, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr h_max_packing_allowed_eq.choose_spec.2.1, h_max_packing_allowed_eq.choose_spec.1 ⟩, h_max_packing_allowed_eq.choose_spec.2.2 ⟩ )

noncomputable def triangleCoveringNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

lemma inductive_bound {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumber G ≤ triangleCoveringNumberOn G (trianglesSharingEdge G e) + triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) := by
      by_contra h_contra;
      -- Let $C_e$ be a minimal cover for $T_e$.
      obtain ⟨C_e, hC_e⟩ : ∃ C_e : Finset (Sym2 V), C_e ⊆ G.edgeFinset ∧ (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) ∧ C_e.card = triangleCoveringNumberOn G (trianglesSharingEdge G e) := by
        have h_min_cover : ∃ C_e : Finset (Sym2 V), C_e ∈ Finset.powerset G.edgeFinset ∧ (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) ∧ ∀ C_e' ∈ Finset.powerset G.edgeFinset, (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e', e ∈ t.sym2) → C_e.card ≤ C_e'.card := by
          have h_min_cover : ∃ C_e ∈ Finset.powerset G.edgeFinset, (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) := by
            refine' ⟨ G.edgeFinset, Finset.mem_powerset.mpr ( Finset.Subset.refl _ ), fun t ht => _ ⟩;
            unfold trianglesSharingEdge at ht; aesop;
            rcases left with ⟨ h₁, h₂ ⟩;
            rcases Finset.card_eq_three.mp h₂ with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; use s(a, b) ; aesop;
          have h_min_cover : ∃ C_e ∈ Finset.filter (fun C_e => ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) (Finset.powerset G.edgeFinset), ∀ C_e' ∈ Finset.filter (fun C_e => ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ C_e, e ∈ t.sym2) (Finset.powerset G.edgeFinset), C_e.card ≤ C_e'.card := by
            exact Finset.exists_min_image _ _ ⟨ h_min_cover.choose, Finset.mem_filter.mpr ⟨ h_min_cover.choose_spec.1, h_min_cover.choose_spec.2 ⟩ ⟩;
          exact ⟨ h_min_cover.choose, Finset.mem_filter.mp h_min_cover.choose_spec.1 |>.1, Finset.mem_filter.mp h_min_cover.choose_spec.1 |>.2, fun C_e' hC_e' hC_e'' => h_min_cover.choose_spec.2 C_e' ( Finset.mem_filter.mpr ⟨ hC_e', hC_e'' ⟩ ) ⟩;
        unfold triangleCoveringNumberOn;
        obtain ⟨ C_e, hC_e₁, hC_e₂, hC_e₃ ⟩ := h_min_cover;
        rw [ Finset.min_eq_inf_withTop ];
        refine' ⟨ C_e, Finset.mem_powerset.mp hC_e₁, hC_e₂, _ ⟩;
        rw [ show ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2 } ) ).inf WithTop.some = WithTop.some C_e.card from ?_ ];
        · rfl;
        · refine' le_antisymm _ _;
          · exact Finset.inf_le ( Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ hC_e₁, hC_e₂ ⟩ ) );
          · simp +zetaDelta at *;
            exact hC_e₃;
      -- Let $C_{\text{rest}}$ be a minimal cover for the rest of the triangles.
      obtain ⟨C_rest, hC_rest⟩ : ∃ C_rest : Finset (Sym2 V), C_rest ⊆ G.edgeFinset ∧ (∀ t ∈ (G.cliqueFinset 3) \ trianglesSharingEdge G e, ∃ e ∈ C_rest, e ∈ t.sym2) ∧ C_rest.card = triangleCoveringNumberOn G ((G.cliqueFinset 3) \ trianglesSharingEdge G e) := by
        unfold triangleCoveringNumberOn;
        have h_min_exists : ∃ C_rest ∈ Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset)), C_rest = Option.getD (Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset))).min 0 := by
          have h_nonempty : Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ G.cliqueFinset 3 \ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset)) ≠ ∅ := by
            simp +decide [ Finset.ext_iff ];
            refine' ⟨ _, G.edgeFinset, _, _, rfl ⟩;
            · exact fun x hx => by simpa using hx;
            · intro t ht ht'; obtain ⟨ u, v, w, hu, hv, hw, h ⟩ := Finset.card_eq_three.mp ht.2; use s(u, v); simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          have h_min_exists : ∀ {S : Finset ℕ}, S ≠ ∅ → ∃ x ∈ S, x = Finset.min S := by
            intro S hS_nonempty
            obtain ⟨x, hx⟩ : ∃ x ∈ S, ∀ y ∈ S, x ≤ y := by
              exact ⟨ Finset.min' S ( Finset.nonempty_of_ne_empty hS_nonempty ), Finset.min'_mem _ _, fun y hy => Finset.min'_le _ _ hy ⟩;
            exact ⟨ x, hx.1, le_antisymm ( Finset.le_min fun y hy => WithTop.coe_le_coe.mpr ( hx.2 y hy ) ) ( Finset.min_le hx.1 ) ⟩;
          obtain ⟨ x, hx₁, hx₂ ⟩ := h_min_exists h_nonempty;
          exact ⟨ x, hx₁, by rw [ ← hx₂ ] ; rfl ⟩;
        obtain ⟨ C_rest, hC_rest₁, hC_rest₂ ⟩ := h_min_exists; rw [ Finset.mem_image ] at hC_rest₁; obtain ⟨ E', hE', rfl ⟩ := hC_rest₁; use E'; aesop;
      refine' h_contra _;
      -- Since $C_e \cup C_{\text{rest}}$ is a cover for $G$, we have $\tau(G) \leq |C_e \cup C_{\text{rest}}|$.
      have h_cover : isTriangleCover G (C_e ∪ C_rest) := by
        refine' ⟨ Finset.union_subset hC_e.1 hC_rest.1, _ ⟩;
        intro t ht; by_cases h : t ∈ trianglesSharingEdge G e <;> simp_all +decide ;
        · exact Exists.elim ( hC_e.2.1 t h ) fun e he => ⟨ e, Or.inl he.1, he.2 ⟩;
        · exact Exists.elim ( hC_rest.2.1 t ht h ) fun e he => ⟨ e, Or.inr he.1, he.2 ⟩;
      have h_tau_le : triangleCoveringNumber G ≤ (C_e ∪ C_rest).card := by
        unfold triangleCoveringNumber;
        unfold Option.getD; aesop;
        have := Finset.min_le ( Finset.mem_image_of_mem Finset.card ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.union_subset ( show C_e ⊆ G.edgeFinset from by simpa [ Finset.subset_iff, Set.subset_def ] using left ) ( show C_rest ⊆ G.edgeFinset from by simpa [ Finset.subset_iff, Set.subset_def ] using left_1 ) ), h_cover ⟩ ) ) ; aesop;
        exact WithTop.coe_le_coe.mp this;
      exact h_tau_le.trans ( Finset.card_union_le _ _ ) |> le_trans <| by rw [ hC_e.2.2, hC_rest.2.2 ] ;

lemma covering_number_le_two_of_subset_four {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (U : Finset V) (hU : U.card ≤ 4)
    (h_subset : ∀ t ∈ G.cliqueFinset 3, t ⊆ U) :
    triangleCoveringNumber G ≤ 2 := by
      -- Since $U$ has at most 4 vertices, any triangle in $G$ must be one of the triangles in $U$. The maximum number of triangles in a set of 4 vertices is 4, but since each triangle shares edges, we can cover all triangles with 2 edges.
      have h_cover : ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧ (∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ 2 := by
        -- Since $U$ has at most 4 vertices, the set of triangles in $U$ is finite and can be covered by at most 2 edges.
        have h_triangles : ∃ E' : Finset (Sym2 V), E' ⊆ Finset.image (fun e => Sym2.mk e) (Finset.offDiag U) ∧ (∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ 2 := by
          -- Since $U$ has at most 4 vertices, the set of triangles in $U$ is finite and can be covered by at most 2 edges. We can choose any two edges that cover all triangles.
          obtain ⟨E', hE'⟩ : ∃ E' : Finset (Sym2 V), E' ⊆ Finset.image (fun e => Sym2.mk e) (Finset.offDiag U) ∧ E'.card ≤ 2 ∧ ∀ t ∈ Finset.powersetCard 3 U, t.card = 3 → ∃ e ∈ E', e ∈ t.sym2 := by
            interval_cases _ : U.card <;> simp_all +decide;
            · exact ⟨ ∅, by simp +decide, by simp +decide, by intros; linarith [ Finset.card_le_card ‹_› ] ⟩;
            · exact ⟨ ∅, by simp +decide, by simp +decide, by intros; exact absurd ( Finset.card_le_card ‹_› ) ( by simp +decide [ * ] ) ⟩;
            · rw [ Finset.card_eq_three ] at *;
              obtain ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ := ‹∃ x y z : V, x ≠ y ∧ x ≠ z ∧ y ≠ z ∧ U = { x, y, z } ›; use { Sym2.mk ( x, y ), Sym2.mk ( x, z ) } ; simp_all +decide ;
              simp_all +decide [ Finset.subset_iff ];
              exact ⟨ ⟨ ⟨ x, y, by aesop ⟩, ⟨ x, z, by aesop ⟩ ⟩, fun t ht ht' => by rw [ Finset.card_eq_three ] at ht'; obtain ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ := ht'; aesop ⟩;
            · -- Since $U$ has 4 vertices, we can choose any two edges that cover all triangles.
              obtain ⟨a, b, c, d, ha, hb, hc, hd, habcd⟩ : ∃ a b c d : V, a ∈ U ∧ b ∈ U ∧ c ∈ U ∧ d ∈ U ∧ a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d ∧ U = {a, b, c, d} := by
                simp_rw +decide [ Finset.card_eq_succ ] at *;
                rcases ‹_› with ⟨ a, t, hat, rfl, b, u, hbu, rfl, c, v, hcv, rfl, d, w, hdw, rfl, hw ⟩ ; use a, b, c, d; aesop;
              refine' ⟨ { Sym2.mk ( a, b ), Sym2.mk ( c, d ) }, _, _, _ ⟩ <;> simp_all +decide;
              · simp +decide [ Finset.insert_subset_iff, habcd ];
                exact ⟨ ⟨ a, b, by aesop ⟩, ⟨ c, d, by aesop ⟩ ⟩;
              · intro t ht ht'; have := Finset.card_eq_three.mp ht'; obtain ⟨ x, y, z, hx, hy, hz, h ⟩ := this; simp_all +decide [ Finset.subset_iff ] ;
                grind;
          refine' ⟨ E', hE'.1, _, hE'.2.1 ⟩;
          intro t ht; specialize hE' ; specialize h_subset t ht; aesop;
          exact right t h_subset ht.card_eq;
        obtain ⟨ E', hE₁, hE₂, hE₃ ⟩ := h_triangles; use E' ∩ G.edgeFinset; aesop;
        · obtain ⟨ e, he₁, he₂ ⟩ := hE₂ t a; use e; aesop;
          have := hE₁ he₁; aesop;
          exact a.1 ( by aesop ) ( by aesop ) ( by aesop );
        · exact le_trans ( Finset.card_le_card fun x hx => by aesop ) hE₃;
      obtain ⟨ E', hE'₁, hE'₂, hE'₃ ⟩ := h_cover; refine' le_trans _ hE'₃; simp +decide [ triangleCoveringNumber ] ; aesop;
      have h_min : (Finset.image Finset.card (Finset.filter (isTriangleCover G) G.edgeFinset.powerset)).min ≤ E'.card := by
        refine' Finset.min_le _ ; aesop;
        refine' ⟨ E', ⟨ hE'₁, ⟨ _, _ ⟩ ⟩, rfl ⟩ <;> aesop;
      cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( isTriangleCover G ) G.edgeFinset.powerset ) ) <;> aesop

def isStar {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ e : Finset V, e.card = 2 ∧ ∀ t ∈ S, e ⊆ t

/-
If a set of triangles S forms a star (all share a common edge), then the triangle covering number of S is at most 1.
-/
lemma tau_star {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS : S ⊆ G.cliqueFinset 3) (h_star : isStar S) :
    triangleCoveringNumberOn G S ≤ 1 := by
      unfold triangleCoveringNumberOn;
      cases h_star ; aesop;
      cases' Finset.card_eq_two.mp left with x hx ; aesop;
      by_cases h : G.Adj x w_1;
      · have h_cover : {Sym2.mk (x, w_1)} ∈ G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t) := by
          aesop;
        have h_min : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ 1 := by
          exact Finset.min_le ( Finset.mem_image.mpr ⟨ _, h_cover, rfl ⟩ );
        cases h : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> aesop;
      · simp_all +decide [ Finset.subset_iff, SimpleGraph.mem_edgeSet ];
        contrapose! h;
        rcases S.eq_empty_or_nonempty with ( rfl | ⟨ t, ht ⟩ ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ];
        · unfold Option.getD at h; aesop;
          rw [ Finset.min_eq_inf_withTop ] at heq ; aesop;
          rw [ Finset.inf_eq_iInf ] at heq;
          have := heq ▸ iInf_le_of_le ∅ ( by aesop ) ; aesop;
          cases this;
          contradiction;
        · have := hS ht;
          exact this.1 ( right _ ht |>.1 ) ( right _ ht |>.2 ) ( by aesop )

/-
If three triangles pairwise share an edge but don't share a common edge, their union has size 4.
-/
lemma intersecting_triples_structure {V : Type*} [DecidableEq V]
    (t1 t2 t3 : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3)
    (h12 : (t1 ∩ t2).card ≥ 2) (h13 : (t1 ∩ t3).card ≥ 2) (h23 : (t2 ∩ t3).card ≥ 2)
    (h_not_star : ¬ ∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 ∧ e ⊆ t3) :
    (t1 ∪ t2 ∪ t3).card = 4 := by
      -- Since $t1$ and $t2$ share an edge, their union has size at most $3 + 3 - 2 = 4$.
      have h_union_t1_t2 : (t1 ∪ t2).card ≤ 4 := by
        have := Finset.card_union_add_card_inter t1 t2; linarith;
      by_cases h_cases : (t1 ∪ t2).card = 4;
      · have h_union_t1_t2_t3 : (t1 ∪ t2 ∪ t3).card ≤ 4 := by
          have h_union_t1_t2_t3_step : (t1 ∩ t3 ∪ t2 ∩ t3).card ≥ 3 := by
            have h_union_t1_t2_t3_step : (t1 ∩ t3 ∩ t2 ∩ t3).card ≤ 1 := by
              contrapose! h_not_star;
              obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq h_not_star;
              exact ⟨ e, he.2, Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ) ⟩;
            have := Finset.card_union_add_card_inter ( t1 ∩ t3 ) ( t2 ∩ t3 ) ; simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ] ;
            linarith;
          have h_union_t1_t2_t3_step : (t1 ∪ t2 ∪ t3).card ≤ (t1 ∪ t2).card + (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)).card := by
            have h_union_t1_t2_t3_step : (t1 ∪ t2 ∪ t3) ⊆ (t1 ∪ t2) ∪ (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)) := by
              grind;
            exact le_trans ( Finset.card_le_card h_union_t1_t2_t3_step ) ( Finset.card_union_le _ _ );
          have h_union_t1_t2_t3_step : (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)).card = t3.card - (t1 ∩ t3 ∪ t2 ∩ t3).card := by
            rw [ Finset.card_sdiff ];
            rw [ Finset.inter_eq_left.mpr ( Finset.union_subset ( Finset.inter_subset_right ) ( Finset.inter_subset_right ) ) ];
          omega;
        exact le_antisymm h_union_t1_t2_t3 ( by linarith [ Finset.card_mono ( Finset.subset_union_left : t1 ∪ t2 ⊆ t1 ∪ t2 ∪ t3 ) ] );
      · have h_union_t1_t2 : t1 = t2 := by
          have h_union_t1_t2 : (t1 ∪ t2).card = 3 := by
            have := Finset.card_union_add_card_inter t1 t2; interval_cases _ : Finset.card ( t1 ∪ t2 ) <;> simp_all +decide ;
            · linarith [ show Finset.card ( t1 ∩ t2 ) ≤ 3 by exact le_trans ( Finset.card_le_card fun x hx => Finset.mem_of_mem_inter_left hx ) h_card.1.le ];
            · linarith [ show ( t1 ∩ t2 ).card ≤ 3 by exact le_trans ( Finset.card_le_card ( Finset.inter_subset_left ) ) h_card.1.le ];
          have := Finset.card_union_add_card_inter t1 t2; aesop;
          have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; aesop;
          exact Eq.symm ( this_2 ( by linarith ) );
        contrapose! h_not_star; aesop;
        exact Exists.elim ( Finset.exists_subset_card_eq h23 ) fun e he => ⟨ e, he.2, Finset.subset_iff.2 fun x hx => Finset.mem_inter.1 ( he.1 hx ) |>.1, Finset.subset_iff.2 fun x hx => Finset.mem_inter.1 ( he.1 hx ) |>.2 ⟩

/-
If a triangle intersects three distinct triangles of a K4 in at least 2 vertices, it is contained in the K4.
-/
lemma triangle_in_k4_of_intersects_triples {V : Type*} [DecidableEq V]
    (t1 t2 t3 t : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 ∧ t.card = 3)
    (h_union : (t1 ∪ t2 ∪ t3).card = 4)
    (h_subset : t1 ⊆ t1 ∪ t2 ∪ t3 ∧ t2 ⊆ t1 ∪ t2 ∪ t3 ∧ t3 ⊆ t1 ∪ t2 ∪ t3)
    (h_distinct : t1 ≠ t2 ∧ t1 ≠ t3 ∧ t2 ≠ t3)
    (h_inter : (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2) :
    t ⊆ t1 ∪ t2 ∪ t3 := by
      aesop;
      intro x hx; by_contra h; simp_all +decide [ Finset.subset_iff ] ;
      -- Since $t$ contains $x$ and $x$ is not in $t1$, $t2$, or $t3$, it means $t \cap t1$, $t \cap t2$, and $t \cap t3$ must all be subsets of $\{y, z\}$ where $y$ and $z$ are the other two elements in $t$.
      have h_inter_subset : t ∩ t1 ⊆ t \ {x} ∧ t ∩ t2 ⊆ t \ {x} ∧ t ∩ t3 ⊆ t \ {x} := by
        grind;
      have h_inter_eq : (t ∩ t1) = t \ {x} ∧ (t ∩ t2) = t \ {x} ∧ (t ∩ t3) = t \ {x} := by
        exact ⟨ Finset.eq_of_subset_of_card_le h_inter_subset.1 ( by rw [ Finset.card_sdiff ] ; aesop ), Finset.eq_of_subset_of_card_le h_inter_subset.2.1 ( by rw [ Finset.card_sdiff ] ; aesop ), Finset.eq_of_subset_of_card_le h_inter_subset.2.2 ( by rw [ Finset.card_sdiff ] ; aesop ) ⟩;
      -- Since $t \cap t1 = t \cap t2 = t \cap t3 = t \setminus \{x\}$, it means $t1$, $t2$, and $t3$ all contain the same two elements as $t \setminus \{x\}$.
      have h_common_elements : t1 ⊇ t \ {x} ∧ t2 ⊇ t \ {x} ∧ t3 ⊇ t \ {x} := by
        simp_all +decide [ Finset.subset_iff ];
        simp_all +decide [ Finset.ext_iff ];
      -- Since $t1$, $t2$, and $t3$ all contain the same two elements as $t \setminus \{x\}$, they must be subsets of $t \setminus \{x\} \cup \{y\}$ for some $y$.
      obtain ⟨y, hy⟩ : ∃ y, t1 = t \ {x} ∪ {y} ∧ t2 = t \ {x} ∪ {y} ∨ t1 = t \ {x} ∪ {y} ∧ t3 = t \ {x} ∪ {y} ∨ t2 = t \ {x} ∪ {y} ∧ t3 = t \ {x} ∪ {y} := by
        have h_common_elements : ∀ {s : Finset V}, s.card = 3 → t \ {x} ⊆ s → ∃ y, s = t \ {x} ∪ {y} := by
          intros s hs hs_subset
          have h_card_diff : (s \ (t \ {x})).card = 1 := by
            grind;
          obtain ⟨ y, hy ⟩ := Finset.card_eq_one.mp h_card_diff;
          exact ⟨ y, by rw [ ← hy, Finset.union_sdiff_of_subset hs_subset ] ⟩;
        obtain ⟨ y1, hy1 ⟩ := h_common_elements left ( by tauto ) ; obtain ⟨ y2, hy2 ⟩ := h_common_elements left_4 ( by tauto ) ; obtain ⟨ y3, hy3 ⟩ := h_common_elements left_7 ( by tauto ) ; use if y1 = y2 then y1 else if y1 = y3 then y1 else y2; aesop;
        grind;
      grind

def isK4 {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ s : Finset V, s.card = 4 ∧ ∀ t ∈ S, t ⊆ s

/-
An intersecting family of triangles is either a star or contained in a K4.
-/
lemma intersecting_family_structure_corrected {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS_nonempty : S.Nonempty) (hS : S ⊆ G.cliqueFinset 3)
    (h_pair : Set.Pairwise (S : Set (Finset V)) shareEdge) :
    isStar S ∨ isK4 S := by
      by_cases h_star : ∃ e : Finset V, e.card = 2 ∧ ∀ t ∈ S, e ⊆ t;
      · exact Or.inl h_star;
      · -- If there are three triangles in S that do not share a common edge, then their union is a K4.
        by_cases h_three : ∃ t1 t2 t3 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ t3 ∈ S ∧ t1 ≠ t2 ∧ t1 ≠ t3 ∧ t2 ≠ t3 ∧ ¬∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 ∧ e ⊆ t3;
        · obtain ⟨ t1, t2, t3, ht1, ht2, ht3, hne ⟩ := h_three;
          have h_union : (t1 ∪ t2 ∪ t3).card = 4 := by
            apply_rules [ intersecting_triples_structure ];
            · have := hS ht1; have := hS ht2; have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
              exact ⟨ by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop ⟩;
            · tauto;
            · tauto;
            · tauto;
            · exact hne.2.2.2;
          refine' Or.inr ⟨ t1 ∪ t2 ∪ t3, h_union, _ ⟩;
          intros t ht
          have h_inter : (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2 := by
            have := h_pair ht ht1; have := h_pair ht ht2; have := h_pair ht ht3; simp_all +decide [ shareEdge ] ;
            by_cases h : t = t1 <;> by_cases h' : t = t2 <;> by_cases h'' : t = t3 <;> simp_all +decide;
            · exact le_trans ‹_› ( Finset.card_mono ( Finset.inter_subset_left ) );
            · exact le_trans this ( Finset.card_mono ( Finset.inter_subset_left ) );
            · have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
              exact this.card_eq.symm ▸ by decide;
          have h_card : t.card = 3 ∧ t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 := by
            have := hS ht; have := hS ht1; have := hS ht2; have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
            exact ⟨ by simpa using ‹G.IsNClique 3 t›.card_eq, by simpa using ‹G.IsNClique 3 t1›.card_eq, by simpa using ‹G.IsNClique 3 t2›.card_eq, by simpa using ‹G.IsNClique 3 t3›.card_eq ⟩;
          apply triangle_in_k4_of_intersects_triples;
          · tauto;
          · exact h_union;
          · simp +decide [ Finset.subset_iff ];
            tauto;
          · tauto;
          · exact h_inter;
        · by_cases h_two : ∃ t1 t2 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ t1 ≠ t2;
          · obtain ⟨ t1, t2, ht1, ht2, hne ⟩ := h_two;
            -- Since $t1$ and $t2$ share an edge, let $e$ be this common edge.
            obtain ⟨e, he⟩ : ∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 := by
              have := h_pair ht1 ht2 hne;
              obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq this;
              exact ⟨ e, he.2, Finset.Subset.trans he.1 ( Finset.inter_subset_left ), Finset.Subset.trans he.1 ( Finset.inter_subset_right ) ⟩;
            refine' Or.inl ⟨ e, he.1, fun t ht => _ ⟩;
            contrapose! h_three;
            use t1, t2, t;
            refine' ⟨ ht1, ht2, ht, hne, _, _, _ ⟩;
            · grind;
            · grind;
            · intro x hx hx1 hx2 hx3;
              have h_eq : x ⊆ t1 ∩ t2 := by
                exact Finset.subset_inter hx1 hx2;
              have h_eq : x = t1 ∩ t2 := by
                have h_eq : (t1 ∩ t2).card = 2 := by
                  have := hS ht1; have := hS ht2; simp_all +decide [ SimpleGraph.mem_cliqueFinset_iff ] ;
                  have := Finset.card_le_card h_eq; simp_all +decide ;
                  have := Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; ( have := Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; ( simp_all +decide [ SimpleGraph.isNClique_iff ] ; ) );
                  interval_cases _ : ( t1 ∩ t2 ).card <;> simp_all +decide;
                  have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; aesop;
                exact Finset.eq_of_subset_of_card_le ‹_› ( by simp +decide [ * ] );
              have := Finset.eq_of_subset_of_card_le ( show e ⊆ t1 ∩ t2 from Finset.subset_inter he.2.1 he.2.2 ) ; aesop;
          · rcases Finset.card_le_one.2 ( fun t1 ht1 t2 ht2 => Classical.not_not.1 fun h => h_two ⟨ t1, t2, ht1, ht2, h ⟩ ) with h;
            cases h.eq_or_lt <;> simp_all +decide;
            rw [ Finset.card_eq_one ] at * ; aesop;
            rw [ SimpleGraph.isNClique_iff ] at hS ; aesop;
            exact False.elim ( h_star ( w.erase ( Classical.choose ( Finset.card_pos.mp ( by linarith ) ) ) ) ( by rw [ Finset.card_erase_of_mem ( Classical.choose_spec ( Finset.card_pos.mp ( by linarith ) ) ), right ] ) ( by intro x hx; exact Finset.mem_of_mem_erase hx ) )

/-
If a set of triangles is contained in 4 vertices, its covering number is at most 2.
-/
lemma covering_number_on_le_two_of_subset_four {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS : S ⊆ G.cliqueFinset 3) (U : Finset V) (hU : U.card ≤ 4) (h_subset : ∀ t ∈ S, t ⊆ U) :
    triangleCoveringNumberOn G S ≤ 2 := by
      -- By definition of `triangleCoveringNumberOn`, we need to show that there exists an edge cover of $S$ with at most 2 edges.
      have h_exists_cover : ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧ (∀ t ∈ S, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ 2 := by
        -- Let $G'$ be the subgraph of $G$ induced by the edges of triangles in $S$.
        set G' : SimpleGraph V := SimpleGraph.fromRel (fun v w => ∃ t ∈ S, {v, w} ⊆ t);
        -- Since all triangles in $S$ are contained in $U$, we can apply `covering_number_le_two_of_subset_four` to $G'$ and $U$.
        have h_covering_number_G' : ∃ E' : Finset (Sym2 V), E' ⊆ G'.edgeFinset ∧ (∀ t ∈ G'.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ 2 := by
          have h_covering_number_G' : ∀ t ∈ G'.cliqueFinset 3, t ⊆ U := by
            simp_all +decide [ SimpleGraph.cliqueFinset ];
            intro t ht;
            have := ht.1; aesop;
            intro v hv;
            obtain ⟨ w, hw, hw' ⟩ := Finset.exists_mem_ne ( show 1 < Finset.card t from by linarith [ ht.2 ] ) v;
            have := this hv hw; aesop;
            rcases this ( Ne.symm hw' ) with ( ⟨ t, ht, ht' ⟩ | ⟨ t, ht, ht' ⟩ ) <;> have := h_subset t ht <;> simp_all +decide [ Finset.subset_iff ];
          have h_covering_number_G' : triangleCoveringNumber G' ≤ 2 := by
            exact?;
          unfold triangleCoveringNumber at h_covering_number_G';
          by_cases h : Finset.Nonempty ( Finset.filter ( isTriangleCover G' ) G'.edgeFinset.powerset ) <;> simp_all +decide [ Finset.min ];
          · have := Finset.exists_min_image _ ( fun x => Finset.card x ) h;
            obtain ⟨ E', hE', hE'' ⟩ := this;
            use E';
            aesop;
            · have := right.2 t; aesop;
            · contrapose! h_covering_number_G';
              rw [ Finset.inf_eq_iInf ];
              rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ];
              rotate_left;
              exact ↑E'.card;
              · intro i; rw [ ciInf_eq_ite ] ; aesop;
              · intro w hw;
                use E';
                rw [ ciInf_eq_ite ] ; aesop;
              · exact h_covering_number_G';
          · contrapose! h;
            refine' ⟨ G'.edgeFinset, _, _ ⟩ <;> simp +decide [ isTriangleCover ];
            intro t ht; have := ht.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            rcases Finset.card_eq_three.mp this with ⟨ a, b, c, hab, hbc, hac ⟩ ; use Sym2.mk ( a, b ) ; aesop;
        obtain ⟨ E', hE'₁, hE'₂, hE'₃ ⟩ := h_covering_number_G'; use E'; aesop;
        · intro e he; specialize hE'₁ he; aesop;
          rcases e with ⟨ v, w ⟩ ; simp_all +decide [ SimpleGraph.fromRel ] ;
          rcases hE'₁.2 with ( ⟨ t, ht, h ⟩ | ⟨ t, ht, h ⟩ ) <;> have := hS ht <;> simp_all +decide [ Finset.subset_iff ];
          · have := hS ht; rw [ SimpleGraph.isNClique_iff ] at this; aesop;
          · have := hS ht; rw [ SimpleGraph.isNClique_iff ] at this; aesop;
        · apply hE'₂ t;
          have := hS a; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          intro v hv w hw; aesop;
          exact Or.inl ⟨ t, a, by aesop_cat ⟩;
      unfold triangleCoveringNumberOn; aesop;
      unfold Option.getD; aesop;
      have := Finset.min_le ( Finset.mem_image_of_mem Finset.card ( show w ∈ Finset.filter ( fun E' => ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t ) ( Finset.powerset G.edgeFinset ) from Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( by aesop_cat ), left_1 ⟩ ) ) ; aesop;
      exact Nat.cast_le.mp ( le_trans this ( WithTop.coe_le_coe.mpr right ) )

/-
The covering number of the set of triangles S_e is at most 2.
-/
lemma tau_S_le_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumberOn G (S G e M) ≤ 2 := by
      -- S_e is either a star or contained in a K4.
      have h_star_or_K4 : isStar (S G e M) ∨ isK4 (S G e M) := by
        apply intersecting_family_structure_corrected G (S G e M);
        · refine' ⟨ e, _ ⟩;
          unfold S; aesop;
          · unfold trianglesSharingEdge; aesop;
            · have := hM.1;
              have := this.1 he; aesop;
            · have := hM.1;
              have := this.1 he; aesop;
              exact this.card_eq.symm ▸ by decide;
          · have := hM.1; unfold isTrianglePacking at this; aesop;
        · exact fun x hx => Finset.mem_filter.mp ( Finset.mem_filter.mp hx |>.1 ) |>.1;
        · intro t1 ht1 t2 ht2 hne; exact lemma_2_2 G M hM e he t1 t2 ht1 ht2;
      rcases h_star_or_K4 with h|h;
      · refine' le_trans ( tau_star _ _ _ h ) _;
        · exact fun x hx => Finset.mem_filter.mp ( Finset.mem_filter.mp hx |>.1 ) |>.1;
        · norm_num;
      · obtain ⟨ s, hs ⟩ := h;
        convert covering_number_on_le_two_of_subset_four G ( S G e M ) _ s _ _ <;> aesop;
        exact fun t ht => Finset.mem_filter.mp ( Finset.mem_filter.mp ht |>.1 ) |>.1

lemma tuza_case_nu_0 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (h : trianglePackingNumber G = 0) : triangleCoveringNumber G = 0 := by
      -- If the triangle packing number is zero, then there are no triangles in the graph. Therefore, the triangle covering number must also be zero because there are no triangles to cover.
      have h_no_triangles : ∀ t ∈ G.cliqueFinset 3, False := by
        unfold trianglePackingNumber at h;
        unfold Option.getD at h; aesop;
        · contrapose! heq;
          refine' ne_of_gt ( lt_of_lt_of_le _ ( Finset.le_max <| Finset.mem_image.mpr ⟨ { t }, _, rfl ⟩ ) ) <;> simp +decide [ * ];
          unfold isTrianglePacking; aesop;
        · rw [ Finset.max_eq_sup_coe ] at heq;
          rw [ WithBot.none_eq_bot ] at heq;
          simp_all +decide [ Finset.sup_eq_bot_iff ];
          exact heq ∅ ( Finset.empty_subset _ ) ( by unfold isTrianglePacking; simp +decide );
      unfold triangleCoveringNumber;
      unfold isTriangleCover; aesop;
      rw [ Finset.min_eq_inf_withTop ] ; aesop;
      rw [ Finset.inf_eq_iInf ];
      rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ];
      rotate_left;
      exact 0;
      · exact fun _ => zero_le _;
      · exact fun w hw => ⟨ ∅, by aesop ⟩;
      · rfl