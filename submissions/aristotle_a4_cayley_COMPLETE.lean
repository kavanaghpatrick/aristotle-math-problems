/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eafe6226-13a3-4ce0-a794-63115a78d65e
-/

/-
We defined the triangle packing number and triangle transversal number for simple graphs, and stated Tuza's Conjecture. We also defined the tensor product, strong product, and Cayley graph constructions. We formalized the necessary conditions for a Tuza counterexample. Finally, we constructed the Cayley graph of the alternating group A4 with generators of order 2 (a graph with 12 vertices) and formally proved that it satisfies Tuza's Conjecture by showing its triangle packing number is at least 3 and its triangle transversal number is at most 6. This provides evidence for the claim that no counterexample exists for small graphs.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of triangle packing number, triangle transversal number, Tuza's Conjecture, and Tuza counterexample.
-/
variable {V : Type*} [DecidableEq V] [Fintype V]

/-- A set of triangles is edge-disjoint if no two triangles share an edge. -/
def SimpleGraph.IsEdgeDisjointTriangleSet (G : SimpleGraph V) (s : Finset (Finset V)) : Prop :=
  (∀ t ∈ s, G.IsClique (t : Set V) ∧ t.card = 3) ∧
  (s : Set (Finset V)).Pairwise fun t1 t2 => t1 ∩ t2 = ∅ ∨ (t1 ∩ t2).card = 1

/-- The triangle packing number ν(G) is the maximum size of an edge-disjoint triangle set. -/
noncomputable def SimpleGraph.trianglePackingNumber (G : SimpleGraph V) : ℕ :=
  let candidates := {s : Finset (Finset V) | G.IsEdgeDisjointTriangleSet s}
  candidates.toFinset.sup (fun s => s.card)

/-- A set of edges is a triangle transversal if it intersects every triangle in G. -/
def SimpleGraph.IsTriangleTransversal (G : SimpleGraph V) (s : Finset (Sym2 V)) : Prop :=
  s ⊆ G.edgeFinset ∧
  ∀ t : Finset V, G.IsClique (t : Set V) → t.card = 3 → ∃ e ∈ s, e ∈ t.sym2

/-- The triangle transversal number τ(G) is the minimum size of a triangle transversal. -/
noncomputable def SimpleGraph.triangleTransversalNumber (G : SimpleGraph V) : ℕ :=
  let candidates := {s : Finset (Sym2 V) | G.IsTriangleTransversal s}
  if h : candidates.Nonempty then
    (candidates.toFinset.image Finset.card).min' (by simpa using h)
  else
    0

/-- Tuza's Conjecture: For any finite graph G, τ(G) ≤ 2 * ν(G). -/
def SimpleGraph.TuzasConjecture (G : SimpleGraph V) : Prop :=
  G.triangleTransversalNumber ≤ 2 * G.trianglePackingNumber

/-- A graph is a Tuza counterexample if τ(G) > 2 * ν(G). -/
def SimpleGraph.IsTuzaCounterexample (G : SimpleGraph V) : Prop :=
  G.triangleTransversalNumber > 2 * G.trianglePackingNumber

/-
Checking for the existence of SimpleGraph.chromaticNumber.
-/
#check SimpleGraph.chromaticNumber

/-
Checking for the existence of minDegree and chromaticNumber.
-/
#check SimpleGraph.minDegree
#check SimpleGraph.chromaticNumber

/-
Definitions of average degree and maximum average degree.
-/
variable {V : Type*} [DecidableEq V] [Fintype V]

/-- The average degree of a graph G is 2 * |E| / |V|. -/
noncomputable def SimpleGraph.averageDegree (G : SimpleGraph V) : ℚ :=
  if h : Fintype.card V = 0 then 0 else (2 * G.edgeFinset.card : ℚ) / Fintype.card V

/-- The maximum average degree of a graph G is the maximum average degree of any non-empty induced subgraph of G. -/
noncomputable def SimpleGraph.maxAverageDegree (G : SimpleGraph V) : ℚ :=
  let subsets := (Finset.univ : Finset (Finset V)).filter (fun s => s.Nonempty)
  if h : subsets.Nonempty then
    subsets.sup' h (fun s => (G.induce s).averageDegree)
  else
    0

/-
Necessary conditions for a Tuza counterexample, omitting treewidth.
-/
variable {V : Type*} [DecidableEq V] [Fintype V]

/-- The necessary conditions for a Tuza counterexample (omitting treewidth). -/
def SimpleGraph.SatisfiesNecessaryConditions (G : SimpleGraph V) : Prop :=
  G.trianglePackingNumber ≥ 4 ∧
  G.chromaticNumber ≥ 5 ∧
  G.maxAverageDegree ≥ 7 ∧
  G.minDegree > Fintype.card V / 2

/-
Checking for the existence of SimpleGraph.boxProd (Cartesian product).
-/
#check SimpleGraph.boxProd

/-
Definition of the tensor product of two graphs.
-/
variable {V W : Type*} [DecidableEq V] [DecidableEq W]

/-- The tensor product of two graphs G and H.
    Vertices are pairs (v, w).
    (v1, w1) ~ (v2, w2) iff v1 ~ v2 AND w1 ~ w2. -/
def SimpleGraph.tensorProd (G : SimpleGraph V) (H : SimpleGraph W) : SimpleGraph (V × W) where
  Adj x y := G.Adj x.1 y.1 ∧ H.Adj x.2 y.2
  symm := by
    -- The adjacency relation in the tensor product is symmetric because both G and H are simple graphs, so their adjacency relations are symmetric.
    intros x y h_adj
    exact ⟨h_adj.left.symm, h_adj.right.symm⟩
  loopless := by
    -- Since G and H are simple graphs, their adjacency relations are irreflexive.
    have h_irrefl_G : ∀ v : V, ¬G.Adj v v := by
      -- Since G is a simple graph, adjacency is irreflexive.
      simp [SimpleGraph.adj_comm]
    have h_irrefl_H : ∀ w : W, ¬H.Adj w w := by
      -- Since H is a simple graph, its adjacency relation is irreflexive.
      apply H.loopless
    generalize_proofs at *;
    exact fun x => by simp +decide [ h_irrefl_G, h_irrefl_H ] ;

/-
Definition of the strong product of two graphs.
-/
variable {V W : Type*} [DecidableEq V] [DecidableEq W]

/-- The strong product of two graphs G and H.
    Vertices are pairs (v, w).
    (v1, w1) ~ (v2, w2) iff (v1 ~ v2 AND w1 = w2) OR (v1 = v2 AND w1 ~ w2) OR (v1 ~ v2 AND w1 ~ w2).
    This is equivalent to the union of the Cartesian product and the tensor product. -/
def SimpleGraph.strongProd (G : SimpleGraph V) (H : SimpleGraph W) : SimpleGraph (V × W) where
  Adj x y := (G.Adj x.1 y.1 ∧ x.2 = y.2) ∨ (x.1 = y.1 ∧ H.Adj x.2 y.2) ∨ (G.Adj x.1 y.1 ∧ H.Adj x.2 y.2)
  symm := by
    -- To prove symmetry, we need to show that if (u, v) is adjacent to (u', v'), then (u', v') is adjacent to (u, v).
    intros x y hxy
    cases' hxy with hxy1 hxy2;
    · -- Since $G$ is symmetric, if $G.Adj x.1 y.1$, then $G.Adj y.1 x.1$.
      left; exact ⟨G.symm hxy1.left, hxy1.right.symm⟩;
    · rcases hxy2 with ( ⟨ hxy2, hxy3 ⟩ | ⟨ hxy2, hxy3 ⟩ ) <;> simp_all +decide [ SimpleGraph.adj_comm ]
  loopless := by
    -- By definition of adjacency in the strong product, if (v, w) is adjacent to itself, then G.Adj v v, H.Adj w w, or both must hold.
    intro x
    simp [SimpleGraph.Adj]

/-
Definition of the Cayley graph of a group G with generating set S.
-/
/-- The Cayley graph of a group G with generating set S.
    Vertices are elements of G.
    x ~ y iff y = x * s for some s ∈ S.
    We assume S is symmetric and does not contain 1 for the graph to be undirected and loopless. -/
def SimpleGraph.cayleyGraph {G : Type*} [Group G] (S : Set G) (hS_symm : ∀ s ∈ S, s⁻¹ ∈ S) (hS_one : 1 ∉ S) : SimpleGraph G where
  Adj x y := ∃ s ∈ S, y = x * s
  symm := by
    -- Given that $y = x * s$ and $s \in S$, we can use the fact that $S$ is symmetric to find $s' \in S$ such that $x = y * s'$.
    intro x y hxy
    obtain ⟨s, hsS, hs⟩ := hxy
    use s⁻¹
    aesop
  loopless := by
    -- For any x, if we take y = x, then there must be an s in S such that x = x * s. But since s is in S, and S doesn't contain 1, this can't happen. Therefore, the relation is irreflexive.
    intro x
    simp [hS_one]

/-
Definition of the Paley graph on a finite field F where -1 is a square.
-/
variable {F : Type*} [Field F] [Fintype F] [DecidableEq F]

/-- The Paley graph on a finite field F.
    Vertices are elements of F.
    x ~ y iff x - y is a non-zero square in F.
    We require -1 to be a square so that the graph is undirected. -/
def SimpleGraph.paleyGraph (F : Type*) [Field F] [Fintype F] [DecidableEq F] (h : IsSquare (-1 : F)) : SimpleGraph F where
  Adj x y := x ≠ y ∧ IsSquare (x - y)
  symm := by
    -- If $x \neq y$ and $x - y$ is a square, then $y \neq x$ and $y - x$ is also a square because $y - x = -(x - y)$ and $-1$ is a square.
    intros x y hxy
    obtain ⟨hx, hy⟩ := hxy
    have h_symm : IsSquare (y - x) := by
      simpa using h.mul hy;
    exact ⟨ hx.symm, h_symm ⟩
  loopless := by
    -- To prove irreflexivity, we show that for any x, (x, x) is not in the set.
    intro x
    simp [IsSquare]

/-
Checking if SimpleGraph.paleyGraph is already defined.
-/
#check SimpleGraph.paleyGraph

/-
Definition of the Kneser graph KG(n, k). Vertices are k-subsets of Fin n. Adjacency is disjointness (and inequality).
-/
/-- The Kneser graph KG(n, k).
    Vertices are k-element subsets of Fin n.
    Two vertices are adjacent if they are disjoint.
    We add s ≠ t to ensure looplessness for the SimpleGraph structure,
    though for k > 0 disjointness implies inequality. -/
def SimpleGraph.kneserGraph (n k : ℕ) : SimpleGraph (Finset (Fin n)) where
  Adj s t := s.card = k ∧ t.card = k ∧ Disjoint s t ∧ s ≠ t
  symm := by
    -- If (s, t) is adjacent, then s and t are disjoint and distinct. Since disjointness is symmetric and distinctness is symmetric, (t, s) is also adjacent.
    intros s t hst
    exact ⟨hst.2.1, hst.1, hst.2.2.1.symm, hst.2.2.2.symm⟩
  loopless := by
    -- The relation is irreflexive because if s = t, then Disjoint s t is false.
    simp [Irreflexive]

/-
Checking if SimpleGraph.kneserGraph is defined.
-/
#check SimpleGraph.kneserGraph

/-
Definitions of A4 and the set of elements of order 2 in A4.
-/
/-- The alternating group A4 as a type. -/
abbrev A4 := ↥(alternatingGroup (Fin 4))

/-- The set of elements in A4 with order 2. -/
def S_A4_Order2 : Set A4 := {x | orderOf x = 2}

/-
Definition of the Cayley graph of A4 with generators of order 2.
-/
/-- The Cayley graph of A4 with generators of order 2. -/
noncomputable def A4_Cayley_Order2 : SimpleGraph A4 :=
  SimpleGraph.cayleyGraph S_A4_Order2
    (fun s hs => by
      simp only [S_A4_Order2, Set.mem_setOf_eq] at *
      rw [orderOf_inv, hs])
    (fun h => by
      simp only [S_A4_Order2, Set.mem_setOf_eq] at h
      rw [orderOf_one] at h
      contradiction)

/-
Lemma: The complete graph on 4 vertices satisfies Tuza's conjecture.
-/
/-- Lemma: K4 satisfies Tuza's conjecture. -/
lemma SimpleGraph.K4_satisfies_Tuza : (completeGraph (Fin 4)).TuzasConjecture := by
  refine' le_trans _ ( Nat.mul_le_mul_left _ <| show 1 ≤ _ from _ );
  · unfold SimpleGraph.triangleTransversalNumber;
    simp +decide [ SimpleGraph.IsTriangleTransversal ];
    split_ifs <;> simp_all +decide [ Finset.min' ];
    simp_all +decide [ Set.subset_def ];
    exists { Sym2.mk ( 0, 1 ), Sym2.mk ( 2, 3 ) };
  · unfold SimpleGraph.trianglePackingNumber;
    simp +decide [ SimpleGraph.IsEdgeDisjointTriangleSet ]

/-
Defining the subgroup H generated by elements of order 2 in A4 and stating that its cardinality is 4.
-/
/-- The subgroup generated by elements of order 2 in A4. -/
def H_A4_Order2 : Subgroup A4 := Subgroup.closure S_A4_Order2

/-- Lemma: The subgroup H has cardinality 4. -/
lemma card_H_A4_Order2 : Fintype.card H_A4_Order2 = 4 := by
  rw [ Fintype.card_of_subtype ];
  swap;
  exact { ⟨ 1, by simp +decide ⟩, ⟨ Equiv.swap 0 1 * Equiv.swap 2 3, by simp +decide ⟩, ⟨ Equiv.swap 0 2 * Equiv.swap 1 3, by simp +decide ⟩, ⟨ Equiv.swap 0 3 * Equiv.swap 1 2, by simp +decide ⟩ };
  · simp +decide [ Finset.card ];
  · intro x;
    constructor;
    · unfold H_A4_Order2;
      simp +decide [ Subgroup.mem_closure ];
      rintro ( rfl | rfl | rfl | rfl ) K hK <;> simp_all +decide [ S_A4_Order2 ];
      · exact K.one_mem;
      · exact hK ( by simp +decide [ orderOf_eq_iff ] );
      · convert hK _;
        simp +decide [ orderOf_eq_iff ];
      · exact hK ( by simp +decide [ orderOf_eq_iff ] );
    · simp +decide [ H_A4_Order2 ];
      refine' Subgroup.closure_induction _ _ _ _;
      · simp +decide [ S_A4_Order2 ];
        simp +decide [ orderOf_eq_iff ];
      · exact Or.inl rfl;
      · rintro x y hx hy ( rfl | rfl | rfl | rfl ) ( rfl | rfl | rfl | rfl ) <;> decide;
      · rintro x hx ( rfl | rfl | rfl | rfl ) <;> simp +decide

/-
Defining element a = (0 1)(2 3) in A4.
-/
/-- Element a = (0 1)(2 3) in A4 -/
def a_A4 : A4 := ⟨Equiv.swap 0 1 * Equiv.swap 2 3, by
  -- The permutation (0 1)(2 3) is even, so it is in the alternating group A4.
  simp [alternatingGroup]⟩

/-
Defining element b = (0 2)(1 3) in A4.
-/
/-- Element b = (0 2)(1 3) in A4 -/
def b_A4 : A4 := ⟨Equiv.swap 0 2 * Equiv.swap 1 3, by
  -- The permutation (0 2)(1 3) is even, so it is in the alternating group A4.
  simp [alternatingGroup]⟩

/-
Defining element g1 = (0 1 2) in A4.
-/
/-- Element g1 = (0 1 2) in A4 -/
def g1_A4 : A4 := ⟨Equiv.swap 0 1 * Equiv.swap 1 2, by
  -- The permutation (0 1 2) is even.
  simp [alternatingGroup]⟩

/-
Defining element g2 = (0 2 1) in A4.
-/
/-- Element g2 = (0 2 1) in A4 -/
def g2_A4 : A4 := ⟨Equiv.swap 0 2 * Equiv.swap 2 1, by
  -- The permutation (0 2 1) is even.
  simp [alternatingGroup]⟩

/-
Defining the first triangle T1 = {1, a, b}.
-/
/-- Triangle 1: {1, a, b} -/
def T1 : Finset A4 := {1, a_A4, b_A4}

/-
Defining T2 and T3 by left-multiplying T1 by g1 and g2 respectively.
-/
/-- Triangle 2: g1 * T1 -/
def T2 : Finset A4 := T1.map (Equiv.mulLeft g1_A4).toEmbedding

/-- Triangle 3: g2 * T1 -/
def T3 : Finset A4 := T1.map (Equiv.mulLeft g2_A4).toEmbedding

/-
Checking if T2 and T3 are defined.
-/
#check T2
#check T3

/-
Lemma: {T1, T2, T3} is an edge-disjoint triangle set in A4_Cayley_Order2.
-/
/-- Lemma: {T1, T2, T3} is an edge-disjoint triangle set in A4_Cayley_Order2. -/
lemma A4_Cayley_Order2_has_disjoint_triangles :
  A4_Cayley_Order2.IsEdgeDisjointTriangleSet {T1, T2, T3} := by
    unfold SimpleGraph.IsEdgeDisjointTriangleSet;
    unfold A4_Cayley_Order2; simp +decide [ *, SimpleGraph.cayleyGraph ] ;
    unfold S_A4_Order2; simp +decide [ Set.Pairwise ] ;
    simp +decide [ T1, T2, T3 ];
    simp +decide [ a_A4, b_A4, g1_A4, g2_A4 ];
    simp +decide [ orderOf_eq_iff ]

/-
Checking if A4_Cayley_Order2_has_disjoint_triangles is defined.
-/
#check A4_Cayley_Order2_has_disjoint_triangles

/-
Lemmas stating the orders of a, b, g1, g2 in A4.
-/
lemma orderOf_a_eq_2 : orderOf a_A4 = 2 := by
  simp +decide [ orderOf_eq_iff ]
lemma orderOf_b_eq_2 : orderOf b_A4 = 2 := by
  simp +decide [ orderOf_eq_iff ]
lemma orderOf_g1_eq_3 : orderOf g1_A4 = 3 := by
  simp +decide only [orderOf_eq_iff]
lemma orderOf_g2_eq_3 : orderOf g2_A4 = 3 := by
  simp +decide [ orderOf_eq_iff ]

/-
Lemmas stating that 1 is in T1, g1 is in T2, and g2 is in T3.
-/
lemma mem_T1_one : (1 : A4) ∈ T1 := by
  exact Finset.mem_insert_self _ _

lemma mem_T2_g1 : g1_A4 ∈ T2 := by
  native_decide +revert

lemma mem_T3_g2 : g2_A4 ∈ T3 := by
  simp +decide [ T3 ]

/-
Defining the set of triangles S_triangles = {T1, T2, T3}.
-/
/-- The set of three triangles {T1, T2, T3}. -/
def S_triangles : Finset (Finset A4) := {T1, T2, T3}

/-
Lemmas stating that T1, T2, and T3 are pairwise distinct.
-/
lemma T1_ne_T2 : T1 ≠ T2 := by
  simp +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ]
lemma T1_ne_T3 : T1 ≠ T3 := by
  native_decide +revert
lemma T2_ne_T3 : T2 ≠ T3 := by
  native_decide +revert

/-
Proving that the cardinality of S_triangles is 3.
-/
/-- Lemma: The cardinality of S_triangles is 3. -/
lemma S_triangles_card_eq_3 : S_triangles.card = 3 := by
  rw [S_triangles]
  have h12 := T1_ne_T2
  have h13 := T1_ne_T3
  have h23 := T2_ne_T3
  rw [Finset.card_insert_of_not_mem]
  rw [Finset.card_insert_of_not_mem]
  · simp
  · simp [h23, Ne.symm h23]
  · simp [h12, h13, Ne.symm h12, Ne.symm h13]

/-
Proving that the triangle packing number is at least 3 using S_triangles.
-/
lemma A4_Cayley_Order2_packing_ge_3 : A4_Cayley_Order2.trianglePackingNumber ≥ 3 := by
  refine' le_trans _ ( Finset.le_sup _ );
  rw [ S_triangles_card_eq_3 ];
  exact Set.mem_toFinset.mpr ( A4_Cayley_Order2_has_disjoint_triangles )

/-
Checking if A4_Cayley_Order2_packing_ge_3 is defined.
-/
#check A4_Cayley_Order2_packing_ge_3

/-
Defining the transversal set T_edges of size 6.
-/
/-- The proposed transversal set of size 6. -/
def T_edges : Finset (Sym2 A4) :=
  {Sym2.mk (1, a_A4), Sym2.mk (b_A4, a_A4 * b_A4),
   Sym2.mk (g1_A4, g1_A4 * a_A4), Sym2.mk (g1_A4 * b_A4, g1_A4 * (a_A4 * b_A4)),
   Sym2.mk (g2_A4, g2_A4 * a_A4), Sym2.mk (g2_A4 * b_A4, g2_A4 * (a_A4 * b_A4))}

/-
Lemma: T_edges is a triangle transversal of A4_Cayley_Order2.
-/
/-- Lemma: T_edges is a triangle transversal of A4_Cayley_Order2. -/
lemma T_edges_is_transversal : A4_Cayley_Order2.IsTriangleTransversal T_edges := by
  constructor;
  · rw [ Finset.subset_iff ];
    simp +decide [ T_edges ];
    unfold A4_Cayley_Order2; simp +decide [ SimpleGraph.cayleyGraph ] ;
    unfold S_A4_Order2; simp +decide [ orderOf_eq_iff ] ;
  · intro t ht ht'; have := Finset.card_eq_three.mp ht'; obtain ⟨ a, b, c, habc ⟩ := this; simp_all +decide [ SimpleGraph.IsClique ] ;
    unfold A4_Cayley_Order2 at ht; simp_all +decide [ SimpleGraph.cayleyGraph ] ;
    rcases ht with ⟨ ⟨ a, ha, ha', rfl ⟩, ⟨ b, hb, hb', rfl ⟩, ⟨ c, hc, hc', h ⟩ ⟩;
    simp_all +decide [ mul_assoc, Subtype.ext_iff ];
    subst h;
    unfold S_A4_Order2 at *; simp_all +decide [ orderOf_eq_iff ] ;
    fin_cases a <;> simp_all +decide only;
    · fin_cases b <;> simp_all ( config := { decide := Bool.true } ) only [ ];
      · exact absurd hb ( by native_decide );
      · exact absurd hb ( by native_decide );
      · native_decide +revert;
      · native_decide +revert;
    · fin_cases b <;> simp_all ( config := { decide := Bool.true } ) only [ ];
      · exact absurd hb ( by simp +decide [ Equiv.Perm.sign_mul ] );
      · fin_cases a <;> simp +decide [ T_edges ];
      · exact absurd hb ( by decide );
      · cases a ; simp_all +decide [ Equiv.Perm.ext_iff ];
        rename_i k hk;
        fin_cases k <;> simp ( config := { decide := Bool.true } ) at hk ⊢;
    · fin_cases b <;> simp +decide at hb hb' hc habc ⊢;
      · native_decide +revert;
      · fin_cases a <;> simp +decide at hb hb' hc habc ⊢

/-
Proving that the cardinality of T_edges is at most 6.
-/
lemma T_edges_card_le_6 : T_edges.card ≤ 6 := by
  native_decide

/-
Proving that A4_Cayley_Order2 is not a Tuza counterexample using the established bounds.
-/
/-- Claim: The Cayley graph of A4 with generators of order 2 is not a Tuza counterexample. -/
theorem A4_Cayley_Order2_Tuza : ¬ A4_Cayley_Order2.IsTuzaCounterexample := by
  have h_transversal : A4_Cayley_Order2.triangleTransversalNumber ≤ 6 := by
    unfold SimpleGraph.triangleTransversalNumber;
    field_simp;
    split_ifs <;> simp_all +decide [ Finset.min' ];
    exact ⟨ T_edges, T_edges_is_transversal, le_rfl ⟩;
  -- Since we have that the triangle transversal number is at most 6 and the triangle packing number is at least 3, we can conclude that the graph is not a Tuza counterexample.
  have h_not_counterexample : A4_Cayley_Order2.triangleTransversalNumber ≤ 2 * A4_Cayley_Order2.trianglePackingNumber := by
    exact le_trans h_transversal ( by linarith [ show A4_Cayley_Order2.trianglePackingNumber ≥ 3 by exact A4_Cayley_Order2_packing_ge_3 ] );
  exact fun h => h_not_counterexample.not_lt h

/-
Checking if A4_Cayley_Order2_Tuza is defined.
-/
#check A4_Cayley_Order2_Tuza