/-
This file was generated by Aristotle.
UUID: 4828661f-89e2-4997-8a84-7787f10886a9

RESULT: τ ≤ 3ν PROVEN (via axiomatic TuzaContext class)
NOTE: Full conjecture τ ≤ 2ν NOT proven - Aristotle states it "remains an open problem"

This approach used scaffolded building blocks but still hit the 3ν ceiling.
Same result as v7 (085f46d5) but via different formalization.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the context for Tuza's Conjecture, including graph operations, packing definitions, and the provided axioms.
-/
class TuzaContext (G : Type) (Edge : Type) (Triangle : Type) [DecidableEq Edge] [DecidableEq Triangle] where
  -- Data
  nu : G → ℕ
  tau : G → ℕ
  all_edges : G → Finset Edge
  triangle_edges : Triangle → Finset Edge
  is_triangle : G → Triangle → Prop
  delete : G → Finset Edge → G

  -- Standard Graph Axioms
  triangle_card : ∀ t, (triangle_edges t).card = 3
  is_triangle_def : ∀ g t, is_triangle g t ↔ triangle_edges t ⊆ all_edges g
  delete_edges_eq : ∀ g S, all_edges (delete g S) = all_edges g \ S

  -- User's Building Blocks
  base_case : ∀ g, nu g = 0 → tau g = 0
  deletion_bound : ∀ g S, tau g ≤ S.card + tau (delete g S)

  -- Packing definition
  is_packing : G → Finset Triangle → Prop :=
    λ g P => (∀ t ∈ P, is_triangle g t) ∧ (∀ t₁ ∈ P, ∀ t₂ ∈ P, t₁ ≠ t₂ → Disjoint (triangle_edges t₁) (triangle_edges t₂))

  max_packing_exists : ∀ g, ∃ P, is_packing g P ∧ P.card = nu g

  intersects_max : ∀ g P, is_packing g P → P.card = nu g →
    ∀ t, is_triangle g t → ∃ t' ∈ P, ¬Disjoint (triangle_edges t) (triangle_edges t')

  -- Redundant but provided blocks
  two_edges_destroy : ∀ g t S, is_triangle g t → S ⊆ triangle_edges t → S.card = 2 → ¬is_triangle (delete g S) t
  mono : ∀ g S, nu (delete g S) ≤ nu g

variable {G : Type} {Edge : Type} {Triangle : Type}
variable [DecidableEq Edge] [DecidableEq Triangle]
variable [TuzaContext G Edge Triangle]

lemma packing_card_edges (g : G) (P : Finset Triangle)
  (h_packing_def : ∀ (g : G) (P : Finset Triangle), TuzaContext.is_packing (G := G) (Edge := Edge) (Triangle := Triangle) g P ↔ (∀ t ∈ P, TuzaContext.is_triangle (G := G) (Edge := Edge) (Triangle := Triangle) g t) ∧ (∀ t₁ ∈ P, ∀ t₂ ∈ P, t₁ ≠ t₂ → Disjoint (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₁) (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₂)))
  (hP : TuzaContext.is_packing (G := G) (Edge := Edge) (Triangle := Triangle) g P) :
  (P.biUnion (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle))).card = 3 * P.card := by
    rw [ Finset.card_biUnion ] <;> aesop;
    rw [ Finset.sum_congr rfl fun x hx => inst_2.triangle_card x, Finset.sum_const, smul_eq_mul, mul_comm ]

lemma max_packing_destroys_all_triangles (g : G) (P : Finset Triangle)
  (h_packing_def : ∀ (g : G) (P : Finset Triangle), TuzaContext.is_packing (G := G) (Edge := Edge) (Triangle := Triangle) g P ↔ (∀ t ∈ P, TuzaContext.is_triangle (G := G) (Edge := Edge) (Triangle := Triangle) g t) ∧ (∀ t₁ ∈ P, ∀ t₂ ∈ P, t₁ ≠ t₂ → Disjoint (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₁) (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₂)))
  (hP : TuzaContext.is_packing (G := G) (Edge := Edge) (Triangle := Triangle) g P)
  (h_max : P.card = TuzaContext.nu (G := G) (Edge := Edge) (Triangle := Triangle) g) :
  TuzaContext.nu (G := G) (Edge := Edge) (Triangle := Triangle) (TuzaContext.delete (G := G) (Edge := Edge) (Triangle := Triangle) g (P.biUnion (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle)))) = 0 := by
    obtain ⟨ Q, hQ₁, hQ₂ ⟩ := ‹TuzaContext G Edge Triangle›.max_packing_exists ( ‹TuzaContext G Edge Triangle›.delete g (Finset.biUnion P ‹TuzaContext G Edge Triangle›.triangle_edges) );
    have h_inter : ∀ t ∈ Q, ∃ t' ∈ P, ¬Disjoint (‹TuzaContext G Edge Triangle›.triangle_edges t) (‹TuzaContext G Edge Triangle›.triangle_edges t') := by
      aesop;
      have := inst_2.intersects_max g P;
      apply this;
      · aesop;
      · exact h_max;
      · specialize left_1 t a;
        rw [ inst_2.is_triangle_def ] at *;
        exact left_1.trans ( by rw [ inst_2.delete_edges_eq ] ; exact Finset.sdiff_subset );
    contrapose! h_inter;
    obtain ⟨ t, ht ⟩ := Finset.card_pos.mp ( by linarith [ Nat.pos_of_ne_zero h_inter ] );
    refine' ⟨ t, ht, fun x hx => _ ⟩;
    refine' Finset.disjoint_left.mpr _;
    intro e he₁ he₂; have := hQ₁; simp_all +decide [ Finset.subset_iff ] ;
    have := this.1 t ht; simp_all +decide [ TuzaContext.is_triangle_def ] ;
    have := this.1 t ht he₁; simp_all +decide [ TuzaContext.delete_edges_eq ] ;

/-
MAIN THEOREM: τ ≤ 3ν
Same result as v7 but via axiomatic approach.
Full Tuza (τ ≤ 2ν) NOT proven.
-/
theorem tau_le_3_nu (g : G)
  (h_packing_def : ∀ (g : G) (P : Finset Triangle), TuzaContext.is_packing (G := G) (Edge := Edge) (Triangle := Triangle) g P ↔ (∀ t ∈ P, TuzaContext.is_triangle (G := G) (Edge := Edge) (Triangle := Triangle) g t) ∧ (∀ t₁ ∈ P, ∀ t₂ ∈ P, t₁ ≠ t₂ → Disjoint (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₁) (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle) t₂))) :
  TuzaContext.tau (G := G) (Edge := Edge) (Triangle := Triangle) g ≤ 3 * TuzaContext.nu (G := G) (Edge := Edge) (Triangle := Triangle) g := by
  obtain ⟨P, hP, hP_card⟩ := TuzaContext.max_packing_exists (G := G) (Edge := Edge) (Triangle := Triangle) g
  let S := P.biUnion (TuzaContext.triangle_edges (G := G) (Edge := Edge) (Triangle := Triangle))
  have hS_card : S.card = 3 * P.card := packing_card_edges g P h_packing_def hP
  have h_nu_zero : TuzaContext.nu (G := G) (Edge := Edge) (Triangle := Triangle) (TuzaContext.delete (G := G) (Edge := Edge) (Triangle := Triangle) g S) = 0 := max_packing_destroys_all_triangles g P h_packing_def hP hP_card
  have h_tau_zero : TuzaContext.tau (G := G) (Edge := Edge) (Triangle := Triangle) (TuzaContext.delete (G := G) (Edge := Edge) (Triangle := Triangle) g S) = 0 := TuzaContext.base_case (TuzaContext.delete (G := G) (Edge := Edge) (Triangle := Triangle) g S) h_nu_zero
  have h_bound := TuzaContext.deletion_bound (G := G) (Edge := Edge) (Triangle := Triangle) g S
  rw [h_tau_zero, add_zero] at h_bound
  rw [hS_card, hP_card] at h_bound
  exact h_bound
