/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2b21c426-552d-4eb4-831e-b797545758e2

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A set of triangles is a packing if they are edge-disjoint.
-/
variable {V : Type*} [DecidableEq V] [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]

/-- A set of triangles is a packing if they are edge-disjoint. -/
def IsTrianglePacking (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧ (S : Set (Finset V)).Pairwise fun t₁ t₂ => (t₁ ∩ t₂).card ≤ 1

/-
The triangle packing number ν(G) is the maximum size of a triangle packing.
-/
/-- The triangle packing number ν(G) is the maximum size of a triangle packing. -/
noncomputable def trianglePackingNumber : ℕ :=
  (G.cliqueFinset 3).powerset.filter (IsTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

/-
A set of edges covers all triangles if every triangle contains at least one edge from the set.
-/
/-- A set of edges covers all triangles if every triangle contains at least one edge from the set. -/
def IsTriangleCovering (F : Finset (Sym2 V)) : Prop :=
  F ⊆ G.edgeFinset ∧ ∀ t ∈ G.cliqueFinset 3, ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ s(u, v) ∈ F

/-
The triangle covering number τ(G) is the minimum size of a triangle covering.
-/
/-- The triangle covering number τ(G) is the minimum size of a triangle covering. -/
noncomputable def triangleCoveringNumber : ℕ :=
  G.edgeFinset.powerset.filter (IsTriangleCovering G) |>.image Finset.card |>.min |>.getD 0

/-
If the triangle packing number is 0, then the triangle covering number is 0.
-/
lemma nu_eq_0_implies_tau_eq_0 (h : trianglePackingNumber G = 0) : triangleCoveringNumber G = 0 := by
  -- Since the triangle packing number is 0, this means there are no edge-disjoint triangles in G.
  have h_no_triangles : ∀ (S : Finset (Finset V)), IsTrianglePacking G S → S = ∅ := by
    unfold trianglePackingNumber at h;
    intro S hS; contrapose! h; aesop;
    have h_max : ∃ S' ∈ Finset.filter (IsTrianglePacking G) (G.cliqueFinset 3).powerset, S'.card > 0 := by
      exact ⟨ S, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hS.1, hS ⟩, Finset.card_pos.mpr ( Finset.nonempty_of_ne_empty h ) ⟩;
    obtain ⟨ S', hS', hS'' ⟩ := h_max;
    have h_max : Finset.max (Finset.image Finset.card (Finset.filter (IsTrianglePacking G) (G.cliqueFinset 3).powerset)) ≥ S'.card := by
      exact Finset.le_max ( Finset.mem_image_of_mem _ hS' );
    cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( IsTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
  -- Since there are no triangles in G, the empty set of edges covers all triangles.
  have h_empty_cover : IsTriangleCovering G ∅ := by
    constructor <;> simp +decide [ IsTriangleCovering ];
    intro t ht; specialize h_no_triangles { t } ; simp_all +decide [ IsTrianglePacking ] ;
  unfold triangleCoveringNumber;
  rw [ Finset.min_eq_inf_withTop ];
  rw [ Finset.inf_eq_sInf_image ];
  rw [ show ( InfSet.sInf ( WithTop.some '' ( ↑ ( Finset.image Finset.card ( Finset.filter ( IsTriangleCovering G ) G.edgeFinset.powerset ) ) : Set ℕ ) ) ) = 0 from le_antisymm _ _ ];
  · rfl;
  · exact csInf_le ⟨ 0, fun x hx => by aesop ⟩ ⟨ 0, by aesop ⟩;
  · exact bot_le

/-
If the triangle packing number is 1, then any two triangles in the graph share an edge.
-/
lemma nu_eq_1_implies_pairwise_edge_sharing (h : trianglePackingNumber G = 1) :
    ∀ t₁ t₂ : Finset V, t₁ ∈ G.cliqueFinset 3 → t₂ ∈ G.cliqueFinset 3 → (t₁ ∩ t₂).card ≥ 2 := by
  -- By definition of triangle packing number, if $\nu(G) = 1$, then any two triangles in the graph share an edge.
  intro t₁ t₂ ht₁ ht₂
  by_contra h_contra;
  have h_packing : IsTrianglePacking G {t₁, t₂} := by
    constructor;
    · grind;
    · simp_all +decide [ Set.Pairwise ];
      exact ⟨ fun _ => Nat.le_of_lt_succ h_contra, fun _ => Nat.le_of_lt_succ ( by rwa [ Finset.inter_comm ] ) ⟩;
  have h_card_packing : (Finset.card {t₁, t₂} : ℕ) ≤ trianglePackingNumber G := by
    have h_card_packing : {t₁, t₂} ∈ (G.cliqueFinset 3).powerset.filter (IsTrianglePacking G) := by
      grind;
    have h_card_packing : ∀ x ∈ Finset.image Finset.card (Finset.filter (IsTrianglePacking G) (G.cliqueFinset 3).powerset), x ≤ Option.getD (Finset.image Finset.card (Finset.filter (IsTrianglePacking G) (G.cliqueFinset 3).powerset)).max 0 := by
      intro x hx;
      have := Finset.le_max hx;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( IsTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
    exact h_card_packing _ ( Finset.mem_image_of_mem _ ‹_› );
  by_cases h : t₁ = t₂ <;> simp_all +decide;
  rw [ SimpleGraph.isNClique_iff ] at ht₂ ; aesop

/-
If three triangles pairwise share an edge but do not share a common edge, their union has size 4.
-/
lemma three_triangles_pairwise_edge_sharing_union_card (t₁ t₂ t₃ : Finset V)
    (h_card₁ : t₁.card = 3) (h_card₂ : t₂.card = 3) (h_card₃ : t₃.card = 3)
    (h₁₂ : 2 ≤ (t₁ ∩ t₂).card) (h₁₃ : 2 ≤ (t₁ ∩ t₃).card) (h₂₃ : 2 ≤ (t₂ ∩ t₃).card)
    (h_no_common : (t₁ ∩ t₂ ∩ t₃).card < 2) :
    (t₁ ∪ t₂ ∪ t₃).card = 4 := by
  have h_union_card : (t₁ ∪ t₂ ∪ t₃).card ≤ 4 := by
    have h_inter_union : (t₁ ∩ (t₂ ∪ t₃)).card ≥ (t₁ ∩ t₂).card + (t₁ ∩ t₃).card - (t₁ ∩ t₂ ∩ t₃).card := by
      rw [ ← Finset.card_union_add_card_inter ];
      simp +decide [ Finset.inter_union_distrib_left, Finset.inter_comm, Finset.inter_left_comm, Finset.inter_assoc ];
    grind;
  interval_cases _ : t₁ ∪ t₂ ∪ t₃ |> Finset.card <;> simp_all +decide;
  · rw [ Finset.card_eq_one ] at *;
    rcases ‹_› with ⟨ a, ha ⟩ ; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
    exact absurd ( Finset.card_le_card ( show t₁ ⊆ { a } from fun x hx => by aesop ) ) ( by aesop );
  · have := Finset.card_le_card ( show t₁ ⊆ t₁ ∪ ( t₂ ∪ t₃ ) from Finset.subset_union_left ) ; simp_all +decide ;
  · have h_union_eq : t₁ = t₁ ∪ t₂ ∪ t₃ := by
      have h_union_eq : t₁ ⊆ t₁ ∪ t₂ ∪ t₃ := by
        grind;
      exact Finset.eq_of_subset_of_card_le h_union_eq ( by aesop );
    norm_num [ Finset.ext_iff ] at h_union_eq;
    have h_union_eq : t₂ = t₁ ∧ t₃ = t₁ := by
      exact ⟨ Finset.eq_of_subset_of_card_le ( fun x hx => h_union_eq x ( Or.inl hx ) ) ( by linarith ), Finset.eq_of_subset_of_card_le ( fun x hx => h_union_eq x ( Or.inr hx ) ) ( by linarith ) ⟩;
    aesop

/-
If a set of triangles pairwise share an edge but do not all share a common edge, then the union of their vertices has size at most 4.
-/
lemma pairwise_edge_sharing_no_common_edge_implies_subset_K4 (S : Finset (Finset V))
    (h_tri : ∀ t ∈ S, t.card = 3)
    (h_pair : (S : Set (Finset V)).Pairwise (fun t₁ t₂ => 2 ≤ (t₁ ∩ t₂).card))
    (h_no_common : ¬ ∃ u v, u ≠ v ∧ ∀ t ∈ S, {u, v} ⊆ t) :
    (S.sup id).card ≤ 4 := by
  by_contra h_contra;
  -- Since there is no common edge, S must contain at least 3 triangles t1, t2, t3 that do not share a common edge.
  obtain ⟨t1, t2, t3, ht1, ht2, ht3, h_pairwise⟩ : ∃ t1 t2 t3 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ t3 ∈ S ∧ 2 ≤ (t1 ∩ t2).card ∧ 2 ≤ (t1 ∩ t3).card ∧ 2 ≤ (t2 ∩ t3).card ∧ (t1 ∩ t2 ∩ t3).card < 2 := by
    -- Since there is no common edge, there exist two triangles t1 and t2 in S such that their intersection has exactly 2 elements.
    obtain ⟨t1, t2, ht1, ht2, h_inter⟩ : ∃ t1 t2 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ (t1 ∩ t2).card = 2 := by
      -- Since S is nonempty, we can pick any two distinct triangles t1 and t2 from S.
      obtain ⟨t1, ht1⟩ : ∃ t1 : Finset V, t1 ∈ S := by
        exact Finset.nonempty_of_ne_empty fun h => by simp +decide [ h ] at h_contra;
      obtain ⟨t2, ht2, ht2_ne_t1⟩ : ∃ t2 : Finset V, t2 ∈ S ∧ t2 ≠ t1 := by
        by_cases h_singleton : S = {t1};
        · aesop;
        · exact Finset.exists_mem_ne ( Finset.one_lt_card.2 ⟨ t1, ht1, by obtain ⟨ t2, ht2 ⟩ := Finset.exists_of_ssubset ( lt_of_le_of_ne ( Finset.singleton_subset_iff.2 ht1 ) ( Ne.symm h_singleton ) ) ; aesop ⟩ ) t1;
      have h_inter : (t1 ∩ t2).card ≤ 2 := by
        have := Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; simp_all +decide ;
        interval_cases _ : Finset.card ( t1 ∩ t2 ) <;> simp_all +decide;
        have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; simp_all +decide ;
      exact ⟨ t1, t2, ht1, ht2, le_antisymm h_inter ( h_pair ht1 ht2 ( Ne.symm ht2_ne_t1 ) ) ⟩;
    -- Since there is no common edge, there exists a triangle t3 in S such that t3 does not contain the common edge of t1 and t2.
    obtain ⟨t3, ht3, h_not_common⟩ : ∃ t3 : Finset V, t3 ∈ S ∧ ¬(t1 ∩ t2 ⊆ t3) := by
      norm_num +zetaDelta at *;
      obtain ⟨ u, v, huv ⟩ := Finset.card_eq_two.mp h_inter;
      simpa [ huv ] using h_no_common u v huv.1;
    refine' ⟨ t1, t2, t3, ht1, ht2, ht3, _, _, _, _ ⟩;
    · linarith;
    · exact h_pair ht1 ht3 ( by aesop );
    · exact h_pair ht2 ht3 ( by aesop );
    · exact lt_of_lt_of_le ( Finset.card_lt_card ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.inter_subset_left, fun h => h_not_common <| h.symm ▸ Finset.inter_subset_right ⟩ ) ) h_inter.le;
  -- Consider any other triangle t ∈ S.
  have h_subset : ∀ t ∈ S, t ⊆ t1 ∪ t2 ∪ t3 := by
    intro t ht
    have h_intersect : 2 ≤ (t ∩ t1).card ∧ 2 ≤ (t ∩ t2).card ∧ 2 ≤ (t ∩ t3).card := by
      exact ⟨ if h : t = t1 then by aesop else h_pair ht ht1 h, if h : t = t2 then by aesop else h_pair ht ht2 h, if h : t = t3 then by aesop else h_pair ht ht3 h ⟩;
    intro x hx;
    by_cases hx1 : x ∈ t1 <;> by_cases hx2 : x ∈ t2 <;> by_cases hx3 : x ∈ t3 <;> simp_all +decide;
    have h_card : (t ∩ t1).card ≤ 2 ∧ (t ∩ t2).card ≤ 2 ∧ (t ∩ t3).card ≤ 2 := by
      have h_card : (t ∩ t1).card ≤ Finset.card (t \ {x}) ∧ (t ∩ t2).card ≤ Finset.card (t \ {x}) ∧ (t ∩ t3).card ≤ Finset.card (t \ {x}) := by
        exact ⟨ Finset.card_le_card fun y hy => by aesop, Finset.card_le_card fun y hy => by aesop, Finset.card_le_card fun y hy => by aesop ⟩;
      simp_all +decide [ Finset.card_sdiff ];
    have h_card : (t ∩ t1) = t \ {x} ∧ (t ∩ t2) = t \ {x} ∧ (t ∩ t3) = t \ {x} := by
      have h_card : (t ∩ t1) ⊆ t \ {x} ∧ (t ∩ t2) ⊆ t \ {x} ∧ (t ∩ t3) ⊆ t \ {x} := by
        grind;
      have h_card : (t ∩ t1).card = (t \ {x}).card ∧ (t ∩ t2).card = (t \ {x}).card ∧ (t ∩ t3).card = (t \ {x}).card := by
        simp_all +decide [ Finset.card_sdiff ];
        exact ⟨ by linarith, by linarith, by linarith ⟩;
      exact ⟨ Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ), Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ), Finset.eq_of_subset_of_card_le ( by tauto ) ( by linarith ) ⟩;
    have h_card : t1 ∩ t2 ∩ t3 ⊇ t \ {x} := by
      grind;
    have := Finset.card_le_card h_card; simp_all +decide ;
    linarith;
  have h_card_union : (t1 ∪ t2 ∪ t3).card = 4 := by
    apply three_triangles_pairwise_edge_sharing_union_card;
    all_goals tauto;
  exact h_contra ( le_trans ( Finset.card_le_card <| show S.sup id ≤ t1 ∪ t2 ∪ t3 from Finset.sup_le fun t ht => h_subset t ht ) h_card_union.le )

/-
If a set of triangles in the graph is contained within a set of 4 vertices, then these triangles can be covered by at most 2 edges.
-/
lemma subset_K4_implies_cover_le_2_restricted (S : Finset (Finset V))
    (h_S : S ⊆ G.cliqueFinset 3)
    (U : Finset V) (h_U : U.card ≤ 4) (h_subset : ∀ t ∈ S, t ⊆ U) :
    ∃ F : Finset (Sym2 V), F ⊆ G.edgeFinset ∧ F.card ≤ 2 ∧ ∀ t ∈ S, ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ s(u, v) ∈ F := by
  by_contra! h_contra';
  -- Since all triangles in S are subsets of U and |U| ≤ 4, we can analyze the possible configurations of triangles on 4 vertices.
  have h_configurations : ∀ T : Finset (Finset V), (∀ t ∈ T, t.card = 3 ∧ t ⊆ U) → ∃ F : Finset (Sym2 V), F.card ≤ 2 ∧ ∀ t ∈ T, ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ s(u, v) ∈ F := by
    intro T hT
    by_cases hU : U.card ≤ 3;
    · by_cases hU : U.card = 3;
      · -- Since U has exactly 3 elements, any triangle in T must be exactly U itself.
        have hT_eq_U : ∀ t ∈ T, t = U := by
          exact fun t ht => Finset.eq_of_subset_of_card_le ( hT t ht |>.2 ) ( by simp +decide [ hT t ht |>.1, hU ] );
        rcases Finset.card_eq_three.mp hU with ⟨ u, v, w, hu, hv, hw, h ⟩ ; use { s(u, v), s(u, w) } ; simp_all +decide ;
        intro t ht; use u, by rw [ hT_eq_U t ht ] ; simp +decide, v, by rw [ hT_eq_U t ht ] ; simp +decide; ; aesop;
      · exact ⟨ ∅, by norm_num, fun t ht => by have := hT t ht; have := Finset.card_le_card this.2; interval_cases _ : U.card <;> simp_all +decide ⟩;
    · -- Since U has exactly 4 elements, we can analyze the possible configurations of triangles on 4 vertices.
      obtain ⟨a, b, c, d, h_abcd⟩ : ∃ a b c d : V, U = {a, b, c, d} ∧ a ≠ b ∧ a ≠ c ∧ a ≠ d ∧ b ≠ c ∧ b ≠ d ∧ c ≠ d := by
        have hU_card : U.card = 4 := by
          linarith;
        simp_rw +decide [ Finset.card_eq_succ ] at hU_card;
        obtain ⟨ a, t, hat, rfl, b, u, hbu, rfl, c, v, hcv, rfl, d, w, hdw, rfl, hw ⟩ := hU_card; use a, b, c, d; aesop;
      -- Consider the possible triangles on {a, b, c, d}.
      have h_triangles : ∀ t ∈ T, t = {a, b, c} ∨ t = {a, b, d} ∨ t = {a, c, d} ∨ t = {b, c, d} := by
        intro t ht
        obtain ⟨ht_card, ht_subset⟩ := hT t ht
        have ht_cases : t ⊆ {a, b, c, d} := by
          aesop;
        have := Finset.card_eq_three.mp ht_card;
        rcases this with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; simp_all +decide [ Finset.subset_iff ] ;
        rcases ht_cases with ⟨ rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl, rfl | rfl | rfl | rfl ⟩ <;> simp +decide [ *, Finset.Subset.antisymm_iff, Finset.subset_iff ] at hxy hxz hyz ⊢;
      refine' ⟨ { s(a, b), s(c, d) }, _, _ ⟩ <;> simp +decide [ * ];
      intro t ht; rcases h_triangles t ht with ( rfl | rfl | rfl | rfl ) <;> simp +decide [ * ] ;
  specialize h_configurations S ; simp_all +decide [ Finset.subset_iff ];
  obtain ⟨F, hF_card, hF_cover⟩ := h_configurations (fun t ht => ⟨by
  exact h_S ht |>.2, h_subset t ht⟩);
  specialize h_contra' ( F.filter fun e => e ∈ G.edgeSet ) ; simp_all +decide [ Finset.subset_iff ] ;
  refine' h_contra' ( le_trans ( Finset.card_filter_le _ _ ) hF_card ) |> fun ⟨ t, ht, h ⟩ => _;
  obtain ⟨ u, hu, v, hv, huv, hF ⟩ := hF_cover t ht; specialize h u v hu hv huv hF; exact h ( h_S ht |>.1 hu hv huv ) ;

/-
If the triangle packing number is 1, then the triangle covering number is at most 2.
-/
lemma nu_eq_1_implies_tau_le_2 (h : trianglePackingNumber G = 1) : triangleCoveringNumber G ≤ 2 := by
  -- If there exists an edge $e = \{u, v\}$ shared by all triangles in $S$, then $\{e\}$ is a triangle covering of size 1. Thus $\tau(G) \leq 1 \leq 2$.
  by_cases h_common : ∃ u v, u ≠ v ∧ ∀ t ∈ G.cliqueFinset 3, {u, v} ⊆ t;
  · -- If there exists an edge $e = \{u, v\}$ shared by all triangles in $S$, then $\{e\}$ is a triangle covering of size 1. Thus $\tau(G) \leq 1$.
    obtain ⟨u, v, huv_ne, huv_cover⟩ := h_common;
    have h_cover : IsTriangleCovering G {s(u, v)} := by
      constructor <;> simp_all +decide [ IsTriangleCovering ];
      · contrapose! huv_cover;
        -- Since the triangle packing number is 1, there exists at least one triangle in the graph.
        obtain ⟨t, ht⟩ : ∃ t ∈ G.cliqueFinset 3, True := by
          have h_triangle : ∃ t ∈ G.cliqueFinset 3, True := by
            have h_nonempty : G.cliqueFinset 3 ≠ ∅ := by
              intro h_empty;
              unfold trianglePackingNumber at h;
              simp_all +decide [ Finset.filter_singleton, IsTrianglePacking ]
            exact Exists.elim ( Finset.nonempty_of_ne_empty h_nonempty ) fun t ht => ⟨ t, ht, trivial ⟩;
          exact h_triangle;
        refine' ⟨ t, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff, SimpleGraph.isNClique_iff ];
        intro hu hv; have := ht.1 hu hv; aesop;
      · exact fun t ht => ⟨ u, huv_cover t ht ( Finset.mem_insert_self _ _ ), v, huv_cover t ht ( Finset.mem_insert_of_mem ( Finset.mem_singleton_self _ ) ), huv_ne, Or.inl ⟨ rfl, rfl ⟩ ⟩;
    refine' le_trans _ ( show 1 ≤ 2 by norm_num );
    unfold triangleCoveringNumber;
    have h_min : (Finset.image Finset.card (Finset.filter (IsTriangleCovering G) (Finset.powerset G.edgeFinset))).min ≤ 1 := by
      have h_one : 1 ∈ Finset.image Finset.card (Finset.filter (IsTriangleCovering G) (Finset.powerset G.edgeFinset)) := by
        simp +zetaDelta at *;
        exact ⟨ { s(u, v) }, ⟨ by simpa using h_cover.1, h_cover ⟩, by simp +decide ⟩
      exact Finset.min_le h_one;
    cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( IsTriangleCovering G ) G.edgeFinset.powerset ) ) <;> aesop;
  · -- Then by `pairwise_edge_sharing_no_common_edge_implies_subset_K4`, the union of all vertices in $S$ has size at most 4.
    have h_union : (Finset.sup (G.cliqueFinset 3) id).card ≤ 4 := by
      apply pairwise_edge_sharing_no_common_edge_implies_subset_K4;
      · simp +decide [ SimpleGraph.cliqueFinset ];
        exact fun t ht => ht.2;
      · intro t₁ ht₁ t₂ ht₂ hne; have := nu_eq_1_implies_pairwise_edge_sharing G h t₁ t₂ ht₁ ht₂; aesop;
      · exact h_common;
    -- By `subset_K4_implies_cover_le_2_restricted`, there exists a cover $F$ of size ≤ 2.
    obtain ⟨F, hF_subset, hF_card, hF_cover⟩ : ∃ F : Finset (Sym2 V), F ⊆ G.edgeFinset ∧ F.card ≤ 2 ∧ ∀ t ∈ G.cliqueFinset 3, ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ s(u, v) ∈ F := by
      apply subset_K4_implies_cover_le_2_restricted;
      exacts [ Finset.Subset.refl _, h_union, fun t ht => Finset.le_sup ( f := id ) ht ];
    refine' le_trans _ hF_card;
    unfold triangleCoveringNumber;
    have hF_covering : IsTriangleCovering G F := by
      exact ⟨ hF_subset, hF_cover ⟩;
    have hF_min : (Finset.image Finset.card (Finset.filter (IsTriangleCovering G) G.edgeFinset.powerset)).min ≤ F.card := by
      exact Finset.min_le ( Finset.mem_image.mpr ⟨ F, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hF_subset, hF_covering ⟩, rfl ⟩ );
    cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( IsTriangleCovering G ) G.edgeFinset.powerset ) ) <;> aesop

/-
If a set of triangles pairwise share an edge, they can be covered by at most 2 edges.
-/
lemma restricted_nu_le_1_implies_cover_le_2 (S : Finset (Finset V))
    (h_S : S ⊆ G.cliqueFinset 3)
    (h_pair : (S : Set (Finset V)).Pairwise (fun t₁ t₂ => 2 ≤ (t₁ ∩ t₂).card)) :
    ∃ F : Finset (Sym2 V), F ⊆ G.edgeFinset ∧ F.card ≤ 2 ∧ ∀ t ∈ S, ∃ u v, u ∈ t ∧ v ∈ t ∧ u ≠ v ∧ s(u, v) ∈ F := by
  by_cases h_common : ∃ u v, u ≠ v ∧ ∀ t ∈ S, {u, v} ⊆ t;
  · cases' h_common with u hu;
    cases' hu with v hv;
    by_cases huv : G.Adj u v;
    · refine' ⟨ { s(u, v) }, _, _, _ ⟩ <;> aesop;
    · have := h_S; simp_all +decide [ Finset.subset_iff, SimpleGraph.cliqueFinset ] ;
      rcases S.eq_empty_or_nonempty with ( rfl | ⟨ t, ht ⟩ ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ];
      · exact ⟨ ∅, by simp +decide ⟩;
      · have := h_S ht; have := this.1; simp_all +decide [ Set.Pairwise ] ;
  · have h_subset_K4 : (S.sup id).card ≤ 4 := by
      convert pairwise_edge_sharing_no_common_edge_implies_subset_K4 S _ h_pair _;
      · exact fun t ht => Finset.mem_filter.mp ( h_S ht ) |>.2.2;
      · exact h_common;
    apply subset_K4_implies_cover_le_2_restricted;
    exacts [ h_S, h_subset_K4, fun t ht => Finset.le_sup ( f := id ) ht ]

/-
If a triangle shares an edge with t1, and t1 is disjoint from t2, then the triangle shares at most one vertex with t2.
-/
lemma disjoint_triangles_implies_neighbors_edge_disjoint (t₁ t₂ a : Finset V)
    (h_card_a : a.card = 3)
    (h_disjoint : Disjoint t₁ t₂)
    (h_neighbor : 2 ≤ (a ∩ t₁).card) :
    (a ∩ t₂).card ≤ 1 := by
  have h_inter : (a ∩ t₁).card + (a ∩ t₂).card ≤ 3 := by
    rw [ ← h_card_a, ← Finset.card_union_of_disjoint ];
    · exact Finset.card_le_card fun x hx => by aesop;
    · exact Disjoint.mono inf_le_right inf_le_right h_disjoint;
  linarith

/-
If {t1, t2} is a maximum packing with t1 and t2 disjoint, then any two triangles sharing an edge with t1 must share an edge with each other.
-/
lemma neighbors_of_disjoint_packing_pairwise_edge_sharing (h_nu : trianglePackingNumber G = 2)
    (t₁ t₂ : Finset V) (h_packing : IsTrianglePacking G {t₁, t₂}) (h_disjoint : Disjoint t₁ t₂) :
    ∀ a b : Finset V, a ∈ G.cliqueFinset 3 → b ∈ G.cliqueFinset 3 →
    2 ≤ (a ∩ t₁).card → 2 ≤ (b ∩ t₁).card → 2 ≤ (a ∩ b).card := by
  intro a b ha hb ha' hb'
  by_contra h_contra;
  -- We construct a packing P = {a, b, t₂}.
  have h_packing_P : IsTrianglePacking G {a, b, t₂} := by
    simp_all +decide [ IsTrianglePacking ];
    simp_all +decide [ Finset.subset_iff, Set.Pairwise ];
    have h_inter_t2_a : (a ∩ t₂).card ≤ 1 := by
      have h_inter_t2_a : (a ∩ t₂).card ≤ 1 := by
        have h_disjoint_t1_t2 : Disjoint t₁ t₂ := h_disjoint
        have h_inter_a_t1 : 2 ≤ (a ∩ t₁).card := ha'
        apply disjoint_triangles_implies_neighbors_edge_disjoint t₁ t₂ a;
        · exact ha.2;
        · assumption;
        · exact h_inter_a_t1;
      exact h_inter_t2_a
    have h_inter_t2_b : (b ∩ t₂).card ≤ 1 := by
      have := disjoint_triangles_implies_neighbors_edge_disjoint t₁ t₂ b hb.2 h_disjoint hb';
      exact this;
    exact ⟨ ⟨ fun _ => by linarith, fun _ => by linarith ⟩, ⟨ fun _ => by rw [ Finset.inter_comm ] ; linarith, fun _ => by linarith ⟩, fun _ => by rw [ Finset.inter_comm ] ; linarith, fun _ => by rw [ Finset.inter_comm ] ; linarith ⟩;
  -- Since {a, b, t₂} is a triangle packing, its size must be less than or equal to the triangle packing number of G.
  have h_packing_size : ({a, b, t₂} : Finset (Finset V)).card ≤ trianglePackingNumber G := by
    unfold trianglePackingNumber;
    have h_packing_size : ({a, b, t₂} : Finset (Finset V)).card ∈ Finset.image Finset.card (Finset.filter (IsTrianglePacking G) (G.cliqueFinset 3).powerset) := by
      refine' Finset.mem_image.mpr ⟨ _, _, rfl ⟩;
      simp_all +decide [ IsTrianglePacking ];
    have := Finset.le_max h_packing_size;
    cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( IsTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
  rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] at h_packing_size <;> simp_all +decide;
  · rintro rfl; simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
    rw [ Finset.inter_comm ] at h_disjoint ; aesop;
  · constructor <;> rintro rfl <;> simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
    · have := hb.card_eq; aesop;
    · simp_all +decide [ Finset.inter_comm ]