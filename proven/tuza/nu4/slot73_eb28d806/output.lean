/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eb28d806-6d26-45b3-9923-eb6b6f947344

Sorry, Aristotle crashed (error code: 9). Please try again.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical

variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def trianglesContainingVertex (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => v ∈ t)

def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ D ≠ A ∧ A ≠ C ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧ (D ∩ A).card = 1 ∧
  (A ∩ C).card = 0 ∧ (B ∩ D).card = 0

lemma triangles_containing_v_covered_by_spokes (G : SimpleGraph V) [DecidableRel G.Adj]
    (v : V) (hv : (G.neighborFinset v).card ≥ 2) :
    ∃ E' : Finset (Sym2 V), E'.card ≤ (G.neighborFinset v).card ∧ E' ⊆ G.edgeFinset ∧
    ∀ t ∈ trianglesContainingVertex G v, ∃ e ∈ E', e ∈ t.sym2 := by
      refine' ⟨ Finset.image ( fun w => Sym2.mk ( v, w ) ) ( G.neighborFinset v ), _, _, _ ⟩;
      · exact Finset.card_image_le;
      · intro e he
        aesop;
      · unfold trianglesContainingVertex;
        simp +decide [ Finset.mem_image, SimpleGraph.cliqueFinset ];
        intro t ht hv
        obtain ⟨w, hw⟩ : ∃ w ∈ t, w ≠ v := by
          exact Finset.exists_mem_ne ( by rw [ ht.card_eq ] ; decide ) v;
        exact ⟨ w, by have := ht.1 ( show v ∈ t from hv ) ( show w ∈ t from hw.1 ) ; aesop ⟩

lemma cycle4_element_contains_shared (G : SimpleGraph V) [DecidableRel G.Adj]
    (X : Finset V) (v_left v_right x1 : V)
    (hX_eq : X = {v_left, v_right, x1})
    (h_ne : v_left ≠ v_right ∧ v_left ≠ x1 ∧ v_right ≠ x1)
    (t : Finset V) (ht : t ∈ trianglesSharingEdge G X) :
    v_left ∈ t ∨ v_right ∈ t := by
  simp only [trianglesSharingEdge, Finset.mem_filter] at ht
  have h_share : (t ∩ X).card ≥ 2 := ht.2
  rw [hX_eq] at h_share
  -- t shares ≥2 vertices with {v_left, v_right, x1}
  -- Every pair contains v_left or v_right (since x1 is the only "base" vertex)
  by_contra h_neither
  push_neg at h_neither
  -- t doesn't contain v_left or v_right, so t ∩ {v_left, v_right, x1} ⊆ {x1}
  have hsub : t ∩ {v_left, v_right, x1} ⊆ {x1} := by
    intro x hx
    simp only [Finset.mem_inter, Finset.mem_insert, Finset.mem_singleton] at hx ⊢
    rcases hx.2 with rfl | rfl | rfl
    · exact absurd hx.1 h_neither.1
    · exact absurd hx.1 h_neither.2
    · rfl
  have hcard : (t ∩ {v_left, v_right, x1}).card ≤ 1 := by
    calc (t ∩ {v_left, v_right, x1}).card ≤ ({x1} : Finset V).card := Finset.card_le_card hsub
      _ = 1 := Finset.card_singleton x1
  omega

lemma cycle4_no_loose_triangles (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hcycle : isCycle4 M A B C D)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    t ∈ trianglesSharingEdge G A ∨ t ∈ trianglesSharingEdge G B ∨
    t ∈ trianglesSharingEdge G C ∨ t ∈ trianglesSharingEdge G D := by
      -- Since A, B, C, D are triangles in the cycle, any triangle t in G's cliqueFinset 3 must intersect at least one of these triangles in at least two vertices.
      have h_intersect : ∃ X ∈ ({A, B, C, D} : Finset (Finset V)), (t ∩ X).card ≥ 2 := by
        obtain ⟨X, hX⟩ : ∃ X ∈ M, (t ∩ X).card ≥ 2 := by
          by_contra h_contra;
          -- Since $M$ is a maximum triangle packing, adding $t$ to $M$ would still give a packing, contradicting the maximality of $M$.
          have h_add_t : isTrianglePacking G (M ∪ {t}) := by
            refine' ⟨ _, _ ⟩;
            · have := hM.1;
              exact Finset.union_subset this.1 ( Finset.singleton_subset_iff.mpr ht );
            · intro x hx y hy hxy;
              cases' Finset.mem_union.mp hx with hx hx <;> cases' Finset.mem_union.mp hy with hy hy <;> simp_all +decide;
              · have := hM.1;
                have := this.2 hx hy hxy; aesop;
              · simpa only [ Finset.inter_comm ] using Nat.le_of_lt_succ ( h_contra x hx );
              · exact Nat.le_of_lt_succ ( h_contra y hy );
          have h_card : (M ∪ {t}).card > M.card := by
            simp +zetaDelta at *;
            rw [ Finset.card_insert_of_notMem ] ; aesop;
            intro h; specialize h_contra t h; simp_all +decide [ Finset.inter_comm ] ;
            exact h_contra.not_le ( by rw [ ht.card_eq ] ; decide );
          have h_max : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ trianglePackingNumber G := by
            unfold trianglePackingNumber;
            intro M' hM'
            have h_subset : M' ⊆ G.cliqueFinset 3 := by
              exact hM'.1;
            have h_max : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
              exact Finset.mem_image.mpr ⟨ M', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr h_subset, hM' ⟩, rfl ⟩;
            have := Finset.le_max h_max;
            cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
          exact h_card.not_le ( le_trans ( h_max _ h_add_t ) ( hM.2 ▸ le_rfl ) );
        cases hcycle ; aesop;
      unfold trianglesSharingEdge; aesop;

lemma cycle4_all_triangles_contain_shared (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hcycle : isCycle4 M A B C D)
    (v_ab v_bc v_cd v_da : V)
    (hAB : A ∩ B = {v_ab}) (hBC : B ∩ C = {v_bc})
    (hCD : C ∩ D = {v_cd}) (hDA : D ∩ A = {v_da})
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    v_ab ∈ t ∨ v_bc ∈ t ∨ v_cd ∈ t ∨ v_da ∈ t := by
  -- Every triangle shares edge with some packing element
  obtain h_case := cycle4_no_loose_triangles G M hM A B C D hcycle t ht
  -- Each packing element X contributes triangles containing v_left OR v_right
  -- where v_left, v_right are the shared vertices adjacent to X
  rcases h_case with hA | hB | hC | hD
  · -- t shares edge with A, so t contains v_ab or v_da
    -- A = {v_ab, v_da, a1} for some a1
    -- Since $t \in \text{trianglesSharingEdge } G A$, we have $|t \cap A| \geq 2$. But $A \cap B = \{v_ab\}$, so $t$ must contain $v_ab$.
    have h_inter_A : (t ∩ A).card ≥ 2 := by
      unfold trianglesSharingEdge at hA; aesop;
    contrapose! h_inter_A; simp_all +decide [ Finset.ext_iff ] ;
    -- Since $t$ does not contain $v_ab$, $v_bc$, $v_cd$, or $v_da$, the intersection $t \cap A$ can only contain elements that are in $A$ but not in $B$, $C$, $D$, or $A$ itself.
    have h_inter_A_subset : t ∩ A ⊆ A \ {v_ab, v_bc, v_cd, v_da} := by
      intro x hx; aesop;
    have h_inter_A_card : (A \ {v_ab, v_bc, v_cd, v_da}).card ≤ 1 := by
      have h_inter_A_card : A.card = 3 := by
        have hA_card : A ∈ G.cliqueFinset 3 := by
          have hA_triangle : A ∈ M := by
            cases hcycle ; aesop;
          have := hM.1;
          exact this.1 hA_triangle;
        exact Finset.mem_filter.mp hA_card |>.2.2.symm ▸ rfl;
      have h_inter_A_card : (A ∩ {v_ab, v_bc, v_cd, v_da}).card ≥ 2 := by
        have h_inter_A_card : v_ab ∈ A ∧ v_da ∈ A := by
          exact ⟨ by specialize hAB v_ab; aesop, by specialize hDA v_da; aesop ⟩;
        have h_inter_A_card : v_ab ≠ v_da := by
          rintro rfl; have := hcycle.2; simp_all +decide ;
          simp_all +decide [ Finset.ext_iff ];
          grind +ring;
        exact Finset.one_lt_card.mpr ⟨ v_ab, by aesop, v_da, by aesop ⟩;
      grind;
    exact lt_of_le_of_lt ( Finset.card_le_card h_inter_A_subset ) ( Nat.lt_succ_of_le h_inter_A_card ) -- Apply cycle4_element_contains_shared
  · -- t shares edge with B, so t contains v_ab or v_bc
    unfold trianglesSharingEdge at hB;
    simp +zetaDelta at *;
    contrapose! hB;
    -- Since $t$ does not contain $v_ab$ or $v_bc$, the intersection $t \cap B$ can only contain elements of $B$ that are not $v_ab$ or $v_bc$.
    have h_inter_B : t ∩ B ⊆ B \ {v_ab, v_bc} := by
      simp_all +decide [ Finset.subset_iff ];
      exact fun x hx hx' => ⟨ by rintro rfl; exact hB.1 hx, by rintro rfl; exact hB.2.1 hx ⟩;
    have h_card_B : B.card = 3 := by
      have := hM.1.1;
      have := this (hcycle.1.symm ▸ Finset.mem_insert_of_mem (Finset.mem_insert_self _ _)) ; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
    have h_card_B_minus : (B \ {v_ab, v_bc}).card ≤ 1 := by
      rw [ Finset.card_sdiff ] ; simp_all +decide [ Finset.subset_iff ];
      -- Since $v_ab$ and $v_bc$ are both in $B$, the intersection $\{v_ab, v_bc\} \cap B$ is exactly $\{v_ab, v_bc\}$, which has cardinality 2.
      have h_inter_B_card : ({v_ab, v_bc} ∩ B) = {v_ab, v_bc} := by
        simp_all +decide [ Finset.ext_iff ];
        exact ⟨ by specialize hAB v_ab; aesop, by specialize hBC v_bc; aesop ⟩;
      -- Since $v_ab$ and $v_bc$ are distinct, the set $\{v_ab, v_bc\}$ has cardinality 2.
      have h_distinct : v_ab ≠ v_bc := by
        rintro rfl; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
        have := hcycle.2.2.2.2.2.2.2.2.2.2.2; simp_all +decide [ Finset.ext_iff ] ;
      rw [ h_inter_B_card, Finset.card_insert_of_notMem, Finset.card_singleton ] ; aesop;
    exact fun _ => lt_of_le_of_lt ( Finset.card_le_card h_inter_B ) ( Nat.lt_succ_of_le h_card_B_minus )
  · -- t shares edge with C, so t contains v_bc or v_cd
    unfold trianglesSharingEdge at hC;
    rw [ Finset.mem_filter ] at hC;
    contrapose! hC;
    -- Since $t$ is a triangle in $G$, it has exactly 3 elements. Since $t$ does not contain $v_ab$, $v_bc$, $v_cd$, or $v_da$, the intersection $t \cap C$ can only contain elements that are in $C$ but not in $t$.
    have h_inter_C : t ∩ C ⊆ C \ {v_bc, v_cd} := by
      grind;
    have h_inter_C_card : (C \ {v_bc, v_cd}).card ≤ 1 := by
      have hC_card : C.card = 3 := by
        have := hcycle.1;
        have := hM.1;
        have := this.1; simp_all +decide [ Finset.subset_iff ] ;
        exact this.2.2.1.2;
      rw [ Finset.card_sdiff ];
      -- Since $v_bc$ and $v_cd$ are distinct elements in $C$, their intersection with $C$ is exactly $\{v_bc, v_cd\}$.
      have h_inter_C_card : ({v_bc, v_cd} ∩ C).card = 2 := by
        rw [ Finset.inter_comm, Finset.card_eq_two ];
        use v_bc, v_cd;
        simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
        rintro rfl;
        have := hcycle.2.2.2.2.2.2.2.2.2.2; simp_all +decide [ Finset.ext_iff ] ;
      rw [ hC_card, h_inter_C_card ];
    exact fun _ => lt_of_le_of_lt ( Finset.card_le_card h_inter_C ) ( Nat.lt_succ_of_le h_inter_C_card )
  · -- t shares edge with D, so t contains v_cd or v_da
    have hTDA : v_da ∈ D ∧ v_cd ∈ D := by
      rw [ Finset.eq_singleton_iff_unique_mem ] at * ; aesop;
    contrapose! hD; simp_all +decide [ Finset.inter_comm ] ;
    unfold trianglesSharingEdge; simp_all +decide [ Finset.inter_comm ] ;
    -- Since $v_da$ and $v_cd$ are not in $t$, the intersection $D \cap t$ can only contain elements from $D$ that are not $v_da$ or $v_cd$.
    have h_inter_subset : D ∩ t ⊆ D \ {v_da, v_cd} := by
      grind;
    have h_inter_card : (D \ {v_da, v_cd}).card ≤ 1 := by
      have h_inter_card : D.card = 3 := by
        -- Since $D$ is a triangle in the cycle4, it must have exactly three elements.
        have hD_card : D ∈ G.cliqueFinset 3 := by
          have := hM.1;
          exact this.1 ( by rw [ hcycle.1 ] ; simp +decide );
        exact Finset.mem_filter.mp hD_card |>.2.2;
      by_cases h : v_da = v_cd <;> simp_all +decide [ Finset.card_sdiff ];
      have := hcycle.2; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
      simp_all +decide [ Finset.ext_iff ];
    exact lt_of_le_of_lt ( Finset.card_le_card h_inter_subset ) ( Nat.lt_succ_of_le h_inter_card )

lemma exists_three_disjoint_implies_contradiction_simplified (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B : Finset V) (hA : A ∈ M) (hB : B ∈ M) (hAB : A ≠ B)
    (t1 t2 t3 : Finset V)
    (ht1 : t1 ∈ G.cliqueFinset 3) (ht2 : t2 ∈ G.cliqueFinset 3) (ht3 : t3 ∈ G.cliqueFinset 3)
    (h_disj_12 : (t1 ∩ t2).card ≤ 1)
    (h_disj_13 : (t1 ∩ t3).card ≤ 1)
    (h_disj_23 : (t2 ∩ t3).card ≤ 1)
    (h_compat : ∀ Z ∈ M, Z ≠ A → Z ≠ B → (t1 ∩ Z).card ≤ 1 ∧ (t2 ∩ Z).card ≤ 1 ∧ (t3 ∩ Z).card ≤ 1) :
    False := by
      have hM' : (M \ {A, B} ∪ {t1, t2, t3}).card > M.card := by
        by_cases h1 : t1 = t2 <;> by_cases h2 : t1 = t3 <;> by_cases h3 : t2 = t3 <;> simp_all +decide;
        · have := ht3.card_eq; aesop;
        · have := ht2.card_eq; aesop;
        · exact absurd h_disj_13 ( by have := ht3.card_eq; aesop );
        · have := ht3.card_eq; aesop;
        · rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> simp +decide [ *, Finset.sdiff_insert ];
          · grind;
          · intro h4 h5;
            have := hM.1.1 h5; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            specialize h_compat t3 h5 ; aesop;
          · contrapose! h_compat;
            use t2;
            simp_all +decide [ SimpleGraph.isNClique_iff ];
          · intro h4 h5; specialize h_compat t1 h5; simp_all +decide [ Finset.inter_comm ] ;
            exact Classical.not_not.1 fun h => absurd ( h_compat h ) ( by linarith [ ht1.card_eq ] );
      have hM'_packing : isTrianglePacking G (M \ {A, B} ∪ {t1, t2, t3}) := by
        unfold isTrianglePacking at *;
        simp_all +decide [ Finset.subset_iff, Set.Pairwise ];
        refine' ⟨ _, _, _, _ ⟩;
        · have := hM.1;
          exact fun x hx hx' hx'' => by have := this.1 hx; exact Finset.mem_filter.mp this |>.2;
        · exact fun _ => by rwa [ Finset.inter_comm ] ;
        · exact ⟨ fun _ => by rwa [ Finset.inter_comm ], fun _ => by rwa [ Finset.inter_comm ] ⟩;
        · intro Z hZ hZA hZB; specialize h_compat Z hZ hZA hZB; simp_all +decide [ Finset.inter_comm ] ;
          have := hM.1; unfold isTrianglePacking at this; aesop;
      have h_max : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ M.card := by
        intro M' hM'_packing
        have h_max : M'.card ≤ trianglePackingNumber G := by
          unfold trianglePackingNumber;
          have h_max : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
            exact Finset.mem_image.mpr ⟨ M', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_iff.mpr fun x hx => by have := hM'_packing.1 hx; aesop ), hM'_packing ⟩, rfl ⟩;
          have := Finset.le_max h_max;
          cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 ).powerset ) ) <;> aesop;
        exact h_max.trans ( hM.2.ge );
      exact not_le_of_gt hM' ( h_max _ hM'_packing )

def M_edges_at (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (v : V) : Finset (Sym2 V) :=
  M.biUnion (fun X => X.sym2.filter (fun e => v ∈ e))

lemma local_cover_le_2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B : Finset V) (hA : A ∈ M) (hB : B ∈ M) (hAB : A ≠ B)
    (v : V) (h_inter : A ∩ B = {v})
    (h_only : ∀ Z ∈ M, v ∈ Z → Z = A ∨ Z = B) :
    ∃ E' : Finset (Sym2 V), E'.card ≤ 2 ∧ E' ⊆ M_edges_at G M v ∧
    ∀ t ∈ G.cliqueFinset 3, v ∈ t →
      (∃ e ∈ M_edges_at G M v, e ∈ t.sym2) →
      (∃ e ∈ E', e ∈ t.sym2) := by
  let E_all := M_edges_at G M v
  -- We want to find E' subset E_all, |E'| <= 2, covering all supported triangles.
  -- Proof by contradiction: Suppose not.
  -- Then for every pair of edges in E_all, there is a triangle not covered.
  -- E_all has size 4.
  -- But we only care about "active" edges.
  -- Let E_active = {e in E_all | exists t, e in t}.
  -- If |E_active| <= 2, we pick E_active. Done.
  -- If |E_active| >= 3.
  -- Let e1, e2, e3 in E_active.
  -- Suppose no pair covers everything.
  -- Then {e1, e2} misses some t3.
  -- t3 must be on e3 (or e4).
  -- If t3 on e3, and not e1, e2.
  -- {e1, e3} misses t2. t2 on e2.
  -- {e2, e3} misses t1. t1 on e1.
  -- So we have t1 on e1 only, t2 on e2 only, t3 on e3 only.
  -- These are disjoint.
  -- Contradiction.
  contrapose! hM;
  have h1 := hM ∅; have h2 := hM { Sym2.mk ( v, v ) } ; simp_all +decide ;
  obtain ⟨ t, ht1, ht2, e, he1, he2 ⟩ := h1; specialize h2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
  unfold M_edges_at at *; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
  obtain ⟨ a, ha1, ha2, ha3 ⟩ := he1; specialize h2 a ha1; aesop;

lemma cycle4_triangle_at_vertex_supported (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (A : Finset V) (hA : A ∈ M)
    (v : V) (hv : v ∈ A)
    (t : Finset V) (ht : t ∈ trianglesSharingEdge G A) (hvt : v ∈ t) :
    ∃ e ∈ M_edges_at G M v, e ∈ t.sym2 := by
      -- Since $t$ is a triangle containing $v$ and sharing an edge with $A$, there must be an edge in $t$ that is also in $A$.
      obtain ⟨x, hx⟩ : ∃ x ∈ t, x ≠ v ∧ x ∈ A := by
        -- Since $t$ is in the trianglesSharingEdge $G$ $A$, there must be at least two elements in $t \cap A$.
        have h_inter_card : (t ∩ A).card ≥ 2 := by
          unfold trianglesSharingEdge at ht; aesop;
        exact Exists.imp ( by aesop ) ( Finset.exists_mem_ne h_inter_card v );
      refine' ⟨ Sym2.mk ( v, x ), _, _ ⟩ <;> simp_all +decide [ M_edges_at ];
      aesop

lemma cycle4_intersection_pigeonhole {V : Type*} [DecidableEq V] [Fintype V]
    (A : Finset V) (v1 v2 : V)
    (h_subset : {v1, v2} ⊆ A)
    (h_distinct : v1 ≠ v2)
    (h_card : A.card = 3)
    (t : Finset V) (h_share : (t ∩ A).card ≥ 2) :
    v1 ∈ t ∨ v2 ∈ t := by
      contrapose! h_share;
      -- Since $t$ does not contain $v1$ or $v2$, the intersection $t \cap A$ can only contain the third vertex of $A$, if it exists.
      have h_third_vertex : t ∩ A ⊆ A \ {v1, v2} := by
        -- Since $t$ does not contain $v1$ or $v2$, any element in $t \cap A$ must be in $A$ but not in $\{v1, v2\}$.
        intros x hx
        aesop;
      -- Since $A \ {v1, v2}$ has at most one element, the intersection $t \cap A$ can have at most one element.
      have h_card_A_minus_v1v2 : (A \ {v1, v2}).card ≤ 1 := by
        rw [ Finset.card_sdiff ] ; simp_all +decide [ Finset.subset_iff ];
      exact lt_of_le_of_lt ( Finset.card_le_card h_third_vertex ) ( Nat.lt_succ_of_le h_card_A_minus_v1v2 )

lemma cycle4_cover_triangle_at_element (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A : Finset V) (hA : A ∈ M)
    (v1 v2 : V) (hv1 : v1 ∈ A) (hv2 : v2 ∈ A) (h_ne : v1 ≠ v2)
    (E1 E2 : Finset (Sym2 V))
    (hE1 : ∀ t' ∈ G.cliqueFinset 3, v1 ∈ t' → (∃ e ∈ M_edges_at G M v1, e ∈ t'.sym2) → ∃ e ∈ E1, e ∈ t'.sym2)
    (hE2 : ∀ t' ∈ G.cliqueFinset 3, v2 ∈ t' → (∃ e ∈ M_edges_at G M v2, e ∈ t'.sym2) → ∃ e ∈ E2, e ∈ t'.sym2)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (h_share : t ∈ trianglesSharingEdge G A) :
    ∃ e ∈ E1 ∪ E2, e ∈ t.sym2 := by
      by_cases h_cases : v1 ∈ t ∨ v2 ∈ t;
      · cases' h_cases with h_case1 h_case2;
        · specialize hE1 t ht h_case1;
          exact Exists.elim ( hE1 <| by
            exact? ) fun e he => ⟨ e, Finset.mem_union_left _ he.1, he.2 ⟩;
        · obtain ⟨ e, he₁, he₂ ⟩ := hE2 t ht h_case2 ( by
            exact? );
          exact ⟨ e, Finset.mem_union_right _ he₁, he₂ ⟩;
      · unfold trianglesSharingEdge at h_share; simp_all +decide ;
        have h_contra : (t ∩ A).card ≤ 1 := by
          have h_card : (t ∩ A).card ≤ (A \ {v1, v2}).card := by
            exact Finset.card_le_card fun x hx => by aesop;
          have h_card : A.card = 3 := by
            have h_card : A ∈ G.cliqueFinset 3 := by
              have := hM.1;
              exact this.1 hA;
            exact Finset.mem_filter.mp h_card |>.2.2;
          grind;
        linarith

lemma cycle4_element_covered_by_locals (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A : Finset V) (hA : A ∈ M)
    (v1 v2 : V) (hv1 : v1 ∈ A) (hv2 : v2 ∈ A) (h_ne : v1 ≠ v2)
    (E1 E2 : Finset (Sym2 V))
    (hE1 : ∀ t' ∈ G.cliqueFinset 3, v1 ∈ t' → (∃ e ∈ M_edges_at G M v1, e ∈ t'.sym2) → ∃ e ∈ E1, e ∈ t'.sym2)
    (hE2 : ∀ t' ∈ G.cliqueFinset 3, v2 ∈ t' → (∃ e ∈ M_edges_at G M v2, e ∈ t'.sym2) → ∃ e ∈ E2, e ∈ t'.sym2)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (h_share : t ∈ trianglesSharingEdge G A) :
    ∃ e ∈ E1 ∪ E2, e ∈ t.sym2 := by
      by_contra h_contra;
      apply_rules [ cycle4_cover_triangle_at_element ];
      exact Classical.not_not.1 fun h => h_contra <| cycle4_cover_triangle_at_element G M hM A hA v1 v2 hv1 hv2 h E1 E2 hE1 hE2 t ht h_share