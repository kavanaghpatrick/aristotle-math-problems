/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f0a24a15-b394-4405-bc43-6373f0c73bf7

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def T_pair (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  trianglesSharingEdge G e ∪ trianglesSharingEdge G f

-- X_ef: bridges between e and f
def X_ef (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2)

def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ D ≠ A ∧ A ≠ C ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧ (D ∩ A).card = 1 ∧
  (A ∩ C).card = 0 ∧ (B ∩ D).card = 0

def isCovering (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧ ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2

lemma isCovering_union (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) (EA EB : Finset (Sym2 V))
    (hA : isCovering G A EA) (hB : isCovering G B EB) :
    isCovering G (A ∪ B) (EA ∪ EB) := by
  -- By definition of $isCovering$, we know that $EA$ covers $A$ and $EB$ covers $B$ by removing one edge from each clique in $A$ and $B$.
  apply And.intro;
  · exact Finset.union_subset hA.1 hB.1;
  · -- By definition of $isCovering$, we know that for any triangle $t$ in $A$, there exists an edge $e$ in $EA$ such that $e$ is in $t$'s sym2.
    intro t ht
    cases' Finset.mem_union.mp ht with htA htB
    · obtain ⟨e, heEA, heT⟩ := hA.right t htA
      exact ⟨e, Finset.mem_union_left _ heEA, heT⟩
    · obtain ⟨e, heEB, heT⟩ := hB.right t htB
      exact ⟨e, Finset.mem_union_right _ heEB, heT⟩

def hasCovering (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : Prop :=
  ∃ E' ⊆ G.edgeFinset, ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2

lemma exists_min_covering (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V))
    (h : hasCovering G triangles) :
    ∃ E', isCovering G triangles E' ∧ E'.card = triangleCoveringNumberOn G triangles := by
  have h_covering_number : ∃ E' ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)), E'.card = (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0) := by
    have h_exists : ∃ E' ∈ Finset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset (G.edgeFinset)), ∀ E'' ∈ Finset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset (G.edgeFinset)), E'.card ≤ E''.card := by
      apply_rules [ Finset.exists_min_image ];
      obtain ⟨ E', hE' ⟩ := h;
      exact ⟨ E', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hE'.1, hE'.2 ⟩ ⟩;
    obtain ⟨ E', hE₁, hE₂ ⟩ := h_exists;
    have h_exists_min : (Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset (G.edgeFinset)))).min = some E'.card := by
      refine' le_antisymm _ _;
      · exact Finset.min_le ( Finset.mem_image_of_mem _ hE₁ );
      · simp +zetaDelta at *;
        exact fun a x hx₁ hx₂ hx₃ => hx₃ ▸ WithTop.coe_le_coe.mpr ( hE₂ x hx₁ hx₂ );
    exact ⟨ E', hE₁, h_exists_min.symm ▸ rfl ⟩;
  unfold isCovering triangleCoveringNumberOn; aesop;

lemma covering_ge_tau (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V))
    (E' : Finset (Sym2 V)) (h : isCovering G triangles E') :
    triangleCoveringNumberOn G triangles ≤ E'.card := by
  -- By definition of triangle covering number, we know that for any covering E', the cardinality of E' is at least the triangle covering number.
  have h_triangle_covering : ∀ E' : Finset (Sym2 V), isCovering G triangles E' → triangleCoveringNumberOn G triangles ≤ E'.card := by
    intro E' hE'
    have h_min : Option.getD (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2})).min 0 ≤ Finset.card E' := by
      have h_subset : E' ∈ Finset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) G.edgeFinset.powerset := by
        unfold isCovering at hE'; aesop;
      have h_min : ∀ {S : Finset ℕ}, S.Nonempty → ∀ x ∈ S, Option.getD (Finset.min S) 0 ≤ x := by
        -- The minimum of a finite set is the least element, so for any x in S, min(S) ≤ x.
        intros S hS_nonempty x hx
        have h_min_le_x : Finset.min S ≤ x := by
          exact Finset.min_le hx;
        cases h : Finset.min S <;> aesop;
      exact h_min ⟨ _, Finset.mem_image_of_mem _ h_subset ⟩ _ ( Finset.mem_image_of_mem _ h_subset );
    exact?;
  exact h_triangle_covering E' h

lemma always_has_covering (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V))
    (h_subset : triangles ⊆ G.cliqueFinset 3) :
    hasCovering G triangles := by
  have h_edge_set : ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧ (∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) := by
    have h_edge_set : ∀ t ∈ triangles, ∃ e ∈ G.edgeFinset, e ∈ t.sym2 := by
      intro t ht
      have ht_clique : t.card = 3 := by
        exact Finset.mem_filter.mp ( h_subset ht ) |>.2.2
      have ht_edges : ∀ v ∈ t, ∀ w ∈ t, v ≠ w → (Sym2.mk (v, w)) ∈ G.edgeFinset := by
        intro v hv w hw hvw; have := h_subset ht; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
        exact this.1 hv hw hvw
      generalize_proofs at *;
      obtain ⟨ v, hv, w, hw, hne ⟩ := Finset.one_lt_card.1 ( by linarith : 1 < Finset.card t ) ; exact ⟨ s(v, w), ht_edges v hv w hw hne, by aesop ⟩ ;
    exact ⟨ G.edgeFinset, Finset.Subset.refl _, h_edge_set ⟩;
  exact h_edge_set

lemma tau_eq_zero_of_no_covering (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V))
    (h : ¬ hasCovering G triangles) :
    triangleCoveringNumberOn G triangles = 0 := by
  -- If there's no covering, then the triangle covering number must be zero because there's no way to cover the triangles with any edges.
  simp [triangleCoveringNumberOn, h];
  -- Since the set is empty, the minimum of the image of the cardinalities is zero.
  have h_empty : Finset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', ∀ a ∈ e, a ∈ t) (G.edgeFinset.powerset) = ∅ := by
    ext E'
    simp [hasCovering] at h;
    specialize h E' ; aesop;
  -- Since the set is empty, the minimum of the image of the cardinalities is zero because the image is also empty.
  simp [h_empty, Finset.min];
  rfl

theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) :
    triangleCoveringNumberOn G (A ∪ B) ≤
    triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by
  by_cases h_cov : hasCovering G (A ∪ B)
  · -- Case: Covering exists
    have h_cov_A : hasCovering G A := by
      obtain ⟨E, hE_sub, hE_cov⟩ := h_cov
      use E, hE_sub
      intro t ht
      exact hE_cov t (Finset.mem_union_left B ht)
    have h_cov_B : hasCovering G B := by
      obtain ⟨E, hE_sub, hE_cov⟩ := h_cov
      use E, hE_sub
      intro t ht
      exact hE_cov t (Finset.mem_union_right A ht)
      
    obtain ⟨EA, hEA_cov, hEA_card⟩ := exists_min_covering G A h_cov_A
    obtain ⟨EB, hEB_cov, hEB_card⟩ := exists_min_covering G B h_cov_B
    
    have h_union_cov : isCovering G (A ∪ B) (EA ∪ EB) := isCovering_union G A B EA EB hEA_cov hEB_cov
    
    calc triangleCoveringNumberOn G (A ∪ B) 
      ≤ (EA ∪ EB).card := covering_ge_tau G (A ∪ B) (EA ∪ EB) h_union_cov
    _ ≤ EA.card + EB.card := Finset.card_union_le EA EB
    _ = triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by rw [hEA_card, hEB_card]
    
  · -- Case: No covering
    rw [tau_eq_zero_of_no_covering G (A ∪ B) h_cov]
    exact Nat.zero_le _

lemma triangle_shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ e ∈ M, (t ∩ e).card ≥ 2 := by
      have := hM.1;
      contrapose! hM;
      -- If $t$ does not share an edge with any triangle in $M$, then $M \cup \{t\}$ is also a packing.
      have h_union_packing : isTrianglePacking G (M ∪ {t}) := by
        -- Since $t$ is a triangle and $M$ is a packing, any two triangles in $M \cup \{t\}$ must share at most one edge.
        have h_pairwise : Set.Pairwise (M ∪ {t} : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1) := by
          simp_all +decide [ Set.Pairwise, Finset.subset_iff ];
          exact ⟨ fun x hx hx' => Nat.le_of_lt_succ ( hM x hx ), fun x hx => ⟨ fun hx' => Nat.le_of_lt_succ ( by simpa only [ Finset.inter_comm ] using hM x hx ), fun y hy hy' => this.2 hx hy ( by aesop ) ⟩ ⟩;
        -- Since $M$ is a packing and $t$ is a triangle, their union $M \cup \{t\}$ is also a packing.
        simp [isTrianglePacking, this, ht];
        simp_all +decide [ Finset.subset_iff, Set.Pairwise ];
        exact fun x hx => Finset.mem_filter.mp ( this.1 hx ) |>.2;
      -- Since $M \cup \{t\}$ is also a packing, its cardinality is strictly greater than $M$'s cardinality.
      have h_card_union : (M ∪ {t}).card > M.card := by
        by_cases h : t ∈ M <;> simp_all +decide;
        specialize hM t h;
        simp_all +decide [ SimpleGraph.isNClique_iff ];
      unfold isMaxPacking;
      simp_all +decide [ trianglePackingNumber ];
      refine' ne_of_lt ( lt_of_lt_of_le h_card_union _ );
      have h_max : (Insert.insert t M).card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
        simp +zetaDelta at *;
        exact ⟨ _, ⟨ Finset.insert_subset_iff.mpr ⟨ by aesop, this.1 ⟩, h_union_packing ⟩, rfl ⟩;
      have := Finset.le_max h_max;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop

-- ══════════════════════════════════════════════════════════════════════════════
-- KEY LEMMA: Bridges are subset of T_pair
-- ══════════════════════════════════════════════════════════════════════════════

-- X_DA ⊆ T_pair(A,B) because any bridge sharing edge with D and A
-- also shares edge with A, hence is in trianglesSharingEdge(A) ⊆ T_pair(A,B)
lemma bridges_subset_tpair (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B D : Finset V) :
    X_ef G D A ⊆ T_pair G A B := by
      -- By definition of $X_{ef}$ and $T_{pair}$, any triangle in $X_{ef} G D A$ must already be in $T_{pair} G A B$ because $D$ is part of the triangles that share an edge with $A$ and $B$. Therefore, $X_{ef} G D A \subseteq T_{pair} G A B$.
      intros t ht
      simp [X_ef, T_pair] at ht ⊢;
      unfold trianglesSharingEdge; aesop;

-- Similarly for other bridges
lemma bridges_BC_subset_tpair_CD (G : SimpleGraph V) [DecidableRel G.Adj]
    (B C D : Finset V) :
    X_ef G B C ⊆ T_pair G C D := by
      exact?

-- ══════════════════════════════════════════════════════════════════════════════
-- MAIN: Cycle reduction to path
-- ══════════════════════════════════════════════════════════════════════════════

-- The cycle A—B—C—D—A can be "cut" to path A—B—C—D
-- The extra D—A adjacency only adds X_DA bridges
-- But X_DA ⊆ T_pair(A,B), so the union is unchanged!
lemma cycle4_same_as_path4_union (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B C D : Finset V) :
    T_pair G A B ∪ T_pair G C D = T_pair G A B ∪ T_pair G C D ∪ X_ef G D A := by
      -- Since $X_{DA}$ is a subset of $T_{AB} \cup T_{CD}$, adding it to the union does not change the set.
      have h_subset : X_ef G D A ⊆ T_pair G A B ∪ T_pair G C D := by
        -- Let $t$ be any triangle in $X_{DA}$. By definition, $t$ shares an edge with both $D$ and $A$.
        intro t ht
        obtain ⟨hDA, hA⟩ : (t ∩ D).card ≥ 2 ∧ (t ∩ A).card ≥ 2 := by
          unfold X_ef at ht; aesop;
        -- Since $t$ shares an edge with both $D$ and $A$, it must be in $X_{DA}$.
        simp [X_ef] at ht ⊢;
        exact Or.inl ( Finset.mem_union_left _ ( Finset.mem_filter.mpr ⟨ Finset.mem_coe.mpr ( Finset.mem_coe.mpr ( by aesop ) ), hA ⟩ ) );
      rw [ Finset.union_eq_left.mpr h_subset ]