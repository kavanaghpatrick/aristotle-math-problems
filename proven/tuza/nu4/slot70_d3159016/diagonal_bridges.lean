/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d3159016-c9f4-49ac-8078-3066257e15a7

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- Definitions (same as other slots)
def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

-- S_e: triangles sharing edge with e but not with any other packing element
def S_e (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ ∀ f ∈ M, f ≠ e → (t ∩ f).card ≤ 1)

-- X_ef: bridges between e and f (triangles sharing edge with both)
def X_ef (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2)

def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ D ≠ A ∧ A ≠ C ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧ (D ∩ A).card = 1 ∧
  (A ∩ C).card = 0 ∧ (B ∩ D).card = 0

-- Helper: packing elements are triangles (card 3)
lemma packing_elem_card_3 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M) : e.card = 3 := by
  -- M is a triangle packing, so e ∈ cliqueFinset 3
  have h_sub := hM.1.1
  have he_clique := h_sub he
  simp only [SimpleGraph.mem_cliqueFinset_iff, SimpleGraph.isNClique_iff] at he_clique
  exact he_clique.2

-- KEY LEMMA: Diagonal pairs have empty bridges
-- If A ∩ C = ∅, no triangle can share an edge with both A and C
lemma diagonal_bridges_empty (G : SimpleGraph V) [DecidableRel G.Adj]
    (A C : Finset V) (hA3 : A.card = 3) (hC3 : C.card = 3)
    (h_disj : (A ∩ C).card = 0) :
    X_ef G A C = ∅ := by
  -- If A and C share no vertex, no triangle can share edge with both
  ext t
  simp only [X_ef, Finset.mem_filter, Finset.not_mem_empty, iff_false]
  intro ⟨ht_clique, h_A, h_C⟩
  -- t has exactly 3 vertices (it's a triangle)
  have ht3 : t.card = 3 := by
    simp only [SimpleGraph.mem_cliqueFinset_iff, SimpleGraph.isNClique_iff] at ht_clique
    exact ht_clique.2
  -- t ∩ A has ≥2 elements, t ∩ C has ≥2 elements
  -- So |t ∩ A| + |t ∩ C| ≥ 4, but t only has 3 vertices
  -- By pigeonhole, t ∩ A and t ∩ C must overlap
  -- Any overlap means A ∩ C ≠ ∅, contradiction
  have h_sum : (t ∩ A).card + (t ∩ C).card ≥ 4 := Nat.add_le_add h_A h_C
  -- But (t ∩ A) ∪ (t ∩ C) ⊆ t, so |(t ∩ A) ∪ (t ∩ C)| ≤ 3
  have h_union_sub : (t ∩ A) ∪ (t ∩ C) ⊆ t := by
    intro x hx
    simp only [Finset.mem_union, Finset.mem_inter] at hx
    rcases hx with ⟨hxt, _⟩ | ⟨hxt, _⟩ <;> exact hxt
  have h_union_card : ((t ∩ A) ∪ (t ∩ C)).card ≤ 3 := by
    calc ((t ∩ A) ∪ (t ∩ C)).card ≤ t.card := Finset.card_le_card h_union_sub
      _ = 3 := ht3
  -- By inclusion-exclusion: |A ∪ B| = |A| + |B| - |A ∩ B|
  -- So |A ∩ B| = |A| + |B| - |A ∪ B| ≥ 4 - 3 = 1
  have h_inter_card : ((t ∩ A) ∩ (t ∩ C)).card ≥ 1 := by
    have h_ie := Finset.card_union_add_card_inter (t ∩ A) (t ∩ C)
    omega
  -- (t ∩ A) ∩ (t ∩ C) = t ∩ (A ∩ C)
  have h_inter_eq : (t ∩ A) ∩ (t ∩ C) = t ∩ (A ∩ C) := by
    ext x
    simp only [Finset.mem_inter]
    tauto
  -- But A ∩ C = ∅, so t ∩ (A ∩ C) = ∅
  rw [h_inter_eq] at h_inter_card
  simp only [Finset.card_eq_zero] at h_disj
  rw [h_disj, Finset.inter_empty] at h_inter_card
  simp at h_inter_card

lemma tau_le_of_exists_cover (G : SimpleGraph V) [DecidableRel G.Adj]
    (T : Finset (Finset V)) (E' : Finset (Sym2 V))
    (h_sub : E' ⊆ G.edgeFinset)
    (h_cover : ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2) :
    triangleCoveringNumberOn G T ≤ E'.card := by
  -- Since $E'$ is a subset of $G.edgeFinset$ and covers $T$, we have $E' \in \{ E'' \subseteq G.edgeFinset \mid E'' \text{ covers } T \}$.
  have h_E'_in_set : E' ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2)) := by
    aesop;
  -- Since $E'$ is in the set of covers, the minimum cardinality of the covers is less than or equal to the cardinality of $E'$.
  have h_min_le_card : ∀ {E'' : Finset (Sym2 V)}, E'' ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2)) → (triangleCoveringNumberOn G T) ≤ E''.card := by
    intro E'' hE'';
    have h_min_le_card : ∀ {s : Finset ℕ}, s.Nonempty → ∀ n ∈ s, (s.min.getD 0) ≤ n := by
      intro s hs n hn; have := Finset.min_le hn; cases h : Finset.min s <;> aesop;
    exact h_min_le_card ⟨ _, Finset.mem_image_of_mem _ hE'' ⟩ _ ( Finset.mem_image_of_mem _ hE'' );
  exact h_min_le_card h_E'_in_set

lemma filter_covers_nonempty (G : SimpleGraph V) [DecidableRel G.Adj]
    (T : Finset (Finset V)) (hT : T ⊆ G.cliqueFinset 3) :
    (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2)).Nonempty := by
  refine' ⟨ _, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.Subset.refl _ ), _ ⟩ ⟩;
  simp_all +decide [ Finset.subset_iff ];
  intro t ht; have := hT ht; rcases this with ⟨ h1, h2 ⟩ ; obtain ⟨ u, v, w, huv, hvw, hwu ⟩ := Finset.card_eq_three.mp h2; use Sym2.mk ( u, v ) ; aesop;

lemma exists_min_cover (G : SimpleGraph V) [DecidableRel G.Adj] (T : Finset (Finset V))
    (hT : T ⊆ G.cliqueFinset 3) :
    ∃ E' ⊆ G.edgeFinset, (∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card = triangleCoveringNumberOn G T := by
  -- By definition of `triangleCoveringNumberOn`, there exists a subset `E'` of `G.edgeFinset` such that `E'` covers all triangles in `T` and `E'.card` is the minimum possible.
  obtain ⟨E', hE'_cover, hE'_card⟩ : ∃ E' ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2)), E'.card = triangleCoveringNumberOn G T := by
    unfold triangleCoveringNumberOn;
    have := Finset.min_of_nonempty ( show Finset.Nonempty ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ T, ∃ e ∈ E', e ∈ t.sym2 ) ( Finset.powerset G.edgeFinset ) ) ) from ?_ );
    · obtain ⟨ a, ha ⟩ := this;
      have := Finset.mem_of_min ha; aesop;
    · refine' Finset.Nonempty.image _ _;
      exact?;
  exact ⟨ E', Finset.mem_powerset.mp ( Finset.mem_filter.mp hE'_cover |>.1 ), Finset.mem_filter.mp hE'_cover |>.2, hE'_card ⟩

theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) :
    triangleCoveringNumberOn G (A ∪ B) ≤
    triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by
      simp +decide [ triangleCoveringNumberOn ];
      by_cases hA : { E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t }.Nonempty;
      · obtain ⟨E₁, hE₁⟩ : ∃ E₁ ⊆ G.edgeFinset, (∀ t ∈ A, ∃ e ∈ E₁, ∀ a ∈ e, a ∈ t) ∧ E₁.card = (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min.getD 0 := by
          have := Finset.min_of_nonempty ( show ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t ) ( Finset.powerset G.edgeFinset ) ) ).Nonempty from ?_ );
          · obtain ⟨ a, ha ⟩ := this;
            have := Finset.mem_of_min ha; aesop;
          · simp +zetaDelta at *;
            exact ⟨ hA.choose, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.mem_powerset.mp ( Finset.mem_filter.mp hA.choose_spec |>.1 ) ), fun t ht => Finset.mem_filter.mp hA.choose_spec |>.2 t ( Or.inl ht ) ⟩ ⟩;
        obtain ⟨E₂, hE₂⟩ : ∃ E₂ ⊆ G.edgeFinset, (∀ t ∈ B, ∃ e ∈ E₂, ∀ a ∈ e, a ∈ t) ∧ E₂.card = (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min.getD 0 := by
          have := Finset.min_of_nonempty ( show ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ).Nonempty from ?_ );
          · obtain ⟨ a, ha ⟩ := this;
            have := Finset.mem_of_min ha;
            rw [ Finset.mem_image ] at this; obtain ⟨ E₂, hE₂, rfl ⟩ := this; use E₂; aesop;
          · obtain ⟨ E', hE' ⟩ := hA;
            exact ⟨ _, Finset.mem_image_of_mem _ ( show E' ∈ { E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } from by aesop ) ⟩;
        have h_union : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min.getD 0 ≤ (E₁ ∪ E₂).card := by
          have h_union : ∀ E' ∈ {E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t}, (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min.getD 0 ≤ E'.card := by
            intro E' hE'
            have h_min : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ E'.card := by
              exact Finset.min_le ( Finset.mem_image_of_mem _ hE' );
            cases h : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> aesop;
          grind;
        exact h_union.trans ( Finset.card_union_le _ _ ) |> le_trans <| by linarith;
      · rw [ Finset.not_nonempty_iff_eq_empty.mp hA ] ; simp +decide;
        exact Nat.zero_le _ -- PROVEN in slot61

lemma exists_strict_triangle_on_edge (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (e : Finset V) (he : e.card = 3)
    (h_tau : triangleCoveringNumberOn G (S_e G M e) > 2)
    (f : Finset V) (hf : f ⊆ e) (hf2 : f.card = 2) :
    ∃ t ∈ S_e G M e, t ∩ e = f := by
  contrapose! h_tau;
  -- Let $g$ and $h$ be the other two pairs in $e$.
  obtain ⟨g, hg⟩ : ∃ g : Finset V, g ⊆ e ∧ g.card = 2 ∧ g ≠ f := by
    have h_pairs : Finset.card (Finset.powersetCard 2 e) = 3 := by
      simp +decide [ he ];
    exact Exists.imp ( by aesop ) ( Finset.exists_mem_ne ( show 1 < Finset.card ( Finset.powersetCard 2 e ) from h_pairs.symm ▸ by decide ) f )
  obtain ⟨h, hh⟩ : ∃ h : Finset V, h ⊆ e ∧ h.card = 2 ∧ h ≠ f ∧ h ≠ g := by
    have h_pairs : Finset.card (Finset.powersetCard 2 e) = 3 := by
      simp +decide [ he ];
    exact Exists.imp ( by aesop ) ( Finset.exists_mem_ne ( show 1 < Finset.card ( Finset.erase ( Finset.powersetCard 2 e ) f ) from by rw [ Finset.card_erase_of_mem ( Finset.mem_powersetCard.mpr ⟨ hf, hf2 ⟩ ), h_pairs ] ; simp +decide ) g );
  -- Any triangle in $S_e$ covers either $g$ or $h$.
  have h_cover : ∀ t ∈ S_e G M e, ∃ e' ∈ ({g, h} : Finset (Finset V)), e' ⊆ t := by
    intro t ht
    have h_inter : (t ∩ e).card ≥ 2 ∧ (t ∩ e) ≠ f := by
      exact ⟨ Finset.mem_filter.mp ht |>.2.1, h_tau t ht ⟩;
    have h_inter_cases : (t ∩ e) = e ∨ (t ∩ e) = g ∨ (t ∩ e) = h := by
      have h_inter_cases : ∀ s ⊆ e, s.card = 2 → s = g ∨ s = h ∨ s = f := by
        have h_inter_cases : Finset.powersetCard 2 e = {f, g, h} := by
          rw [ Finset.eq_of_subset_of_card_le ( Finset.insert_subset_iff.mpr ⟨ Finset.mem_powersetCard.mpr ⟨ hf, hf2 ⟩, Finset.insert_subset_iff.mpr ⟨ Finset.mem_powersetCard.mpr ⟨ hg.1, hg.2.1 ⟩, Finset.singleton_subset_iff.mpr ( Finset.mem_powersetCard.mpr ⟨ hh.1, hh.2.1 ⟩ ) ⟩ ⟩ ) ] ; simp +decide [ *, Finset.card_powersetCard ];
          rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> aesop;
        intro s hs hs'; replace h_inter_cases := Finset.ext_iff.mp h_inter_cases s; aesop;
      have h_inter_cases : (t ∩ e).card = 2 ∨ (t ∩ e).card = 3 := by
        have h_inter_cases : (t ∩ e).card ≤ 3 := by
          exact le_trans ( Finset.card_le_card fun x hx => by aesop ) he.le;
        grind;
      cases h_inter_cases <;> simp_all +decide [ Finset.eq_of_subset_of_card_le ];
      · cases h_inter_cases ( t ∩ e ) ( Finset.inter_subset_right ) ‹_› <;> aesop;
      · have h_inter_eq_e : t ∩ e = e := by
          exact Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right ) ( by aesop );
        exact Or.inl ( h_inter_eq_e ▸ Finset.inter_subset_left );
    rcases h_inter_cases with ( h | h | h ) <;> simp_all +decide [ Finset.subset_iff ];
    · exact Or.inl fun x hx => Finset.mem_of_mem_inter_left ( h.symm ▸ hx );
    · exact Or.inr fun x hx => Finset.mem_of_mem_inter_left ( h.symm ▸ hx );
  -- Let $E_g$ be the edge corresponding to pair $g$, $E_h$ corresponding to $h$.
  obtain ⟨E_g, hE_g⟩ : ∃ E_g : Finset (Sym2 V), E_g ⊆ G.edgeFinset ∧ (∀ t ∈ S_e G M e, ∃ e' ∈ E_g, e' ∈ t.sym2) ∧ E_g.card ≤ 2 := by
    use (g.sym2 ∩ G.edgeFinset) ∪ (h.sym2 ∩ G.edgeFinset);
    simp_all +decide [ Finset.subset_iff ];
    refine' ⟨ _, _, _ ⟩;
    · tauto;
    · intro t ht; specialize h_cover t ht; rcases h_cover with ( h | h ) <;> simp_all +decide [ Finset.ext_iff ] ;
      · obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.card_eq_two.mp hg.2.1;
        by_cases hxy : G.Adj x hx <;> simp_all +decide [ SimpleGraph.adj_comm ];
        · exact ⟨ Sym2.mk ( x, hx ), Or.inl ⟨ by aesop, by aesop ⟩, by aesop ⟩;
        · unfold S_e at ht; simp_all +decide [ Finset.subset_iff ] ;
          have := ht.1.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          exact False.elim ( hxy ( ht.1 h.1 h.2 ( by aesop ) ) );
      · obtain ⟨ x, hx ⟩ := Finset.card_eq_two.mp hh.2.1;
        obtain ⟨ y, hxy, rfl ⟩ := hx;
        by_cases hxy' : G.Adj x y <;> simp_all +decide [ SimpleGraph.adj_comm ];
        · exact ⟨ Sym2.mk ( x, y ), Or.inr ⟨ by aesop, by aesop ⟩, by aesop ⟩;
        · unfold S_e at ht; simp_all +decide [ Finset.subset_iff ] ;
          have := ht.1.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
          exact False.elim ( hxy' ( ht.1 h.1 h.2 hxy ) );
    · refine' le_trans ( Finset.card_union_le _ _ ) _;
      refine' le_trans ( add_le_add ( Finset.card_le_one.mpr _ ) ( Finset.card_le_one.mpr _ ) ) _ <;> simp_all +decide [ Finset.subset_iff ];
      · intro a ha₁ ha₂ b hb₁ hb₂; rcases a with ⟨ x, y ⟩ ; rcases b with ⟨ u, v ⟩ ; simp_all +decide [ Finset.card_eq_two ] ;
        rcases hg.2.1 with ⟨ x', y', hxy', rfl ⟩ ; rcases hh.2.1 with ⟨ u', v', huv', rfl ⟩ ; aesop;
      · intro a ha ha' b hb hb'; rcases a with ⟨ x, y ⟩ ; rcases b with ⟨ u, v ⟩ ; simp_all +decide [ Sym2.eq ] ;
        have := Finset.card_eq_two.mp hh.2.1; obtain ⟨ a, b, hab ⟩ := this; aesop;
  refine' le_trans _ hE_g.2.2;
  apply tau_le_of_exists_cover;
  · exact hE_g.1;
  · exact hE_g.2.1

lemma tau_le_2_of_K4_plus_one_pair (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (e : Finset V) (he : e.card = 3)
    (S : Finset (Finset V)) (hS : S ⊆ S_e G M e)
    (u v w : V) (h_e : e = {u, v, w}) (h_distinct : u ≠ v ∧ v ≠ w ∧ u ≠ w)
    (x : V) (hx : x ∉ e)
    (t1 t2 t3 : Finset V)
    (h_t1 : t1 = {u, v, x}) (h_t1_mem : t1 ∈ S)
    (h_t2 : t2 = {v, w, x}) (h_t2_mem : t2 ∈ S)
    (h_t3 : t3 = {w, u, x}) (h_t3_mem : t3 ∈ S)
    (h_extras : ∀ t ∈ S, t ≠ t1 → t ≠ t2 → t ≠ t3 → t ∩ e = {u, v}) :
    triangleCoveringNumberOn G S ≤ 2 := by
  -- We claim that the set of edges $E' = \{ \{u, v\}, \{w, x\} \}$ covers $S$.
  set E' : Finset (Sym2 V) := {Sym2.mk (u, v), Sym2.mk (w, x)} with hE';
  -- We need to show that $E'$ covers $S$.
  have h_cover : ∀ t ∈ S, ∃ e ∈ E', e ∈ t.sym2 := by
    intro t ht
    by_cases h_cases : t = t1 ∨ t = t2 ∨ t = t3;
    · rcases h_cases with ( rfl | rfl | rfl ) <;> simp +decide [ *, Finset.mem_sym2_iff ];
    · have := h_extras t ht ( by tauto ) ( by tauto ) ( by tauto ) ; simp_all +decide [ Finset.ext_iff ] ;
      exact Or.inl ⟨ by specialize this u; aesop, by specialize this v; aesop ⟩;
  -- We need to show that $E'$ is a subset of $G.edgeFinset$.
  have h_subset : E' ⊆ G.edgeFinset := by
    simp_all +decide [ Finset.subset_iff ];
    have := hS h_t1_mem; have := hS h_t2_mem; have := hS h_t3_mem; simp_all +decide [ S_e ] ;
    have := hS h_t1_mem; have := hS h_t2_mem; have := hS h_t3_mem; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
    grind;
  refine' le_trans ( tau_le_of_exists_cover G S E' h_subset h_cover ) _;
  exact Finset.card_insert_le _ _

lemma disjoint_triples_imply_contradiction (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 t3 : Finset V)
    (h_t1 : t1 ∈ S_e G M e) (h_t2 : t2 ∈ S_e G M e) (h_t3 : t3 ∈ S_e G M e)
    (h_disj : (t1 ∩ t2).card ≤ 1 ∧ (t2 ∩ t3).card ≤ 1 ∧ (t1 ∩ t3).card ≤ 1)
    (h_distinct : t1 ≠ t2 ∧ t2 ≠ t3 ∧ t1 ≠ t3) :
    False := by
  rcases hM with ⟨ hM₁, hM₂ ⟩;
  -- The set $M' = (M \setminus \{e\}) \cup \{t_1, t_2, t_3\}$ is a valid triangle packing, and its cardinality is greater than $|M|$.
  have hM'_valid : isTrianglePacking G ((M \ {e}) ∪ {t1, t2, t3}) := by
    unfold isTrianglePacking at *;
    simp_all +decide [ Finset.subset_iff, Set.Pairwise ];
    simp_all +decide [ Finset.inter_comm, S_e ]
  have hM'_card : ((M \ {e}) ∪ {t1, t2, t3}).card > M.card := by
    rw [ Finset.card_union_of_disjoint ] <;> simp +decide [ *, Finset.card_sdiff, Finset.subset_iff ];
    · omega;
    · simp_all +decide [ S_e ];
      refine' ⟨ fun h => Classical.not_not.1 fun hne => _, fun h => Classical.not_not.1 fun hne => _, fun h => Classical.not_not.1 fun hne => _ ⟩ <;> have := hM₁.2 <;> simp_all +decide [ Finset.subset_iff ];
      · exact absurd ( this h he hne ) ( by linarith );
      · exact absurd ( this h he hne ) ( by aesop );
      · exact absurd ( this h he hne ) ( by linarith );
  have h_contradiction : (M \ {e} ∪ {t1, t2, t3}).card ≤ trianglePackingNumber G := by
    have h_contradiction : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ trianglePackingNumber G := by
      unfold trianglePackingNumber;
      intro M' hM'
      have hM'_in_filter : M' ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset := by
        simp_all +decide [ isTrianglePacking ];
      have := Finset.le_max ( Finset.mem_image_of_mem Finset.card hM'_in_filter );
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
    exact h_contradiction _ hM'_valid;
  linarith