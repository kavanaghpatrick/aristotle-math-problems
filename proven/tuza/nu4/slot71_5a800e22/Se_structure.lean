/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5a800e22-377b-453a-8930-3dccfcc6ff71

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

-- S_e: triangles sharing edge with e but not with any other packing element
def S_e (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) (e : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ ∀ f ∈ M, f ≠ e → (t ∩ f).card ≤ 1)

-- X_ef: bridges between e and f
def X_ef (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2)

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def T_pair (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  trianglesSharingEdge G e ∪ trianglesSharingEdge G f

def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ D ≠ A ∧ A ≠ C ∧ B ≠ D ∧
  (A ∩ B).card = 1 ∧ (B ∩ C).card = 1 ∧ (C ∩ D).card = 1 ∧ (D ∩ A).card = 1 ∧
  (A ∩ C).card = 0 ∧ (B ∩ D).card = 0

theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) :
    triangleCoveringNumberOn G (A ∪ B) ≤
    triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by
  unfold triangleCoveringNumberOn;
  by_cases hA : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2;
  · by_cases hB : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2;
    · obtain ⟨E₁, hE₁⟩ : ∃ E₁ ∈ G.edgeFinset.powerset, (∀ t ∈ A, ∃ e ∈ E₁, e ∈ t.sym2) ∧ E₁.card = (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2})).min.getD 0 := by
        have h_min_card : ∃ E₁ ∈ Finset.filter (fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset), ∀ E₂ ∈ Finset.filter (fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset), E₁.card ≤ E₂.card := by
          apply_rules [ Finset.exists_min_image ];
          exact ⟨ hA.choose, Finset.mem_filter.mpr ⟨ hA.choose_spec.1, hA.choose_spec.2 ⟩ ⟩;
        obtain ⟨ E₁, hE₁₁, hE₁₂ ⟩ := h_min_card;
        use E₁;
        rw [ Finset.min_eq_inf_withTop ];
        rw [ show ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ A, ∃ e ∈ E', e ∈ t.sym2 ) ( G.edgeFinset.powerset ) ) ).inf WithTop.some = WithTop.some E₁.card from ?_ ];
        · exact ⟨ Finset.mem_filter.mp hE₁₁ |>.1, Finset.mem_filter.mp hE₁₁ |>.2, rfl ⟩;
        · refine' le_antisymm _ _;
          · exact Finset.inf_le ( Finset.mem_image_of_mem _ hE₁₁ );
          · simp +zetaDelta at *;
            exact hE₁₂;
      obtain ⟨E₂, hE₂⟩ : ∃ E₂ ∈ G.edgeFinset.powerset, (∀ t ∈ B, ∃ e ∈ E₂, e ∈ t.sym2) ∧ E₂.card = (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2})).min.getD 0 := by
        have := Finset.min_of_mem ( show Finset.card ( Classical.choose hB ) ∈ Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2 ) ( Finset.powerset G.edgeFinset ) ) from Finset.mem_image.mpr ⟨ _, Finset.mem_filter.mpr ⟨ Classical.choose_spec hB |>.1, Classical.choose_spec hB |>.2 ⟩, rfl ⟩ );
        obtain ⟨ b, hb ⟩ := this;
        have := Finset.mem_of_min hb;
        rw [ Finset.mem_image ] at this; obtain ⟨ E₂, hE₂, rfl ⟩ := this; exact ⟨ E₂, Finset.mem_filter.mp hE₂ |>.1, Finset.mem_filter.mp hE₂ |>.2, by rw [ hb ] ; rfl ⟩ ;
      have h_union_cover : ∃ E' ∈ G.edgeFinset.powerset, (∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ E₁.card + E₂.card := by
        use E₁ ∪ E₂;
        grind;
      have h_min_le : ∀ E' ∈ G.edgeFinset.powerset, (∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2) → (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2})).min.getD 0 ≤ E'.card := by
        intros E' hE' hE'_cover;
        have h_min_le : ∀ x ∈ Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2}), (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2})).min.getD 0 ≤ x := by
          simp +decide [ Option.getD ];
          intro x E' hE' hE'_cover hx;
          cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t ) ( Finset.powerset G.edgeFinset ) ) ) <;> simp +decide [ h ];
          exact Nat.cast_le.mp ( h ▸ Finset.min_le ( Finset.mem_image.mpr ⟨ E', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( by simpa [ Finset.subset_iff ] using hE' ), hE'_cover ⟩, hx ⟩ ) );
        exact h_min_le _ ( Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ hE', hE'_cover ⟩ ) );
      exact le_trans ( h_min_le _ h_union_cover.choose_spec.1 h_union_cover.choose_spec.2.1 ) ( h_union_cover.choose_spec.2.2.trans ( by linarith ) );
    · rw [ show ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2 } : Finset ( Finset ( Sym2 V ) ) ) = ∅ from Finset.eq_empty_of_forall_notMem fun E' hE' => hB ⟨ E', Finset.mem_filter.mp hE' |>.1, Finset.mem_filter.mp hE' |>.2 ⟩ ] ; simp +decide;
      rw [ show { E' ∈ G.edgeFinset.powerset | ∀ t, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } = ∅ from Finset.eq_empty_of_forall_notMem fun E' hE' => hB ⟨ E', Finset.mem_filter.mp hE' |>.1, fun t ht => by obtain ⟨ e, he₁, he₂ ⟩ := Finset.mem_filter.mp hE' |>.2 t ( Or.inr ht ) ; exact ⟨ e, he₁, by simpa using he₂ ⟩ ⟩ ] ; simp +decide;
  · rw [ show ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2 } : Finset ( Finset ( Sym2 V ) ) ) = ∅ from Finset.eq_empty_of_forall_notMem fun E' hE' => hA ⟨ E', Finset.mem_filter.mp hE' |>.1, fun t ht => Finset.mem_filter.mp hE' |>.2 t ( Finset.mem_union_left _ ht ) ⟩ ] ; simp +decide;
    simp +decide [ Option.getD ] -- PROVEN in slot61

lemma S_e_pairwise_intersect (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 : Finset V) (ht1 : t1 ∈ S_e G M e) (ht2 : t2 ∈ S_e G M e)
    (ht1_ne_e : t1 ≠ e) (ht2_ne_e : t2 ≠ e) (hne : t1 ≠ t2) :
    (t1 ∩ t2).card ≥ 2 := by
  obtain ⟨ ht1_card, ht1_adj ⟩ := hM;
  -- By the maximality of $M$, any triangle packing $M'$ with $|M'| > |M|$ contradicts the definition of $M$ as a maximum packing.
  have h_contra : ¬∃ M' : Finset (Finset V), isTrianglePacking G M' ∧ M'.card > M.card := by
    have h_contra : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ trianglePackingNumber G := by
      unfold trianglePackingNumber;
      intro M' hM'
      have hM'_in_powerset : M' ∈ Finset.powerset (G.cliqueFinset 3) := by
        exact Finset.mem_powerset.mpr hM'.1;
      have hM'_in_image : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
        aesop;
      have := Finset.le_max hM'_in_image;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
    exact fun ⟨ M', hM', hM'' ⟩ => hM''.not_le ( ht1_adj ▸ h_contra M' hM' );
  contrapose! h_contra;
  refine' ⟨ Insert.insert t1 ( Insert.insert t2 ( M.erase e ) ), _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
  · unfold S_e at *; simp_all +decide [ Finset.subset_iff, Set.Pairwise ] ;
    exact ⟨ Nat.le_of_lt_succ h_contra, fun _ => by rw [ Finset.inter_comm ] ; exact Nat.le_of_lt_succ h_contra, fun f hf hf' => ⟨ fun _ => by simpa only [ Finset.inter_comm ] using ht1.2.2 f hf hf', fun _ => by simpa only [ Finset.inter_comm ] using ht2.2.2 f hf hf' ⟩ ⟩;
  · rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem ] <;> simp_all +decide [ Finset.subset_iff ];
    · omega;
    · intro h; have := ht1_adj ▸ Finset.card_pos.2 ⟨ e, he ⟩ ; simp_all +decide [ S_e ] ;
      exact absurd ( ht1_card.2 h he ( by aesop ) ) ( by linarith );
    · intro H; have := ht1_card.2 he H; simp_all +decide ;
      simp_all +decide [ Finset.inter_comm, S_e ];
      exact absurd ( this ( Ne.symm ht1_ne_e ) ) ( by linarith )

lemma S_e_cross_intersect (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 : Finset V) (ht1 : t1 ∈ S_e G M e) (ht2 : t2 ∈ S_e G M e)
    (ht1_ne_e : t1 ≠ e) (ht2_ne_e : t2 ≠ e)
    (h_diff_edges : t1 ∩ e ≠ t2 ∩ e) :
    ∃ x, x ∉ e ∧ x ∈ t1 ∧ x ∈ t2 := by
  have h_inter : (t1 ∩ t2).card ≥ 2 := by
    apply S_e_pairwise_intersect G M hM e he t1 t2 ht1 ht2 ht1_ne_e ht2_ne_e;
    grind;
  -- Since $t1$ and $t2$ are triangles, they must each have exactly three elements.
  have h_card_t1 : t1.card = 3 := by
    unfold S_e at ht1;
    simp_all +decide [ SimpleGraph.cliqueFinset ];
    exact ht1.1.card_eq
  have h_card_t2 : t2.card = 3 := by
    unfold S_e at ht2;
    simp_all +decide [ SimpleGraph.isNClique_iff ];
  have h_card_e : e.card = 3 := by
    have := hM.1;
    have := this.1;
    have := this he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
    exact this.2;
  have h_inter_e : (t1 ∩ e).card = 2 ∧ (t2 ∩ e).card = 2 := by
    have h_inter_e : (t1 ∩ e).card ≥ 2 ∧ (t2 ∩ e).card ≥ 2 := by
      unfold S_e at ht1 ht2; aesop;
    have h_inter_e : (t1 ∩ e).card ≤ 3 ∧ (t2 ∩ e).card ≤ 3 := by
      exact ⟨ le_trans ( Finset.card_le_card fun x hx => by aesop ) h_card_t1.le, le_trans ( Finset.card_le_card fun x hx => by aesop ) h_card_t2.le ⟩;
    cases h_inter_e.1.eq_or_lt <;> cases h_inter_e.2.eq_or_lt <;> simp_all +decide;
    · have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ e ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ e ⊆ e ) ; simp_all +decide ;
    · have := Finset.eq_of_subset_of_card_le ( show t1 ∩ e ⊆ e from Finset.inter_subset_right ) ; simp_all +decide ;
      have := Finset.eq_of_subset_of_card_le this ; aesop;
    · have := Finset.eq_of_subset_of_card_le ( show t2 ∩ e ⊆ e from Finset.inter_subset_right ) ; simp_all +decide ;
      have := Finset.eq_of_subset_of_card_le this ; aesop;
    · exact ⟨ by linarith, by linarith ⟩;
  contrapose! h_diff_edges;
  have h_inter_eq : (t1 ∩ t2 ∩ e).card ≥ 2 := by
    have h_inter_eq : (t1 ∩ t2 ∩ e).card = (t1 ∩ t2).card := by
      exact congr_arg Finset.card ( Finset.ext fun x => by by_cases hx : x ∈ e <;> aesop );
    linarith;
  have h_inter_eq : (t1 ∩ t2 ∩ e) = (t1 ∩ e) ∧ (t1 ∩ t2 ∩ e) = (t2 ∩ e) := by
    have h_inter_eq : (t1 ∩ t2 ∩ e) ⊆ (t1 ∩ e) ∧ (t1 ∩ t2 ∩ e) ⊆ (t2 ∩ e) := by
      simp +contextual [ Finset.subset_iff ];
    exact ⟨ Finset.eq_of_subset_of_card_le h_inter_eq.1 ( by linarith ), Finset.eq_of_subset_of_card_le h_inter_eq.2 ( by linarith ) ⟩;
  grind

lemma S_e_structure_case2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M)
    (t1 t2 : Finset V) (ht1 : t1 ∈ S_e G M e) (ht2 : t2 ∈ S_e G M e)
    (ht1_ne_e : t1 ≠ e) (ht2_ne_e : t2 ≠ e)
    (h_diff_edges : t1 ∩ e ≠ t2 ∩ e) :
    ∃ x, x ∉ e ∧ ∀ t ∈ S_e G M e, t ≠ e → x ∈ t := by
  -- By `S_e_cross_intersect` applied to $t_1, t_2$, there exists $x \notin e$ such that $x \in t_1$ and $x \in t_2$.
  obtain ⟨x, hx_not_in_e, hx_in_t1, hx_in_t2⟩ : ∃ x ∉ e, x ∈ t1 ∧ x ∈ t2 := by
    exact?;
  -- Since $t1$ and $t2$ are triangles, their sizes are 3. Therefore, $t1 \setminus e$ and $t2 \setminus e$ each have exactly one element, which is $x$.
  have ht1_minus_e : t1 \ e = {x} := by
    have ht1_card : t1.card = 3 := by
      unfold S_e at ht1;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      exact ht1.1.card_eq
    have ht1_inter_e_card : (t1 ∩ e).card = 2 := by
      have := Finset.card_le_card ( show t1 ∩ e ⊆ t1 from Finset.inter_subset_left ) ; simp_all +decide ;
      interval_cases _ : Finset.card ( t1 ∩ e ) <;> simp_all +decide [ S_e ];
      have := Finset.eq_of_subset_of_card_le ( show t1 ∩ e ⊆ t1 from Finset.inter_subset_left ) ; simp_all +decide ;
      exact hx_not_in_e ( this hx_in_t1 )
    have ht1_minus_e_card : (t1 \ e).card = 1 := by
      have := Finset.card_sdiff_add_card_inter t1 e; simp_all +decide ;
    rw [ Finset.card_eq_one ] at ht1_minus_e_card;
    obtain ⟨ y, hy ⟩ := ht1_minus_e_card; rw [ Finset.eq_singleton_iff_unique_mem ] at *; aesop;
  have ht2_minus_e : t2 \ e = {x} := by
    have ht2_card : t2.card = 3 := by
      have := Finset.mem_filter.mp ht2;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      exact this.1.card_eq;
    have ht2_inter_e_card : (t2 ∩ e).card = 2 := by
      have ht2_inter_e : (t2 ∩ e).card ≥ 2 := by
        unfold S_e at ht2; aesop;
      have ht2_inter_e_le : (t2 ∩ e).card ≤ 2 := by
        have ht2_inter_e_le : (t2 ∩ e).card ≤ t2.card - 1 := by
          refine' Nat.le_sub_one_of_lt ( Finset.card_lt_card _ );
          grind;
        aesop;
      linarith;
    have ht2_minus_e_card : (t2 \ e).card = 1 := by
      have := Finset.card_sdiff_add_card_inter t2 e; aesop;
    rw [ Finset.card_eq_one ] at ht2_minus_e_card;
    obtain ⟨ y, hy ⟩ := ht2_minus_e_card; rw [ Finset.eq_singleton_iff_unique_mem ] at hy; aesop;
  refine' ⟨ x, hx_not_in_e, fun t ht ht_ne_e => _ ⟩;
  by_cases h_cases : t ∩ e = t1 ∩ e;
  · -- Since $t \cap e = t1 \cap e$ and $t1 \cap e \ne t2 \cap e$, we can apply `S_e_cross_intersect` to $t$ and $t2$.
    obtain ⟨z, hz_not_in_e, hz_in_t, hz_in_t2⟩ : ∃ z ∉ e, z ∈ t ∧ z ∈ t2 := by
      apply S_e_cross_intersect G M hM e he t t2 ht ht2 ht_ne_e ht2_ne_e;
      grind;
    rw [ Finset.eq_singleton_iff_unique_mem ] at ht2_minus_e ; aesop;
  · -- By `S_e_cross_intersect` applied to $t$ and $t_1$, there exists $y \notin e$ such that $y \in t$ and $y \in t_1$.
    obtain ⟨y, hy_not_in_e, hy_in_t, hy_in_t1⟩ : ∃ y ∉ e, y ∈ t ∧ y ∈ t1 := by
      apply S_e_cross_intersect G M hM e he t t1 ht ht1 ht_ne_e ht1_ne_e h_cases;
    rw [ Finset.eq_singleton_iff_unique_mem ] at ht1_minus_e ; aesop

lemma S_e_structure (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e : Finset V) (he : e ∈ M) :
    (∃ u v : V, u ∈ e ∧ v ∈ e ∧ u ≠ v ∧ ∀ t ∈ S_e G M e, t ≠ e → {u, v} ⊆ t) ∨
    (∃ x : V, x ∉ e ∧ ∀ t ∈ S_e G M e, t ≠ e → x ∈ t) := by
  by_cases h_empty : S_e G M e \ {e} = ∅;
  · simp_all +decide [ Finset.ext_iff ];
    by_cases he_empty : e = ∅;
    · have := hM.1.1 he; aesop;
    · by_cases he_singleton : e.card = 1;
      · have := hM.1.1 he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
        rw [ SimpleGraph.isNClique_iff ] at this ; aesop;
      · exact Or.inl ( Finset.one_lt_card.1 ( lt_of_le_of_ne ( Finset.card_pos.2 ( Finset.nonempty_of_ne_empty he_empty ) ) ( Ne.symm he_singleton ) ) );
  · by_cases h_case1 : ∀ t1 t2 : Finset V, t1 ∈ S_e G M e \ {e} → t2 ∈ S_e G M e \ {e} → t1 ∩ e = t2 ∩ e;
    · obtain ⟨t1, ht1⟩ : ∃ t1 : Finset V, t1 ∈ S_e G M e \ {e} := by
        exact Finset.nonempty_of_ne_empty h_empty;
      have h_inter : (t1 ∩ e).card ≥ 2 := by
        unfold S_e at ht1; aesop;
      obtain ⟨ u, hu, v, hv, huv ⟩ := Finset.one_lt_card.mp h_inter;
      refine' Or.inl ⟨ u, v, _, _, huv, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
      intro t ht ht'; specialize h_case1 t t1 ht ht' ht1.1 ht1.2; replace h_case1 := Finset.ext_iff.mp h_case1; have := h_case1 u; have := h_case1 v; aesop;
    · obtain ⟨t1, t2, ht1, ht2, h_diff⟩ : ∃ t1 t2 : Finset V, t1 ∈ S_e G M e \ {e} ∧ t2 ∈ S_e G M e \ {e} ∧ t1 ∩ e ≠ t2 ∩ e := by
        grind +ring;
      obtain ⟨x, hx⟩ : ∃ x, x ∉ e ∧ ∀ t ∈ S_e G M e, t ≠ e → x ∈ t := by
        apply S_e_structure_case2 G M hM e he t1 t2;
        · exact Finset.mem_sdiff.mp ht1 |>.1;
        · exact Finset.mem_sdiff.mp ht2 |>.1;
        · aesop;
        · aesop;
        · exact h_diff;
      exact Or.inr ⟨ x, hx ⟩