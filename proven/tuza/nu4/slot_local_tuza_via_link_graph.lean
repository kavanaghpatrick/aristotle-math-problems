/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7e7767af-2c70-49b8-8566-332458dce09e
-/

/-
We have formalized the local Tuza bound via link graph reduction.
Key results proved:
1. `local_tuza_via_link_graph`: For any vertex v, τ(T_v) ≤ 2·ν(T_v).
2. `partition_piece_tuza_bound`: For any subset Ti ⊆ T_v, τ(Ti) ≤ 2·ν(Ti).

The proof uses the link graph construction:
- `linkGraph`: The graph of neighbors of v that form triangles with v.
- `triangleToLinkEdge`: Bijection between triangles at v and edges in the link graph.
- `disjoint_triangles_iff_matching`: Disjoint triangles correspond to disjoint edges (matching).
- `cover_at_v_le_vertex_cover`: Triangle cover size is bounded by link graph vertex cover size.
- `vertex_cover_le_two_matching`: Standard result VC ≤ 2·Matching.
- `packing_at_v_eq_matching`: Triangle packing number equals link graph matching number.

We also extended this to subsets `Ti` using `subLinkGraph`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical

variable {V : Type*} [Fintype V] [DecidableEq V]

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

noncomputable def trianglePackingOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  triangles.powerset.filter (fun S =>
    S ⊆ triangles ∧
    Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1))
    |>.image Finset.card |>.max |>.getD 0

def trianglesContainingVertex (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => v ∈ t)

/-- The link graph of v: edges between neighbors of v that form triangles with v -/
def linkGraph (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) : SimpleGraph V where
  Adj x y := G.Adj x y ∧ G.Adj v x ∧ G.Adj v y ∧ x ≠ y ∧ x ≠ v ∧ y ≠ v
  symm := by
    intro x y ⟨hxy, hvx, hvy, hne, hxv, hyv⟩
    exact ⟨hxy.symm, hvy, hvx, hne.symm, hyv, hxv⟩
  loopless := by
    intro x ⟨_, _, _, hne, _, _⟩
    exact hne rfl

/-- Link graph has decidable adjacency -/
instance linkGraphDecidableRel (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) :
    DecidableRel (linkGraph G v).Adj := by
  intro x y
  unfold linkGraph
  infer_instance

/-- Triangles containing v correspond bijectively to edges in the link graph -/
def triangleToLinkEdge (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) (hv : v ∈ t) :
    (linkGraph G v).edgeSet :=
  let s := t.erase v
  have hs : s.card = 2 := by
    -- Since $t$ is a clique of size 3, its cardinality is 3. Removing $v$ from $t$ leaves a set of size 2.
    have ht_card : t.card = 3 := by
      -- By definition of `cliqueFinset`, if `t ∈ G.cliqueFinset 3`, then `t` is a 3-clique of `G`.
      have h_clique : G.IsNClique 3 t := by
        exact?;
      -- By definition of `IsNClique`, if `t` is a 3-clique, then `t.card = 3`.
      apply h_clique.card_eq;
    -- Since $t$ has cardinality 3 and $v \in t$, removing $v$ from $t$ leaves a set of cardinality 2.
    simp [s, ht_card, hv]
  have hne : (s.offDiag.image Sym2.mk).Nonempty := by
    -- Since $s$ has exactly two elements, there is exactly one pair in the off-diagonal, which maps to an edge in the link graph. Therefore, the image is nonempty.
    have h_pair : ∃ x y : V, x ∈ s ∧ y ∈ s ∧ x ≠ y := by
      -- Since $s$ has exactly two elements, we can apply the theorem that states a finite set with cardinality 2 must contain two distinct elements.
      apply Finset.card_eq_two.mp hs |> fun ⟨x, y, hxy⟩ => ⟨x, y, by aesop⟩;
    -- Since $x$ and $y$ are in $s$ and $x \neq y$, the pair $(x, y)$ is in the off-diagonal of $s$, and thus Sym2.mk (x, y) is in the image.
    obtain ⟨x, y, hx, hy, hxy⟩ := h_pair;
    use Sym2.mk (x, y);
    aesop
  let e := Classical.choose hne
  ⟨e, by
    -- Since $e$ is in the image of $s.offDiag$ under $Sym2.mk$, there exist $x, y \in s$ such that $e = \{x, y\}$.
    obtain ⟨x, y, hx, hy, hxy⟩ : ∃ x y : V, x ∈ s ∧ y ∈ s ∧ x ≠ y ∧ e = Sym2.mk (x, y) := by
      have := Classical.choose_spec hne; aesop;
      exact ⟨ w, ⟨ left, right_2 ⟩, w_1, ⟨ left_1, right_3 ⟩, right_1, right.symm ⟩;
    -- Since $x$ and $y$ are in $s$, they are neighbors of $v$ in $G$ and not equal to $v$. Also, since $t$ is a clique, $x$ and $y$ are adjacent.
    have h_adj : G.Adj x y ∧ G.Adj v x ∧ G.Adj v y ∧ x ≠ v ∧ y ≠ v := by
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      have := ht.1; aesop;
    -- Since $e = \{x, y\}$ and $x$ and $y$ are adjacent in $G$ and both adjacent to $v$, $e$ is an edge in the link graph.
    simp [hxy, h_adj];
    exact ⟨ h_adj.1, h_adj.2.1, h_adj.2.2.1, hxy.1, h_adj.2.2.2.1, h_adj.2.2.2.2 ⟩⟩

/-
Two triangles containing a vertex $v$ are edge-disjoint (intersection size at most 1) if and only if their corresponding edges in the link graph of $v$ are disjoint.
-/
lemma disjoint_triangles_iff_matching (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (t1 t2 : Finset V) (ht1 : t1 ∈ trianglesContainingVertex G v)
    (ht2 : t2 ∈ trianglesContainingVertex G v) (hne : t1 ≠ t2) :
    (t1 ∩ t2).card ≤ 1 ↔ Disjoint (t1.erase v) (t2.erase v) := by
  simp_all +decide [ Finset.disjoint_iff_inter_eq_empty, Finset.ext_iff ];
  constructor <;> intro h;
  · contrapose! h;
    exact Finset.one_lt_card.2 ⟨ h.choose, Finset.mem_inter.2 ⟨ h.choose_spec.1, h.choose_spec.2.2 ⟩, v, Finset.mem_inter.2 ⟨ Finset.mem_filter.mp ht1 |>.2, Finset.mem_filter.mp ht2 |>.2 ⟩, by simpa using h.choose_spec.2.1 ⟩;
  · exact Finset.card_le_one.mpr fun x hx y hy => Classical.not_not.1 fun hxy => h x ( Finset.mem_of_mem_inter_left hx ) ( by aesop ) ( Finset.mem_of_mem_inter_right hx )

/-- Vertex cover number of a graph -/
noncomputable def vertexCoverNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (Finset.univ : Finset V).powerset.filter (fun S =>
    ∀ e ∈ G.edgeFinset, ∃ v ∈ S, v ∈ e)
    |>.image Finset.card |>.min |>.getD 0

/-- Maximum matching size of a graph -/
noncomputable def maxMatchingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun M =>
    ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset)
    |>.image Finset.card |>.max |>.getD 0

/-
The size of the minimum vertex cover is at most twice the size of the maximum matching.
-/
/-- STANDARD RESULT: Minimum vertex cover ≤ 2 × maximum matching -/
theorem vertex_cover_le_two_matching (G : SimpleGraph V) [DecidableRel G.Adj] :
    vertexCoverNumber G ≤ 2 * maxMatchingNumber G := by
  -- Let $M$ be a maximum matching in $G$.
  obtain ⟨M, hM⟩ : ∃ M : Finset (Sym2 V), M ⊆ G.edgeFinset ∧ (∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) ∧ M.card = maxMatchingNumber G := by
    unfold maxMatchingNumber;
    have := Finset.max_of_nonempty ( show Finset.Nonempty ( Finset.image Finset.card { M ∈ G.edgeFinset.powerset | ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset } ) from ⟨ 0, Finset.mem_image.mpr ⟨ ∅, by simp +decide ⟩ ⟩ );
    obtain ⟨ a, ha ⟩ := this; have := Finset.mem_image.mp ( Finset.mem_of_max ha ) ; aesop;
  -- Let $S$ be the set of all endpoints of edges in $M$.
  set S := M.biUnion (fun e => e.toFinset) with hS_def;
  -- Since each edge in $M$ has two endpoints, $|S| \leq 2|M|$.
  have hS_card : S.card ≤ 2 * M.card := by
    have hS_card : ∀ e ∈ M, (e.toFinset).card ≤ 2 := by
      intro e he;
      rcases e with ⟨ x, y ⟩ ; simp +decide [ Sym2.toFinset ];
      simp +decide [ Sym2.toMultiset ];
      exact Finset.card_insert_le _ _;
    exact le_trans ( Finset.card_biUnion_le ) ( by simpa [ mul_comm ] using Finset.sum_le_sum hS_card );
  -- We claim that $S$ is a vertex cover.
  have hS_vertex_cover : ∀ e ∈ G.edgeFinset, ∃ v ∈ S, v ∈ e := by
    intro e he
    by_contra h_contra
    push_neg at h_contra;
    -- If $e$ is not covered by $S$, then $M \cup \{e\}$ is a matching larger than $M$, contradicting the maximality of $M$.
    have hM_union_e : (M ∪ {e}).card > M.card ∧ (∀ e1 ∈ M ∪ {e}, ∀ e2 ∈ M ∪ {e}, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) := by
      simp +zetaDelta at *;
      refine' ⟨ _, _, _ ⟩;
      · rw [ Finset.card_insert_of_notMem ] ; aesop;
        rintro heM; specialize h_contra; rcases e with ⟨ u, v ⟩ ; simp_all +decide ;
        exact h_contra u _ heM ( by simp +decide ) |>.1 rfl;
      · intro a ha hne; rw [ Finset.disjoint_left ] ; intro x hx hx'; specialize h_contra x a ha; aesop;
      · simp_all +decide [ Finset.disjoint_left ];
        exact fun x hx => ⟨ fun _ y hy hy' => h_contra y x hx hy hy', fun y hy hxy z hz hz' => hM.2.1 x hx y hy hxy hz hz' ⟩;
    have hM_union_e : (M ∪ {e}).card ≤ maxMatchingNumber G := by
      have hM_union_e : (M ∪ {e}) ∈ (G.edgeFinset.powerset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset)) := by
        simp_all +decide [ Finset.subset_iff ];
      have hM_union_e : ∀ x ∈ Finset.image (fun M => M.card) (G.edgeFinset.powerset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset)), x ≤ (Finset.image (fun M => M.card) (G.edgeFinset.powerset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset))).max.getD 0 := by
        intro x hx;
        have := Finset.le_max hx;
        cases h : Finset.max ( Finset.image ( fun M => M.card ) ( Finset.filter ( fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset ) ( Finset.powerset G.edgeFinset ) ) ) <;> aesop;
      exact hM_union_e _ ( Finset.mem_image_of_mem _ ‹_› );
    linarith;
  refine' le_trans _ ( hS_card.trans ( by rw [ hM.2.2 ] ) );
  unfold vertexCoverNumber;
  have h_min_le : ∀ {s : Finset ℕ}, s.Nonempty → Option.getD (s.min) 0 ≤ s.min := by
    intro s hs; cases h : s.min <;> aesop;
  specialize @h_min_le ( Finset.image Finset.card ( Finset.filter ( fun S => ∀ e ∈ G.edgeFinset, ∃ v ∈ S, v ∈ e ) ( Finset.powerset ( Finset.univ : Finset V ) ) ) ) ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_univ _ ), hS_vertex_cover ⟩ ) ⟩ ; aesop;

/-
Given an edge in the link graph of $v$, construct the corresponding triangle containing $v$.
-/
/-- Edges in the link graph correspond to triangles containing v -/
def linkEdgeToTriangle (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (e : (linkGraph G v).edgeFinset) : trianglesContainingVertex G v :=
  ⟨insert v e.1.toFinset, by
    unfold trianglesContainingVertex;
    rcases e with ⟨ e, he ⟩;
    rcases e with ⟨ x, y ⟩;
    unfold linkGraph at he;
    simp_all +decide [ SimpleGraph.isNClique_iff ];
    simp_all +decide [ SimpleGraph.edgeFinset, Sym2.toFinset ];
    simp_all +decide [ Sym2.toMultiset, Finset.card_insert_of_notMem ];
    rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_singleton ] <;> aesop⟩

def triangleEdgeEquiv (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) :
    trianglesContainingVertex G v ≃ (linkGraph G v).edgeFinset where
  toFun t :=
    let h := Finset.mem_filter.mp t.2
    let e := triangleToLinkEdge G v t.1 h.1 h.2
    ⟨e.1, by rw [SimpleGraph.mem_edgeFinset]; exact e.2⟩
  invFun e :=
    let t := linkEdgeToTriangle G v e
    ⟨t.1, t.2⟩
  left_inv := by
    -- To prove the left inverse property, we show that applying the composition of the two functions to any triangle returns the original triangle.
    intros t
    simp [linkEdgeToTriangle, triangleToLinkEdge];
    rcases t with ⟨ t, ht ⟩;
    congr;
    rw [ Finset.ext_iff ];
    have := Classical.choose_spec ( Finset.card_pos.mp ( show 0 < Finset.card ( t.erase v |> Finset.offDiag |> Finset.image Sym2.mk ) from ?_ ) );
    all_goals simp_all +decide [ Finset.mem_image, Finset.mem_offDiag ];
    obtain ⟨ a, b, h, h' ⟩ := this;
    intro x; rw [ ← h' ] ; simp +decide [ Sym2.eq_iff ] ;
    all_goals simp_all +decide [ trianglesContainingVertex ];
    all_goals have := Finset.card_eq_three.mp ht.1.2; obtain ⟨ c, d, e, hcd, hde, hec ⟩ := this; simp_all +decide [ SimpleGraph.isNClique_iff ];
    all_goals rcases ht.2 with ( rfl | rfl | rfl ) <;> simp_all +decide [ SimpleGraph.adj_comm ];
    any_goals rw [ Finset.offDiag ] ; simp +decide [ * ];
    any_goals rw [ Finset.Nonempty ] ; simp +decide [ * ];
    any_goals rcases h with ⟨ ⟨ ha, ha' ⟩, ⟨ hb, hb' ⟩, hab ⟩ ; rcases ha' with ( rfl | rfl | rfl ) <;> rcases hb' with ( rfl | rfl | rfl ) <;> tauto;
    · exact ⟨ d, e, by tauto ⟩;
    · exact ⟨ c, e, by aesop ⟩;
    · exact ⟨ c, d, by aesop ⟩
  right_inv := by
    intro e;
    rcases e with ⟨ e, he ⟩;
    unfold linkEdgeToTriangle triangleToLinkEdge;
    -- Since $e$ is an edge in the link graph, removing $v$ from the triangle gives back $e$.
    have h_erase : (insert v e.toFinset).erase v = e.toFinset := by
      ext x;
      -- If x is in the insert of v and e.toFinset, then x is either v or in e.toFinset. But since we're erasing v, x can't be v. So x must be in e.toFinset.
      simp [Finset.mem_insert, Finset.mem_erase];
      intro hx h; simp_all +decide [ linkGraph ] ;
      cases e ; aesop;
    have h_image : (Finset.image Sym2.mk (Sym2.toFinset e).offDiag).Nonempty ∧ ∀ x ∈ Finset.image Sym2.mk (Sym2.toFinset e).offDiag, x = e := by
      rcases e with ⟨ x, y ⟩ ; simp +decide [ Sym2.eq_swap ] ;
      simp +decide [ Sym2.eq_iff, Finset.Nonempty ];
      aesop;
    have := Classical.choose_spec h_image.1;
    grind

/-
The bijection between triangles at $v$ and edges in the link graph preserves the "disjointness" property (intersection size $\le 1$ for triangles corresponds to disjointness for edges).
-/
lemma triangleEdgeEquiv_preserves_disjointness (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (t1 t2 : trianglesContainingVertex G v) (hne : t1 ≠ t2) :
    (t1.1 ∩ t2.1).card ≤ 1 ↔ Disjoint (triangleEdgeEquiv G v t1).1.toFinset (triangleEdgeEquiv G v t2).1.toFinset := by
      convert ( disjoint_triangles_iff_matching G v t1.val t2.val t1.property t2.property <| by aesop ) using 1;
      unfold triangleEdgeEquiv;
      -- By definition of `triangleToLinkEdge`, the edge in the link graph is exactly the set of neighbors of `v` in the triangle.
      have h_edge : ∀ t : { x : Finset V // x ∈ trianglesContainingVertex G v }, (triangleToLinkEdge G v t.val (Finset.mem_filter.mp t.2).1 (Finset.mem_filter.mp t.2).2).1.toFinset = t.val.erase v := by
        intro t;
        have h_edge : ∀ t : { x : Finset V // x ∈ trianglesContainingVertex G v }, (triangleToLinkEdge G v t.val (Finset.mem_filter.mp t.2).1 (Finset.mem_filter.mp t.2).2).1.toFinset = t.val.erase v := by
          intro t
          have h_card : (t.val.erase v).card = 2 := by
            have := Finset.mem_filter.mp t.2;
            simp_all +decide [ SimpleGraph.isNClique_iff ]
          have h_edge : ∀ s : Finset V, s.card = 2 → (s.offDiag.image Sym2.mk).Nonempty → ∀ e ∈ s.offDiag.image Sym2.mk, e.toFinset = s := by
            simp +contextual [ Finset.card_eq_two ];
            aesop;
          apply h_edge;
          · exact h_card;
          · simp +decide [ h_card ];
            exact Finset.card_pos.mp ( by simp +decide [ h_card ] );
          · exact?;
        exact h_edge t;
      aesop

/-
The size of the maximum triangle packing at $v$ is equal to the size of the maximum matching in the link graph of $v$.
-/
/-- Triangle packing at v = Matching in link graph -/
lemma packing_at_v_eq_matching (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) :
    trianglePackingOn G (trianglesContainingVertex G v) = maxMatchingNumber (linkGraph G v) := by
  -- We use the bijection triangleEdgeEquiv and the preservation of disjointness
  let f := triangleEdgeEquiv G v
  let S_tri := trianglesContainingVertex G v
  let S_edge := (linkGraph G v).edgeFinset
  -- The packing number is the max size of a subset of S_tri with pairwise intersection <= 1
  -- The matching number is the max size of a subset of S_edge with pairwise disjoint edges
  -- The bijection f maps compatible subsets to compatible subsets
  symm;
  refine' le_antisymm _ _;
  · have h_max_packing_le_max_matching : ∀ M : Finset (Sym2 V), M ⊆ S_edge → (∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) → (M.card ≤ trianglePackingOn G S_tri) := by
      intro M hM_sub hM_disjoint
      obtain ⟨S, hS⟩ : ∃ S : Finset (Finset V), S ⊆ S_tri ∧ (∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → (t1 ∩ t2).card ≤ 1) ∧ S.card = M.card := by
        -- By definition of $f$, we can map each edge in $M$ to a triangle in $S_tri$.
        obtain ⟨S, hS⟩ : ∃ S : Finset (Finset V), S ⊆ S_tri ∧ (∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → (t1 ∩ t2).card ≤ 1) ∧ S.card = M.card := by
          have h_image : ∃ S : Finset (trianglesContainingVertex G v), S.card = M.card ∧ ∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → (t1.1 ∩ t2.1).card ≤ 1 := by
            have h_image : ∃ S : Finset (trianglesContainingVertex G v), S.card = M.card ∧ ∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → Disjoint (f t1).1.toFinset (f t2).1.toFinset := by
              use Finset.filter (fun t => (f t).1 ∈ M) (Finset.univ : Finset (trianglesContainingVertex G v));
              refine' ⟨ _, _ ⟩;
              · refine' Finset.card_bij ( fun t ht => ( f t : Sym2 V ) ) _ _ _ <;> simp +decide [ hM_sub ];
                · intro a ha ha' b hb hb' hab; have := f.injective ( Subtype.ext hab ) ; aesop;
                · intro e he; obtain ⟨ t, ht ⟩ := f.surjective ⟨ e, hM_sub he ⟩ ; use t; aesop;
              · simp +zetaDelta at *;
                exact fun a ha ha' b hb hb' hab => hM_disjoint _ ha' _ hb' <| by simpa [ Subtype.ext_iff ] using fun h => hab <| by simpa [ Subtype.ext_iff ] using f.injective <| Subtype.ext h;
            obtain ⟨ S, hS₁, hS₂ ⟩ := h_image;
            refine' ⟨ S, hS₁, fun t1 ht1 t2 ht2 hne => _ ⟩;
            have := triangleEdgeEquiv_preserves_disjointness G v t1 t2 hne;
            exact this.mpr ( hS₂ t1 ht1 t2 ht2 hne )
          obtain ⟨ S, hS₁, hS₂ ⟩ := h_image;
          refine' ⟨ S.image Subtype.val, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
          · exact?;
          · rw [ Finset.card_image_of_injective _ Subtype.coe_injective, hS₁ ];
        use S;
      unfold trianglePackingOn;
      have hS_le_packing : S.card ∈ Finset.image Finset.card (Finset.filter (fun S => S ⊆ S_tri ∧ Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)) (Finset.powerset S_tri)) := by
        simp_all +decide [ Set.Pairwise ];
        exact ⟨ S, ⟨ hS.1, hS.2.1 ⟩, hS.2.2 ⟩;
      have := Finset.le_max hS_le_packing;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( fun S => S ⊆ S_tri ∧ ( S : Set ( Finset V ) ).Pairwise fun t1 t2 => ( t1 ∩ t2 ).card ≤ 1 ) ( Finset.powerset S_tri ) ) ) <;> aesop;
    contrapose! h_max_packing_le_max_matching;
    unfold maxMatchingNumber at h_max_packing_le_max_matching;
    have := Finset.max_of_nonempty ( show Finset.Nonempty ( Finset.image Finset.card ( Finset.filter ( fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset ) ( Finset.powerset S_edge ) ) ) from ?_ );
    · obtain ⟨ a, ha ⟩ := this;
      have := Finset.mem_of_max ha;
      rw [ Finset.mem_image ] at this; obtain ⟨ M, hM₁, hM₂ ⟩ := this; use M; aesop;
    · exact ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.empty_subset _ ), by simp +decide ⟩ ) ⟩;
  · -- Let $S$ be a maximum triangle packing at $v$. By definition, $S$ is a set of triangles containing $v$ such that any two triangles in $S$ are edge-disjoint.
    obtain ⟨S, hS⟩ : ∃ S : Finset (trianglesContainingVertex G v), trianglePackingOn G S_tri = S.card ∧ Set.Pairwise (S : Set (trianglesContainingVertex G v)) (fun t1 t2 => (t1.1 ∩ t2.1).card ≤ 1) := by
      unfold trianglePackingOn;
      have := Finset.max_of_nonempty ( show Finset.Nonempty ( Finset.image Finset.card ( Finset.filter ( fun S : Finset ( Finset V ) => S ⊆ S_tri ∧ ( S : Set ( Finset V ) ).Pairwise fun t1 t2 => ( t1 ∩ t2 ).card ≤ 1 ) ( Finset.powerset S_tri ) ) ) from ?_ );
      · obtain ⟨ a, ha ⟩ := this;
        obtain ⟨ S, hS ⟩ := Finset.mem_image.mp ( Finset.mem_of_max ha );
        refine' ⟨ Finset.univ.filter fun x => x.val ∈ S, _, _ ⟩ <;> simp_all +decide [ Finset.ext_iff, Set.ext_iff ];
        · rw [ show ( Finset.filter ( fun x : { x // x ∈ trianglesContainingVertex G v } => ( x : Finset V ) ∈ S ) ( Finset.attach S_tri ) ).card = S.card from ?_ ];
          · exact hS.2.symm ▸ rfl;
          · rw [ ← Finset.card_image_of_injective _ Subtype.coe_injective ] ; congr ; ext ; aesop;
        · intro x hx y hy hxy; have := hS.1.2; aesop;
      · exact ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.empty_subset _ ), Finset.empty_subset _, by simp +decide ⟩ ) ⟩;
    -- Since $S$ is a set of triangles containing $v$, the image of $S$ under $f$ is a set of edges in the link graph of $v$.
    set T := Finset.image f S with hT;
    -- Since $T$ is a set of edges in the link graph of $v$, it is a matching.
    have hT_matching : ∀ e1 ∈ T, ∀ e2 ∈ T, e1 ≠ e2 → Disjoint e1.1.toFinset e2.1.toFinset := by
      intro e1 he1 e2 he2 hne;
      obtain ⟨ t1, ht1, rfl ⟩ := Finset.mem_image.mp he1; obtain ⟨ t2, ht2, rfl ⟩ := Finset.mem_image.mp he2; specialize hS; have := hS.2 ht1 ht2; simp_all +decide ;
      have := triangleEdgeEquiv_preserves_disjointness G v t1 t2 hne; aesop;
    -- Since $T$ is a matching, its size is at most the maximum matching size of the link graph of $v$.
    have hT_size : T.card ≤ maxMatchingNumber (linkGraph G v) := by
      have hT_size : ∀ M : Finset (Sym2 V), (∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) → M ⊆ S_edge → M.card ≤ maxMatchingNumber (linkGraph G v) := by
        intros M hM hM_subset;
        have hM_max : M.card ∈ Finset.image (fun M : Finset (Sym2 V) => M.card) (Finset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) (Finset.powerset S_edge)) := by
          exact Finset.mem_image.mpr ⟨ M, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hM_subset, hM ⟩, rfl ⟩;
        unfold maxMatchingNumber;
        have := Finset.le_max hM_max;
        rw [ WithBot.coe_le_iff ] at this;
        rcases this with ⟨ b, hb₁, hb₂ ⟩ ; rw [ hb₁ ] ; exact hb₂.trans ( by simp +decide [ Option.getD ] ) ;
      convert hT_size ( T.image Subtype.val ) _ _;
      · rw [ Finset.card_image_of_injective _ Subtype.coe_injective ];
      · grind;
      · exact Finset.image_subset_iff.mpr fun x hx => x.2;
    rw [ Finset.card_image_of_injective _ f.injective ] at hT_size ; aesop

/-
Given a vertex cover of the link graph, we can construct a triangle cover of the original graph with size at most the vertex cover size.
-/
lemma exists_triangle_cover_from_link_vertex_cover (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (S : Finset V) (hS : ∀ e ∈ (linkGraph G v).edgeFinset, ∃ x ∈ S, x ∈ e) :
    ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧
      (∀ t ∈ trianglesContainingVertex G v, ∃ e ∈ E', e ∈ t.sym2) ∧
      E'.card ≤ S.card := by
  refine' ⟨ S.filter ( fun u => G.Adj v u ) |> Finset.image fun u => Sym2.mk ( v, u ), _, _, _ ⟩;
  · intro e he
    aesop;
  · intro t ht;
    -- Since $t$ is a triangle containing $v$, there exist $x, y \in t$ such that $t = \{v, x, y\}$.
    obtain ⟨x, y, hx, hy, ht_eq⟩ : ∃ x y : V, x ∈ t ∧ y ∈ t ∧ t = {v, x, y} ∧ G.Adj v x ∧ G.Adj v y ∧ G.Adj x y := by
      unfold trianglesContainingVertex at ht;
      simp_all +decide [ Finset.ext_iff, SimpleGraph.isNClique_iff ];
      obtain ⟨ x, y, z, hxyz ⟩ := Finset.card_eq_three.mp ht.1.2;
      by_cases hvx : v = x <;> by_cases hvy : v = y <;> by_cases hvz : v = z <;> simp_all +decide;
      · exact Or.inl ⟨ fun a => by tauto, ht.2.1.symm ⟩;
      · exact Or.inr ⟨ fun a => by tauto, ht.1.symm, ht.2.2.symm, ht.2.1.symm ⟩;
    obtain ⟨ u, hu, hu' ⟩ := hS ( Sym2.mk ⟨ x, y ⟩ ) ( by
      unfold linkGraph; aesop; );
    use Sym2.mk ( v, u ) ; aesop;
  · exact Finset.card_image_le.trans ( Finset.card_filter_le _ _ )

/-
The triangle covering number at $v$ is at most the vertex cover number of the link graph at $v$.
-/
lemma cover_at_v_le_vertex_cover (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) :
    triangleCoveringNumberOn G (trianglesContainingVertex G v) ≤ vertexCoverNumber (linkGraph G v) := by
      -- By definition of the minimum, there exists an $E'$ in the set such that $|E'| \leq |S|$.
      obtain ⟨E', hE'⟩ : ∃ E' ∈ Finset.filter (fun E' => ∀ t ∈ trianglesContainingVertex G v, ∃ e ∈ E', e ∈ t.sym2) (Finset.powerset G.edgeFinset), E'.card ≤ vertexCoverNumber (linkGraph G v) := by
        obtain ⟨S, hS⟩ : ∃ S : Finset V, S ∈ Finset.filter (fun S => ∀ e ∈ (linkGraph G v).edgeFinset, ∃ x ∈ S, x ∈ e) (Finset.powerset (Finset.univ : Finset V)) ∧ S.card = vertexCoverNumber (linkGraph G v) := by
          unfold vertexCoverNumber;
          have h_min : Finset.Nonempty (Finset.image Finset.card ({S ∈ Finset.univ.powerset | ∀ e ∈ (linkGraph G v).edgeFinset, ∃ v ∈ S, v ∈ e})) := by
            simp +zetaDelta at *;
            refine' ⟨ Finset.univ, _ ⟩;
            simp +decide [ Finset.mem_univ, SimpleGraph.edgeSet ];
            exact fun e he => by rcases e with ⟨ x, y ⟩ ; aesop;
          have := Finset.min_of_nonempty h_min;
          obtain ⟨ a, ha ⟩ := this; have := Finset.mem_of_min ha; aesop;
        obtain ⟨ E', hE' ⟩ := exists_triangle_cover_from_link_vertex_cover G v S ( by simpa using hS.1 );
        exact ⟨ E', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hE'.1, hE'.2.1 ⟩, hE'.2.2.trans hS.2.le ⟩;
      refine' le_trans _ hE'.2;
      have h_min : ∀ {S : Finset ℕ}, S.Nonempty → ∀ x ∈ S, Option.getD (S.min) 0 ≤ x := by
        intro S hS x hx; have := Finset.min_le hx; cases h : Finset.min S <;> aesop;
      exact h_min ⟨ _, Finset.mem_image_of_mem _ hE'.1 ⟩ _ ( Finset.mem_image_of_mem _ hE'.1 )

/-
For any vertex $v$, the triangle covering number of the set of triangles containing $v$ is at most twice the triangle packing number of that set.
-/
/-- MAIN THEOREM: Local Tuza bound via link graph reduction -/
theorem local_tuza_via_link_graph (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) :
    triangleCoveringNumberOn G (trianglesContainingVertex G v) ≤
    2 * trianglePackingOn G (trianglesContainingVertex G v) := by
  calc triangleCoveringNumberOn G (trianglesContainingVertex G v)
      ≤ vertexCoverNumber (linkGraph G v) := cover_at_v_le_vertex_cover G v
    _ ≤ 2 * maxMatchingNumber (linkGraph G v) := vertex_cover_le_two_matching (linkGraph G v)
    _ = 2 * trianglePackingOn G (trianglesContainingVertex G v) := by
        rw [packing_at_v_eq_matching]

/-
Define the subgraph of the link graph induced by the subset of triangles `Ti`. Two vertices `x, y` are adjacent if `x \ne y` and `{v, x, y} \in Ti`.
-/
/-- The subgraph of the link graph corresponding to a subset of triangles Ti -/
def subLinkGraph (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (Ti : Finset (Finset V)) : SimpleGraph V where
  Adj x y := x ≠ y ∧ ∃ t ∈ Ti, t = {v, x, y}
  symm := by
    intro x y ⟨hne, t, ht, heq⟩
    refine ⟨hne.symm, t, ht, ?_⟩
    rw [heq]
    ext z
    simp [Finset.mem_insert]
    tauto
  loopless := by
    intro x ⟨hne, _⟩
    exact hne rfl

/-- subLinkGraph has decidable adjacency -/
instance subLinkGraphDecidableRel (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (Ti : Finset (Finset V)) : DecidableRel (subLinkGraph G v Ti).Adj := by
  intro x y
  unfold subLinkGraph
  infer_instance

/-
The triangle packing number of a subset of triangles at $v$ equals the matching number of the corresponding sub-link graph.
-/
/-- Triangle packing on Ti = Matching in subLinkGraph -/
lemma packing_Ti_eq_matching_subLink (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (Ti : Finset (Finset V)) (hTi : Ti ⊆ trianglesContainingVertex G v) :
    trianglePackingOn G Ti = maxMatchingNumber (subLinkGraph G v Ti) := by
  refine' le_antisymm ( _ : _ ≤ _ ) ( _ : _ ≤ _ );
  · -- By definition of trianglePackingOn, we know that there exists a subset of triangles in Ti that are edge-disjoint.
    obtain ⟨S, hS⟩ : ∃ S : Finset (Finset V), S ⊆ Ti ∧ (∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → (t1 ∩ t2).card ≤ 1) ∧ S.card = trianglePackingOn G Ti := by
      have := Finset.max_of_nonempty ( show ( Finset.image Finset.card ( Finset.filter ( fun S => S ⊆ Ti ∧ Set.Pairwise ( S : Set ( Finset V ) ) fun t1 t2 => ( t1 ∩ t2 ).card ≤ 1 ) Ti.powerset ) ).Nonempty from ?_ );
      · unfold trianglePackingOn;
        obtain ⟨ a, ha ⟩ := this;
        have := Finset.mem_of_max ha; aesop;
      · exact ⟨ 0, Finset.mem_image.mpr ⟨ ∅, by aesop ⟩ ⟩;
    -- Let $M$ be the set of edges in the sub-link graph corresponding to the triangles in $S$.
    obtain ⟨M, hM⟩ : ∃ M : Finset (Sym2 V), M ⊆ (subLinkGraph G v Ti).edgeFinset ∧ M.card = S.card ∧ ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset := by
      -- For each triangle $t \in S$, let $e_t$ be the corresponding edge in the sub-link graph.
      have h_edges : ∀ t ∈ S, ∃ e : Sym2 V, e ∈ (subLinkGraph G v Ti).edgeFinset ∧ e.toFinset = t.erase v := by
        intro t ht
        obtain ⟨x, y, hx, hy, hxy⟩ : ∃ x y : V, x ≠ y ∧ t = {v, x, y} := by
          have := hTi ( hS.1 ht );
          unfold trianglesContainingVertex at this;
          simp_all +decide [ Finset.ext_iff, SimpleGraph.cliqueFinset ];
          have := Finset.card_eq_three.mp this.1.2;
          obtain ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ := this; simp_all +decide [ Finset.ext_iff ] ;
          rcases this.2 with ( rfl | rfl | rfl ) <;> [ exact ⟨ y, z, hyz, by aesop ⟩ ; exact ⟨ x, z, hxz, by aesop ⟩ ; exact ⟨ x, y, hxy, by aesop ⟩ ];
        refine' ⟨ Sym2.mk ( x, y ), _, _ ⟩ <;> simp +decide [ *, Sym2.eq_swap ];
        · exact ⟨ hx, _, hS.1 ht, rfl ⟩;
        · ext; simp [Sym2.toFinset];
          intro h; have := hTi ( hS.1 ht ) ; simp_all +decide [ trianglesContainingVertex ] ;
          rintro rfl; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
      choose! f hf1 hf2 using h_edges;
      refine' ⟨ Finset.image ( fun t : S => f t.1 t.2 ) Finset.univ, _, _, _ ⟩ <;> simp_all +decide [ Finset.card_image_of_injective, Function.Injective ];
      · exact Set.range_subset_iff.mpr fun t => hf1 _ t.2;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _, Finset.card_attach, hS.2.2 ];
        intro x y hxy; have := hf2 x x.2; have := hf2 y y.2; simp_all +decide [ Finset.ext_iff ] ;
        ext a; by_cases ha : a = v <;> simp_all +decide ;
        have := hTi ( hS.1 x.2 ) ; have := hTi ( hS.1 y.2 ) ; simp_all +decide [ trianglesContainingVertex ] ;
      · intro e1 x hx he1 e2 y hy he2 hne
        have h_disjoint : (x.erase v) ∩ (y.erase v) = ∅ := by
          have := hS.2.1 x hx y hy ( by aesop ) ; simp_all +decide [ Finset.ext_iff ] ;
          contrapose! this;
          obtain ⟨ a, ha1, ha2, ha3 ⟩ := this; exact Finset.one_lt_card.mpr ⟨ a, by aesop, v, by have := hTi ( hS.1 hx ) ; have := hTi ( hS.1 hy ) ; simp_all +decide [ trianglesContainingVertex ] ⟩ ;
        simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
        grind;
    -- Since $M$ is a matching in the sub-link graph, its size is at most the maximum matching number of the sub-link graph.
    have hM_le_maxMatching : M.card ≤ maxMatchingNumber (subLinkGraph G v Ti) := by
      unfold maxMatchingNumber;
      have hM_le_maxMatching : M ∈ Finset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) (Finset.powerset (subLinkGraph G v Ti).edgeFinset) := by
        aesop;
      have hM_le_maxMatching : M.card ∈ Finset.image Finset.card (Finset.filter (fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) (Finset.powerset (subLinkGraph G v Ti).edgeFinset)) := by
        exact Finset.mem_image_of_mem _ hM_le_maxMatching;
      have := Finset.le_max hM_le_maxMatching;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset ) ( Finset.powerset ( subLinkGraph G v Ti ).edgeFinset ) ) ) <;> aesop;
    grind;
  · -- Given a matching in the subLinkGraph, we can map each edge to the corresponding triangle in Ti.
    have h_matching_to_packing : ∀ M : Finset (Sym2 V), M ⊆ (subLinkGraph G v Ti).edgeFinset → (∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) → ∃ S : Finset (Finset V), S ⊆ Ti ∧ (∀ t1 ∈ S, ∀ t2 ∈ S, t1 ≠ t2 → (t1 ∩ t2).card ≤ 1) ∧ S.card = M.card := by
      intro M hM hM';
      have h_triangle_map : ∀ e ∈ M, ∃ t ∈ Ti, t = {v} ∪ e.toFinset := by
        intro e he
        obtain ⟨x, y, hxy⟩ : ∃ x y : V, e = Sym2.mk (x, y) ∧ x ≠ y ∧ ∃ t ∈ Ti, t = {v, x, y} := by
          have := hM he; simp_all +decide [ subLinkGraph ] ;
          rcases e with ⟨ x, y ⟩ ; aesop;
        convert hxy.2.2 using 1 ; ext ; aesop;
      choose! f hf1 hf2 using h_triangle_map;
      refine' ⟨ Finset.image f M, _, _, _ ⟩;
      · exact Finset.image_subset_iff.mpr hf1;
      · simp_all +decide [ Finset.disjoint_iff_inter_eq_empty ];
        intro e1 he1 e2 he2 hne; specialize hM' e1 he1 e2 he2; simp_all +decide [ Finset.ext_iff ] ;
        by_cases h : e1 = e2 <;> simp_all +decide [ Finset.ext_iff ];
        rw [ Finset.card_le_one_iff ] ; aesop;
      · rw [ Finset.card_image_of_injOn ];
        intro e1 he1 e2 he2 h; specialize hM' e1 he1 e2 he2; simp_all +decide [ Finset.disjoint_left ] ;
        contrapose! hM';
        rcases e1 with ⟨ x, y ⟩ ; rcases e2 with ⟨ u, v ⟩ ; simp_all +decide [ Finset.ext_iff ];
        cases h x ; cases h y ; aesop;
    have h_matching_to_packing : ∀ M : Finset (Sym2 V), M ⊆ (subLinkGraph G v Ti).edgeFinset → (∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset) → M.card ≤ trianglePackingOn G Ti := by
      intro M hM hM'; obtain ⟨ S, hS₁, hS₂, hS₃ ⟩ := h_matching_to_packing M hM hM'; rw [ ← hS₃ ] ;
      unfold trianglePackingOn;
      have h_max : S.card ∈ Finset.image Finset.card ({S ∈ Ti.powerset | S ⊆ Ti ∧ (↑S : Set (Finset V)).Pairwise fun (t1 t2 : Finset V) => (t1 ∩ t2).card ≤ 1}) := by
        simp +zetaDelta at *;
        exact ⟨ S, ⟨ hS₁, fun t1 ht1 t2 ht2 hne => hS₂ t1 ht1 t2 ht2 hne ⟩, rfl ⟩;
      have := Finset.le_max h_max;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( fun S => S ⊆ Ti ∧ ( S : Set ( Finset V ) ).Pairwise fun t1 t2 => ( t1 ∩ t2 ).card ≤ 1 ) ( Finset.powerset Ti ) ) ) <;> aesop;
    unfold maxMatchingNumber;
    rcases x : Finset.max ( Finset.image Finset.card ( Finset.filter ( fun M => ∀ e1 ∈ M, ∀ e2 ∈ M, e1 ≠ e2 → Disjoint e1.toFinset e2.toFinset ) ( Finset.powerset ( subLinkGraph G v Ti ).edgeFinset ) ) ) with ( _ | x ) <;> simp +decide [ x ];
    have := Finset.mem_of_max x;
    rw [ Finset.mem_image ] at this; obtain ⟨ M, hM, rfl ⟩ := this; exact h_matching_to_packing M ( Finset.mem_powerset.mp ( Finset.mem_filter.mp hM |>.1 ) ) ( Finset.mem_filter.mp hM |>.2 ) ;

/-
Given a vertex cover of the sub-link graph for a set of triangles $Ti$, we can construct a cover of $Ti$ in the original graph with size at most the vertex cover size.
-/
lemma exists_triangle_cover_from_subLink_vertex_cover (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (Ti : Finset (Finset V)) (hTi : Ti ⊆ trianglesContainingVertex G v)
    (S : Finset V) (hS : ∀ e ∈ (subLinkGraph G v Ti).edgeFinset, ∃ x ∈ S, x ∈ e) :
    ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧
      (∀ t ∈ Ti, ∃ e ∈ E', e ∈ t.sym2) ∧
      E'.card ≤ S.card := by
  refine' ⟨ Finset.image ( fun x => Sym2.mk ( v, x ) ) ( S.filter fun x => G.Adj v x ), _, _, _ ⟩;
  · intro e he
    aesop;
  · intro t ht
    obtain ⟨x, y, hx, hy, hxy⟩ : ∃ x y, x ≠ y ∧ t = {v, x, y} ∧ G.Adj v x ∧ G.Adj v y := by
      have := hTi ht;
      unfold trianglesContainingVertex at this;
      simp_all +decide [ Finset.subset_iff, SimpleGraph.is3Clique_iff ];
      rcases this with ⟨ ⟨ a, b, hab, x, hx, hx', rfl ⟩, hv ⟩ ; simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ] ;
      rcases hv with ( rfl | rfl | rfl ) <;> simp_all +decide [ SimpleGraph.adj_comm ];
      · exact ⟨ b, x, by aesop ⟩;
      · exact ⟨ a, x, by aesop ⟩;
      · exact ⟨ a, b, by aesop ⟩;
    specialize hS ( Sym2.mk ( x, y ) ) ; simp_all +decide [ SimpleGraph.adj_comm ] ;
    exact hS ⟨ hx, ⟨ { v, x, y }, ht, by aesop ⟩ ⟩ |> fun ⟨ a, ha, ha' ⟩ => ⟨ a, ⟨ ha, by rcases ha' with ( rfl | rfl ) <;> tauto ⟩, by rcases ha' with ( rfl | rfl ) <;> tauto ⟩;
  · exact Finset.card_image_le.trans ( Finset.card_filter_le _ _ )

/-
The triangle covering number of a subset of triangles $Ti$ at $v$ is at most the vertex cover number of the corresponding sub-link graph.
-/
lemma cover_Ti_le_vertex_cover_subLink (G : SimpleGraph V) [DecidableRel G.Adj] (v : V)
    (Ti : Finset (Finset V)) (hTi : Ti ⊆ trianglesContainingVertex G v) :
    triangleCoveringNumberOn G Ti ≤ vertexCoverNumber (subLinkGraph G v Ti) := by
      -- By `exists_triangle_cover_from_subLink_vertex_cover`, there exists a set of edges `E'` in `G` such that `E'` covers all triangles in `Ti` and `|E'| ≤ |S|`.
      obtain ⟨E', hE'_subset, hE'_covers, hE'_card⟩ : ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧ (∀ t ∈ Ti, ∃ e ∈ E', e ∈ t.sym2) ∧ E'.card ≤ vertexCoverNumber (subLinkGraph G v Ti) := by
        -- Let $S$ be a minimum vertex cover of the sub-link graph $L' = \text{subLinkGraph}(G, v, Ti)$.
        obtain ⟨S, hS⟩ : ∃ S : Finset V, S.card = vertexCoverNumber (subLinkGraph G v Ti) ∧ ∀ e ∈ (subLinkGraph G v Ti).edgeFinset, ∃ x ∈ S, x ∈ e := by
          unfold vertexCoverNumber;
          have := Finset.min_of_mem ( show Finset.card ( Finset.univ : Finset V ) ∈ Finset.image Finset.card ( Finset.filter ( fun S => ∀ e ∈ ( subLinkGraph G v Ti ).edgeFinset, ∃ v ∈ S, v ∈ e ) ( Finset.powerset ( Finset.univ : Finset V ) ) ) from ?_ );
          · rcases this with ⟨ b, hb ⟩ ; have := Finset.mem_of_min hb; aesop;
          · simp +decide;
            refine' ⟨ Finset.univ, _, _ ⟩ <;> simp +decide;
            exact fun e he => by rcases e with ⟨ x, y ⟩ ; aesop;
        exact Exists.imp ( by aesop ) ( exists_triangle_cover_from_subLink_vertex_cover G v Ti hTi S hS.2 );
      unfold triangleCoveringNumberOn;
      refine' le_trans _ hE'_card;
      have h_image_card_le : Finset.card E' ∈ Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ Ti, ∃ e ∈ E', e ∈ t.sym2}) := by
        aesop;
      have := Finset.min_le h_image_card_le;
      rw [ WithTop.le_coe_iff ] at this ; aesop

/-
For any subset of triangles $Ti$ containing a vertex $v$, the triangle covering number of $Ti$ is at most twice the triangle packing number of $Ti$.
-/
/-- For each partition piece T_i (triangles containing shared vertex v_i),
    we have τ(T_i) ≤ 2·ν(T_i) -/
theorem partition_piece_tuza_bound (G : SimpleGraph V) [DecidableRel G.Adj]
    (Ti : Finset (Finset V)) (v : V)
    (hTi : Ti ⊆ trianglesContainingVertex G v) :
    triangleCoveringNumberOn G Ti ≤ 2 * trianglePackingOn G Ti := by
  calc triangleCoveringNumberOn G Ti
      ≤ vertexCoverNumber (subLinkGraph G v Ti) := cover_Ti_le_vertex_cover_subLink G v Ti hTi
    _ ≤ 2 * maxMatchingNumber (subLinkGraph G v Ti) := vertex_cover_le_two_matching (subLinkGraph G v Ti)
    _ = 2 * trianglePackingOn G Ti := by rw [packing_Ti_eq_matching_subLink G v Ti hTi]