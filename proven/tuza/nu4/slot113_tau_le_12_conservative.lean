/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5d2756b0-17d7-4e88-98ed-55117529555c
-/

/-
Verified the conservative bound τ ≤ 12 for the Cycle4 case of Tuza's conjecture (ν=4).
Successfully proved all lemmas and the main theorem `tau_le_12_cycle4_conservative` using the provided strategy.
Key results:
- `cycle4_tpair_covers_all`: All triangles are in T_pair(A,B) ∪ T_pair(C,D).
- `tau_tpair_le_6`: Each T_pair is covered by ≤ 6 edges.
- `tau_le_12_cycle4_conservative`: The total covering number is ≤ 12.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

def isTriangleCover (G : SimpleGraph V) [DecidableRel G.Adj] (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧ ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

-- ══════════════════════════════════════════════════════════════════════════════
-- CYCLE_4 CONFIGURATION
-- ══════════════════════════════════════════════════════════════════════════════

structure Cycle4 (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) where
  A : Finset V
  B : Finset V
  C : Finset V
  D : Finset V
  hA : A ∈ M
  hB : B ∈ M
  hC : C ∈ M
  hD : D ∈ M
  hM_eq : M = {A, B, C, D}
  v_ab : V
  v_bc : V
  v_cd : V
  v_da : V
  hAB : A ∩ B = {v_ab}
  hBC : B ∩ C = {v_bc}
  hCD : C ∩ D = {v_cd}
  hDA : D ∩ A = {v_da}
  h_vab_A : v_ab ∈ A
  h_vab_B : v_ab ∈ B
  h_vbc_B : v_bc ∈ B
  h_vbc_C : v_bc ∈ C
  h_vcd_C : v_cd ∈ C
  h_vcd_D : v_cd ∈ D
  h_vda_D : v_da ∈ D
  h_vda_A : v_da ∈ A

-- ══════════════════════════════════════════════════════════════════════════════
-- T_PAIR DECOMPOSITION
-- ══════════════════════════════════════════════════════════════════════════════

/-- T_pair(A,B): Triangles sharing edge with A or B -/
def T_pair (G : SimpleGraph V) [DecidableRel G.Adj] (A B : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => (t ∩ A).card ≥ 2 ∨ (t ∩ B).card ≥ 2)

/-- Triangles containing vertex v -/
def trianglesContaining (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => v ∈ t)

/-- Triangles avoiding vertex v -/
def trianglesAvoiding (G : SimpleGraph V) [DecidableRel G.Adj] (v : V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun t => v ∉ t)

/-- PROVEN: Subadditivity -/
lemma tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (S₁ S₂ : Finset (Finset V)) (h₁ : S₁ ⊆ G.cliqueFinset 3) (h₂ : S₂ ⊆ G.cliqueFinset 3)
    (bound₁ bound₂ : ℕ)
    (hS₁ : ∃ E₁ ⊆ G.edgeFinset, E₁.card ≤ bound₁ ∧ ∀ t ∈ S₁, ∃ e ∈ E₁, e ∈ t.sym2)
    (hS₂ : ∃ E₂ ⊆ G.edgeFinset, E₂.card ≤ bound₂ ∧ ∀ t ∈ S₂, ∃ e ∈ E₂, e ∈ t.sym2) :
    ∃ E ⊆ G.edgeFinset, E.card ≤ bound₁ + bound₂ ∧ ∀ t ∈ S₁ ∪ S₂, ∃ e ∈ E, e ∈ t.sym2 := by
  obtain ⟨E₁, hE₁_sub, hE₁_card, hE₁_cover⟩ := hS₁
  obtain ⟨E₂, hE₂_sub, hE₂_card, hE₂_cover⟩ := hS₂
  use E₁ ∪ E₂
  constructor
  · exact Finset.union_subset hE₁_sub hE₂_sub
  constructor
  · calc (E₁ ∪ E₂).card ≤ E₁.card + E₂.card := Finset.card_union_le E₁ E₂
         _ ≤ bound₁ + bound₂ := Nat.add_le_add hE₁_card hE₂_card
  · intro t ht
    simp only [Finset.mem_union] at ht
    cases ht with
    | inl h₁ =>
      obtain ⟨e, he_mem, he_in⟩ := hE₁_cover t h₁
      exact ⟨e, Finset.mem_union_left E₂ he_mem, he_in⟩
    | inr h₂ =>
      obtain ⟨e, he_mem, he_in⟩ := hE₂_cover t h₂
      exact ⟨e, Finset.mem_union_right E₁ he_mem, he_in⟩

/-- PROVEN: Every triangle shares edge with packing -/
lemma triangle_shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ X ∈ M, (t ∩ X).card ≥ 2 := by
  -- By maximality of M, t must share at least two vertices with some triangle in M.
  have h_max : ∀ t ∈ G.cliqueFinset 3, ∃ X ∈ M, (t ∩ X).card ≥ 2 := by
    intro t ht
    by_contra h_no_triangle
    push_neg at h_no_triangle
    have h_packing : isTrianglePacking G (M ∪ {t}) := by
      constructor;
      · -- Since $M$ is a packing, it is a subset of the cliqueFinset 3. Adding $t$ to $M$ should still be a subset of the cliqueFinset 3 because $t$ itself is in the cliqueFinset 3.
        have hM_subset : M ⊆ G.cliqueFinset 3 := by
          have := hM.1.1; aesop;
        exact Finset.union_subset hM_subset ( Finset.singleton_subset_iff.mpr ht );
      · -- Since $M$ is a packing, any two distinct triangles in $M$ have at most one vertex in common.
        have h_pairwise_M : ∀ t1 t2 : Finset V, t1 ∈ M → t2 ∈ M → t1 ≠ t2 → (t1 ∩ t2).card ≤ 1 := by
          have := hM.1.2; aesop;
        intro t1 ht1 t2 ht2 hne; by_cases h : t1 = t <;> by_cases h' : t2 = t <;> simp_all +decide ;
        · simpa only [ Finset.inter_comm ] using Nat.le_of_lt_succ ( h_no_triangle _ ht2 );
        · simpa only [ Finset.inter_comm ] using Nat.le_of_lt_succ ( h_no_triangle _ ht1 );
    have h_card : (M ∪ {t}).card > M.card := by
      -- Since $t \notin M$, adding $t$ to $M$ increases the cardinality by one.
      have h_not_in_M : t ∉ M := by
        intro h; specialize h_no_triangle t h; simp_all +decide ;
        exact h_no_triangle.not_le ( by rw [ ht.card_eq ] ; decide );
      aesop;
    have h_contradiction : trianglePackingNumber G ≥ (M ∪ {t}).card := by
      have h_contradiction : (M ∪ {t}) ∈ (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) := by
        simp_all +decide [ Finset.subset_iff ];
        exact fun x hx => Finset.mem_coe.mp ( Finset.mem_coe.mpr ( h_packing.1 ( Finset.mem_insert_of_mem hx ) ) ) |> fun h => by simpa using h;
      unfold trianglePackingNumber;
      have := Finset.le_max ( Finset.mem_image_of_mem Finset.card h_contradiction );
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 ).powerset ) ) <;> aesop;
    linarith [ hM.2 ];
  exact h_max t ht -- Standard maximality, well-established

/-- All triangles covered by T_pair(A,B) ∪ T_pair(C,D) -/
lemma cycle4_tpair_covers_all (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (cfg : Cycle4 G M) :
    G.cliqueFinset 3 ⊆ T_pair G cfg.A cfg.B ∪ T_pair G cfg.C cfg.D := by
  intro t ht
  obtain ⟨X, hX_mem, hX_share⟩ := triangle_shares_edge_with_packing G M hM t ht
  rw [cfg.hM_eq] at hX_mem
  simp only [Finset.mem_insert, Finset.mem_singleton] at hX_mem
  rcases hX_mem with rfl | rfl | rfl | rfl
  · simp only [Finset.mem_union]; left; simp only [T_pair, Finset.mem_filter]; exact ⟨ht, Or.inl hX_share⟩
  · simp only [Finset.mem_union]; left; simp only [T_pair, Finset.mem_filter]; exact ⟨ht, Or.inr hX_share⟩
  · simp only [Finset.mem_union]; right; simp only [T_pair, Finset.mem_filter]; exact ⟨ht, Or.inl hX_share⟩
  · simp only [Finset.mem_union]; right; simp only [T_pair, Finset.mem_filter]; exact ⟨ht, Or.inr hX_share⟩

lemma tau_containing_v_in_pair_le_4 (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset V) (hA : A ∈ G.cliqueFinset 3) (hB : B ∈ G.cliqueFinset 3)
    (v : V) (h_inter : A ∩ B = {v}) :
    ∃ E ⊆ G.edgeFinset, E.card ≤ 4 ∧
      ∀ t ∈ (T_pair G A B).filter (fun t => v ∈ t), ∃ e ∈ E, e ∈ t.sym2 := by
  refine' ⟨ _, _, _, _ ⟩;
  exact ( A \ { v } ).image ( fun w => Sym2.mk ( v, w ) ) ∪ ( B \ { v } ).image ( fun w => Sym2.mk ( v, w ) );
  · simp_all +decide [ Finset.subset_iff ];
    rintro _ ( ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ | ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ];
    · replace h_inter := Finset.ext_iff.mp h_inter v ; aesop;
    · rw [ Finset.eq_singleton_iff_unique_mem ] at h_inter ; aesop;
  · rw [ Finset.card_union_of_disjoint ];
    · rw [ Finset.card_image_of_injOn, Finset.card_image_of_injOn ];
      · simp_all +decide [ Finset.card_sdiff ];
        simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
        have := hA.2; have := hB.2; aesop;
      · intro w hw w' hw' h; aesop;
      · intro w hw w' hw' h; aesop;
    · simp_all +decide [ Finset.disjoint_left, Sym2.eq_iff ];
      intro a x hx hx' hx'' y hy hy' hy''; subst_vars; simp_all +decide [ Finset.eq_singleton_iff_unique_mem ] ;
  · simp_all +decide [ Finset.ext_iff, T_pair ];
    intro t ht h hvt; cases' h with h h <;> obtain ⟨ w, hw ⟩ := Finset.exists_mem_ne h v <;> use Sym2.mk ( v, w ) <;> aesop;

/-- PROVEN: 2 base edges cover triangles avoiding v -/
lemma tau_avoiding_v_le_2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : M ⊆ G.cliqueFinset 3)
    (A B : Finset V) (hA : A ∈ M) (hB : B ∈ M)
    (v : V) (h_inter : A ∩ B = {v}) :
    ∃ E ⊆ G.edgeFinset, E.card ≤ 2 ∧
      ∀ t ∈ (trianglesAvoiding G v).filter (fun t => (t ∩ A).card ≥ 2 ∨ (t ∩ B).card ≥ 2),
        ∃ e ∈ E, e ∈ t.sym2 := by
  -- Let A = {v, a1, a2} and B = {v, b1, b2}.
  obtain ⟨a1, a2, ha1, ha2, hA⟩ : ∃ a1 a2 : V, a1 ≠ a2 ∧ A = {v, a1, a2} := by
    have hA_card : A.card = 3 := by
      have := hM hA; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
      exact this.2;
    have hA_subset : v ∈ A := by
      exact Finset.mem_of_mem_inter_left ( h_inter.symm ▸ Finset.mem_singleton_self _ );
    rw [ Finset.card_eq_three ] at hA_card; obtain ⟨ a1, a2, a3, ha1, ha2, ha3 ⟩ := hA_card; use if a1 = v then a2 else if a2 = v then a3 else a1, if a1 = v then a3 else if a2 = v then a1 else a2; aesop;
  obtain ⟨b1, b2, hb1, hb2, hB⟩ : ∃ b1 b2 : V, b1 ≠ b2 ∧ B = {v, b1, b2} := by
    have := hM hB;
    rw [ SimpleGraph.cliqueFinset ] at this;
    rw [ Finset.mem_filter ] at this;
    obtain ⟨ b1, b2, hb1, hb2 ⟩ := Finset.card_eq_three.mp this.2.2;
    simp_all +decide [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
    grind;
  refine' ⟨ { Sym2.mk ( a1, a2 ), Sym2.mk ( b1, b2 ) }, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
  · have := hM hA; have := hM hB; simp_all +decide [ Finset.ext_iff, SimpleGraph.isNClique_iff ] ;
  · exact Finset.card_insert_le _ _;
  · simp_all +decide [ Finset.ext_iff, trianglesAvoiding ];
    intro t ht hv h; contrapose! h; simp_all +decide [ Finset.card_le_one, SimpleGraph.isNClique_iff ] ;
    exact ⟨ lt_of_le_of_lt ( Finset.card_le_one.mpr ( by aesop ) ) ( by decide ), lt_of_le_of_lt ( Finset.card_le_one.mpr ( by aesop ) ) ( by decide ) ⟩

/-- T_pair bound: τ(T_pair) ≤ 6 -/
lemma tau_tpair_le_6 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : M ⊆ G.cliqueFinset 3)
    (A B : Finset V) (hA : A ∈ M) (hB : B ∈ M) (hAB : A ≠ B)
    (v : V) (h_inter : A ∩ B = {v}) :
    ∃ E ⊆ G.edgeFinset, E.card ≤ 6 ∧
      ∀ t ∈ T_pair G A B, ∃ e ∈ E, e ∈ t.sym2 := by
  -- For `S_in`: Use `tau_containing_v_in_pair_le_4` with `A` and `B`.
  obtain ⟨E_in, hE_in⟩ : ∃ E_in ⊆ G.edgeFinset, E_in.card ≤ 4 ∧ ∀ t ∈ (T_pair G A B).filter (fun t => v ∈ t), ∃ e ∈ E_in, e ∈ t.sym2 := by
    convert tau_containing_v_in_pair_le_4 G A B ( hM hA ) ( hM hB ) v h_inter;
  -- For `S_out`: Use `tau_avoiding_v_le_2` with `M`, `A`, `B`.
  obtain ⟨E_out, hE_out⟩ : ∃ E_out ⊆ G.edgeFinset, E_out.card ≤ 2 ∧ ∀ t ∈ (T_pair G A B).filter (fun t => v ∉ t), ∃ e ∈ E_out, e ∈ t.sym2 := by
    convert tau_avoiding_v_le_2 G M hM A B hA hB v h_inter using 6;
    unfold T_pair trianglesAvoiding; aesop;
  refine' ⟨ E_in ∪ E_out, Finset.union_subset hE_in.1 hE_out.1, _, _ ⟩ <;> simp_all +decide [ Finset.card_union_le ];
  · exact le_trans ( Finset.card_union_le _ _ ) ( add_le_add hE_in.2.1 hE_out.2.1 );
  · exact fun t ht => if h : v ∈ t then hE_in.2.2 t ht h |> fun ⟨ e, he₁, he₂ ⟩ => ⟨ e, Or.inl he₁, he₂ ⟩ else hE_out.2.2 t ht h |> fun ⟨ e, he₁, he₂ ⟩ => ⟨ e, Or.inr he₁, he₂ ⟩

theorem tau_le_12_cycle4_conservative (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (hM_card : M.card = 4)
    (cfg : Cycle4 G M)
    (h_diag_AC : (cfg.A ∩ cfg.C).card ≤ 1)
    (h_diag_BD : (cfg.B ∩ cfg.D).card ≤ 1)
    (h_nu_4 : trianglePackingNumber G = 4) :
    triangleCoveringNumber G ≤ 12 := by
  have hM_sub : M ⊆ G.cliqueFinset 3 := hM.1.1
  have hAB_ne : cfg.A ≠ cfg.B := by
    intro h
    have hA_card : cfg.A.card = 3 := (SimpleGraph.mem_cliqueFinset_iff.mp (hM_sub cfg.hA)).2
    have h_inter : cfg.A ∩ cfg.B = {cfg.v_ab} := cfg.hAB
    rw [h] at h_inter
    rw [Finset.inter_self] at h_inter
    rw [h] at hA_card
    rw [h_inter] at hA_card
    simp at hA_card
  have hCD_ne : cfg.C ≠ cfg.D := by
    intro h
    have hC_card : cfg.C.card = 3 := (SimpleGraph.mem_cliqueFinset_iff.mp (hM_sub cfg.hC)).2
    have h_inter : cfg.C ∩ cfg.D = {cfg.v_cd} := cfg.hCD
    rw [h] at h_inter
    rw [Finset.inter_self] at h_inter
    rw [h] at hC_card
    rw [h_inter] at hC_card
    simp at hC_card

  -- Step 1: All triangles covered by T_pair(A,B) ∪ T_pair(C,D)
  have h_cover := cycle4_tpair_covers_all G M hM cfg

  -- Step 2: T_pair(A,B) needs ≤ 6 edges
  obtain ⟨E_AB, hE_AB_sub, hE_AB_card, hE_AB_cover⟩ :=
    tau_tpair_le_6 G M hM_sub cfg.A cfg.B cfg.hA cfg.hB hAB_ne cfg.v_ab cfg.hAB

  -- Step 3: T_pair(C,D) needs ≤ 6 edges
  obtain ⟨E_CD, hE_CD_sub, hE_CD_card, hE_CD_cover⟩ :=
    tau_tpair_le_6 G M hM_sub cfg.C cfg.D cfg.hC cfg.hD hCD_ne cfg.v_cd cfg.hCD

  -- Step 4: Union gives ≤ 12
  -- By definition of `triangleCoveringNumber`, we have that `triangleCoveringNumber G ≤ E_AB.card + E_CD.card`.
  have h_triangleCoveringNumber_le : triangleCoveringNumber G ≤ (E_AB ∪ E_CD).card := by
    unfold triangleCoveringNumber;
    -- Since $E_AB \cup E_CD$ is a valid triangle cover, we have $(E_AB \cup E_CD).card \geq \text{triangleCoveringNumber } G$.
    have h_triangleCover_le_union : isTriangleCover G (E_AB ∪ E_CD) := by
      exact ⟨ Finset.union_subset hE_AB_sub hE_CD_sub, fun t ht => by rcases Finset.mem_union.1 ( h_cover ht ) with ( ht | ht ) <;> [ obtain ⟨ e, he₁, he₂ ⟩ := hE_AB_cover t ht; obtain ⟨ e, he₁, he₂ ⟩ := hE_CD_cover t ht ] <;> exact ⟨ e, Finset.mem_union.2 ( by aesop ), he₂ ⟩ ⟩;
    have h_triangleCover_le_union : (Finset.image Finset.card (Finset.filter (isTriangleCover G) G.edgeFinset.powerset)).min ≤ (E_AB ∪ E_CD).card := by
      exact Finset.min_le ( Finset.mem_image.mpr ⟨ _, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.union_subset hE_AB_sub hE_CD_sub ), h_triangleCover_le_union ⟩, rfl ⟩ );
    cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( isTriangleCover G ) G.edgeFinset.powerset ) ) <;> aesop;
  exact h_triangleCoveringNumber_le.trans ( le_trans ( Finset.card_union_le _ _ ) ( add_le_add hE_AB_card hE_CD_card ) )