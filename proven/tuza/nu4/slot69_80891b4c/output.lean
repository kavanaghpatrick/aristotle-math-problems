/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 80891b4c-dfa6-42fb-93af-195123a75936

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Classical


variable {V : Type*} [Fintype V] [DecidableEq V]

-- ══════════════════════════════════════════════════════════════════════════════
-- DEFINITIONS (same as path_4)
-- ══════════════════════════════════════════════════════════════════════════════

def isTrianglePacking (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isMaxPacking (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

noncomputable def triangleCoveringNumber (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => E' ⊆ G.edgeFinset ∧
    ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

noncomputable def triangleCoveringNumberOn (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2)
    |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def T_pair (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  trianglesSharingEdge G e ∪ trianglesSharingEdge G f

def trianglesContaining (triangles : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  triangles.filter (fun t => v ∈ t)

def trianglesAvoiding (triangles : Finset (Finset V)) (v : V) : Finset (Finset V) :=
  triangles.filter (fun t => v ∉ t)

-- ══════════════════════════════════════════════════════════════════════════════
-- CYCLE_4 STRUCTURE
-- ══════════════════════════════════════════════════════════════════════════════

def isCycle4 (M : Finset (Finset V)) (A B C D : Finset V) : Prop :=
  M = {A, B, C, D} ∧
  A ≠ B ∧ B ≠ C ∧ C ≠ D ∧ D ≠ A ∧ A ≠ C ∧ B ≠ D ∧
  -- Adjacent pairs share exactly 1 vertex
  (A ∩ B).card = 1 ∧
  (B ∩ C).card = 1 ∧
  (C ∩ D).card = 1 ∧
  (D ∩ A).card = 1 ∧
  -- Opposite pairs are disjoint (no shared vertex)
  (A ∩ C).card = 0 ∧
  (B ∩ D).card = 0

theorem tau_union_le_sum (G : SimpleGraph V) [DecidableRel G.Adj]
    (A B : Finset (Finset V)) :
    triangleCoveringNumberOn G (A ∪ B) ≤
    triangleCoveringNumberOn G A + triangleCoveringNumberOn G B := by
  unfold triangleCoveringNumberOn;
  by_cases hA : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ A ∪ B, ∃ e ∈ E', e ∈ t.sym2;
  · -- Since $E_1 \cup E_2$ is a valid edge set covering both $A$ and $B$, its cardinality is at least as large as the minimum cardinality of any such edge set.
    have h_union : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min + (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min := by
      have h_union : ∀ E1 ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), ∀ E2 ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ Finset.card E1 + Finset.card E2 := by
        intros E1 hE1 E2 hE2
        have h_union : E1 ∪ E2 ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}) := by
          grind;
        -- Since the minimum of a set is less than or equal to any element in the set, and E1 ∪ E2 is in the set, we have min ≤ Finset.card (E1 ∪ E2).
        have h_min_le_union : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A ∪ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ Finset.card (E1 ∪ E2) := by
          exact Finset.min_le ( Finset.mem_image_of_mem _ h_union );
        exact h_min_le_union.trans ( mod_cast Finset.card_union_le _ _ );
      by_cases hB : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t;
      · obtain ⟨E1, hE1⟩ : ∃ E1 ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), ∀ E' ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), E1.card ≤ E'.card := by
          apply_rules [ Finset.exists_min_image ];
          exact ⟨ hA.choose, Finset.mem_filter.mpr ⟨ hA.choose_spec.1, fun t ht => by simpa using hA.choose_spec.2 t ( Finset.mem_union_left _ ht ) ⟩ ⟩;
        obtain ⟨E2, hE2⟩ : ∃ E2 ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), ∀ E' ∈ ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t}), E2.card ≤ E'.card := by
          apply_rules [ Finset.exists_min_image ];
          exact ⟨ hB.choose, Finset.mem_filter.mpr ⟨ hB.choose_spec.1, hB.choose_spec.2 ⟩ ⟩;
        convert h_union E1 hE1.1 E2 hE2.1 using 1;
        congr! 1;
        · refine' le_antisymm _ _;
          · exact Finset.min_le ( Finset.mem_image_of_mem _ hE1.1 );
          · simp +zetaDelta at *;
            exact fun a x hx hx' hx'' => hx''.symm ▸ hE1.2 x hx hx';
        · refine' le_antisymm _ _;
          · exact Finset.min_le ( Finset.mem_image_of_mem _ hE2.1 );
          · simp +zetaDelta at *;
            exact fun a x hx hx' hx'' => hx''.symm ▸ hE2.2 x hx hx';
      · contrapose! hB;
        obtain ⟨ E', hE'₁, hE'₂ ⟩ := hA;
        exact ⟨ E', hE'₁, fun t ht => by obtain ⟨ e, he₁, he₂ ⟩ := hE'₂ t ( Finset.mem_union_right _ ht ) ; exact ⟨ e, he₁, by simpa using he₂ ⟩ ⟩;
    convert h_union using 1;
    cases h : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> cases h' : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ A, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> cases h'' : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> simp +decide [ h, h', h'' ];
    · -- Since the minimum of the image of the cardinality of the set of edge sets covering A ∪ B is ⊤, this leads to a contradiction because the minimum of a non-empty set of natural numbers cannot be ⊤.
      have h_contra : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ A ∪ B, ∃ e ∈ E', ∀ a ∈ e, a ∈ t := by
        obtain ⟨ E', hE', hE'' ⟩ := hA;
        exact ⟨ E', hE', fun t ht => by obtain ⟨ e, he₁, he₂ ⟩ := hE'' t ht; exact ⟨ e, he₁, by simpa using he₂ ⟩ ⟩;
      obtain ⟨ E', hE', hE'' ⟩ := h_contra;
      exact absurd h ( ne_of_lt ( lt_of_le_of_lt ( Finset.min_le ( Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ hE', fun t ht => by aesop ⟩ ) ) ) ( WithTop.coe_lt_top _ ) ) );
    · -- Since the minimum of the image of the cardinality over the set of edge sets covering B is ⊤, this implies that there are no edge sets covering B, which contradicts the existence of E' covering A ∪ B.
      have h_contra : ∃ E' ∈ G.edgeFinset.powerset, ∀ t ∈ B, ∃ e ∈ E', e ∈ t.sym2 := by
        exact ⟨ hA.choose, hA.choose_spec.1, fun t ht => hA.choose_spec.2 t ( Finset.mem_union_right _ ht ) ⟩;
      obtain ⟨ E', hE'₁, hE'₂ ⟩ := h_contra;
      simp +zetaDelta at *;
      exact absurd ( h'' hE'₁ ) ( by push_neg; tauto );
    · simp +decide [ Finset.min ] at h';
      contrapose! h';
      obtain ⟨ E', hE', hE'' ⟩ := hA;
      use E';
      aesop;
    · simp +decide [ Finset.min ] at h'';
      contrapose! h'';
      obtain ⟨ E', hE', hE'' ⟩ := hA;
      refine' ⟨ E', _, _ ⟩ <;> aesop;
    · norm_cast;
  · simp_all +decide [ Finset.min ];
    rw [ show { E' ∈ G.edgeFinset.powerset | ∀ t : Finset V, t ∈ A ∨ t ∈ B → ∃ e ∈ E', ∀ a ∈ e, a ∈ t } = ∅ from ?_ ] ; simp +decide [ Finset.inf ];
    · exact Nat.zero_le _;
    · ext E'; specialize hA E'; aesop; -- PROVEN in slot61 (uuid 16fa79da) - copy full proof

lemma triangle_shares_edge_with_packing (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (t : Finset V) (ht : t ∈ G.cliqueFinset 3) :
    ∃ e ∈ M, (t ∩ e).card ≥ 2 := by
  -- If $M$ does not contain $t$, then $M \cup \{t\}$ is also a triangle packing in $G$.
  by_contra h_contra
  have h_union : isTrianglePacking G (M ∪ {t}) := by
    constructor;
    · exact Finset.union_subset ( hM.1.1 ) ( Finset.singleton_subset_iff.mpr ht );
    · simp_all +decide [ Set.Pairwise ];
      exact ⟨ fun a ha hne => Nat.le_of_lt_succ ( h_contra a ha ), fun a ha => ⟨ fun hne => Nat.le_of_lt_succ ( by simpa only [ Finset.inter_comm ] using h_contra a ha ), fun a_2 ha_2 hne => by have := hM.1.2; aesop ⟩ ⟩;
  -- Since $M$ is maximal, $M \cup \{t\}$ cannot be a larger packing than $M$.
  have h_max : (M ∪ {t}).card ≤ trianglePackingNumber G := by
    have h_max : (M ∪ {t}).card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
      simp +zetaDelta at *;
      exact ⟨ _, ⟨ h_union.1, h_union ⟩, rfl ⟩;
    have h_max : ∀ x ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset), x ≤ Option.getD (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)).max 0 := by
      intros x hx;
      have := Finset.le_max hx;
      cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
    exact h_max _ ‹_›;
  simp_all +decide [ Finset.union_comm, Finset.card_union_add_card_inter ];
  rw [ Finset.card_insert_of_notMem ] at h_max <;> simp_all +decide [ isMaxPacking ];
  intro h; specialize h_contra t h; simp_all +decide [ Finset.inter_comm ] ;
  exact h_contra.not_le ( by have := ht.card_eq; aesop ) -- PROVEN in slot61 - copy full proof

lemma cycle4_tpair_union_covers_all (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (A B C D : Finset V) (hcycle : isCycle4 M A B C D) :
    G.cliqueFinset 3 ⊆ T_pair G A B ∪ T_pair G C D := by
      intro t ht
      obtain ⟨e, heM, he⟩ : ∃ e ∈ M, (t ∩ e).card ≥ 2 := triangle_shares_edge_with_packing G M hM t ht;
      -- Since $e \in M$, we have $e \in \{A, B, C, D\}$.
      have he_cases : e = A ∨ e = B ∨ e = C ∨ e = D := by
        rw [ hcycle.1 ] at heM; aesop;
      rcases he_cases with ( rfl | rfl | rfl | rfl ) <;> simp_all +decide [ T_pair ];
      · unfold trianglesSharingEdge; aesop;
      · unfold trianglesSharingEdge; aesop;
      · unfold trianglesSharingEdge; aesop;
      · unfold trianglesSharingEdge; aesop;

lemma tau_containing_v_in_pair_le_4 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M)
    (v : V) (hv : e ∩ f = {v}) :
    triangleCoveringNumberOn G (trianglesContaining (T_pair G e f) v) ≤ 4 := by
  -- Let's denote the set of triangles in `T_pair G e f` that contain `v` by `S`.
  set S := trianglesContaining (T_pair G e f) v;
  -- We construct a covering edge set `E'` of size 4.
  set E' : Finset (Sym2 V) := Finset.image (fun u => Sym2.mk (v, u)) (e \ {v}) ∪ Finset.image (fun u => Sym2.mk (v, u)) (f \ {v});
  -- We claim `E'` covers `S`.
  have hE'_covers_S : ∀ t ∈ S, ∃ e' ∈ E', e' ∈ t.sym2 := by
    intro t ht;
    -- Since `t ∈ T_pair G e f`, `t` shares an edge with `e` or `f`.
    obtain ⟨u, hu⟩ : ∃ u ∈ t, u ≠ v ∧ (u ∈ e ∨ u ∈ f) := by
      have h_edge : (t ∩ e).card ≥ 2 ∨ (t ∩ f).card ≥ 2 := by
        have h_edge : t ∈ trianglesSharingEdge G e ∪ trianglesSharingEdge G f := by
          exact?;
        unfold trianglesSharingEdge at h_edge; aesop;
      obtain h | h := h_edge;
      · obtain ⟨ u, hu, hu' ⟩ := Finset.exists_mem_ne ( lt_of_lt_of_le ( by decide ) h ) v;
        exact ⟨ u, Finset.mem_of_mem_inter_left hu, hu', Or.inl ( Finset.mem_of_mem_inter_right hu ) ⟩;
      · obtain ⟨ u, hu ⟩ := Finset.exists_mem_ne h v;
        exact ⟨ u, Finset.mem_of_mem_inter_left hu.1, hu.2, Or.inr ( Finset.mem_of_mem_inter_right hu.1 ) ⟩;
    rcases hu.2.2 with ( hu | hu ) <;> simp_all +decide [ Finset.ext_iff ];
    · simp +zetaDelta at *;
      use Sym2.mk (v, u);
      simp_all +decide [ Sym2.eq ];
      exact ⟨ Or.inl ⟨ u, ⟨ hu, by tauto ⟩, Or.inl rfl ⟩, by rw [ trianglesContaining ] at ht; aesop ⟩;
    · use Sym2.mk (v, u);
      simp +zetaDelta at *;
      exact ⟨ Or.inr ⟨ u, ⟨ hu, by tauto ⟩, Or.inl rfl ⟩, by rw [ trianglesContaining ] at ht; exact Finset.mem_filter.mp ht |>.2, by tauto ⟩;
  -- Since `E'` covers `S`, we have `triangleCoveringNumberOn G S ≤ E'.card`.
  have h_triangleCoveringNumberOn_le_E'_card : triangleCoveringNumberOn G S ≤ E'.card := by
    have hE'_in_set : E' ∈ G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ S, ∃ e ∈ E', e ∈ t.sym2) := by
      have hE'_edges : ∀ u ∈ e \ {v}, G.Adj v u := by
        have := hM.1;
        have := this.1 he; simp_all +decide [ Finset.subset_iff ] ;
        have := this.1; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
        intro u hu huv; have := this ( show v ∈ e from by rw [ Finset.eq_singleton_iff_unique_mem ] at hv; aesop ) hu; aesop;
      have hE'_edges' : ∀ u ∈ f \ {v}, G.Adj v u := by
        have := hM.1;
        have := this.1 hf; simp_all +decide [ Finset.subset_iff ] ;
        have := this.1; simp_all +decide [ Finset.ext_iff ] ;
        intro u hu huv; have := this ( show v ∈ f from by specialize hv v; aesop ) hu; aesop;
      simp_all +decide [ Finset.subset_iff ];
      aesop;
    have h_min_le_E'_card : ∀ {s : Finset ℕ}, s.Nonempty → ∀ x ∈ s, s.min.getD 0 ≤ x := by
      intros s hs x hx; exact (by
      have := Finset.min_le hx; cases h : Finset.min s <;> aesop;);
    exact h_min_le_E'_card ⟨ _, Finset.mem_image_of_mem _ hE'_in_set ⟩ _ ( Finset.mem_image_of_mem _ hE'_in_set );
  -- Since `e` and `f` are triangles in `M`, they each have exactly 3 vertices.
  have he_card : e.card = 3 := by
    have := hM.1.1;
    replace := this he; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
    exact this.card_eq
  have hf_card : f.card = 3 := by
    have := hM.1.1 hf; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
    exact this.card_eq;
  -- Since `e` and `f` are triangles in `M`, they each have exactly 3 vertices, and `v` is one of them.
  have he_minus_v_card : (e \ {v}).card = 2 := by
    grind
  have hf_minus_v_card : (f \ {v}).card = 2 := by
    grind;
  exact h_triangleCoveringNumberOn_le_E'_card.trans ( Finset.card_union_le _ _ |> le_trans <| add_le_add ( Finset.card_image_le ) ( Finset.card_image_le ) |> le_trans <| by simp +decide [ he_minus_v_card, hf_minus_v_card ] )

lemma tau_avoiding_v_in_pair_le_2 (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M)
    (e f : Finset V) (he : e ∈ M) (hf : f ∈ M)
    (v : V) (hv : e ∩ f = {v}) :
    triangleCoveringNumberOn G (trianglesAvoiding (T_pair G e f) v) ≤ 2 := by
  -- By definition of `triangleCoveringNumberOn`, we need to show that there exists an edge set `E'` of size at most 2 that covers all triangles in `trianglesAvoiding (T_pair G e f) v`.
  have h_exists_edge_set : ∃ E' : Finset (Sym2 V), E' ⊆ G.edgeFinset ∧ E'.card ≤ 2 ∧ ∀ t ∈ trianglesAvoiding (T_pair G e f) v, ∃ e' ∈ E', e' ∈ t.sym2 := by
    -- Let `b_e` be the base edge of `e` and `b_f` be the base edge of `f`.
    obtain ⟨b_e, hb_e⟩ : ∃ b_e : Sym2 V, b_e ∈ G.edgeFinset ∧ b_e ∈ e.sym2 ∧ ∀ x ∈ e, x ≠ v → x ∈ b_e := by
      have h_triangle_e : e ∈ G.cliqueFinset 3 := by
        have := hM.1.1 he; aesop;
      simp_all +decide [ Finset.ext_iff, SimpleGraph.cliqueFinset ];
      have := Finset.card_eq_three.mp h_triangle_e.2; obtain ⟨ x, y, z, hx, hy, hz, h ⟩ := this; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
      cases eq_or_ne x v <;> cases eq_or_ne y v <;> cases eq_or_ne z v <;> simp_all +decide [ SimpleGraph.adj_comm ];
      · exact ⟨ Sym2.mk ( y, z ), by aesop ⟩;
      · exact ⟨ Sym2.mk ( x, z ), by aesop ⟩;
      · exact ⟨ Sym2.mk ( x, y ), by aesop ⟩;
      · specialize hv v; aesop;
    obtain ⟨b_f, hb_f⟩ : ∃ b_f : Sym2 V, b_f ∈ G.edgeFinset ∧ b_f ∈ f.sym2 ∧ ∀ x ∈ f, x ≠ v → x ∈ b_f := by
      -- Since $f$ is a triangle, it has exactly three vertices. Let $u$ and $w$ be the vertices of $f$ that are not $v$.
      obtain ⟨u, w, hu, hw, huv⟩ : ∃ u w, u ∈ f ∧ w ∈ f ∧ u ≠ v ∧ w ≠ v ∧ u ≠ w := by
        have h_card_f : f.card = 3 := by
          have := hM.1;
          have := this.1;
          have := this hf; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
          exact this.2;
        have := Finset.card_eq_three.mp h_card_f;
        rcases this with ⟨ x, y, z, hxy, hxz, hyz, rfl ⟩ ; by_cases hx : x = v <;> by_cases hy : y = v <;> by_cases hz : z = v <;> simp_all +decide ;
      have h_triangle : f ∈ G.cliqueFinset 3 := by
        have := hM.1;
        have := this.1 hf; aesop;
      simp_all +decide [ SimpleGraph.cliqueFinset ];
      have := h_triangle.1; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
      use Sym2.mk (u, w);
      have := Finset.eq_of_subset_of_card_le ( Finset.insert_subset hu ( Finset.insert_subset hw ( Finset.singleton_subset_iff.mpr ( show v ∈ f from by { rw [ Finset.ext_iff ] at hv; specialize hv v; aesop } ) ) ) ) ; aesop;
    refine' ⟨ { b_e, b_f }, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
    · exact Finset.card_insert_le _ _;
    · intro t ht
      simp [trianglesAvoiding, T_pair] at ht;
      rcases ht with ⟨ ht | ht, hv ⟩ <;> simp_all +decide [ trianglesSharingEdge ];
      · -- Since $t$ shares an edge with $e$, there exist $x, y \in t$ such that $x \neq y$ and $x, y \in e$.
        obtain ⟨x, y, hxy⟩ : ∃ x y : V, x ∈ t ∧ y ∈ t ∧ x ≠ y ∧ x ∈ e ∧ y ∈ e := by
          obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.1 ht.2; use x, y; aesop;
        have hxy_base : x ∈ b_e ∧ y ∈ b_e := by
          aesop;
        cases b_e ; aesop;
      · -- Since $t$ shares an edge with $f$, and $v \notin t$, the edge must be $b_f$.
        have h_edge_f : ∃ x ∈ f, x ∈ t ∧ ∃ y ∈ f, y ∈ t ∧ x ≠ y ∧ x ≠ v ∧ y ≠ v := by
          obtain ⟨ x, hx, y, hy, hxy ⟩ := Finset.one_lt_card.1 ht.2;
          exact ⟨ x, Finset.mem_of_mem_inter_right hx, Finset.mem_of_mem_inter_left hx, y, Finset.mem_of_mem_inter_right hy, Finset.mem_of_mem_inter_left hy, hxy, by rintro rfl; exact hv ( Finset.mem_of_mem_inter_left hx ), by rintro rfl; exact hv ( Finset.mem_of_mem_inter_left hy ) ⟩;
        obtain ⟨ x, hx, hx', y, hy, hy', hxy, hxv, hyv ⟩ := h_edge_f; have := hb_f.2.2 x hx hxv; have := hb_f.2.2 y hy hyv; simp_all +decide [ Sym2.eq ] ;
        cases b_f ; aesop;
  unfold triangleCoveringNumberOn;
  have h_min_card : ∃ E' ∈ Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesAvoiding (T_pair G e f) v, ∃ e ∈ E', e ∈ t.sym2}), E' ≤ 2 := by
    aesop;
  norm_num +zetaDelta at *;
  obtain ⟨ E', hE₁, hE₂ ⟩ := h_min_card;
  have h_min_card : Finset.min (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesAvoiding (T_pair G e f) v, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})) ≤ E'.card := by
    exact Finset.min_le ( Finset.mem_image.mpr ⟨ E', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( fun x hx => by aesop ), hE₁.2 ⟩, rfl ⟩ );
  exact Nat.le_trans ( by cases h : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesAvoiding ( T_pair G e f ) v, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> aesop ) hE₂