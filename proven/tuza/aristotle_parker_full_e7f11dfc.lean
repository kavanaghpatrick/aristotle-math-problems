/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e7f11dfc-9b36-4654-8133-124e823114d6

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

def isTrianglePacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (S : Finset (Finset V)) : Prop :=
  S ⊆ G.cliqueFinset 3 ∧
  Set.Pairwise (S : Set (Finset V)) (fun t1 t2 => (t1 ∩ t2).card ≤ 1)

noncomputable def trianglePackingNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

def isTriangleCover {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (E' : Finset (Sym2 V)) : Prop :=
  E' ⊆ G.edgeFinset ∧
  ∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E', e ∈ t.sym2

noncomputable def triangleCoveringNumber {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] : ℕ :=
  G.edgeFinset.powerset.filter (isTriangleCover G) |>.image Finset.card |>.min |>.getD 0

def trianglesSharingEdge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) : Finset (Finset V) :=
  (G.cliqueFinset 3).filter (fun x => (x ∩ t).card ≥ 2)

def S {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (t : Finset V) (M : Finset (Finset V)) : Finset (Finset V) :=
  (trianglesSharingEdge G t).filter (fun x => ∀ m ∈ M, m ≠ t → (x ∩ m).card ≤ 1)

def isMaxPacking {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (M : Finset (Finset V)) : Prop :=
  isTrianglePacking G M ∧ M.card = trianglePackingNumber G

def shareEdge {V : Type*} [DecidableEq V] (t1 t2 : Finset V) : Prop :=
  (t1 ∩ t2).card ≥ 2

lemma lemma_2_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    ∀ t1 t2, t1 ∈ S G e M → t2 ∈ S G e M → shareEdge t1 t2 := by
      unfold shareEdge S at *; aesop;
      -- If t1 and t2 do not share an edge, then they are disjoint triangles in S_e.
      by_contra h_not_share;
      -- Consider $M' = (M \setminus \{e\}) \cup \{t1, t2\}$.
      set M' : Finset (Finset V) := (M \ {e}) ∪ {t1, t2};
      -- M' is a triangle packing.
      have hM'_packing : isTrianglePacking G M' := by
        constructor <;> simp_all +decide [ Finset.subset_iff ];
        · aesop;
          · unfold trianglesSharingEdge at left; aesop;
          · unfold trianglesSharingEdge at left_1; aesop;
          · exact hM.1.1 left_2 |> fun h => by simpa using h;
        · intro x hx y hy hxy; aesop;
          · linarith;
          · rw [ Finset.inter_comm ] ; linarith;
          · rw [ Finset.inter_comm ] ; aesop;
          · exact right_1 x left_2 right_2 |> le_trans ( Finset.card_mono <| by aesop_cat );
          · have := hM.1;
            exact this.2 left_2 left_3 hxy;
      -- The size of M' is |M| - 1 + 2 = |M| + 1.
      have hM'_size : M'.card = M.card + 1 := by
        rw [ Finset.card_union_of_disjoint ] <;> aesop;
        · rw [ Finset.card_sdiff ] ; aesop;
          rw [ Finset.card_insert_of_notMem, Finset.card_singleton ] ; aesop;
          · rw [ Nat.sub_add_cancel ( Finset.card_pos.mpr ⟨ e, he ⟩ ) ];
          · unfold trianglesSharingEdge at *; aesop;
            exact h_not_share.not_le ( by have := left_1.card_eq; aesop );
        · unfold trianglesSharingEdge at left; aesop;
          specialize right t1 a ; aesop;
          exact Classical.not_not.1 fun h => by have := left.card_eq; aesop;
        · unfold trianglesSharingEdge at *; aesop;
          have := right _ a; have := right_1 _ a; simp_all +decide [ Finset.inter_comm ] ;
          exact Classical.not_not.1 fun h => by have := this h; linarith [ left_1.card_eq ] ;
      unfold isMaxPacking at hM; aesop;
      have hM'_size_le : ∀ S : Finset (Finset V), isTrianglePacking G S → S.card ≤ trianglePackingNumber G := by
        unfold trianglePackingNumber; aesop;
        have hM'_size_le : S ∈ Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset := by
          exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( a.1 ), a ⟩;
        have hM'_size_le : S.card ≤ Finset.max (Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset)) := by
          exact Finset.le_max ( Finset.mem_image_of_mem _ hM'_size_le );
        cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
        exact WithBot.coe_le_coe.mp hM'_size_le;
      linarith [ hM'_size_le _ hM'_packing ]

noncomputable def trianglePackingNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  triangles.powerset.filter (isTrianglePacking G) |>.image Finset.card |>.max |>.getD 0

lemma lemma_2_3 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    trianglePackingNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) = trianglePackingNumber G - 1 := by
      simp +decide [ trianglePackingNumberOn ];
      -- Since $M$ is a maximum packing, we have $\nu(G) = |M|$.
      have h_max_packing : trianglePackingNumber G = M.card := by
        unfold isMaxPacking at hM; aesop;
      have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) → M'.card ≤ M.card - 1 := by
        intro M' hM' hM'_allowed
        have hM'_allowed_card : (M' ∪ {e}).card ≤ M.card := by
          have hM'_allowed_card : isTrianglePacking G (M' ∪ {e}) := by
            constructor;
            · simp_all +decide [ Finset.subset_iff ];
              have := hM.1.1 he; aesop;
            · simp_all +decide [ Set.Pairwise ];
              simp_all +decide [ Finset.subset_iff, isTrianglePacking ];
              simp_all +decide [ Finset.inter_comm, trianglesSharingEdge ];
              exact ⟨ fun x hx hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun x hx => ⟨ fun hx' => Nat.le_of_lt_succ ( hM'_allowed hx ), fun y hy hy' => hM'.2 hx hy hy' ⟩ ⟩;
          have h_max_packing_allowed : ∀ M' : Finset (Finset V), isTrianglePacking G M' → M'.card ≤ M.card := by
            intros M' hM'
            have h_max_packing_allowed : M'.card ≤ trianglePackingNumber G := by
              have h_max_packing_allowed : M' ∈ (G.cliqueFinset 3).powerset.filter (isTrianglePacking G) := by
                exact Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hM'.1, hM' ⟩;
              unfold trianglePackingNumber;
              have h_max_packing_allowed : M'.card ∈ Finset.image Finset.card (Finset.filter (isTrianglePacking G) (G.cliqueFinset 3).powerset) := by
                exact Finset.mem_image_of_mem _ h_max_packing_allowed;
              have := Finset.le_max h_max_packing_allowed; aesop;
              cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) <;> aesop;
            exact h_max_packing ▸ h_max_packing_allowed;
          exact h_max_packing_allowed _ hM'_allowed_card;
        have hM'_allowed_card : e ∉ M' := by
          intro h; have := hM'_allowed h; simp_all +decide [ trianglesSharingEdge ] ;
          exact absurd ( this.2 this.1 ) ( by rw [ this.1.2 ] ; decide );
        rw [ Finset.card_union ] at * ; aesop;
        exact Nat.le_sub_one_of_lt hM'_allowed_card_1;
      have h_max_packing_allowed_eq : ∃ M' : Finset (Finset V), isTrianglePacking G M' ∧ M' ⊆ (G.cliqueFinset 3 \ trianglesSharingEdge G e) ∧ M'.card = M.card - 1 := by
        refine' ⟨ M.erase e, _, _, _ ⟩ <;> simp_all +decide [ isTrianglePacking ];
        · have := hM.1; aesop;
          · exact fun x hx => this.1 ( Finset.mem_of_mem_erase hx );
          · exact fun x hx y hy hxy => this.2 ( by aesop ) ( by aesop ) hxy;
        · intro t ht; specialize hM; have := hM.1; aesop;
          · exact Finset.mem_filter.mp ( this.1 right ) |>.2;
          · have := this.2;
            exact absurd ( this right he left ) ( by unfold trianglesSharingEdge at a; aesop );
      rw [ show ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 \ trianglesSharingEdge G e |> Finset.powerset ) ) ).max = ↑ ( M.card - 1 ) from ?_ ];
      · aesop;
      · refine' le_antisymm _ _;
        · aesop;
          exact WithBot.coe_le_coe.mpr ( h_max_packing_allowed x a_2 a_1 );
        · exact Finset.le_max ( Finset.mem_image.mpr ⟨ h_max_packing_allowed_eq.choose, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr h_max_packing_allowed_eq.choose_spec.2.1, h_max_packing_allowed_eq.choose_spec.1 ⟩, h_max_packing_allowed_eq.choose_spec.2.2 ⟩ )

noncomputable def triangleCoveringNumberOn {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (triangles : Finset (Finset V)) : ℕ :=
  G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) |>.image Finset.card |>.min |>.getD 0

def isStar {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ e : Finset V, e.card = 2 ∧ ∀ t ∈ S, e ⊆ t

lemma tau_star {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS : S ⊆ G.cliqueFinset 3) (h_star : isStar S) :
    triangleCoveringNumberOn G S ≤ 1 := by
      unfold triangleCoveringNumberOn;
      cases h_star ; aesop;
      cases' Finset.card_eq_two.mp left with x hx ; aesop;
      by_cases h : G.Adj x w_1;
      · have h_cover : {Sym2.mk (x, w_1)} ∈ G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t) := by
          aesop;
        have h_min : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ 1 := by
          exact Finset.min_le ( Finset.mem_image.mpr ⟨ _, h_cover, rfl ⟩ );
        cases h : Finset.min ( Finset.image Finset.card ( { E' ∈ G.edgeFinset.powerset | ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t } ) ) <;> aesop;
      · simp_all +decide [ Finset.subset_iff, SimpleGraph.mem_edgeSet ];
        contrapose! h;
        rcases S.eq_empty_or_nonempty with ( rfl | ⟨ t, ht ⟩ ) <;> simp_all +decide [ SimpleGraph.isNClique_iff ];
        · unfold Option.getD at h; aesop;
          rw [ Finset.min_eq_inf_withTop ] at heq ; aesop;
          rw [ Finset.inf_eq_iInf ] at heq;
          have := heq ▸ iInf_le_of_le ∅ ( by aesop ) ; aesop;
          cases this;
          contradiction;
        · have := hS ht;
          exact this.1 ( right _ ht |>.1 ) ( right _ ht |>.2 ) ( by aesop )

lemma intersecting_triples_structure {V : Type*} [DecidableEq V]
    (t1 t2 t3 : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3)
    (h12 : (t1 ∩ t2).card ≥ 2) (h13 : (t1 ∩ t3).card ≥ 2) (h23 : (t2 ∩ t3).card ≥ 2)
    (h_not_star : ¬ ∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 ∧ e ⊆ t3) :
    (t1 ∪ t2 ∪ t3).card = 4 := by
      -- Since $t1$ and $t2$ share an edge, their union has size at most $3 + 3 - 2 = 4$.
      have h_union_t1_t2 : (t1 ∪ t2).card ≤ 4 := by
        have := Finset.card_union_add_card_inter t1 t2; linarith;
      by_cases h_cases : (t1 ∪ t2).card = 4;
      · have h_union_t1_t2_t3 : (t1 ∪ t2 ∪ t3).card ≤ 4 := by
          have h_union_t1_t2_t3_step : (t1 ∩ t3 ∪ t2 ∩ t3).card ≥ 3 := by
            have h_union_t1_t2_t3_step : (t1 ∩ t3 ∩ t2 ∩ t3).card ≤ 1 := by
              contrapose! h_not_star;
              obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq h_not_star;
              exact ⟨ e, he.2, Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ), Finset.Subset.trans he.1 ( by aesop_cat ) ⟩;
            have := Finset.card_union_add_card_inter ( t1 ∩ t3 ) ( t2 ∩ t3 ) ; simp_all +decide [ Finset.inter_left_comm, Finset.inter_comm ] ;
            linarith;
          have h_union_t1_t2_t3_step : (t1 ∪ t2 ∪ t3).card ≤ (t1 ∪ t2).card + (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)).card := by
            have h_union_t1_t2_t3_step : (t1 ∪ t2 ∪ t3) ⊆ (t1 ∪ t2) ∪ (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)) := by
              grind;
            exact le_trans ( Finset.card_le_card h_union_t1_t2_t3_step ) ( Finset.card_union_le _ _ );
          have h_union_t1_t2_t3_step : (t3 \ (t1 ∩ t3 ∪ t2 ∩ t3)).card = t3.card - (t1 ∩ t3 ∪ t2 ∩ t3).card := by
            rw [ Finset.card_sdiff ];
            rw [ Finset.inter_eq_left.mpr ( Finset.union_subset ( Finset.inter_subset_right ) ( Finset.inter_subset_right ) ) ];
          omega;
        exact le_antisymm h_union_t1_t2_t3 ( by linarith [ Finset.card_mono ( Finset.subset_union_left : t1 ∪ t2 ⊆ t1 ∪ t2 ∪ t3 ) ] );
      · have h_union_t1_t2 : t1 = t2 := by
          have h_union_t1_t2 : (t1 ∪ t2).card = 3 := by
            have := Finset.card_union_add_card_inter t1 t2; interval_cases _ : Finset.card ( t1 ∪ t2 ) <;> simp_all +decide ;
            · linarith [ show Finset.card ( t1 ∩ t2 ) ≤ 3 by exact le_trans ( Finset.card_le_card fun x hx => Finset.mem_of_mem_inter_left hx ) h_card.1.le ];
            · linarith [ show ( t1 ∩ t2 ).card ≤ 3 by exact le_trans ( Finset.card_le_card ( Finset.inter_subset_left ) ) h_card.1.le ];
          have := Finset.card_union_add_card_inter t1 t2; aesop;
          have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; aesop;
          exact Eq.symm ( this_2 ( by linarith ) );
        contrapose! h_not_star; aesop;
        exact Exists.elim ( Finset.exists_subset_card_eq h23 ) fun e he => ⟨ e, he.2, Finset.subset_iff.2 fun x hx => Finset.mem_inter.1 ( he.1 hx ) |>.1, Finset.subset_iff.2 fun x hx => Finset.mem_inter.1 ( he.1 hx ) |>.2 ⟩

lemma triangle_in_k4_of_intersects_triples {V : Type*} [DecidableEq V]
    (t1 t2 t3 t : Finset V) (h_card : t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 ∧ t.card = 3)
    (h_union : (t1 ∪ t2 ∪ t3).card = 4)
    (h_subset : t1 ⊆ t1 ∪ t2 ∪ t3 ∧ t2 ⊆ t1 ∪ t2 ∪ t3 ∧ t3 ⊆ t1 ∪ t2 ∪ t3)
    (h_distinct : t1 ≠ t2 ∧ t1 ≠ t3 ∧ t2 ≠ t3)
    (h_inter : (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2) :
    t ⊆ t1 ∪ t2 ∪ t3 := by
      aesop;
      intro x hx; by_contra h; simp_all +decide [ Finset.subset_iff ] ;
      -- Since $t$ contains $x$ and $x$ is not in $t1$, $t2$, or $t3$, it means $t \cap t1$, $t \cap t2$, and $t \cap t3$ must all be subsets of $\{y, z\}$ where $y$ and $z$ are the other two elements in $t$.
      have h_inter_subset : t ∩ t1 ⊆ t \ {x} ∧ t ∩ t2 ⊆ t \ {x} ∧ t ∩ t3 ⊆ t \ {x} := by
        grind;
      have h_inter_eq : (t ∩ t1) = t \ {x} ∧ (t ∩ t2) = t \ {x} ∧ (t ∩ t3) = t \ {x} := by
        exact ⟨ Finset.eq_of_subset_of_card_le h_inter_subset.1 ( by rw [ Finset.card_sdiff ] ; aesop ), Finset.eq_of_subset_of_card_le h_inter_subset.2.1 ( by rw [ Finset.card_sdiff ] ; aesop ), Finset.eq_of_subset_of_card_le h_inter_subset.2.2 ( by rw [ Finset.card_sdiff ] ; aesop ) ⟩;
      -- Since $t \cap t1 = t \cap t2 = t \cap t3 = t \setminus \{x\}$, it means $t1$, $t2$, and $t3$ all contain the same two elements as $t \setminus \{x\}$.
      have h_common_elements : t1 ⊇ t \ {x} ∧ t2 ⊇ t \ {x} ∧ t3 ⊇ t \ {x} := by
        simp_all +decide [ Finset.subset_iff ];
        simp_all +decide [ Finset.ext_iff ];
      -- Since $t1$, $t2$, and $t3$ all contain the same two elements as $t \setminus \{x\}$, they must be subsets of $t \setminus \{x\} \cup \{y\}$ for some $y$.
      obtain ⟨y, hy⟩ : ∃ y, t1 = t \ {x} ∪ {y} ∧ t2 = t \ {x} ∪ {y} ∨ t1 = t \ {x} ∪ {y} ∧ t3 = t \ {x} ∪ {y} ∨ t2 = t \ {x} ∪ {y} ∧ t3 = t \ {x} ∪ {y} := by
        have h_common_elements : ∀ {s : Finset V}, s.card = 3 → t \ {x} ⊆ s → ∃ y, s = t \ {x} ∪ {y} := by
          intros s hs hs_subset
          have h_card_diff : (s \ (t \ {x})).card = 1 := by
            grind;
          obtain ⟨ y, hy ⟩ := Finset.card_eq_one.mp h_card_diff;
          exact ⟨ y, by rw [ ← hy, Finset.union_sdiff_of_subset hs_subset ] ⟩;
        obtain ⟨ y1, hy1 ⟩ := h_common_elements left ( by tauto ) ; obtain ⟨ y2, hy2 ⟩ := h_common_elements left_4 ( by tauto ) ; obtain ⟨ y3, hy3 ⟩ := h_common_elements left_7 ( by tauto ) ; use if y1 = y2 then y1 else if y1 = y3 then y1 else y2; aesop;
        grind;
      grind

def isK4 {V : Type*} [DecidableEq V] (S : Finset (Finset V)) : Prop :=
  ∃ s : Finset V, s.card = 4 ∧ ∀ t ∈ S, t ⊆ s

lemma intersecting_family_structure_corrected {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS_nonempty : S.Nonempty) (hS : S ⊆ G.cliqueFinset 3)
    (h_pair : Set.Pairwise (S : Set (Finset V)) shareEdge) :
    isStar S ∨ isK4 S := by
      by_cases h_star : ∃ e : Finset V, e.card = 2 ∧ ∀ t ∈ S, e ⊆ t;
      · exact Or.inl h_star;
      · -- If there are three triangles in S that do not share a common edge, then their union is a K4.
        by_cases h_three : ∃ t1 t2 t3 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ t3 ∈ S ∧ t1 ≠ t2 ∧ t1 ≠ t3 ∧ t2 ≠ t3 ∧ ¬∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 ∧ e ⊆ t3;
        · obtain ⟨ t1, t2, t3, ht1, ht2, ht3, hne ⟩ := h_three;
          have h_union : (t1 ∪ t2 ∪ t3).card = 4 := by
            apply_rules [ intersecting_triples_structure ];
            · have := hS ht1; have := hS ht2; have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
              exact ⟨ by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop, by rw [ SimpleGraph.isNClique_iff ] at *; aesop ⟩;
            · tauto;
            · tauto;
            · tauto;
            · exact hne.2.2.2;
          refine' Or.inr ⟨ t1 ∪ t2 ∪ t3, h_union, _ ⟩;
          intros t ht
          have h_inter : (t ∩ t1).card ≥ 2 ∧ (t ∩ t2).card ≥ 2 ∧ (t ∩ t3).card ≥ 2 := by
            have := h_pair ht ht1; have := h_pair ht ht2; have := h_pair ht ht3; simp_all +decide [ shareEdge ] ;
            by_cases h : t = t1 <;> by_cases h' : t = t2 <;> by_cases h'' : t = t3 <;> simp_all +decide;
            · exact le_trans ‹_› ( Finset.card_mono ( Finset.inter_subset_left ) );
            · exact le_trans this ( Finset.card_mono ( Finset.inter_subset_left ) );
            · have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
              exact this.card_eq.symm ▸ by decide;
          have h_card : t.card = 3 ∧ t1.card = 3 ∧ t2.card = 3 ∧ t3.card = 3 := by
            have := hS ht; have := hS ht1; have := hS ht2; have := hS ht3; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
            exact ⟨ by simpa using ‹G.IsNClique 3 t›.card_eq, by simpa using ‹G.IsNClique 3 t1›.card_eq, by simpa using ‹G.IsNClique 3 t2›.card_eq, by simpa using ‹G.IsNClique 3 t3›.card_eq ⟩;
          apply triangle_in_k4_of_intersects_triples;
          · tauto;
          · exact h_union;
          · simp +decide [ Finset.subset_iff ];
            tauto;
          · tauto;
          · exact h_inter;
        · by_cases h_two : ∃ t1 t2 : Finset V, t1 ∈ S ∧ t2 ∈ S ∧ t1 ≠ t2;
          · obtain ⟨ t1, t2, ht1, ht2, hne ⟩ := h_two;
            -- Since $t1$ and $t2$ share an edge, let $e$ be this common edge.
            obtain ⟨e, he⟩ : ∃ e : Finset V, e.card = 2 ∧ e ⊆ t1 ∧ e ⊆ t2 := by
              have := h_pair ht1 ht2 hne;
              obtain ⟨ e, he ⟩ := Finset.exists_subset_card_eq this;
              exact ⟨ e, he.2, Finset.Subset.trans he.1 ( Finset.inter_subset_left ), Finset.Subset.trans he.1 ( Finset.inter_subset_right ) ⟩;
            refine' Or.inl ⟨ e, he.1, fun t ht => _ ⟩;
            contrapose! h_three;
            use t1, t2, t;
            refine' ⟨ ht1, ht2, ht, hne, _, _, _ ⟩;
            · grind;
            · grind;
            · intro x hx hx1 hx2 hx3;
              have h_eq : x ⊆ t1 ∩ t2 := by
                exact Finset.subset_inter hx1 hx2;
              have h_eq : x = t1 ∩ t2 := by
                have h_eq : (t1 ∩ t2).card = 2 := by
                  have := hS ht1; have := hS ht2; simp_all +decide [ SimpleGraph.mem_cliqueFinset_iff ] ;
                  have := Finset.card_le_card h_eq; simp_all +decide ;
                  have := Finset.card_le_card ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; ( have := Finset.card_le_card ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; ( simp_all +decide [ SimpleGraph.isNClique_iff ] ; ) );
                  interval_cases _ : ( t1 ∩ t2 ).card <;> simp_all +decide;
                  have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_left : t1 ∩ t2 ⊆ t1 ) ; have := Finset.eq_of_subset_of_card_le ( Finset.inter_subset_right : t1 ∩ t2 ⊆ t2 ) ; aesop;
                exact Finset.eq_of_subset_of_card_le ‹_› ( by simp +decide [ * ] );
              have := Finset.eq_of_subset_of_card_le ( show e ⊆ t1 ∩ t2 from Finset.subset_inter he.2.1 he.2.2 ) ; aesop;
          · rcases Finset.card_le_one.2 ( fun t1 ht1 t2 ht2 => Classical.not_not.1 fun h => h_two ⟨ t1, t2, ht1, ht2, h ⟩ ) with h;
            cases h.eq_or_lt <;> simp_all +decide;
            rw [ Finset.card_eq_one ] at * ; aesop;
            rw [ SimpleGraph.isNClique_iff ] at hS ; aesop;
            exact False.elim ( h_star ( w.erase ( Classical.choose ( Finset.card_pos.mp ( by linarith ) ) ) ) ( by rw [ Finset.card_erase_of_mem ( Classical.choose_spec ( Finset.card_pos.mp ( by linarith ) ) ), right ] ) ( by intro x hx; exact Finset.mem_of_mem_erase hx ) )

lemma covering_number_on_le_two_of_subset_four {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (S : Finset (Finset V)) (hS : S ⊆ G.cliqueFinset 3) (U : Finset V) (hU : U.card ≤ 4) (h_subset : ∀ t ∈ S, t ⊆ U) :
    triangleCoveringNumberOn G S ≤ 2 := by
      have h_tau_star : ∃ E' ⊆ G.edgeFinset, E'.card ≤ 2 ∧ ∀ t ∈ S, ∃ e ∈ E', e ∈ t.sym2 := by
        -- Consider the set of edges $E'$ consisting of the edges of $U$.
        obtain ⟨E', hE'_subset, hE'_card⟩ : ∃ E' : Finset (Sym2 V), E' ⊆ Finset.image (fun e : V × V => Sym2.mk e) (Finset.offDiag U) ∧ E'.card ≤ 2 ∧ ∀ t ∈ S, ∃ e ∈ E', e ∈ t.sym2 := by
          interval_cases _ : U.card <;> simp_all +decide;
          · intro t ht; specialize h_subset t ht; specialize hS ht; aesop;
          · -- Since U has only one element, any triangle in S would have to be a subset of U, but a triangle requires three vertices. Therefore, S must be empty.
            have hS_empty : S = ∅ := by
              ext t
              simp [h_subset, ‹U.card = 1›];
              intro ht; have := hS ht; simp_all +decide [ SimpleGraph.cliqueFinset ] ;
              have := Finset.card_le_card ( h_subset t ht ) ; simp_all +decide ;
              exact this.not_lt ( by rw [ ‹G.IsNClique 3 t›.card_eq ] ; decide );
            exact ⟨ ∅, by simp +decide [ hS_empty ] ⟩;
          · -- Since U has exactly two elements, any triangle in S must be a subset of U. But a triangle requires three vertices, so if U has only two elements, there can't be any triangles in S. Therefore, S must be empty.
            have hS_empty : S = ∅ := by
              ext t;
              have := hS; simp_all +decide [ Finset.subset_iff ];
              contrapose! this;
              exact ⟨ t, this, fun h => by have := Finset.card_le_card ( show t ⊆ U from fun x hx => h_subset t this hx ) ; linarith [ h.2 ] ⟩;
            exact ⟨ ∅, by simp +decide [ hS_empty ] ⟩;
          · -- Since $U$ has exactly 3 vertices, any triangle in $S$ must be a subset of $U$. The triangles in $S$ are all the 3-element subsets of $U$. So, each triangle in $S$ is exactly $U$ itself.
            have h_triangles : ∀ t ∈ S, t = U := by
              intro t ht; have := hS ht; simp_all +decide [ Finset.subset_iff ] ;
              exact Finset.eq_of_subset_of_card_le ( h_subset t ht ) ( by have := hS ht; exact this.card_eq.symm ▸ by simp +decide [ * ] );
            rcases Finset.card_eq_three.mp ‹_› with ⟨ a, b, c, hab, hbc, hac ⟩ ; simp_all +decide;
            use { Sym2.mk ( a, b ), Sym2.mk ( a, c ) } ; simp_all +decide [ Finset.subset_iff ] ;
            exact ⟨ ⟨ ⟨ a, b, by aesop ⟩, ⟨ a, c, by aesop ⟩ ⟩, fun t ht => by specialize h_triangles t ht; aesop ⟩;
          · -- Since $U$ has 4 vertices, we can choose any two edges that cover all triangles in $S$.
            obtain ⟨u1, u2, u3, u4, hu⟩ : ∃ u1 u2 u3 u4 : V, u1 ≠ u2 ∧ u1 ≠ u3 ∧ u1 ≠ u4 ∧ u2 ≠ u3 ∧ u2 ≠ u4 ∧ u3 ≠ u4 ∧ U = {u1, u2, u3, u4} := by
              simp_rw +decide [ Finset.card_eq_succ ] at *;
              rcases ‹_› with ⟨ a, t, hat, rfl, b, u, hbu, rfl, c, v, hcv, rfl, d, w, hdw, rfl, hw ⟩ ; use a, b, c, d; aesop;
            refine' ⟨ { Sym2.mk ( u1, u2 ), Sym2.mk ( u3, u4 ) }, _, _, _ ⟩ <;> simp +decide [ Finset.subset_iff, * ];
            · exact ⟨ ⟨ u1, u2, by aesop ⟩, ⟨ u3, u4, by aesop ⟩ ⟩;
            · intro t ht; specialize h_subset t ht; simp_all +decide [ Finset.subset_iff ] ;
              have := hS ht; rcases this with ⟨ ht1, ht2 ⟩ ; rcases Finset.card_eq_three.mp ht2 with ⟨ x, y, z, hx, hy, hz, hxyz ⟩ ; simp_all +decide ;
              grind;
        refine' ⟨ E' ∩ G.edgeFinset, _, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
        · exact le_trans ( Finset.card_le_card fun x hx => by aesop ) hE'_card.1;
        · -- Since $t$ is a triangle in $S$, and $S$ is a subset of the cliqueFinset 3 of $G$, $t$ must be a 3-clique in $G$. Therefore, any edge in $t$ is an edge in $G$.
          intros t ht
          obtain ⟨e, heE', he⟩ := hE'_card.right t ht
          have heG : e ∈ G.edgeSet := by
            obtain ⟨ a, b, ⟨ ha, hb, hab ⟩, rfl ⟩ := hE'_subset heE' ; specialize hS ht ; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            exact hS.1 ( by aesop ) ( by aesop ) hab
          use e;
      obtain ⟨ E', hE₁, hE₂, hE₃ ⟩ := h_tau_star;
      unfold triangleCoveringNumberOn;
      simp +zetaDelta at *;
      have h_min_le_two : (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t})).min ≤ 2 := by
        exact Finset.min_le ( Finset.mem_image.mpr ⟨ E', Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( by simpa [ ← Finset.coe_subset ] using hE₁ ), hE₃ ⟩, rfl ⟩ ) |> le_trans <| by simpa using hE₂;
      cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( fun E' => ∀ t ∈ S, ∃ e ∈ E', ∀ a ∈ e, a ∈ t ) ( Finset.powerset G.edgeFinset ) ) ) <;> aesop

lemma tau_S_le_2 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumberOn G (S G e M) ≤ 2 := by
      -- S_e is either a star or contained in a K4.
      have h_star_or_K4 : isStar (S G e M) ∨ isK4 (S G e M) := by
        apply intersecting_family_structure_corrected G (S G e M);
        · refine' ⟨ e, _ ⟩;
          unfold S; aesop;
          · unfold trianglesSharingEdge; aesop;
            · have := hM.1;
              have := this.1 he; aesop;
            · have := hM.1;
              have := this.1 he; aesop;
              exact this.card_eq.symm ▸ by decide;
          · have := hM.1; unfold isTrianglePacking at this; aesop;
        · exact fun x hx => Finset.mem_filter.mp ( Finset.mem_filter.mp hx |>.1 ) |>.1;
        · intro t1 ht1 t2 ht2 hne; exact lemma_2_2 G M hM e he t1 t2 ht1 ht2;
      rcases h_star_or_K4 with h|h;
      · refine' le_trans ( tau_star _ _ _ h ) _;
        · exact fun x hx => Finset.mem_filter.mp ( Finset.mem_filter.mp hx |>.1 ) |>.1;
        · norm_num;
      · obtain ⟨ s, hs ⟩ := h;
        convert covering_number_on_le_two_of_subset_four G ( S G e M ) _ s _ _ <;> aesop;
        exact fun t ht => Finset.mem_filter.mp ( Finset.mem_filter.mp ht |>.1 ) |>.1

lemma exists_max_packing {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] :
    ∃ M : Finset (Finset V), isMaxPacking G M := by
      -- By definition of maximum packing number, there exists a packing M with size equal to the trianglePackingNumber.
      obtain ⟨M, hM⟩ : ∃ M : Finset (Finset V), M.card = trianglePackingNumber G ∧ isTrianglePacking G M := by
        unfold trianglePackingNumber;
        cases' Finset.max_of_nonempty ( show Finset.Nonempty ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) ( G.cliqueFinset 3 |> Finset.powerset ) ) ) from ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr <| Finset.empty_subset _, by unfold isTrianglePacking; aesop ⟩ ) ⟩ ) with M hM;
        have := Finset.mem_of_max hM; aesop;
      exact ⟨ M, hM.2, hM.1 ⟩

lemma triangleCoveringNumberOn_eq_zero_of_packing_zero {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) (h_subset : triangles ⊆ G.cliqueFinset 3)
    (h_packing : trianglePackingNumberOn G triangles = 0) :
    triangleCoveringNumberOn G triangles = 0 := by
      unfold triangleCoveringNumberOn;
      -- Since there are no triangles in the set, the condition ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2 is trivially true for E' = ∅.
      have h_empty : ∅ ∈ {E' ∈ G.edgeFinset.powerset | ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2} := by
        -- Since the packing number is zero, there are no triangles in the set, so the condition is trivially satisfied.
        have h_empty : ∀ t ∈ triangles, False := by
          unfold trianglePackingNumberOn at h_packing;
          -- If the maximum cardinality of the packings is zero, then every packing in the set has a cardinality of zero.
          have h_empty_packing : ∀ p ∈ Finset.filter (isTrianglePacking G) triangles.powerset, p.card = 0 := by
            intro p hp
            have h_card : p.card ≤ 0 := by
              have h_card : p.card ≤ Finset.max (Finset.image Finset.card (Finset.filter (isTrianglePacking G) triangles.powerset)) := by
                exact Finset.le_max ( Finset.mem_image_of_mem _ hp );
              cases h : Finset.max ( Finset.image Finset.card ( Finset.filter ( isTrianglePacking G ) triangles.powerset ) ) <;> aesop;
            exact le_antisymm h_card ( Nat.zero_le _ );
          intro t ht; specialize h_empty_packing { t } ; simp_all +decide ;
          exact h_empty_packing ⟨ by simpa using h_subset ht, by simp +decide ⟩;
        aesop;
      -- Since the empty set is in the filter, its cardinality is 0. Therefore, the minimum of the image of the cardinalities must be 0.
      have h_min : Finset.min (Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2})) = some 0 := by
        refine' le_antisymm _ _ <;> simp_all +decide [ Finset.min ];
        · exact Finset.inf_le ( Finset.mem_powerset.mpr ( Finset.empty_subset _ ) ) |> le_trans <| by simp +decide ;
        · exact fun _ _ => WithTop.coe_le_coe.mpr ( Nat.zero_le _ );
      rw [ h_min, Option.getD_some ]

lemma inductive_bound {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (M : Finset (Finset V)) (hM : isMaxPacking G M) (e : Finset V) (he : e ∈ M) :
    triangleCoveringNumber G ≤ triangleCoveringNumberOn G (trianglesSharingEdge G e) + triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) := by
      -- Let $E_1$ be a minimum edge cover of the triangles sharing $e$, and $E_2$ be a minimum edge cover of the triangles not sharing $e$.
      obtain ⟨E1, hE1⟩ : ∃ E1 : Finset (Sym2 V), E1 ⊆ G.edgeFinset ∧ (∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ E1, e ∈ t.sym2) ∧ E1.card = triangleCoveringNumberOn G (trianglesSharingEdge G e) := by
        -- By definition of image, there exists a subset E1 in the powerset of G's edges such that E1 satisfies the conditions and its cardinality is the minimum element of the image.
        obtain ⟨E1, hE1⟩ : ∃ E1 ∈ (G.edgeFinset.powerset.filter (fun E' => ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2)), E1.card = triangleCoveringNumberOn G (trianglesSharingEdge G e) := by
          unfold triangleCoveringNumberOn;
          have h_nonempty : {E' ∈ G.edgeFinset.powerset | ∀ t ∈ trianglesSharingEdge G e, ∃ e ∈ E', e ∈ t.sym2}.Nonempty := by
            -- The entire edge set of G is a subset of itself and covers all triangles in G, including those in trianglesSharingEdge G e.
            use G.edgeFinset;
            simp +decide [ trianglesSharingEdge ];
            intro t ht ht'; obtain ⟨ a, b, c, habc ⟩ := Finset.card_eq_three.mp ht.2; simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            exact ⟨ s(a, b), by aesop ⟩;
          have := Finset.min_of_mem ( Finset.mem_image_of_mem Finset.card h_nonempty.choose_spec );
          rcases this with ⟨ b, hb ⟩ ; rw [ hb ] ; simp +decide [ Option.getD ] ;
          have := Finset.mem_of_min hb; aesop;
        aesop;
      have h_tau_le_tau1_plus_tau2_aux : ∃ E : Finset (Sym2 V), E ⊆ G.edgeFinset ∧ (∀ t ∈ G.cliqueFinset 3, ∃ e ∈ E, e ∈ t.sym2) ∧ E.card ≤ E1.card + triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) := by
        -- Let $E_2$ be a minimum edge cover of the triangles not sharing $e$.
        obtain ⟨E2, hE2⟩ : ∃ E2 : Finset (Sym2 V), E2 ⊆ G.edgeFinset ∧ (∀ t ∈ (G.cliqueFinset 3) \ (trianglesSharingEdge G e), ∃ e ∈ E2, e ∈ t.sym2) ∧ E2.card = triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G e)) := by
          have hE2 : ∃ E2 ∈ Finset.filter (fun E' => ∀ t ∈ (G.cliqueFinset 3) \ (trianglesSharingEdge G e), ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset), E2.card = (Finset.image Finset.card (Finset.filter (fun E' => ∀ t ∈ (G.cliqueFinset 3) \ (trianglesSharingEdge G e), ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset))).min.getD 0 := by
            have hE2 : Finset.Nonempty (Finset.filter (fun E' => ∀ t ∈ (G.cliqueFinset 3) \ (trianglesSharingEdge G e), ∃ e ∈ E', e ∈ t.sym2) (G.edgeFinset.powerset)) := by
              use G.edgeFinset;
              simp +decide [ SimpleGraph.cliqueFinset ];
              intro t ht ht'; rcases Finset.card_eq_three.mp ht.2 with ⟨ a, b, c, ha, hb, hc, hab, hbc, hac ⟩ ; use s(a, b); simp_all +decide [ SimpleGraph.isNClique_iff ] ;
            have := Finset.min_of_mem ( Finset.mem_image_of_mem Finset.card hE2.choose_spec );
            obtain ⟨ b, hb ⟩ := this; rw [ hb ] ; simp +decide [ Option.getD ] ;
            have := Finset.mem_of_min hb; aesop;
          exact ⟨ hE2.choose, Finset.mem_powerset.mp ( Finset.mem_filter.mp hE2.choose_spec.1 |>.1 ), Finset.mem_filter.mp hE2.choose_spec.1 |>.2, hE2.choose_spec.2 ⟩;
        use E1 ∪ E2;
        simp_all +decide [ Finset.subset_iff ];
        exact ⟨ fun x hx => hx.elim ( fun hx => hE1.1 hx ) fun hx => hE2.1 hx, fun t ht => if h : t ∈ trianglesSharingEdge G e then by obtain ⟨ e, he, he' ⟩ := hE1.2.1 t h; exact ⟨ e, Or.inl he, he' ⟩ else by obtain ⟨ e, he, he' ⟩ := hE2.2.1 t ht h; exact ⟨ e, Or.inr he, he' ⟩, le_trans ( Finset.card_union_le _ _ ) ( add_le_add ( hE1.2.2.le ) ( hE2.2.2.le ) ) ⟩;
      obtain ⟨ E, hE₁, hE₂, hE₃ ⟩ := h_tau_le_tau1_plus_tau2_aux;
      refine' le_trans _ ( le_trans hE₃ ( add_le_add_right hE1.2.2.le _ ) );
      unfold triangleCoveringNumber;
      have h_min_le_E : Finset.min (Finset.image Finset.card (Finset.filter (isTriangleCover G) G.edgeFinset.powerset)) ≤ Finset.card E := by
        exact Finset.min_le ( Finset.mem_image.mpr ⟨ E, Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr hE₁, ⟨ hE₁, hE₂ ⟩ ⟩, rfl ⟩ );
      cases h : Finset.min ( Finset.image Finset.card ( Finset.filter ( isTriangleCover G ) G.edgeFinset.powerset ) ) <;> aesop

lemma tuza_case_nu_1 {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (h : trianglePackingNumber G = 1) : triangleCoveringNumber G ≤ 2 := by
      -- Since $\nu(G) = 1$, there exists a single triangle in $G$.
      obtain ⟨t, ht⟩ : ∃ t : Finset V, t ∈ G.cliqueFinset 3 := by
        contrapose! h;
        simp_all +decide [ trianglePackingNumber ];
        rw [ show ( G.cliqueFinset 3 : Finset ( Finset V ) ) = ∅ by ext; aesop ] ; simp +decide;
        simp +decide [ Finset.filter_singleton, isTrianglePacking ];
      -- Since $\nu(G) = 1$, the maximum packing $M$ must be a single triangle $t$.
      obtain ⟨M, hM⟩ : ∃ M : Finset (Finset V), isMaxPacking G M ∧ M = {t} := by
        refine' ⟨ { t }, _, rfl ⟩;
        refine' ⟨ _, _ ⟩ <;> simp_all +decide [ isMaxPacking ];
        unfold isTrianglePacking; aesop;
      have h_tau_S : triangleCoveringNumberOn G (trianglesSharingEdge G t) ≤ 2 := by
        have := tau_S_le_2 G M hM.1 t (by
        aesop);
        unfold S at this; aesop;
      have h_tau_G_minus_S : triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G t)) ≤ 0 := by
        have h_tau_G_minus_S : trianglePackingNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G t)) = 0 := by
          -- Since $\nu(G) = 1$, the maximum packing $M$ must be a single triangle $t$. Therefore, removing any triangles that share an edge with $t$ leaves no triangles, so the packing number of the remaining triangles is zero.
          have h_tau_S : trianglePackingNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G t)) = trianglePackingNumber G - 1 := by
            convert lemma_2_3 G M hM.1 t ( by aesop ) using 1;
          aesop;
        apply triangleCoveringNumberOn_eq_zero_of_packing_zero G ((G.cliqueFinset 3) \ trianglesSharingEdge G t) (by
        exact?) h_tau_G_minus_S |> le_of_eq;
      have h_tau_G : triangleCoveringNumber G ≤ triangleCoveringNumberOn G (trianglesSharingEdge G t) + triangleCoveringNumberOn G ((G.cliqueFinset 3) \ (trianglesSharingEdge G t)) := by
        apply inductive_bound G M hM.left t (by
        aesop);
      linarith

def X {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (e f : Finset V) : Finset (Finset V) :=
  (trianglesSharingEdge G e) ∩ (trianglesSharingEdge G f)

lemma mem_X_implies_v_in_t {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (e f : Finset V) (v : V) (he : e.card = 3) (hf : f.card = 3) (h_inter : e ∩ f = {v}) :
    ∀ t ∈ X G e f, v ∈ t := by
      -- Since $t$ is in both triangles sharing edge $e$ and $f$, and their intersection is $\{v\}$, $t$ must contain $v$.
      intros t ht
      have h_t_e : t ∈ trianglesSharingEdge G e := by
        exact Finset.mem_inter.mp ht |>.1
      have h_t_f : t ∈ trianglesSharingEdge G f := by
        exact Finset.mem_inter.mp ht |>.2
      have h_t_inter : (t ∩ e).card ≥ 2 ∧ (t ∩ f).card ≥ 2 := by
        unfold trianglesSharingEdge at *; aesop;
      have h_t_v : v ∈ t := by
        have h_t_v : (t ∩ e) ∩ (t ∩ f) ≠ ∅ := by
          have h_t_v : (t ∩ e ∩ (t ∩ f)).card ≥ (t ∩ e).card + (t ∩ f).card - (t ∩ e ∪ t ∩ f).card := by
            rw [ ← Finset.card_union_add_card_inter ] ; simp +decide [ Finset.inter_comm, Finset.inter_left_comm, Finset.inter_assoc ] ;
          have h_t_v : (t ∩ e ∪ t ∩ f).card ≤ 3 := by
            have h_t_v : (t ∩ e ∪ t ∩ f) ⊆ t := by
              exact Finset.union_subset ( Finset.inter_subset_left ) ( Finset.inter_subset_left );
            have h_t_v : t.card ≤ 3 := by
              have h_t_v : t ∈ G.cliqueFinset 3 := by
                exact Finset.mem_filter.mp h_t_e |>.1;
              exact Finset.mem_filter.mp h_t_v |>.2.2.le;
            exact le_trans ( Finset.card_le_card ‹_› ) h_t_v;
          exact Finset.Nonempty.ne_empty ( Finset.card_pos.mp ( by omega ) );
        simp_all +decide [ Finset.ext_iff ]
      exact h_t_v

lemma triangleCoveringNumberOn_le_of_cover {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) (E' : Finset (Sym2 V))
    (h_subset : E' ⊆ G.edgeFinset)
    (h_cover : ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) :
    triangleCoveringNumberOn G triangles ≤ E'.card := by
      -- Since $E'$ is in the set of edge sets that cover the triangles, its cardinality is in the image of the cardinality function over this set.
      have h_E'_in_image : E'.card ∈ Finset.image Finset.card ({E' ∈ G.edgeFinset.powerset | ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2}) := by
        grind;
      -- Since $E'.card$ is in the image, the minimum of the image must be less than or equal to $E'.card$.
      have h_min_le_E'_card : ∀ {s : Finset ℕ}, E'.card ∈ s → s.min.getD 0 ≤ E'.card := by
        -- Since the minimum of a set is less than or equal to any element in the set, we have `s.min ≤ E'.card`.
        intros s hs
        have h_min_le_E'_card : s.min ≤ E'.card := by
          exact Finset.min_le hs;
        cases h : s.min <;> aesop;
      exact h_min_le_E'_card h_E'_in_image

lemma triangleCoveringNumberOn_le_of_cover' {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (triangles : Finset (Finset V)) (E' : Finset (Sym2 V))
    (h_subset : E' ⊆ G.edgeFinset)
    (h_cover : ∀ t ∈ triangles, ∃ e ∈ E', e ∈ t.sym2) :
    triangleCoveringNumberOn G triangles ≤ E'.card := by
      -- Since $E'$ is a valid cover for the triangles, the covering number is the minimum cardinality of such a set $E'$. Therefore, the covering number must be less than or equal to the cardinality of $E'$.
      apply triangleCoveringNumberOn_le_of_cover G triangles E' h_subset h_cover

lemma shares_incident_edge_of_shares_edge_and_mem {V : Type*} [DecidableEq V]
    (e t : Finset V) (v : V)
    (he : e.card = 3) (hv_e : v ∈ e) (hv_t : v ∈ t)
    (h_share : (t ∩ e).card ≥ 2) :
    ∃ u ∈ e, u ≠ v ∧ {v, u} ⊆ t := by
      -- Since the intersection of t and e has at least two elements and v is already in both, there must be another element u in e that is also in t.
      obtain ⟨u, hu₁, hu₂⟩ : ∃ u ∈ t ∩ e, u ≠ v := by
        exact Finset.exists_mem_ne h_share v
      generalize_proofs at *; (
      grind)

lemma tau_X_le_2' {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]
    (e f : Finset V) (v : V) (he : G.IsNClique 3 e) (hf : G.IsNClique 3 f) (h_inter : e ∩ f = {v}) :
    triangleCoveringNumberOn G (X G e f) ≤ 2 := by
      -- Since every triangle in X G e f contains the vertex v, they all share the edge {v, u} for some u in e. Therefore, the set of edges {v, u} for u in e is a triangle cover.
      have h_cover : ∀ t ∈ X G e f, ∃ u ∈ e, u ≠ v ∧ {v, u} ⊆ t := by
        intro t ht
        obtain ⟨u, hu⟩ : ∃ u ∈ e, u ≠ v ∧ {v, u} ⊆ t := by
          have h_card : (t ∩ e).card ≥ 2 := by
            exact Finset.mem_filter.mp ( Finset.mem_inter.mp ht |>.1 ) |>.2
          have h_card : ∀ t ∈ X G e f, v ∈ t := by
            intro t ht
            apply mem_X_implies_v_in_t G e f v he.card_eq hf.card_eq h_inter t ht;
          have h_card : ∃ u ∈ e, u ≠ v ∧ u ∈ t := by
            obtain ⟨ u, hu ⟩ := Finset.exists_mem_ne ‹_› v; use u; aesop;
          exact ⟨ h_card.choose, h_card.choose_spec.1, h_card.choose_spec.2.1, Finset.insert_subset_iff.mpr ⟨ by solve_by_elim, Finset.singleton_subset_iff.mpr h_card.choose_spec.2.2 ⟩ ⟩
        use u, hu.left, hu.right.left, hu.right.right
        skip;
      refine' le_trans ( triangleCoveringNumberOn_le_of_cover' G _ _ _ _ ) _;
      refine' Finset.image ( fun u => s(v, u) ) ( e.filter ( fun u => u ≠ v ) );
      · simp_all +decide [ SimpleGraph.isNClique_iff ];
        intro u hu; have := he.1 ( show v ∈ e from by rw [ Finset.eq_singleton_iff_unique_mem ] at h_inter; aesop ) ( show u ∈ e from by aesop ) ; aesop;
      · intro t ht; obtain ⟨ u, hu, hu', hu'' ⟩ := h_cover t ht; use s(v, u); aesop;
      · have := he.card_eq; simp_all +decide [ Finset.ext_iff ] ;
        exact le_trans ( Finset.card_image_le ) ( by rw [ show Finset.filter ( fun u => ¬u = v ) e = e.erase v by ext u; by_cases hu : u = v <;> aesop ] ; simp +decide [ *, Finset.card_erase_of_mem ( show v ∈ e from by specialize h_inter v; aesop ) ] )