## Problem Title: Type I [56,28,12] Self-Dual Code Construction

---

## Executive Summary

Construct a Type I binary self-dual code with parameters [56,28,12] (length 56, dimension 28, minimum distance 12) and verify its properties. Existence of this code would be a novel result in coding theory.

---

## Background

### Self-Dual Codes

**Definition:** A binary linear code C is self-dual if C = C^⊥ (code equals its dual).

**Properties:**
- Length n must be even
- Dimension k = n/2
- All codewords have even weight (Type I) or divisible by 4 (Type II)

### [56,28,12] Parameters

**n = 56** (code length)
**k = 28** (dimension, half of length)
**d = 12** (minimum distance)

**Type I:** All codewords have even weight

---

## Known Results

**Bounds:**
- Singleton bound: d ≤ n - k + 1 = 29 ✓
- Hamming bound: satisfied for these parameters
- Plotkin bound: d ≤ 2⌊n/4⌋ = 28 ✓

**Gleason's Theorem:** Self-dual code weight enumerator is uniquely determined.

**Status:** [56,28,12] existence is OPEN QUESTION in coding theory.

---

## Concrete Parameters

**Binary field**: ℤ₂ = {0,1}
**Generator matrix**: G ∈ ℤ₂^(28×56)
**Parity check matrix**: H = G^T (self-dual property)
**Minimum distance**: d_min = 12

---

## Goal 1: Construction via Circulant Blocks

### Task
Construct candidate code using circulant matrix structure.

### Approach: Double Circulant Construction

**Generator Matrix Form:**
```
G = [I₂₈ | A]
```
where I₂₈ is 28×28 identity and A is 28×28 circulant matrix.

**Self-Dual Condition:** A must satisfy A A^T = I₂₈ (mod 2)

**Circulant A:** Generated by first row (a₀, a₁, ..., a₂₇)

**Search:** Find (a₀, ..., a₂₇) such that:
1. A A^T = I₂₈ (mod 2)
2. Resulting code has d_min ≥ 12

### Formalization

```lean
-- Binary field
def F2 := ZMod 2

-- Circulant matrix from generator row
def circulant_matrix (n : ℕ) (gen : Fin n → F2) : Matrix (Fin n) (Fin n) F2 :=
  fun i j => gen ((j - i) % n)

-- Generator matrix [I | A]
def double_circulant_gen (n : ℕ) (gen : Fin n → F2) : Matrix (Fin n) (Fin (2*n)) F2 :=
  fun i j => if j < n then (if i = j then 1 else 0) else circulant_matrix n gen i (j - n)

-- Self-dual condition
def is_self_dual_gen {n : ℕ} (G : Matrix (Fin n) (Fin (2*n)) F2) : Prop :=
  G * G.transpose = 1

-- Code from generator
def code_from_gen {n k : ℕ} (G : Matrix (Fin k) (Fin n) F2) : Set (Fin n → F2) :=
  {c | ∃ m : Fin k → F2, c = m ᵥ* G}

-- Minimum distance
def minimum_distance {n : ℕ} (C : Set (Fin n → F2)) : ℕ :=
  (C.filter (· ≠ 0)).toFinset.image hamming_weight |>.min.getD 0
```

---

## Goal 2: Minimum Distance Verification

### Task
Prove that the constructed code has d_min ≥ 12.

### Approach: Exhaustive Weight Enumeration

**Key Observation:** For dimension 28, there are 2^28 ≈ 268M codewords.

**Strategy:**
1. Enumerate all 2^28 codewords (computational)
2. Compute Hamming weight of each
3. Find minimum weight among non-zero codewords
4. Verify min_weight ≥ 12

**Optimization:** Use weight enumerator polynomial.

### Weight Enumerator

**Definition:** W(x,y) = ∑_{c∈C} x^{n-wt(c)} y^{wt(c)}

**For self-dual Type I codes:** W(x,y) determined by Gleason's theorem.

**Verification:** Check coefficients for weights 2,4,6,8,10 are zero.

### Formalization

```lean
-- Hamming weight
def hamming_weight {n : ℕ} (v : Fin n → F2) : ℕ :=
  (Finset.univ.filter (fun i => v i ≠ 0)).card

-- Weight distribution
def weight_distribution {n : ℕ} (C : Set (Fin n → F2)) : Fin (n+1) → ℕ :=
  fun w => (C.filter (fun c => hamming_weight c = w)).toFinset.card

-- Theorem: minimum distance ≥ 12
theorem code_56_28_12_min_distance (gen : Fin 28 → F2) :
  let G := double_circulant_gen 28 gen
  is_self_dual_gen G →
  let C := code_from_gen G
  minimum_distance C ≥ 12
```

---

## Goal 3: Weight Enumerator Verification

### Task
Verify that the code's weight enumerator matches Gleason's theorem for Type I self-dual codes.

### Gleason's Formula

**For length n divisible by 8:**
```
W(x,y) = α·φ₁(x,y) + β·φ₂(x,y)
```
where:
- φ₁(x,y) = x^8 + 14x^4y^4 + y^8
- φ₂(x,y) = x^4y^4(x^4 - y^4)^4

**For n=56:** Uniquely determined weight enumerator.

**Verification:** Compute W(x,y) for constructed code and check it matches Gleason's formula.

---

## Goal 4: Uniqueness and Automorphism Group (Stretch)

### Task
If code is found, analyze its automorphism group.

**Automorphism:** Permutation σ of coordinates such that σ(C) = C.

**For circulant construction:** Cyclic group C₂₈ is subgroup of Aut(C).

**Question:** Is Aut(C) = C₂₈ or larger?

---

## Success Criteria

✅ **Explicit construction**: 28×56 generator matrix G
✅ **Self-dual verification**: G G^T = I₂₈ (mod 2)
✅ **Distance proof**: d_min ≥ 12 verified computationally or analytically
✅ **Weight enumerator**: Matches Gleason's theorem
✅ **Concrete parameters**: [56,28,12] not just [n,n/2,d]

### Red Flags
❌ Only proves existence (no explicit construction)
❌ Generic [n,n/2,d] arguments
❌ Claimed construction but d_min < 12
❌ No weight enumerator verification

---

## Expected Output

**Target**: 250-400 lines

### Structure
1. **Definitions** (60-80 lines): F2, matrices, circulant, self-dual
2. **Construction** (80-120 lines): Search for generator row, build G
3. **Distance Verification** (60-100 lines): Weight computation, d_min ≥ 12
4. **Weight Enumerator** (50-80 lines): Compute W(x,y), verify Gleason
5. **Overall Result** (20-30 lines): Combine properties

---

## Novelty Assessment

**Why 7-8/10:**
- First construction of [56,28,12] self-dual code (if successful)
- Explicit generator matrix
- Formal verification of all properties
- Novel result in coding theory

**Existing Work:**
- [56,28,d] codes known for d ≤ 11
- [56,28,12] existence is open

**Our Contribution:**
- Constructive proof
- Lean 4 formalization
- Weight enumerator verification

**Success Probability**: 30% (construction existence uncertain)
